<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>qbxtD7 &amp;&amp; NOIP提高组考前刷题冲刺班（第七场） | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1606823908106">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="qbxtD7 &amp;&amp; NOIP提高组考前刷题冲刺班（第七场） | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="A
n^15
写的搜索
n2m那种
B
容斥
ljh:
是7的倍数,减去是2/3/5的倍数,+是6/10/15的倍数,-是30的倍数
my:
至少是2,3,5,7的倍数-至少是2,3,5的倍数
于是我们就可以写一个ljh的容斥,然后相减
C..." />
    <meta name="keywords" content="容斥,比赛题,倍增,线段树" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1606823908106" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              qbxtD7 &amp;&amp; NOIP提高组考前刷题冲刺班（第七场）
            </h2>
            <div class="post-info">
              <span>
                2020-11-27
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/mUSUJZ9R7J/" class="post-tag">
                  # 容斥
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/A3FIICRYA/" class="post-tag">
                  # 比赛题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/lzY108Fv7/" class="post-tag">
                  # 倍增
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/i0TglRCqu/" class="post-tag">
                  # 线段树
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcad0zLL7ld1tWSMSvJoUdfNsVFvAwhqQZIKrGhgiI0VtmtCVHyM0KFQ17HR3JY082Zn4H.U9lysnFG.e9UCHBuE!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>A</p>
<p>n^15</p>
<p>写的搜索</p>
<p>n<sup>2</sup>m那种</p>
<p>B</p>
<p>容斥</p>
<p>ljh:</p>
<p>是7的倍数,减去是2/3/5的倍数,+是6/10/15的倍数,-是30的倍数</p>
<p>my:</p>
<p>至少是2,3,5,7的倍数-至少是2,3,5的倍数</p>
<p>于是我们就可以写一个ljh的容斥,然后相减</p>
<p>C</p>
<p>最小化?/yun</p>
<p>我们可以维护一个矩阵,行表示a选什么列表示b选什么</p>
<p>然后我们就有某一个数是a,b都选之后这个矩阵只有一个矩阵下三角是满足的</p>
<p>然后相当于我们一个边就代表这里面一个点</p>
<p>把这个[ab]矩阵变成一个点,边变成一个矩阵</p>
<p>那么我们相当于给一个矩阵加1</p>
<p>然后要找一个点使得被最小的矩阵覆盖</p>
<p>可以进行扫描线</p>
<p>my:</p>
<p>额没有那么妙</p>
<p>就是考虑增量,对于一个右端点,用线段树维护所有左端点处答案</p>
<p>然后一路增量过去即可.....就是枚举新点的所有边然后区间修改</p>
<p>注意我们一条边再被经过时要改两次,就是左边被改一次右边被改一次....</p>
<p>时间复杂度都是O(nlogn)</p>
<p>code:</p>
<pre><code class="language-cpp">
//tsx线段树
//关门弟子
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 4e5 + 7;
int n, m, ccnt;
int home[MAXN], nxt[MAXN], to[MAXN];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

struct rec {
	int adt;
	ll Mx;
	rec(int ADT = 0, ll Mix = 0): adt(ADT), Mx(Mix) {};
} tr[MAXN];

rec operator+(const rec &amp;x, const rec &amp;y) {
	rec nw = rec();
	nw.adt = x.adt + y.adt;
	nw.Mx = x.Mx + y.adt;
	return nw;
}

inline void calc(int k, int v) {
	tr[k].Mx += v;
	tr[k].adt += v;
	return;
}

inline void update(int k) {
	tr[k].Mx = min(tr[k &lt;&lt; 1].Mx, tr[k &lt;&lt; 1 | 1].Mx);
	return;
}

inline void pushdown(int k) {
	if(tr[k].adt) {
		calc(k &lt;&lt; 1, tr[k].adt);
		calc(k &lt;&lt; 1 | 1, tr[k].adt);
		tr[k].adt = 0;
	}
}

///jk
inline void add(int k, int l, int r, int L, int R, rec jk) {
	// printf(&quot;add : %d %d %d %d %d %lld V is %d\n&quot;, k, l, r, L, R, tr[k].Mx, jk.adt);
	if(L &lt;= l &amp;&amp; r &lt;= R) {
		calc(k, jk.adt);
		return ;
	}
	pushdown(k);
	int mid = (l + r) &gt;&gt; 1;
	if(L &lt;= mid)add(k &lt;&lt; 1, l, mid, L, R, jk);
	if(R &gt; mid)add(k &lt;&lt; 1 | 1, mid + 1, r, L, R, jk);
	update(k);
	return;
}

inline int qry(int k, int l, int r, int L, int R) {
	if(L &lt;= l &amp;&amp; r &lt;= R) {
		// printf(&quot;qry  : %d %d %lld\n&quot;, l, r, tr[k].Mx);
		return tr[k].Mx;
	}
	pushdown(k);
	int mid = (l + r) &gt;&gt; 1;
	if(R &lt;= mid)return qry(k &lt;&lt; 1, l, mid, L, R);
	else if(L &gt; mid)return qry(k &lt;&lt; 1 | 1, mid + 1, r, L, R);
	else return min(qry(k &lt;&lt; 1, l, mid, L, R), qry(k &lt;&lt; 1 | 1, mid + 1, r, L, R));
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1, x, y; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	int ans = 1e9;
	for(int u = 2; u &lt; n; ++u) {
		// printf(&quot;now is :%lld \n&quot;, u);
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			// printf(&quot;vis is %d\n&quot;, v);
			if(v &gt; u || v == 1) {
				add(1, 1, n, 2, u, rec(1, 0));
			} else {
				add(1, 1, n, v + 1, u, rec(1, 0));
				add(1, 1, n, 2, v, rec(-1, 0));
			}//如果包括了他们俩,就-1
			//显然左端点1不能成为答案吧
		}
		// printf(&quot;%d ?\n&quot;, qry(1, 1, n, 2, u));
		ans = min(ans, qry(1, 1, n, 2, u));//查询区间答案???
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>D</p>
<p>首先直接dp要记录这个轮数</p>
<p>妈的不要</p>
<p>所以说我们发现这个转移矩阵是个循环矩阵</p>
<p>所以说我们就可以循环矩阵快速幂(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2log)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>,qc的做法)</p>
<p>但是写出转移式子就发现可以倍增做这个事情</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示2^i步,走j步的方案数</p>
<p>然后,,,,,我们就能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了...</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑f_{i,j}表示前2^i轮,最后0号在j的方案数(走了j步)
//转移考虑两个拼起来的时候,对于位置x,我们有一个类似卷积的东西
//就是类似于走了y步,再去走k步,满足(x+k)%(n-1)==x
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 2000;
const int MAXlog = 40;
int n, m, t, d;
int a[MAXN];
int f[MAXlog][MAXN], g[MAXN], dp[MAXN];

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline void solve() {
	for(int i = 1; i &lt;= m; ++i)f[0][a[i]] = 1;
	for(int i = 1; i &lt;= 30; ++i) {
		for(int j = 0; j &lt; n; ++j) {
			for(int k = 0; k &lt; n; ++k) {
				add(f[i][(j + k) % n], 1ll * f[i - 1][k]*f[i - 1][j] % P);
			}
		}
	}
	//走0步,一步都不算
	g[0] = 1;
	for(int i = 0; i &lt;= 30; ++i) {
		if(t &gt;&gt; i &amp; 1) {
			// printf(&quot;%d ?\n&quot;, i);
			for(int j = 0; j &lt; n; ++j) {
				for(int k = 0; k &lt; n; ++k) {
					// printf(&quot;%d %d %d %d\n&quot;, j, k, f[i][k], g[j]);
					add(dp[(j + k) % n], 1ll * g[j]*f[i][k] % P);
				}
			}
			for(int j = 0; j &lt; n; ++j)g[j] = dp[j], dp[j] = 0;
		}
	}
	int ans = 0;
	// for(int i = 0; i &lt; n; ++i)printf(&quot;%d &quot;, g[i]);
	for(int i = 0; i &lt; n; i += d)add(ans, g[i]);
	printf(&quot;%d\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;t, &amp;d);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	solve();
	return 0;
}
/*

9 10 96318817 5
29086
14551
3546
12089
18582
10244
23380
4102
31676
31273


*/

</code></pre>
<p>全局最小割</p>
<p>钦定一个s,t</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是随便一个</p>
<p>然后选一个点i,然后使得i和前面的所有点连的边数最大</p>
<p>然后会发现这样能构造出一个序列</p>
<p>最后删掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所有连边即可</p>
<p>但是还没有考虑两个点是合并的</p>
<p>也很简单,我们把两个点merge成一个点,然后再做上述过程</p>
<p>随后我们接着随便选,把剩下n-1个点合乘一个,所有过程答案求最小值即可</p>
<p>对于一个图,随机logn棵生成树,这log棵生成树不能有共同的边</p>
<p>随机G'有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">nlog^2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>条边</p>
<p>然后这些生成树中有一个生成树</p>
<p>最小的分割方案是会分成三份</p>
<p>所以说我们可以选两条边断掉,然后枚举其中一条用数据结构优化另一条的枚举</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>3</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">mlog^3n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
<p>区间的代价为这一段的出现数字种类的平方</p>
<p>然后问总划分方案使得划分代价最小</p>
<p>首先都分成一段是可能优的答案为n</p>
<p>然后你会发现这个东西啊naive</p>
<p>因为平方上升,所以说我们直接枚举i前根号个不同的数字即可.....<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>c</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=f_j+cst(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p>这个预处理可以动脑子</p>
<p>平面最近点对</p>
<p>随便按横坐标劈开</p>
<p>然后分治左右得到答案d</p>
<p>然后中间合并的话.....</p>
<p>你会发现答案一定在x-d和x+d之间的范围内</p>
<p>然后把那些点找出来,按照纵坐标排序</p>
<p>考虑其中某一个点,向前后枚举几个点纵坐标距离差就已经超过d了...就停止</p>
<p>会发现这里我们只需要枚举几次就能超越d</p>
<p>然后又会发现这个三角形咋办啊</p>
<p>枚举一个,剩下的都在附近??</p>
<p>从中间分开,算左右答案</p>
<p>现在我们只需要看x-d和x+d的</p>
<p>纵坐标排序</p>
<p>剩下两个点只能在y+d范围</p>
<p>然后感觉一下,这个点不会很多</p>
<p>我们先枚举第一个,再枚举第二个并用第一个第二个距离再减第三个的纵坐标范围</p>
<p>n个点,m条边的有向图</p>
<p>然后在i点选操作j有得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>下一秒所在的点可能在这个点指出去的某个点</p>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示i这个点做操作j到点k的概率</p>
<p>保证和为1</p>
<p>最小化t=0时的得分期望</p>
<p>1e-6误差</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示t=0在i的最小得分</p>
<p>初始化....f=0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">f^{(k)}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span></span>表示第k次计算是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值</p>
<p>每一步</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>a</mi></msub><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><munder><mo>∑</mo><mi>j</mi></munder><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msubsup><mi>f</mi><mi>j</mi><mrow><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mrow></mrow></mrow><annotation encoding="application/x-tex">f^{(k)}_{i}=min_a{C_{i,a}+\frac 1 2*\sum_j {p_{i,a,j}*f^{(k-1)}_j}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.735217em;vertical-align:-1.413777em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后多算几轮,知道快超时就输出,使得误差很小</p>
<p>(差不多三四十次就好了....)</p>
<p>然后这里老师数学分析了一下,证明这个误差确实不会很大</p>
<p>牛顿迭代</p>
<p>找到某个点,然后搞一个直线(导数)</p>
<p>从直线出发求交点横坐标然后带入再求导</p>
<p>再求那个导数的交点横坐标......</p>
<p>一直迭代直到找到0点</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">loglogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span></p>
<p>P4055 [JSOI2009]游戏</p>
<p>显然是二分图染色后跑最大匹配,非必须点就是可行的答案</p>
<p>然后我们可以从不在最大匹配的(一定是非匹配点)点集中向最大匹配点走沿着匹配边,和i同一侧的点都是非必须的</p>
<p>因为至少有一种方案是选上i</p>
<p>SP11469 SUBSET - Balanced Cow Subsets</p>
<p>先除半,然后左边有10个点,右边有10个</p>
<p>我们左边的和为a,右边的和为b,左边另一堆数和为c,右边另一堆数和为d</p>
<p>a+b=c+d</p>
<p>a-c=d-b</p>
<p>相当于我们左边枚举子集得到所有可能的差</p>
<p>然后右边也一样做做</p>
<p>利用map来匹配一下!</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>3</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(3^{\frac n 2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.09708em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/p4049-jsoi2007he-jin/">
              <h3 class="post-title">
                P4049 [JSOI2007]合金
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
