<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSP-S2考前综合强化刷题（第三场） | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1608303943190">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSP-S2考前综合强化刷题（第三场） | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="昨天挂10,今天挂20QAQ
A
1e6!全部写出来五十万位的数/se
高精度期望80pts
做法一:
会发现我们只需要比较大小
那么我们可以用个能够比较大小的映射函数
开根号显然我们还要算好几百位的数
比如对数函数!
logN!=log1..." />
    <meta name="keywords" content="计数题,比赛题,猜结论,字符串" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1608303943190" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSP-S2考前综合强化刷题（第三场）
            </h2>
            <div class="post-info">
              <span>
                2020-10-03
              </span>
              <span>
                14 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/JP89ddpfS/" class="post-tag">
                  # 计数题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/A3FIICRYA/" class="post-tag">
                  # 比赛题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/c7QHdP10U/" class="post-tag">
                  # 猜结论
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/k8ekJE9lH/" class="post-tag">
                  # 字符串
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcatNm750txzpI1gQ6ekEmGJ.3FUnhcJ9CJ3UPK99H0a*Tv*O1g8MevXSwirch*8jjZuKSZlnosQhOhetFfKJbtw!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>昨天挂10,今天挂20QAQ</p>
<p>A</p>
<p>1e6!全部写出来五十万位的数/se</p>
<p>高精度期望80pts</p>
<p>做法一:</p>
<p>会发现我们只需要比较大小</p>
<p>那么我们可以用个能够比较大小的映射函数</p>
<p>开根号显然我们还要算好几百位的数</p>
<p>比如对数函数!</p>
<p>logN!=log1+log2+log3....+log(n)</p>
<p>也就是说我们1e6个数全部求一个阶乘然后搞一个前缀和数组,这个和的第i项就是n!取对数</p>
<p>然后只需要枚举一个k,看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>−</mo><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_n-S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的大小关系</p>
<p>做法二:</p>
<p>结论 : 左边的阶乘不会大于右边的阶乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><msup><mn>6</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1e6^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>倍</p>
<p>显然如果大于我们就可以把左边的一个分给右边并保证仍成立</p>
<p>所以可以记录左边的倍数比右边打多少</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
#define ll long long
using namespace std;
const int MAXN = 2e6 + 7;
db f[MAXN];
ll g[MAXN];
int n;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	if(n == 1) {
		return puts(&quot;1&quot;), 0;
	}
	if(n == 2) {
		return puts(&quot;2&quot;), 0;
	}
	if(n == 3) {
		return puts(&quot;3&quot;), 0;
	}
	f[3] = 6;
	g[3] = 3;//前三个,初始化一下
	for(ll i = 4; i &lt;= n; ++i) {
		f[i] = f[i - 1];
		g[i] = g[i - 1];
		while(f[i] / i &lt; 1 &amp;&amp; g[i] &lt; i) {
			++g[i];
			f[i] = f[i] * g[i] * g[i];
		}
		f[i] /= i;
	}
	printf(&quot;%lld\n&quot;, g[n]);
	return 0;
}

</code></pre>
<p>扩展:组合数问题</p>
<p>首先杨辉三角最下面一行的中间是最大的,而且次大的一定在最大的相邻位置</p>
<p>所以这k个数我们只需要用一个大根堆比较然后依次选下去就好了</p>
<p>然后我们从大根堆取k次就是前k大的组合数</p>
<p>显然比较大小不能取模,我们可以对其取对数</p>
<p>然后</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">C_{n,m}=logn!-logm!-log(n-m)!
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></span></p>
<p>B</p>
<p>先处理字符串,把整个拓扑图建出来</p>
<p>然后n^2去pick每个即可...</p>
<p>模拟建图处理字符串的时候可以分阶段来搞...然后有一个:;就换阶段,这样比较好写</p>
<p>注意把所有字符串按照字典序pick出来然后分配下点的编号</p>
<p>写模拟一定要代码优美一些</p>
<p>全考场切的最快?</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑按照依赖关系建图
//会发现是一个拓扑排序
//然后我们有一些时间轴,每个时间轴都可以向后推进
//然后时间轴要任务的时候我们可以把所有点按照深度和名字进行排序
//然后就可以做了?
//名字字符集为小写大写数字,要是不是就撕了zhx
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e3 + 7;
const int MAXM = 3e5 + 7;
#define ll long long
string s, a, b;
map&lt;string, int&gt; mp;
int T, ccnt, home[MAXN], nxt[MAXM], to[MAXM], in[MAXN];

priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt; &gt;  hp;
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;  heap;
int vis[MAXN], tim[MAXN], Sm;
struct NODE {
	int id, ft;
	bool operator&lt;(const NODE x)const {
		return ft == x.ft ? id &gt; x.id : ft &gt; x.ft;
	}
} e[MAXN];

priority_queue&lt;NODE&gt; task;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	in[y]++;
}

int main() {
	freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; s;
	int flg = 0;
	//正在进行第几个阶段?
	//任务的名字为第二关键字??
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == '/') {
			hp.push(a);
			a.clear();
			flg = -1;
			continue;
		}
		if(s[i] == ';') {
			hp.push(a);
			a.clear();
			flg = 0;
			continue;
		}
		if(s[i] == ':') {
			flg = 1;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		}
	}
	a.clear();
	while(!hp.empty()) {
		a = hp.top();
		hp.pop();
		cout &lt;&lt; a &lt;&lt; endl;
		mp[a] = ++T;
	}
	a.clear();
	flg = 0;
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == ';') {
			flg = 0;
			a.clear();
			continue;
		}
		if(s[i] == ':') {
			flg++;
			continue;
		}
		if(s[i] == '/') {//上四挡
			flg = 4;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		} else if(flg == 1) {
			if(s[i] == '[') {
				continue;
			}
			if(s[i] == ',' || s[i] == ']') {
				if(b.empty())continue;
				ct(mp[b], mp[a]);
				b.clear();
				continue;
			}
			b.push_back(s[i]);
		} else if(flg == 2) {
			tim[mp[a]] = tim[mp[a]] * 10 + s[i] - '0';
			cout &lt;&lt; a &lt;&lt; endl;
			//快读即可
		}
		if(flg == 4) {
			Sm = Sm * 10 + s[i] - '0';
			if(Sm &gt; T)break;
		}
	}
	for(int i = 1; i &lt;= T; ++i)e[i].id = i;
	//有多少任务就有多少点
	int fed = 0;
	while(fed &lt; Sm) {
		++fed;
		heap.push(0);
		//每个机器最早结束时间
	}
	fed = 0;
	while(fed &lt; T) {
		for(int i = 1; i &lt;= T; ++i) {
			if(in[i] == 0 &amp;&amp; !vis[i]) {
				vis[i] = 1;
				task.push(e[i]);
				//把这个点放入qwq里
			}
		}
		int t = heap.top();
		heap.pop();
		NODE u = task.top();
		task.pop();
		for(int i = home[u.id]; i; i = nxt[i]) {
			int v = to[i];
			e[v].ft = max(e[v].ft,  tim[u.id] + max(t, u.ft));
			//考虑我们这个任务结束的时间应该是这个任务开始做的时间+做这个任务的时间
			//前者显然和机器开工时间与开始做时间最大值有关
			in[v]--;
		}
		fed++;
		heap.push(max(t, u.ft) + tim[u.id]);
	}
	int ans = 0;
	while(!heap.empty()) {
		ans = max(ans, heap.top());
		heap.pop();
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

abc:[a1,a2]:10;AB1:[]:2;AB2:[]:3;ab1:[AB1,AB2]:3;ab3:[AB2]:4;a2:[ab1,ab3,AB2]:2;a1:[ab1]:3/3


*/
</code></pre>
<p>C</p>
<p>挂了20QAQAQAQ</p>
<p>对于长度为1,我们可以直接暴力</p>
<p>对于长度&lt;=10,我们可以直接复制粘贴到一样长</p>
<p>考场上直接TLE/ll</p>
<p>注意50!整除任何你想要的,所以不用考虑余数</p>
<p>均为质数</p>
<p>3,5的情况?</p>
<p>010010010010010<br>
100111001110011</p>
<p>-&gt;</p>
<p>110121011120021</p>
<p>你会发现第一个串会和第二个字符串每一位都有重叠的操作!!</p>
<p>那么其实相当于(2个0+1个1)*(2个0+3个1)=4个0+8个1+3个2??</p>
<p>因为一定会有重复!</p>
<p><s>生成函数??</s></p>
<p>当两字符串互质时,我们只关心彼此间0/1的个数!</p>
<p>然后我们最后相当于多个二项式相乘!!</p>
<p>...可以分治FFT优化</p>
<p>然鹅,如果不互质就萎了</p>
<p>分块匹配!!!</p>
<p>lcm 4,6 =12</p>
<p>4 4 4 4-&gt; 1 2 1 2 1 2<br>
6 6 -&gt;      1 2 3 1 2 3</p>
<p>设最大公因数为g</p>
<p>10 01 10 01 10 01<br>
01 00 11 01 00 11</p>
<p>你会发现4的每一块的第一位都不可能和6的第二位产生影响</p>
<p>然后我们可以继续,取出4的第二位和六的每一块的第二位乘起来</p>
<p>然后得到两个多项式系数求和?</p>
<p>这两个答案求和就是我们想要的答案,可以发现多项式的指数可能变小?</p>
<p>扩展到n个?你会发现我们要小心gcd!QAQ</p>
<p>如果一个字符串含有2,3,5,7,作为因子那么我们就把它扩展到32<em>27</em>25*49的形式</p>
<p>但是如果包含了大于7的因子,他的平方一定大于50,所以只会包括一个大于7的</p>
<p>怎么扩?</p>
<p>每个p拓展到12p,因为我们最大只能有4</p>
<p>这样做完之后,我们最大公约数为12(或者更大一个p)</p>
<p>所有数我们可以按照12进行分组,然后做12次多项式乘法就好了</p>
<p>然后会发现我们可以做了!</p>
<p>每组有12位,要做12次乘法</p>
<p>然后一共有n/12组</p>
<p>每组的第一个数之间做多项式乘法</p>
<p>复杂度瓶颈在于扩展1e6的....</p>
<p>打码通过精加工变得好快/jk</p>
<p>code:</p>
<pre><code class="language-cpp">
//From Dawn light
//first kill!
//orzzhx
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1000;
const int MAXT = 105;
const int MAXS = 55;
const int P = 1e9 + 7;
int n, la, lc;
string s[MAXT];
ll fac[MAXT];
int L[MAXT], a[MAXT][MAXS], vis[MAXN], B[50][MAXN];
ll A[MAXN];
ll D[MAXN], E[MAXN];

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}


ll c[MAXN];
inline void mul(ll *a, ll *b, int &amp;la, int lb) {
	memset(c, 0, sizeof(c));
	for(int i = 0; i &lt; lb; ++i) {
		for(int j = 0; j &lt; la; ++j) {
			add(c[i + j], b[i] * a[j] % P);
		}
	}
	la = la + lb - 1;
	for(int i = 0; i &lt; la; ++i)a[i] = c[i];
	return ;
}

const int Bas = 1058400;
int C[Bas + 3];

inline void init() {
	fac[0] = 1;
	for(int i = 1; i &lt;= 50; ++i)fac[i] = fac[i - 1] * i % P;
	for(int i = 1; i &lt;= n; ++i) {
		L[i] = s[i].size();
		for(int k = 0; k &lt; L[i]; ++k)a[i][k] = s[i][k] - '0';
		int tmp = L[i];
		while(tmp % 2 == 0)tmp /= 2;
		while(tmp % 3 == 0)tmp /= 3;
		while(tmp % 5 == 0)tmp /= 5;
		while(tmp % 7 == 0)tmp /= 7;
		if(tmp == 1) {
			vis[0] = 1;
			for(int k = 0; k &lt; Bas; ++k)C[k]+=a[i][k % L[i]];
		} else {
			int tl = tmp * 12;
			vis[tmp] = 1;
			for(int k = 0; k &lt; tl; ++k)B[tmp][k]+= a[i][k % L[i]];
		}
	}
	bool flg = vis[0];
	for(int t = 0; t &lt; 12; ++t) {
		la = 0;vis[0] &amp;= flg;memset(A, 0, sizeof(A));
		for(int k = t; k &lt; Bas; k += 12) {A[C[k]]++;la = max(la, C[k] + 1);}
		for(int i = 1; i &lt;= 50; ++i) 	{
			if(!vis[i]) continue;
			memset(E, 0, sizeof(E));
			lc = 0;
			for(int k = t; k &lt; i * 12; k += 12) {E[B[i][k]]++;lc = max(lc, B[i][k] + 1);}
			if(!vis[0]) {vis[0] = 1; la = lc; for(int k = 0; k &lt; lc; ++k)A[k] = E[k]; continue;}
			mul(A, E, la, lc);
		}
		for(int k = 0; k &lt; la; ++k)add(D[k], A[k]);
	}
	vis[0] &amp;= flg;
	return ;
}
inline bool cmp(const string x, const string y) {
	return x.size() &lt; y.size();
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; s[i];
	sort(s + 1, s + n + 1, cmp);
	init();
	int qwq = fac[50];
	if(vis[0])qwq = qwq * ksm(Bas, P - 2) % P; else qwq = qwq * ksm(12, P - 2) % P;
	for(int i = 1; i &lt;= 50; ++i)if(vis[i])qwq = qwq * ksm(i, P - 2) % P;
	for(int i = 0; i &lt;= n; ++i)printf(&quot;%lld\n&quot;, 1ll * D[i] * qwq % P);
	return 0;
}



</code></pre>
<p>D</p>
<p>显然我们可以枚举中间的那个j,然后计算左右两边的贡献,就是左边那些大于他的和右边那些大于他的都可以拼起来</p>
<p>然后你会发现我们这个贡献好像就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i*(n-k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就是有多少区间包括他</p>
<p>做完了,树状数组维护即可</p>
<p>注意翻转值域的时候不要出现0</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 5e5 + 7;
const int P = 1e9 + 7;
int n, a[MAXN];
ll ans;
struct rec {
#define lowbit(x) (x&amp;(-x))
	ll tr[MAXN];
	inline void add(int x, ll V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline ll qry(int x) {
		ll ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} bt1, bt2;

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int M = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		M = max(M, a[i]);
	}
	++M;
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], n - i + 1);
	}
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], -n + i - 1);
		add(ans, bt1.qry(M - a[i] - 1) * bt2.qry(M - a[i] - 1) % P);
		bt2.add(M - a[i], i);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/">
              <h3 class="post-title">
                CSP-S2考前综合强化刷题（第二场）
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
