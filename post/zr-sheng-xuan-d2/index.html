<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZR省选讲课D2 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1614811461873">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="ZR省选讲课D2 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="T1
0~n-1的三个排列,问是否能找到一种排列方式满足ai+bi=ci(modn)a_i+b_i=c_i(mod n)ai​+bi​=ci​(modn)
偶数无解,左右和不相等
因为左边是0,右边是一个不是n的倍数的数
奇数直接0,1,2..." />
    <meta name="keywords" content="培训题,构造" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1614811461873" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              ZR省选讲课D2
            </h2>
            <div class="post-info">
              <span>
                2021-01-02
              </span>
              <span>
                22 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/GZNzWf9EG/" class="post-tag">
                  # 培训题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/nuL1JOWcod/" class="post-tag">
                  # 构造
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcXWdSo2JSaGilHS7uK7M5*4tqkMKZ13sUmHStlLxamqLfGFT2zoRrkiZUQQqFYDBdsJiJaMcvGS6AJK8GThOQUw!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>T1</p>
<p>0~n-1的三个排列,问是否能找到一种排列方式满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>c</mi><mi>i</mi></msub><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a_i+b_i=c_i(mod n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>偶数无解,左右和不相等</p>
<p>因为左边是0,右边是一个不是n的倍数的数</p>
<p>奇数直接0,1,2,3,4....排着加就好了,得到每个位置是2i</p>
<p>2 mod n不同余</p>
<p>所以每个数乘上一个不同余的数还是不同余</p>
<p>T2</p>
<p>2^n-1的完全图,你要找出尽量多没公共边三元环,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>&lt;</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">2^n&lt;1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.703492em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>这个答案等价于 两个三元环中 任意两个元素 不相同的构造</p>
<p>然后我们考虑这个构造是能卡到上界的,就是能构造到边数/3个三元环</p>
<p>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>2</mn><mo>)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(2^n-1)(2^n-2)}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>具体方法就是对于x<sup>y</sup>z=0的三元组,我们把它加入答案</p>
<p>因为一条边确定了,在这个构造中其余两条边也就唯一确定了,而且不会确定到其他case</p>
<p>所以可以证明这些两两不交</p>
<p>又因为固定了x,y后z唯一,所以我们仅枚举x,y能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2^n-1)*(2^n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>种方案</p>
<p>另外不难发现这样每个三元组被统计了6次,所以实际上我们是算了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">(2^n-1)*(2^n-2)/6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">6</span></span></span></span>,卡到了上界</p>
<p>T3</p>
<p>一个 2𝑛 个点的完全图，你需要把这些边分成 2𝑛−1 组，每组 𝑛 条边，且每组都是一个匹配（即任噫两条边没有公共点）</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝑛</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">𝑛≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>假设两个点编号为x,y,钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>&lt;</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;=x,y&lt;2n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">x+y(mod 2n-1)=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的x,y扔进组i中,考虑为啥不重复啊</p>
<p>首先显然一个边只能分入一组中,同时因为是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">mod 2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>剩余系,所以这个点显然也只能分入一次(匹配)</p>
<p>2n-1的连边怎么办啊</p>
<p>因为2n-1是奇数,那么对于每一个i,存在唯一的k使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>k</mi><mo>=</mo><mi>i</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2k=i (mod 2n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>所以k和2n-1的连边分入i组就是一组合法的解,这样2n-1就好啦</p>
<p>T4</p>
<p>n点完全图,从中选出尽量多不相交生成树,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n&lt;=1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>上界显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor n/2 \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></p>
<p>偶数怎么构造?</p>
<p>考虑归纳,已经构造好了n=2k case</p>
<p>n=2k+1是显然可以构造的</p>
<p>因为此时每个点都在每棵树中,所以我们只需要随便选择k个不同的点,然后连接上新点(2k+1)即可</p>
<p>注意这个是构造到最后的时候才能用,要不然下一步就没有2k的case了....</p>
<p>n=2k+2</p>
<p>先选1<sub>k这些点连上2k+1,k+1</sub>2k连上2k+2,这样我们就把之前k棵树都加上了新的点2k+2,2k+1</p>
<p>然后我们还要多出一棵树,此时我们直接把k+1<sub>2k和2k+1连边,然后1</sub>k和2k+2连边,然后2k+1和2k+2连边就好啦</p>
<p>时间复杂度就是快的</p>
<p>T5</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1609552189975.png" alt="" loading="lazy"></figure>
<p>答案是2n-2-凸包上的点数</p>
<p>证明是下界?</p>
<p>考虑用三角剖分,就是相邻层凸包之间的多边形三角剖分,这些是至少要满足哒</p>
<p>观察可知点数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>l</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">l_i,l_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>的相邻两层多边形三角剖分可以贡献<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>+</mo><msub><mi>l</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">l_i+l_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>个</p>
<p>故这样是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub><mo>+</mo><msub><mi>l</mi><mn>2</mn></msub><mo>+</mo><msub><mi>l</mi><mn>2</mn></msub><mo>+</mo><msub><mi>l</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>l</mi><mi>k</mi></msub><mo>−</mo><mn>2</mn><mo>=</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>2</mn><mo>−</mo><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1+l_2+l_2+l_3.....+l_k-2=2n-2-l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>(最内层直接三角剖分即可)</p>
<p>构造方案?</p>
<p>随机一个方向p向量</p>
<p>然后在每个点附近+p方向-p方向无穷小距离放置一个点</p>
<p>这样所有三角形都能被覆盖啦?</p>
<p>你会发现三角形内角和180度,也就是完全覆盖了一个半平面</p>
<p>那么三个顶点中放置的点至少有一个是满足落在内部...或边上的!</p>
<p>不过发现落在边上的可以随机一个方向打败他!(如果真非就......)</p>
<p>然后我们可以把在最外面的凸包上的点外面防止的点删掉,所以用的一定可以减去外层凸包的</p>
<p>然后凸包最左边和最右边的点(严格来说是和p相切的两个位置)可以多删掉一个点,因为两个点都在凸包外面qwq</p>
<p>T6</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1609590807312.png" alt="" loading="lazy"></figure>
<p>考虑增量构造就是我们先构造好前i列都是key第i+1列怎么构造</p>
<p>移动方法很简单,我们可以把右边任意一个字符放到左边,加入我们现在要把这一列都变为k</p>
<pre><code class="language-cpp">i       j
k        
*      k
*
k
*
</code></pre>
<p>就是*右移到k这个位置,然后再上移j直到一个k在那个位置,然后再把这一行左移回去</p>
<p>不难发现这一行左边都没变</p>
<p>而后面所有列的k都不够了,此时我们有一些abc垃圾优先塞入这些不是k的空位上,然后ey尽量留着</p>
<p>除非e,y也够了,够了他们就是垃圾了,丢进去就好了</p>
<p>如果列数不是3的倍数,此时直接操作到最后一次能凑齐key的就停就好了,右边的不用瞎踢蹬</p>
<p>除非是3的倍数,最后一个可能凑不齐y了....</p>
<pre><code class="language-cpp">i j
e?
e(?)
e?
e[y]
?y
?y
??
</code></pre>
<p>只需要考虑两边都是小于n的,因为都等于n或者一个等于n我们不用动</p>
<p>转一下,一定可以找到一行满足最后两个位置都是垃圾,挪到最下面一行</p>
<p>使用这两个垃圾位置可以交换最后两列任意其他位置!!(),[]</p>
<p>第一次 把要交换的位置()下去,然后第二次最后一行右移一位,然后再把最后一列[y]移动过来,再左移一位</p>
<pre><code class="language-cpp">i j
ey
ey
ey
e?
??
??
[y](?)
</code></pre>
<p>然后我们再把最后一列移动到原来()的位置,然后再把y右移一位,然后最后一列还原原位置,然后最后一行左移一位,这样最后一行不会变化!</p>
<p>T6</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1609566081998.png" alt="" loading="lazy"></figure>
<p>*李队切了</p>
<p>我们会发现可以把序列分成n段,每一段n+1个数字,然后每次我们找到第二小的数字最小的段</p>
<p>把这一段最小的和次小的数字选入子序列中,然后删除这一段,同时把所有其他段里面小于这段第二小的数字全部删掉</p>
<p>那么你会发现,第一次操作最多删除n+1,删除n+1的结果其他的都就是删掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">1~n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mord mathdefault">n</span></span></span></span>,而且每个均摊删掉至多一个</p>
<p>同样的我们递归进行下去,所有其他段数字个数至多减少1,所以每一段不可能减少到0个!</p>
<p>所以必然有解</p>
<p>T7</p>
<p>有个 2𝑛×𝑚 的棋盘，有 𝑛×𝑚 个红格子和 𝑛×𝑚 个蓝格子。保证棋盘的左上角是红色，右下角是蓝色。你需要把蓝色格点中心两两连出一个向量，红色格子中心两两连出一个向量，你需要让这些向量之和为 0.</p>
<p>*李队切了</p>
<p>nm为奇数跑欧拉回路内部向量和为0</p>
<p>如果左上角时红色,右下角是蓝色,我们会发现可以直接去掉,剩下的跑奇数的情况,然后左上角连到所有<br>
红右下角连到所有蓝的怎么搞成0</p>
<p>整张图中心对称一下,如果颜色不一样可以直接抵连边抵消</p>
<p>如果都是一样颜色的呢?同时向这个点连边,会发现这个向量的和是对角线,因为中心对称所以是整个斜对角线</p>
<p>然后会发现这样的点对数量是一样的,因为点数是一样的,所以相反的对角线数量相同,所以直接向两个点方向连就好了.....</p>
<p>这样做下去一定对角线也都消掉了,所以做完了qaq</p>
<p><s>这个有点过分巧妙</s></p>
<p>T8</p>
<p>给定一个环，环上每个点是三种颜色（RGB）之一，若一个点左右两边点的颜色不一样，你就可以任意改变这个点的颜色。<br>
问能否在 10𝑛 次操作内，把一个环变成另一个。如果能，给出构造。<br>
$ 5≤𝑛≤10^5$</p>
<p>关键在于你要发现这个操作是可逆的......所以我们只需要把两个环变成同一个中间状态</p>
<p>首先我们定义一个东西是破拆就是把一个有限制的变成任意位置都没有限制的</p>
<p>RBGRBG就是一个合法状态</p>
<p>首先暴力把两个都破拆后</p>
<p>我们考虑从1<sub>n扫,把他们都变成</sub><sub>RBQRBQ</sub>~</p>
<p>每次操作保证i-1和i+1颜色绝对不同,然后改变i即可,如果改变了i使得相同了,就先变一下i+2</p>
<p>这样可以保证任意时刻所有点都能够操作,直到合环的时候</p>
<p>你发现其实合环的时候也是可以的,因为我们这个目标状态是完全破拆态,所以不会导致夹死了n位置(n-1和1一定不同)</p>
<p>仔细数一下这个操作次数从一个环变到另一个环</p>
<p>就是4n的</p>
<p>T9</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1609592026755.png" alt="" loading="lazy"></figure>
<p>*李队切了</p>
<p>我们四方格考虑4次操作保证右下角格子是最大的,而且上面两个格子是无效的</p>
<p>无用行 :12</p>
<p>pos : 34</p>
<p>操作就是如果3位置大于4转一次,这样我们一行的较大值就移到右边去了</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1609565726409.png" alt="" loading="lazy"></figure>
<p>如果从下向上工作的话,你会发现我们可以把每一行的最大值集中到最右端,除去第一行和第二行我们无法操作!</p>
<p>然后我们想,把这些最大值集中起来,所以在最右列集中到顶部即可</p>
<p>然后再从右向左转第一行,就能保证最大值一直在最左边</p>
<p>然后再从第一行向下转一次,就能转到最后第一列最后一行</p>
<p>然后再把这个最大值从最后一行翻到最后一列就能确定好第一个位置了</p>
<p>但是第一列是不能放进2*2的矩阵的,就是你把第二列到第n列都放好后出问题了,没空位了</p>
<pre><code class="language-cpp">* ab
x cd
</code></pre>
<p>我们要把cd转到bd腾出一个位置</p>
<p>我们转c&gt;b?abcd即可</p>
<p>但是你会发现我们可能相等,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">c==b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></p>
<p>然鹅此时你会发现转不转都一样,等价的</p>
<p>怎么转回来,此时我们要把</p>
<p>bd<br>
ac</p>
<p>转回去</p>
<p>12<br>
34</p>
<p>编号不随着转动变</p>
<p>2&gt;3?转一次</p>
<p>1&gt;4?转一次</p>
<p>3&gt;2?转一次</p>
<p>当2&gt;3的时候转3次,否则会一次也没转,所以是等价的</p>
<p>注意我们没法维护最小值,但是可以按顺序排好最大值,n&lt;=9</p>
<p><s>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>是可以的</s></p>
<p>T10</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1609592509650.png" alt="" loading="lazy"></figure>
<p>2-sat</p>
<p>每个元素要么取上界要么取下界,这样显然合法</p>
<p>一般的元素上下界就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[0,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>这样</p>
<p>那么我们强行建出图,0/1表示取到这个点上下界,对于max,表示如果我取下界你取上界,我取上界你随便这样子,这个2-sat边是或边</p>
<p>min也是一样的,是或边,那么跑一个2-sat,可以知道一个连通块里面是一样的</p>
<p>所以直接弄2-sat然后跑个缩点拓扑图</p>
<p>你会发现跑tarjan进行的标号,其中最深的强联通分量显然就是拓扑序头头,然后一个个回溯就好啦</p>
<p>上下界找的方法很简单,就是所有max取min,所有min取max,显然是可以的</p>
<p>然后如果已经矛盾直接连我有了就好了</p>
<p>T11</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1609567758241.png" alt="" loading="lazy"></figure>
<p>非叶节点即出度为2的点啊,一开始是树的,结果直接树形DP就好了</p>
<p>这个有点玄妙</p>
<p>就是你考虑如果全是0/1值相等的时候我们可以直接判断出来:全部钦定1</p>
<p>然后如果0/1值不同,我们会发现(x,y是这个叶节点局面下根的取值)</p>
<p>0000000 x<br>
1000000 x<br>
1100000 x<br>
1110000 x<br>
1111000 y<br>
1111100 y<br>
1111110 y<br>
1111111 y</p>
<p>这样的一个取值序列,中间一定会有一个时刻发生了变化</p>
<p>所以我们把那个位置外其他位置都钦定了,然后那个位置是0的时候和前一个一样是x,然后那个是1后面是y</p>
<p>所以我们直接二分这个位置检验即可....</p>
<p>答案就是n-1 qwq</p>
<p><s>这个正确性好像是微积分的区间套,连续变化</s></p>
<p>T12</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1609592780324.png" alt="" loading="lazy"></figure>
<p>如果没有一颗树的限制,我们可以考虑分治,log的时间确定一个边</p>
<p>具体的,这个点和前1<sub>n/2的问一次,和后n/2+1</sub>n的问一次,这样子</p>
<p>一条边只会被问log次确定</p>
<p>但现在是一颗树,不妨把一些已知信息拿出来,然后用做差值呢</p>
<p>所以我们考虑能不能先确定1-&gt;2,2-&gt;3,3-&gt;4.....这些边是否存在</p>
<p>可以用点1,先问一遍1-&gt;2,2-&gt;3.....的边数</p>
<p>然后断开1和2的边,每次问一下1和别的点共n次,会发现要么是(第一次的值-1,第一次值)要么是(第一次+1第一次),前者是1-&gt;2一定存在,后者是1-&gt;2一定不存在</p>
<p>如果都相同,我们再问一下1所在的菊花图即可</p>
<p>从而确定1号点出边是否存在,然后根据点1来得到其他所有点的连边情况</p>
<p>就是每次断掉1-&gt;x,然后加入x-1-&gt;x来看这个答案对不对</p>
<p>再对于每个点来一个可爱的二分就做完了</p>
<p>T13</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1609593146206.png" alt="" loading="lazy"></figure>
<p>前两行前两列只要能削成0就完了,如果此时不能变为0就无解啦</p>
<p>证明:</p>
<p>123<br>
456<br>
789</p>
<p>然后我们会发现无论怎么操作,1+6+8位置的值和2+4+9位置的值和都是不变的(自己玩以下)</p>
<p>那怎么解决这两行这两列呢</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1609569070938.png" alt="" loading="lazy"></figure>
<p>就是两行上面的用对角线消,下面的用列消</p>
<p>T14</p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1609593360983.png" alt="" loading="lazy"></figure>
<p>考虑值域分块,我们有一个很优秀的性质:整个序列的值域分块得到的每一段的子序列也是区间值域分块的每一段</p>
<p>就是说<br>
1,2,4,5,6   9,10,11是整个的值域分块</p>
<p>那么区间的只能是1,2,4 9,10这样他的子序列</p>
<p>而又发现我们处理出每一块的值域分块的所有子序列对应集合然后一个询问直接合并根号次就好了</p>
<p>那么每次询问相当于下标在每个块中的提取出来合并,这个方法很简单,可以把开头找到然后查出前驱后继</p>
<p>就是下标在这块中的前驱后继</p>
<p>比如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1,8,9,7,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">5,3,1,2,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">8,9,7,6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span></span></span></span></p>
<p>就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1,2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">8,9,7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span></span></span></span></p>
<p>会发现我们就有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>B</mi><mo>∗</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n/B*Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></p>
<p>怎么处理一个块内连续段??</p>
<p>按值域剖开预处理左右两端连续小段</p>
<p>按照归并排序似的方法</p>
<p>找到每个元素在原序列中下标,此时下标已经排好序了</p>
<p>然后从按照下标来归并,如果左边放进去了就和右边的都合并一次</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>+</mo><mi>q</mi><mo>)</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O((n+q)\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>T14</p>
<p>CF1364E</p>
<p>考虑我们随机一个数,然后把或出来的最小值都拿出来再随机一个数,操作一下,直到最小值是1</p>
<p>这样我们是期望减半的qwq,二进制位1的个数</p>
<p>这样我们期望是:<span class='katex-error' title='ParseError: KaTeX parse error: Got function &#039;\sqrt&#039; with no arguments as superscript at position 16: n + \sqrt n +4^\̲s̲q̲r̲t̲ ̲n.....'>n + \sqrt n +4^\sqrt n.....</span></p>
<p>但是我们还有n次询问,所以不卡常就完蛋了</p>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1609570723575.png" alt="" loading="lazy"></figure>
<p>这样的做法可以达到2n卡不满,因为只有第三种要额外花费,所以我们randomshuffle一下</p>
<p>虽然我们看上去这个做法是3n的,但是根据随机的理论,是可以随便过的</p>
<p>T15</p>
<p>CF1365G</p>
<p>有一个数组 A，你可以每次询问一些位置，会告诉你这些位置上数字的或。<br>
你需要在 13 次操作内得到所有的 𝑃_𝑖 表示除了 𝐴_𝑖 以外其它所有数字的按位或。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>𝑛</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">𝑛≤1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>映 射</p>
<p>首先二进制分组很简单吧,就是拿下标二进制分组做</p>
<p>这样要20次操作,命没了</p>
<p>把所有13位的恰好有6个1的二进制数拿过来,显然可以做到满射</p>
<p>然后把每个二进制位为1的拿出来求一次或</p>
<p>那你会发现对于一个数x,他的表示有一些位置是0,那么把这些位置是1的数拿出来,然后他们或起来</p>
<p>你想,这样可能会有10110没有算入10010的case</p>
<p>然鹅,我们每个数的二进制下1的个数是相同的,所以不可能少算,那一位不同之后一定会有一位相同!</p>
<p>T16</p>
<p>CF1290D</p>
<p>卡 常 数</p>
<p>相当于找一个数字之前是否出现过</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>k</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{k}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>一个块</p>
<p>每次考虑把前面的块放入队列,然后后面的块放进去查</p>
<p>这样复杂度是<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \k at position 7: O(2n^2\̲k̲)'>O(2n^2\k)</span></p>
<p>我们可以卡 常</p>
<p>枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mtext> </mtext><mfrac><mrow><mn>2</mn><mi>n</mi></mrow><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">i=1~\frac{2n}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>然后每次把间隔为i的块加入队列</p>
<p>这样差不多我们有一个1/2常数</p>
<p>因为你会发现我们不需要把前面的块推出来再加入啦!</p>
<p>常数之和3/2</p>
<p>T17</p>
<p>CF1292E</p>
<p>询问CC,CH,CO,HO,OO</p>
<p>我们就知道所有C后面的和O前面的,这些把序列分成若干段,中间的都是相同字符,根据开头结尾判断即可</p>
<p>这样只有最后一个和前面一个没有确定,再花三次问出来就好了</p>
<p>但是4不对的!</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1609572824139.png" alt="" loading="lazy"></figure>
<p>T18</p>
<p>CF1288F</p>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1609573125450.png" alt="" loading="lazy"></figure>
<p>上下界费用流(?)</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>−</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">∞</mi><mo>]</mo><mo>&gt;</mo><mi>R</mi><mo>−</mo><mi>r</mi><mo>&gt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S-[1,\infty]&gt;R-r&gt;T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∞</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></p>
<p>对于red,源点向其连下界为1</p>
<p>右边也一样,连接</p>
<p>中间的我们连接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v,1,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(v,u,1,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1609596516518.png" alt="" loading="lazy"></figure>
<p>T19</p>
<p>CF1097E</p>
<p>g(P)表示把P划分为最少的上升子序列和下降子序列的个数</p>
<p>eg:123456 = 1</p>
<p>145236=1456+23=2</p>
<p>132456=1456+32=2</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><msub><mi>g</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">f_n=max g_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>上界是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>x</mi><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1+2+3+....+x&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>的x</p>
<p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>∗</mo><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x*(x+1)/2&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>最小的x</p>
<p>根据dirworth定理,这个东西张这个样子</p>
<p>1 3,2 6,5,4 10,9,8,7</p>
<p>那么怎么构造一个小于这个的方案呢?</p>
<p>如果一个排列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>I</mi><mi>S</mi><mo>&gt;</mo><msub><mi>f</mi><mi>n</mi></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LIS&gt;f_n=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">n-=l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>,那你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>x</mi><mo>∗</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">&lt;x*(x-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>所以这样n必然可以x-1次操作完成</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mo>=</mo><msub><mi>f</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">l&lt;=f_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>l就是最长反链</p>
<p>直接用LDSdp划分,就只用l次了!</p>
<p>复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>T20</p>
<p>CF1227G||CF1261E</p>
<p>做过啊</p>
<p>显然可以变成矩阵,问题是每一行都要不相同</p>
<p>先排序保证数字不降</p>
<p>然后我们考虑有一个合法的方案是从i,i开始填,向下放a_i个1</p>
<p>怎么证明任意两行不同呢</p>
<p>首先你会发现对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mo>&gt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i-&gt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>都会有1</p>
<p>那么对于i+1列,他一定是第i+1行开始填的,如果i和i+1行要相同,a_i+1就不能跨过第j列,那继续向下推</p>
<p>你会发现推到第j行我们能推出那个数是0,就没了</p>
<p>T21</p>
<p>模型转换换</p>
<p>黑色的是有球的,白色的无球,是坑</p>
<p>那么我们要把一个球放入另一个坑中</p>
<p>你会发现我们一个球会一路爬过去要先清空路中的球</p>
<p>考虑算贡献,对于一个点代表的子树向他父亲的边算贡献</p>
<p>那么对于这条边相当于我们要花费路径长度的代价才能实现一次操作</p>
<p>环套树,我们要讨论环的奇偶性</p>
<p>环是奇数,你会发现我们断开一条边后u,v深度奇偶性相同,等价于操作后我们会+2个球</p>
<p>那么也就是说我们可以对于这两个点同时+1/-1,多放入或者少放入球</p>
<p>有解当且仅当坑和球奇偶性相同,那么我们就可以</p>
<p>偶环,操作一次相当于把球扔进动或者抠出来</p>
<p>有解当且仅当坑和球数量相同</p>
<p>解法:</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1609576037813.png" alt="" loading="lazy"></figure>
<p>T22</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1609576211015.png" alt="" loading="lazy"></figure>
<p>矩阵中的数互不同</p>
<p>找等价操作</p>
<p>先分析一下这个操作下的不变量是什么。</p>
<p>首先一列里面三个数字要么是顺着的要么是反着的，它们不可能被分开。并且一次交换只能交换奇数位/偶数位中的相邻两个。</p>
<p>按奇偶位置分开，设 𝑓(1/0) 表示奇数位/偶数位上反转列数量的奇偶性，𝑔(1/0) 表示奇数位/偶数位的逆序对数量的奇偶性。</p>
<p>首先一次奇数位为中心的操作会让 𝑔(0)<sup>=1,𝑓(1)</sup>=1，偶数位的操作相反。因此总有 𝑓(0)=𝑔(1),𝑓(1)=𝑔(0)。</p>
<p>接下来我们证明这是充分条件。</p>
<p>我们先把所有列不管正反先交换到对应位置上。然后设小写字母表示原来的列，大写字母表示反转之后的列：</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1609597400039.png" alt="" loading="lazy"></figure>
<p>就是说我们先把两列变成间隔为1的,然后交换回去就好了</p>
<p>上述构造证明了任意距离为 2 的两列都可以直接被反转。</p>
<p>由于奇偶性的保证，刚交换完时的 𝑓 必然和最终的 𝑓 相等，因此直接反转必然可以成为答案。</p>
<p>也就是说,我们奇数列/欧数列单独一定满足不符合的/翻转的位置写出来是</p>
<p>0111000111,其中有偶数个1</p>
<p>那么我们从左向右扫一遍,遇到一个1就翻转i和i+1即可</p>
<p>事实上如果 𝑛≤1000，可以输出方案，步数级别 𝑂(𝑛^2)。</p>
<p>不要求输出方案只需要球逆序对数量，直接 bit 即可（或者由于只需要球奇偶性可以做到线性）。</p>
<p>但是这题是判yes/no qwq</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/zr-sheng-xuan-jiang-ke-d1/">
              <h3 class="post-title">
                ZR省选讲课D1
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
