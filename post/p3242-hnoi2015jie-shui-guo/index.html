<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>P3242 [HNOI2015]接水果 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1606122087696">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="P3242 [HNOI2015]接水果 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="预处理部分:
考虑怎么判断一条路径是否被另一条覆盖
设要被包含的路径是(u,v),而去包含的是(x,y)
对于LCA(u,v)==u的,
(x,y)中至少有一个在v子树里面
钦定x在v的子树里,那么dfnv&lt;=dfnx&lt;=dfn..." />
    <meta name="keywords" content="平面转换,扫描线,整体二分,线段树" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1606122087696" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              P3242 [HNOI2015]接水果
            </h2>
            <div class="post-info">
              <span>
                2020-08-24
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/BpczJh3Jx/" class="post-tag">
                  # 平面转换
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/MqPv-P4mK/" class="post-tag">
                  # 扫描线
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/DjesUT3xSE/" class="post-tag">
                  # 整体二分
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/i0TglRCqu/" class="post-tag">
                  # 线段树
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mceRZazz6MeZpbcBANAA7JWsPcncNNLMdMFUX.Jal.DOD2hIegEIYKwEGog0fOyH9.efbWokFI1g81vR5E8FvpSc!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="预处理部分">预处理部分:</h1>
<p>考虑怎么判断一条路径是否被另一条覆盖</p>
<p>设要被包含的路径是(u,v),而去包含的是(x,y)</p>
<h2 id="对于lcauvu的">对于LCA(u,v)==u的,</h2>
<p>(x,y)中至少有一个在v子树里面</p>
<p>钦定x在v的子树里,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>x</mi></msub><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn_v&lt;=dfn_x&lt;=dfn_v+siz[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span></p>
<p>而且钦定g为uv方向的儿子,就是y向v走一步走到的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>g</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>&lt;</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn_g+siz[g]&lt;=dfn_y&lt;=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>&lt;</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">1&lt;=dfn_y&lt;dfn_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>也就是说在除了g子树外任意一点都可以!</p>
<p>会发现这6个上下界和(x,y)没有关系</p>
<p>这相当于四维限制,只能转换到平面上,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_x,dfn_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>要在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>g</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v,dfn_g+siz[g])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>为左下角,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v+siz[v],n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为右上角的矩形或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>为左下角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v+siz[v],dfn_g-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>为右上角的矩形里面(这样你会发现x,y坐标都满足了限制)</p>
<p>也就是说,我们如果搞两个矩形加,那么(x,y)包含的路径数查询就是单点查询了!</p>
<p>但是还没完,我们再看看另一类路径</p>
<h2 id="lcauvuv"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(u,v)!=(u||v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></h2>
<p>那么我们有(x,y)包括(u,v)的话....</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 27: …x&lt;=dfn_v+siz[v]$̲$即x在v的子树里!

$$d…'>dfn_v&lt;=dfn_x&lt;=dfn_v+siz[v]$$即x在v的子树里!

$$dfn_u&lt;=dfn_y&lt;=dfn_u+siz[u]$$即x在u的子树里!

这个矩阵加的信息也和$(x,y)$是什么没有关系,所以可以处理!

$(dfn_v,dfn_u)$为左下角,$(dfn_v+siz[v],dfn_u+siz[u])$为右上角的矩形

这样我们可以搞到一个二维平面上,但是问题是第k大怎么处理...QAQ

# 搞事情部分:

既然我们只能很快的查出**有多少个**,不妨把第k大用个二分去解决

1. 二分一个答案,对于一个询问,把所有大于二分值的盘子加入平面

2. 查询水果点上有多少个数,如果多了就调大二分值,否则调小二分值

但是这样也太太太慢了

 ##  整体二分!

所有水果我们一起二分一个答案,把大于这个值的盘子加入平面

然后所有都查询一遍$O(mlogm)$

之后我们把数量小于k的(说明要调小)放入左边区间递归,同时把盘子中小于k的放入左边,然后把数量大于k的放入右边区间递归,同时把盘子中大于k的放入右边

## 最后一步!如何实现矩阵+单点求和?

扫描线好题/se

可以考虑用扫描线,把所有的矩形和询问点都加入分界点中,然后遇到修改在线段树上改,遇到查询就查一下

这样复杂度就会O(nlogn)了

总复杂度我们不难得出

$O((m+n)lognlogV)$

4e4的范围应该能过了....

后记:

写代码的时候注意线段树清空,以及第一步建边的时候拆询问,可能导致一些在几千组询问的时候WA掉的锅

还有整体二分的时候同时分盘子和水果....不过相对坑较小

附带7.33kb未删除调试code:

```cpp

//你知道真正的写吐了吗....
//整体分毒
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e5 + 7;
int n, p, q, V;
struct rec {
	int x, y, z, w, id;
	bool operator&lt;(const rec &amp;x) const {
		return z &lt; x.z;
	}
} b[MAXN], a[MAXN], mdf[MAXN], qry[MAXN], C[MAXN], D[MAXN], A[MAXN], B[MAXN];
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], dep[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int depp, siz[MAXN], dfn[MAXN], son[MAXN], fa[MAXN];
inline void dfs(int u, int F) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		fa[v] = u;
		dep[v] = dep[u] + 1;
		dfs(v, u);
		siz[u] += siz[v];
		if(siz[v] &gt; siz[son[u]])son[u] = v;
	}
	return ;
}
int top[MAXN];
inline void dfs2(int u, int topf) {
	top[u] = topf;
	dfn[u] = ++depp;
	if(!son[u])return ;
	dfs2(son[u], topf);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa[u] || v == son[u])continue;
		dfs2(v, v);
	}
	return ;
}

inline int LCA(int x, int y) {
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])x ^= y ^= x ^= y;
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])x ^= y ^= x ^= y;
	return x;
}

inline int getG(int x, int y) {//y到x第一个点
	if(x == y)return x;
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])x ^= y ^= x ^= y;
		if(fa[top[x]] == y) {
			// printf(&quot;G:%d %d? %d\n&quot;, x, top[x], y);
			return top[x];//不在一个重链
		}
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])x ^= y ^= x ^= y;
	return son[x];//如果正好在一个重链
}


inline void init() {
	int rc = p;
	for(int i = 1; i &lt;= rc; ++i) {
		int u = b[i].x;
		int v = b[i].y;
		if(dep[u] &gt; dep[v])u ^= v ^= u ^= v;
		int anc = LCA(u, v);
		// printf(&quot;%d?/cy\n&quot;, i);
		if(anc == u) {//first
			// printf(&quot;u,v,anc is %d %d %d?\n&quot;, u, v, anc);
			int g = getG(v, anc);
			int nxt = i;
			if(dfn[g] + siz[g] &lt;= n) {
				nxt = p + 1;
				mdf[i].x = dfn[v];
				mdf[i].y = dfn[g] + siz[g];
				mdf[i].w = dfn[v] + siz[v] - 1;
				mdf[i].id = n;
			}
			// printf(&quot;%d?\n&quot;, nxt);
			if(1 &lt;= dfn[g] - 1) {//好像没用
				if(nxt == p + 1)
					++p;
				mdf[nxt].x = 1;
				mdf[nxt].y = dfn[v];
				mdf[nxt].w = dfn[g] - 1;
				mdf[nxt].id = dfn[v] + siz[v] - 1;
				mdf[nxt].z = b[i].z;
			}
			// printf(&quot;%d %d???\n&quot;, nxt, p);
			// printf(&quot;g is :%d ,(%d,%d)and (%d,%d) bing! (%d,%d)and (%d,%d)\n&quot;, g, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id, mdf[nxt].x, mdf[nxt].y, mdf[nxt].w, mdf[nxt].id);
		} else {
			if(dfn[u] &lt; dfn[v])swap(u, v);
			mdf[i].x = dfn[v];
			mdf[i].y = dfn[u];
			mdf[i].w = dfn[v] + siz[v] - 1;
			mdf[i].id = dfn[u] + siz[u] - 1;
			// printf(&quot;u:%d v:%d (%d,%d)and (%d,%d) \n&quot;, u, v, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id);
		}
		mdf[i].z = b[i].z;
	}
	// for(int i = 1; i &lt;= p; ++i) {
	// 	printf(&quot;%d %d %d %d %d\n&quot;, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id, mdf[i].z);
	// }
	for(int i = 1; i &lt;= q; ++i) {
		int u = a[i].x;
		int v = a[i].y;
		// printf(&quot;%d %dqwerty\n&quot;, dfn[u], dfn[v]);
		qry[i].x = dfn[u];
		qry[i].y = dfn[v];
		qry[i].id = a[i].id;
		qry[i].z = a[i].z;
	}
	// puts(&quot;It&#039;s OK!&quot;);
	return;
}

namespace seg {
	int ls[MAXN], rs[MAXN], T, sum[MAXN], tag[MAXN], root;
	inline void pushdown(int k) {
		if(!tag[k])return ;
		if(!ls[k]) {
			ls[k] = ++T;
			ls[T] = 0;
			rs[T] = 0;
			sum[T] = 0;
			tag[T] = 0;
		}
		if(!rs[k]) {
			rs[k] = ++T;
			ls[T] = 0;
			rs[T] = 0;
			sum[T] = 0;
			tag[T] = 0;
		}
		tag[ls[k]] += tag[k];
		sum[ls[k]] += tag[k];
		tag[rs[k]] += tag[k];
		sum[rs[k]] += tag[k];
		tag[k] = 0;
	}
	inline void modify(int &amp;k, int l, int r, int x, int y, int V) {
		if(!k) {
			k = ++T;
			ls[k] = 0;
			rs[k] = 0;
			sum[k] = 0;
			tag[k] = 0;
		}
		// printf(&quot;%d?\n&quot;, tag[k]);
		if(x &lt;= l &amp;&amp; y &gt;= r) {
			// printf(&quot;%d?%d %d %d\n&quot;, l, r, x, y);
			tag[k] += V;
			sum[k] += V; //非叶节点的这个没用
			// printf(&quot;%d?\n&quot;, sum[k]);
			return ;
		}
		pushdown(k);
		int mid = (l + r) &gt;&gt; 1;
		if(x &lt;= mid)modify(ls[k], l, mid, x, y, V);
		if(y &gt; mid)modify(rs[k], mid + 1, r, x, y, V);
	}
	inline int query(int k, int l, int r, int pos) {
		if(!k)return 0;
		// printf(&quot;%d %d %d\n&quot;, k, sum[k], tag[k]);
		if(l == r) {
			// printf(&quot;%d %d %d %d\n&quot;, l, r, k, sum[k]);
			return sum[k];
		}
		pushdown(k);
		int mid = (l + r) &gt;&gt; 1;
		if(pos &lt;= mid)return query(ls[k], l, mid, pos);
		else return query(rs[k], mid + 1, r, pos);
	}
}
using namespace seg;
int ans[MAXN];

struct SEG {
	int x, L, R;
	bool operator&lt;(const SEG &amp;y) {
		return x == y.x ? L &gt; y.L : x &lt; y.x;
	}
} que[MAXN];

bool cmp(const int &amp;x, const int &amp;y) {
	return mdf[x].z &lt; mdf[y].z;
}
//l1,r1 is mdf
//l2,r2 is ask
inline void fz(int L, int R, int l1, int r1, int l2, int r2) {
	if(L == R) {
		for(int i = l2; i &lt;= r2; ++i) {
			ans[qry[i].id] = L;
		}
		return ;
	}
	if(L &gt; R)return ;
	int mid = (L + R) &gt;&gt; 1;
	// printf(&quot;qwq in?%d %d %d %d %d %d %d\n&quot;, L, mid, R, l1, r1, l2, r2);
	assert(R &gt;= L);
	int T1 = 0, T2 = 0;
	for(int i = l1; i &lt;= r1; ++i) {
		// printf(&quot;%d?%d\n&quot;, mdf[i].x, mdf[i].y);
		if(mdf[i].z &lt;= mid) {
			B[++T1] = mdf[i];
		} else {
			A[++T2] = mdf[i];
		}
	}
	int T3 = 0;
	for(int i = 1; i &lt;= T1; ++i) {
		que[++T3].x = B[i].x;
		que[T3].L = B[i].y;
		que[T3].R = B[i].id;
		que[++T3].x = B[i].w + 1;
		que[T3].L = B[i].y;
		que[T3].R = -B[i].id;//del
	}
	//B is &lt; mid;
	for(int i = l2; i &lt;= r2; ++i) {
		que[++T3].x = qry[i].x;
		que[T3].L = -i;
		que[T3].R = qry[i].y;
		// printf(&quot;%d???%d\n&quot;, qry[i].y, qry[i].x);
	}
	sort(que + 1, que + T3 + 1);
	// for(int i = 1; i &lt;= T3; ++i)if(que[i].L &lt;= 0)printf(&quot;%d %d\n&quot;, que[i].x, que[i].L);
	// printf(&quot;??%d?\n&quot;, T3);
	root = T = 0;
	int tot1 = 0, tot2 = 0;
	for(int i = 1; i &lt;= T3; ++i) {
		assert(que[i].L != 0);
		// printf(&quot;%d?-&gt;\n&quot;, que[i].x);
		if(que[i].R &lt; 0) {
			que[i].R = -que[i].R;
			// printf(&quot;???what?:%d %d %d\n&quot;, que[i].x, que[i].L, que[i].R);
			modify(root, 1, n, que[i].L, que[i].R, -1);
		} else if(que[i].L &lt; 0) {
			que[i].L = -que[i].L;
			int P = que[i].L;
			int tmp = query(root, 1, n, que[i].R);
			// printf(&quot;Yes I am :%d?%d %d %d?%d\n&quot;, tmp, qry[P].id, qry[P].z, que[i].x, que[i].R);
			if(tmp &lt; qry[P].z) {
				// printf(&quot;I am a poor boy&quot;);
				C[++tot1] = qry[P];
				C[tot1].z -= tmp;
			} else {
				D[++tot2] = qry[P];//decrease
				ans[qry[P].id] = mid;
			}
		} else {
			// printf(&quot;%d %d\n&quot;, que[i].L, que[i].R);
			modify(root, 1, n, que[i].L, que[i].R, 1);
		}
	}
	for(int i = 0; i &lt; tot2; ++i) {
		qry[i + l2] = D[i + 1];
	}//C is who need less
	for(int i = 1; i &lt;= tot1; ++i) {
		qry[i + l2 + tot2 - 1] = C[i];
	}//D is who need big
	int fja = tot2 + l2;//分界点
	for(int i = 0; i &lt; T1; ++i) {
		mdf[i + l1] = B[i + 1];
	}//B is who need less
	for(int i = 1; i &lt;= T2; ++i) {
		mdf[i + l1 + T1 - 1] = A[i];
	}//A is who need big
	int fjb = T1 + l1;
	// printf(&quot;New R1 :%d,New R2 :	%d\n&quot;, fja, fjb);
	if(fjb - 1 &gt;= l1 &amp;&amp; fja - 1 &gt;= l2)
		fz(L, mid, l1, fjb - 1, l2, fja - 1);
	if(r1 &gt;= fjb &amp;&amp; r2 &gt;= fja)
		fz(mid + 1, R, fjb, r1, fja, r2);
	return;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;q);
	for(int i = 2, a, b; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		ct(a, b);
		ct(b, a);
	}
	for(int i = 1; i &lt;= p; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;b[i].x, &amp;b[i].y, &amp;b[i].z);
		V = max(V, b[i].z);
	}
	dep[1] = 1;
	dfs(1, 0); //init dfn,siz
	dfs2(1, 1);
	// for(int i = 1; i &lt;= n; ++i)printf(&quot;well finished....%d %d\n&quot;, i, dfn[i]);
	for(int i = 1; i &lt;= q; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);
		if(dfn[a[i].x] &gt; dfn[a[i].y])
			swap(a[i].x, a[i].y);
		a[i].id = i;
	}
	init();
	fz(1, V, 1, p, 1, q); //整体二分!!
	for(int i = 1; i &lt;= q; ++i) {
		printf(&quot;%d\n&quot;, ans[i]);
	}
	return 0;
}


```

~~调了一个晚上+上午50min....~~</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E9%A2%84%E5%A4%84%E7%90%86%E9%83%A8%E5%88%86">预处理部分:</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BA%8Elcauvu%E7%9A%84">对于LCA(u,v)==u的,</a></li>
<li><a href="#lcauvuv"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(u,v)!=(u||v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/lgr-075-luo-gu-8-yue-yue-sai-ii/">
              <h3 class="post-title">
                 【LGR-075】洛谷 8 月月赛 II
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
