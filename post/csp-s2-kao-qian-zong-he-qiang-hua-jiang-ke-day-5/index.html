<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSP-S2考前综合强化讲课(Day 5) | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1608132150600">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSP-S2考前综合强化讲课(Day 5) | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="
菜啊
异或粽子的做法
前缀和
维护所有右端点当且最小左端点,然后我们每次找全局的右端点-左端点最大值
取出一个就把区间左右边的add进堆里
这样一直做下去直到找齐k个

显然这个东西在排序意义下就是取中位数
那么就是动态维护区间中位数

..." />
    <meta name="keywords" content="决策单调性,分块,培训题,线段树" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1608132150600" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSP-S2考前综合强化讲课(Day 5)
            </h2>
            <div class="post-info">
              <span>
                2020-10-05
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/COtpYRseX/" class="post-tag">
                  # 决策单调性
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/2ioLAuAHI/" class="post-tag">
                  # 分块
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/GZNzWf9EG/" class="post-tag">
                  # 培训题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/i0TglRCqu/" class="post-tag">
                  # 线段树
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVpgXsL7QDAXY31uagkJHUfPf*K.NcUh87plRUA4wB4pT*xWhA7VyJ4j7qLzjQDntRbvk*VrnVilgZTZSG*FSSo!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601880403208.png" alt="" loading="lazy"></figure>
<p>菜啊</p>
<p>异或粽子的做法</p>
<p>前缀和</p>
<p>维护所有右端点当且最小左端点,然后我们每次找全局的右端点-左端点最大值</p>
<p>取出一个就把区间左右边的add进堆里</p>
<p>这样一直做下去直到找齐k个</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601880494617.png" alt="" loading="lazy"></figure>
<p>显然这个东西在排序意义下就是取中位数</p>
<p>那么就是动态维护区间中位数</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601882617595.png" alt="" loading="lazy"></figure>
<p>显然可以线段树二分,从最左侧到最右侧一次放广告,找到最左边第一个能放广告的位置,就把放进去剪掉空余</p>
<p>一直模拟到n即可</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601882696048.png" alt="" loading="lazy"></figure>
<p>还是要维护一下的,前缀最大空房间位置,后缀最大空房间位置,然后一个区间总的最大空房间</p>
<p>然后线段树二分,能向左就向左</p>
<p>合并的时候两边最大和中间最大取max</p>
<p>然后修改直接把那些区间拿出来改改</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601883312053.png" alt="" loading="lazy"></figure>
<p>堵塞的交通都是有毛病的题</p>
<p>维护一个区间左边一列连通性,右边一列连通性,区间连通块数</p>
<p>然后合并时候,我们考虑下左右连通新联通情况</p>
<p>同一连通块可以用一个编号存下</p>
<p>然后中间连通信息可以推出新的左右连通信息!</p>
<p>我们最多5个二进制位可以记录一个编号,那么20个数也可以用两个longlong存下,左边一个右边一个</p>
<p>合并的时候直接分配新标号</p>
<p>同时我们也可以计算出新减少的连通块数,因为但凡中间能够产生一次新的合并就要-1</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601886002030.png" alt="" loading="lazy"></figure>
<p>偶数次???好像奇数次我们很会做</p>
<p>会发现我们是可以数据结构的</p>
<p>那么我们首先可以算出所有不同的数异或和</p>
<p>然后我们查出一个异或和之后异或上奇数的异或和即可</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601887892141.png" alt="" loading="lazy"></figure>
<p>线段树维护那个EI/se</p>
<p>然后合并的时候也是异或一下</p>
<p>考虑每一位拿出来,然后新的式子是:</p>
<p>(^^<sup>+</sup>^<sup>+</sup>^<sup>+)</sup>(+ + + +)</p>
<p>显然第i位加起来的信息可以处理,每一位异或起来有多少1可以处理,每一位有多少一可以处理</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1601892854693.png" alt="" loading="lazy"></figure>
<p>默念口诀:</p>
<p>导函数值单增最大化单调栈</p>
<p>导函数值单减最大化单调队列</p>
<p>证明?</p>
<p>你考虑我们时间点只可能越来优,但是一开始可能还不到那个时间</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1601894416862.png" alt="" loading="lazy"></figure>
<p>一开始想三个数组每个元素找一个最小的出现位置,然后三个lst最小出现位置求和</p>
<p>这样假了</p>
<p>14567892<br>
3333332</p>
<p>n^2显然可以枚举两个第三个单调变化</p>
<p>然后我们考虑枚举第一个,然后快速<strong>查询</strong>二三个数组的答案,<br>
那么我们就能快速解决了</p>
<p>先考虑从后向前删除,因为加入限制显然比撤销限制更好做</p>
<p>把A数组每个值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,钦点一个(x,y),x表示在第二个数组中最早出现的位置,y表示第三个数组最早出现的位置</p>
<p>然后我们要做的就是有最小的矩形把所有点都覆盖了</p>
<p>并不这样的,我们是要用最少的矩形把所有<strong>权值</strong>都覆盖了</p>
<p>但是由于我们每个点可能有相同的权值,所有很自闭</p>
<p>那么我们就仔细观察一下可能成为决策的那些点</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1601894934975.png" alt="" loading="lazy"></figure>
<p>就是那些<strong>拐点</strong>!</p>
<p>为什么?</p>
<p>因为别忘了,我们的数组是<strong>小于等于</strong>,而现在点只是小于</p>
<p>选一个拐点就选了左及下方所有点</p>
<p>所以我们会发现这个拐点的右上方矩阵一定没有用了,因为不存在一个更早的元素</p>
<p>所以我们现在要维护的是:</p>
<ol>
<li>一个类似于凸包的阶梯</li>
<li>所有拐点答案最大值</li>
</ol>
<p>做法:</p>
<p>用set维护阶梯,即可,插入一个点会把那些都小于等于它的删掉,做法就是找到第一维大于他的然后向前跳,直到第二维不满足了</p>
<p>当然也要看第一个第一维大于他的</p>
<p>用heap维护答案也很显然,被删掉就lazypop,加入就push</p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1601896182256.png" alt="" loading="lazy"></figure>
<p>显然这个题可以魔法森林</p>
<p>枚举一维,LCT一维</p>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1601896586064.png" alt="" loading="lazy"></figure>
<p>显然这个题可以根号平衡</p>
<p>O(1)修改,O(\sqrtn)查询</p>
<p>然后大小分块第一个</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1601897052737.png" alt="" loading="lazy"></figure>
<p>我的做法:</p>
<p>序列分块,时域分块</p>
<p>首先每个区间可以分块,记录答案</p>
<p>会发现修改后我们每个块暴力打标记即可</p>
<p>然后每个时域可以分块,当我们查到边角块的时候,暴力下放根号次修改即可</p>
<p>然后你会发现我们要每根号次重构,总复杂度就是什么<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtm at position 4: O(n\̲s̲q̲r̲t̲m̲+m\sqrtn)'>O(n\sqrtm+m\sqrtn)</span></p>
<p>std:</p>
<p>上述做法愚蠢在于我们不能快速得到一些a的值</p>
<p>考虑我们把a分个块,然后你会发现修改一个a的值可以做到<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtn at position 1: \̲s̲q̲r̲t̲n̲'>\sqrtn</span></p>
<p>然后查询一个a的值可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mn>1</mn><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">O1 qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></p>
<p>然后函数我们也暴力分块就好了</p>
<p>做完了</p>
<p>小z的袜子</p>
<p>?</p>
<p>莫队的一个优化,奇偶分治</p>
<p>但是不要用了,飞哥亲口说的</p>
<p>就是左端点分块,相同右端点直接单增</p>
<p>优化就是左边的块是奇数的时候按照升序排序,否则按照降序排序</p>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1601899038885.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1601899052301.png" alt="" loading="lazy"></figure>
<p>其实就是康拓展开的写法,考虑先停到哪个位置,然后我们再计算后面的贡献就好了</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-wu-chang/">
              <h3 class="post-title">
                CSP-S2考前综合强化刷题（第五场）
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
