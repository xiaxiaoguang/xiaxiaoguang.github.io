<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSP-S2考前综合强化刷题（第五场） | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1606394259499">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CSP-S2考前综合强化刷题（第五场） | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="A
首先分析下题目性质
iii只比i−1i-1i−1天多1
然后只比i−2i-2i−2多2
那么会发现i要花费的天数可以是想化一些天追上i-1,然后在追上i−1i-1i−1的前提下去追i−2i-2i−2...
那么如果我们没追上i-1就追上..." />
    <meta name="keywords" content="分块,比赛题,动态规划" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1606394259499" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CSP-S2考前综合强化刷题（第五场）
            </h2>
            <div class="post-info">
              <span>
                2020-10-05
              </span>
              <span>
                9 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/2ioLAuAHI/" class="post-tag">
                  # 分块
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/A3FIICRYA/" class="post-tag">
                  # 比赛题
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/CJ-ugjBAY/" class="post-tag">
                  # 动态规划
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVpgXsL7QDAXY31uagkJHUdn4E0UiNQrt5mJSkNr*gKebsOkuyUnarCR71Vz8zlECGPTCam1uaCqxfoGdBGvg3I!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>A</p>
<p>首先分析下题目性质</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>只比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>天多1</p>
<p>然后只比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>多2</p>
<p>那么会发现i要花费的天数可以是想化一些天追上i-1,然后在追上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的前提下去追<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>...</p>
<p>那么如果我们没追上i-1就追上i-2的话...<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>也一定可以用哪个时间追上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>这个东西就比较显然....相邻取min</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 1e6 + 7;

int n, a[MAXN], ans;

signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	ans = 1e15;
	for(int i = 1; i &lt; n; ++i) {
		ans = min(ans, a[i] - a[i + 1]);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>B</p>
<p>曼哈顿距离,屑啊</p>
<p>显然我们前n/2大的都要在左边,后n/2大的在右边</p>
<p>那么我们只需要看看那些位置不满足这个性质,然后把他们任意交换就好了</p>
<p>因为是曼哈顿距离....所以就是后n/2前n/2大的下标之和-前n/2后n/2大的下标之和</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
#define ll long long
ll ans;
int n;
struct  rec {
	int x, id;
	bool operator&lt;(const rec &amp;w)const {
		return x &lt; w.x;
	}
} a[MAXN];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].x);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	for(int i = 1; i &lt;= n / 2; ++i) {
		if(a[i].id &gt; n / 2) {
			ans += a[i].id;
		}
	}
	for(int i = n / 2 + 1; i &lt;= n; ++i) {
		if(a[i].id &lt;= n / 2) {
			ans -= a[i].id;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>显然我们直接排序然后k个分一组是错误的,因为我们切换字符可以直接砍掉一堆</p>
<p>但是这个东西是可以在trie树上做的</p>
<p>我们把所有串插入trie然后在上面dfs即可,统计每个子树和,然后我们回溯的时候如果子树中够k个就凑一下</p>
<p>因为这样做能保证每个组尽可能的深的地方匹配,所以是对的</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>26</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e6 + 7;
int n, k;
char s[MAXN];
int rt = 1, T = 1;
int ch[MAXN][27];
int ed[MAXN];
inline void ins(char *s, int L) {
	int nw = rt;
	for(int i = 0; i &lt; L; ++i) {
		int t = s[i] - 'a';
		if(!ch[nw][t]) {
			ch[nw][t] = ++T;
		}
		nw = ch[nw][t];
	}
	ed[nw]++;//kk
	return ;
}

ll ans;
inline void dfs(int u, int dep) {
	for(int i = 0; i &lt; 26; ++i) {
		if(ch[u][i]) {
			dfs(ch[u][i], dep + 1);
			ed[u] += ed[ch[u][i]];
		}
	}
	ans += 1ll * dep * (ed[u] / k);
	ed[u] %= k;
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%s&quot;, s);
		int l = strlen(s);
		ins(s, l);
	}
	dfs(1, 0);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>D</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><msqrt><mrow><mo>∑</mo><mi>K</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">k&gt;\sqrt{\sum{K}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30500499999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.934995em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-2.894995em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30500499999999997em;"><span></span></span></span></span></span></span></span></span></p>
<p>考虑直接暴力,可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>K</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(K(n+m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>做法就是把每个位置修改一下然后再考虑m次暴力即可</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><msqrt><mrow><mo>∑</mo><mi>K</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">k&lt;\sqrt{\sum{K}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30500499999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.934995em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-2.894995em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30500499999999997em;"><span></span></span></span></span></span></span></span></span></p>
<p>考虑快速回答询问</p>
<p>显然的是这个询问不会很快...此时会发现我们能够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">k^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>二维数点了</p>
<p>李队有一个O(1)回答的做法,好像是根号平衡啊</p>
<p>就是考虑用前缀和分块,然后我们修改复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>二维平面上我们就直接扫描线扫过去</p>
<p>可以离线做到一个log,复杂度<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtQ at position 5: O(Q \̲s̲q̲r̲t̲Q̲ ̲log)'>O(Q \sqrtQ log)</span></p>
<p>code:</p>
<pre><code class="language-cpp">
//数据处理题
//超高校级的幸运
//如果数据随机,\sum_K会减少的很快,暴力就快
//如果构造去他妈的
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 5e5 + 7;
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int n, m, q, Bas, ccnt;
int home[MAXN], nxt[MAXN], tl[MAXN], tr[MAXN], ans[MAXN];
int q1[MAXN], q2[MAXN], t1, t2, a[MAXN];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	tl[ccnt] = y;
	tr[ccnt] = z;
}

const int BIG = 1e7 + 8;

struct rec {
	int u, v, x, y;
	rec(int u = 0, int v = 0, int x = 0, int y = 0) : u(u), v(v), x(x), y(y) {};
	bool operator&lt;(const rec &amp;w) const {
		return u == w.u ? x &lt; w.x : u &lt; w.u;
	}
} e[MAXN], qry[MAXN], mda[BIG];

inline void solve1() {
	for(int i = 1; i &lt;= t1; ++i) {
		int id = q1[i];
		for(int k = home[qry[id].v]; k; k = nxt[k]) {
			int L = tl[k];
			int R = tr[k];
			for(int  j = L; j &lt;= R; ++j)
				a[j] = i;
		}
		for(int j = 1; j &lt;= m; ++j) {
			if(a[e[j].u] == i &amp;&amp; a[e[j].v] == i) {
				ans[qry[id].v] = 1;
				break;
			}
		}
	}
	return ;
}

struct bit {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN];
	inline void add(int x, int V) {
		for(; x &lt;= n; x += lowbit(x))
			tr[x] += V;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tre;
#define  lowbit(x) (x&amp;(-x))
inline void solve2() {
	int tot = 0;
	for(int t = 1; t &lt;= t2; ++t) {
		int i = q2[t];
		for(int j = home[qry[i].v]; j; j = nxt[j]) {
			for(int k = j; k; k = nxt[k]) {
				mda[++tot] = (rec) {
					tl[k] - 1, tl[j], tr[j], -qry[i].v
				};
				mda[++tot] = (rec) {
					tr[k], tl[j], tr[j], qry[i].v
				};
			}
		}
	}
	for(int i = 1; i &lt;= m; ++i) {
		mda[++tot] = (rec) {
			e[i].u, e[i].v, -1
		};
	}
	sort(mda + 1, mda + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mda[i].x == -1) {
			tre.add(mda[i].v, 1);
		} else if(mda[i].y &gt; 0) {
			if(mda[i].v == 1)ans[mda[i].y] += tre.qry(mda[i].x);
			else ans[mda[i].y] += tre.qry(mda[i].x) - tre.qry(mda[i].v - 1);
		} else {
			mda[i].y = -mda[i].y;
			if(mda[i].v == 1)ans[mda[i].y] -= tre.qry(mda[i].x);
			else ans[mda[i].y] -= tre.qry(mda[i].x) - tre.qry(mda[i].v - 1);

		}
	}
	return ;
}
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	n = read();
	m = read();
	q = read();
	for(int i = 1; i &lt;= m; ++i) {
		e[i].u = read();
		e[i].v = read();
		if(e[i].u &gt; e[i].v)swap(e[i].u, e[i].v);
	}
	for(int i = 1; i &lt;= q; ++i) {
		qry[i].u = read();
		qry[i].v = i;
		for(int j = 1, x, y; j &lt;= qry[i].u; ++j) {
			x = read();
			y = read();
			ct(i, x, y);
		}
	}
	Bas = 1e4;
	int res	 = 4e6; //循环展开
	sort(qry + 1, qry + q + 1);
	int i = q;
	int cnt = 1e8 / max(n, m);
	for(; i &gt;= 1; --i) {
		if(qry[i].u * qry[i].u &gt;= Bas &amp;&amp; cnt) {
			q1[++t1] = i;
			--cnt;
		} else {
			break;
		}
	}
	int j = 1;
	for(; j &lt;= i; ++j) {
		if(res) {
			q2[++t2] = j;
			res = max(0, res - qry[j].u * qry[j].u);
		} else {
			q1[++t1] = j;
		}
	}
	solve1();//暴力1
	solve2();//暴力2
	for(int i = 1; i &lt;= q; ++i) {
		if(ans[i])printf(&quot;GG\n&quot;);
		else printf(&quot;SAFE\n&quot;);
	}
	return 0;
}


</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-jiang-ke-day-4/">
              <h3 class="post-title">
                CSP-S2考前综合强化讲课(Day 4)
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
