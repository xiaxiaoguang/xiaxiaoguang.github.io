<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>[转载]分治数据结构常用技巧 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1610549815675">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="[转载]分治数据结构常用技巧 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="-1.前言
可配合 题单:一些常用的数据结构维护手法 食用。
这里讲的不是数据结构,而是数据结构的使用技巧。
如果把经典数据结构比作装备的话,这些技巧就是使用装备之前必学的技能。
当然,技能并不能直接增强武器本身,但是可以更加巧妙地分解问题..." />
    <meta name="keywords" content="平衡树,分治,线段树" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1610549815675" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              [转载]分治数据结构常用技巧
            </h2>
            <div class="post-info">
              <span>
                2021-01-09
              </span>
              <span>
                35 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/JOK1-GwD6/" class="post-tag">
                  # 平衡树
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/kSO6sSvK1o/" class="post-tag">
                  # 分治
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/i0TglRCqu/" class="post-tag">
                  # 线段树
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcfAF2mxtdrAGVlIZ3t1FXAh6HB1zSpHhaFVlkRJExTL2mb8N.quyRMF1HMu*pmHZG.ElLiikqGJ4SosyaZDsbhA!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="-1前言">-1.前言</h1>
<p>可配合 <a href="https://www.luogu.com.cn/training/5297">题单:一些常用的数据结构维护手法</a> 食用。</p>
<p>这里讲的不是数据结构,而是数据结构的使用技巧。</p>
<p>如果把经典数据结构比作装备的话,这些技巧就是使用装备之前必学的技能。</p>
<p>当然,技能并不能直接增强武器本身,但是可以更加巧妙地分解问题。</p>
<p>对于每种技巧,都会有一些基本要素:</p>
<ul>
<li><strong>要求</strong> : 什么样的数据结构可以使用这个技巧呢?</li>
<li><strong>效果</strong> : 使用这个技巧我们能玩什么exciting的操作呢?</li>
<li><strong>扩展</strong> : 这个技巧在其他奇奇怪怪的地方有什么用处呢?这个技巧有什么本质理解吗?</li>
</ul>
<p>此外要注意的是,<strong>不适合</strong>在对某种算法毫无印象的时候,尝试使用本Blog入门,那会令你多走弯路。</p>
<p>最好是在有初步印象之后再来看,或者复习的时候看,会有比较好的效果。</p>
<p>题目不一定是最适合入门的(所以对综合能力要求较高),但是是比较适合总结性质的。</p>
<p>如果想看<strong>浓缩版</strong>的总结,请直接翻到每一节的末尾。</p>
<hr>
<h1 id="0常见的数据结构">0.常见的数据结构</h1>
<p>先来清点一下去我们的武器。(本人孤陋寡闻如果有人知道更多请在评论区空投感激不尽qwq)</p>
<p>武器都有各自的特点,技能要配合合适的武器。</p>
<p>我们需要分析的,不仅是武器的长处,还有武器的弱点。</p>
<p>你可以这么认为 : 武器在拥有某种弱点的同时,必然相应地在其他方面有长处,否则早就被淘汰了(凸包?)</p>
<p>所以,假如你在做题的时候,发现出题人特意在某些方面放松要求,如允许离线,内存宽裕,看起来能加权却偏偏不加权等行为,你就可以按照这些特征去寻找合适的武器。</p>
<p>换句话说,尽量使用题目给你的全部特殊条件。</p>
<p><s>当然,不排除出题人懒或者题很简单的情况。</s></p>
<ul>
<li>
<p>方便构造,但不方便修改(静态)</p>
<p>贡献可以“分体”计算,把信息(修改)分成几份,分别构造数据结构,分别查询,可以合并答案。</p>
<p>也就是说,不能考虑操作之间的互相影响。</p>
<p>一个简单的排除方法是 : 能否支持消除任个操作的影响(删除)。</p>
<ul>
<li>正确的例子
<ul>
<li>有序序列(相对BST而言) : 有几个数 ≤Lim≤<em>L<strong>i</strong>m</em></li>
<li>AC自动机 : 匹配次数</li>
<li>凸壳(动态可以做,只是比较麻烦) : 函数最大值</li>
<li>虚树</li>
<li>后缀数组/SAM(<code>parent tree</code>上构造)</li>
</ul>
</li>
<li>错误的例子
<ul>
<li>大多数的图上路径问题,因为路径难免会互相影响。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可支持假如,撤回,但不支持删除(时间栈)</p>
<p>理论上,所有<strong>非均摊</strong>的数据结构都可以撤回。</p>
<p>一个显然的方法是 : 开栈记录所有的数组修改,然后反着做回去。</p>
<p>对于需要均摊分析复杂度的数据结构,也并非一定无法撤回,如果能够把撤回操作描述成这个数据结构的原操作的话,仍然能使用均摊分析。</p>
<p>举个例子 : LCT维护最小生成树。</p>
<p>由于每次操作时加入一条边会删去环上最大边,丢失了原图的信息,肯定是不能支持任意删除的。</p>
<p>但是撤回的时候,只需要把连断边操作反着做就好了。</p>
<p>也就是说,数据结构本身是能够删除的,但是由于做法的正确性限制无法任意删除。</p>
<ul>
<li>正确的例子
<ul>
<li>并查集(按秩合并)</li>
<li>LCT维护最小生成树</li>
<li>线性基</li>
<li>动态凸壳(虽然一次可能删掉很多点,把删去的点放到别处暂存即可)</li>
</ul>
</li>
<li>错误的例子
<ul>
<li>大多数均摊数据结构,如果不支持删除,那就不用考虑了。</li>
<li>静态的就更不用说了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1逆向思维">1.逆向思维</h1>
<p>这并不是一个固定的算法,但可以衍生出许多套路,甚至涉及和数据结构无关的领域。</p>
<h2 id="11-时间倒流">1.1 时间倒流</h2>
<p>考虑某种动态问题,按着题目给出的顺序做,我们不会,但是倒过来做就会了。</p>
<p>于是我们倒过来做(废话)</p>
<p>常见的有 删除 \Leftrightarrow⇔插入 ;分裂 \Leftrightarrow⇔合并 等等。</p>
<p>总之,要在这个过程中找到对状态的逆操作。</p>
<ul>
<li>
<p><strong>例题</strong> : [P1197 <a href="https://www.luogu.com.cn/problem/P1197">JSOI2008]星球大战</a></p>
<p><strong>题意</strong> : 删边求联通块个数。</p>
</li>
</ul>
<p>考虑删边的逆操作是加边,而加边求连通块个数就是并查集基本操作。</p>
<p><a href="https://www.luogu.com.cn/record/17950322">评测记录</a> (<s>代码时间久远,不喜勿喷</s>)</p>
<h2 id="12-查询状态的互补">1.2 查询/状态的互补</h2>
<p>找出贡献的充要条件,然后做等价变换。</p>
<ul>
<li>
<p><strong>例题①</strong> : <a href="https://www.luogu.com.cn/problem/P1502">P1502 窗口的星星</a></p>
<p><strong>题意</strong> : 给一个固定的平行于坐标轴的 r<em>c</em>r<em>∗</em>c*矩形,问其最多能在平面直角坐标系中框柱几个点。</p>
</li>
</ul>
<p>直接做并不好做,我们不知道该把这个矩形放在哪里,决策空间很大。</p>
<p>设矩形左上角为 A<em>A</em>,一个点能被统计到的充要条件 : 点在矩形内。</p>
<p>然而,我们如果把每个点变成以其为右下角的 r<em>c</em>r<em>∗</em>c<em>矩形,其能贡献的充要条件变为 : A</em>A*在产生的矩形内。</p>
<p>现在问题就变成了 : 寻找一个点使其在最多矩形内。</p>
<p>我们使用扫描线即可。</p>
<p><a href="https://www.luogu.com.cn/record/18517338">评测记录</a> (<s>代码时间久远,不喜勿喷</s>)</p>
<ul>
<li>
<p><strong>例题②</strong> : [P2982 <a href="https://www.luogu.com.cn/problem/P2982">USACO10FEB]慢下来Slowing down</a></p>
<p><strong>题意</strong> : 给出一棵树,要求支持单点加,从根到某个点的路径求和。</p>
</li>
</ul>
<p>树链剖分可以做,但是没必要。</p>
<p>我们的修改十分简单,但是询问很难,我们不妨把两者的难度平衡一下。</p>
<p>考虑一个修改 u<em>u</em>会对某个询问 v<em>v</em>有贡献的充要条件 : u<em>u</em>在 rt<em>r**t</em>到 v<em>v</em>的路径上。</p>
<p>也就等价于 : u<em>u</em>是 v<em>v</em>的父亲, v<em>v</em>在 u<em>u</em>的子树内。</p>
<p>现在就变成了 : 给出 v<em>v</em>统计其在多少个点的子树内。</p>
<p>我们每次子树加,单点查询。dfs序拍扁之后,使用序列线段树即可。</p>
<p><a href="https://www.luogu.com.cn/record/9554392">评测记录</a> (<s>代码时间久远,不喜勿喷</s>)</p>
<ul>
<li>其实这东西在DP里面也有应用,先咕着</li>
</ul>
<hr>
<h1 id="2cdq分治">2.CDQ分治</h1>
<p>考虑若干个查询 \texttt{Q}Q ,和修改 \texttt{C}C ,查询只会被自己前面的修改影响。</p>
<p>我们无法找到某种直接实现这个目的数据结构(或者常数过大,很难实现),但是我们发现,<strong>静态</strong>的问题十分好做。</p>
<p>(而且, \texttt{C}C 可以向 \texttt{Q}Q 分批次贡献)</p>
<p>换句话说,如果 \texttt{C}C 全在 \texttt{Q}Q 前面,这个问题我们就会做了,此外,初始化的复杂度和 \texttt{C}C 的个数相关。</p>
<p>那么我们<strong>可能</strong>可以采用这个分治方法解决问题。</p>
<ul>
<li><strong>算法流程</strong></li>
</ul>
<p>我们考虑如下的操作序列 :</p>
<p>\large\underline\texttt{C C Q C C Q Q C}C C Q C C Q Q C</p>
<ol>
<li>
<p>我们从正中间分成两半,考虑左边的修改对右边询问的贡献(<strong>跨越隔板的贡献</strong>),可得:</p>
<p>\large\underline\texttt{C C Q C}\ \ |\ \ \underline\texttt{C Q Q C}C C Q C ∣ C Q Q C</p>
<p>\large\underline\texttt{C C . C}\Rightarrow\underline\texttt{. Q Q .}C C . C⇒. Q Q .</p>
</li>
</ol>
<p>我们采用我们会的<strong>静态</strong>方法解决这个问题。</p>
<p>然后因为不再需要考虑跨越隔板的贡献,相当于这两块不再有关系,可以分治成子问题。</p>
<ol>
<li>分治处理左边的 \large\underline\texttt{C C Q C}C C Q C</li>
<li>分治处理右边的 \large\underline\texttt{C Q Q C}C Q Q C</li>
</ol>
<p>如此分治下去……</p>
<hr>
<ul>
<li><strong>例题①</strong> : <a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a> (<s>纯属娱乐</s>)</li>
</ul>
<p>这里把区间询问容斥变成两个前缀相减,把问题转化成 :</p>
<p>初始全<code>0</code>的一维数组,单点加,前缀求和。</p>
<p>采用CDQ分治,考虑这一个子问题中有 O(m)<em>O</em>(<em>m</em>)个操作。</p>
<p>考虑跨越隔板的贡献,现在是个静态问题。</p>
<p>\large\underline\texttt{C C C...}\ \Rightarrow\ \underline\texttt{Q Q Q...}C C C... ⇒ Q Q Q...</p>
<p>我们可以先把 \texttt{C}C 和 \texttt{Q}Q 按照数组位置排序,然后就变成了一个十分显然的前缀和。</p>
<p>问题在于,我们还需要排序,这会让复杂度多个 log<em>l<strong>o</strong>g</em>。</p>
<ul>
<li>
<p><strong>技巧</strong> : 分治中归并</p>
<p>有些时候,我们使用 \texttt{C}C 建立静态结构时,直接建立复杂度较劣,但是利用两个儿子余下的信息建立,则更快一些。</p>
<p>比如说有序序列,直接<code>sort</code>是 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)的,但把两个儿子的有序序列合并是 O(n)<em>O</em>(<em>n</em>)的。</p>
<p>除此之外还有凸壳(也需要排序)</p>
<p>此时,我们就要求先分治处理两个子问题(<strong>后序遍历</strong>),再计算跨越本分隔板的贡献。</p>
</li>
</ul>
<p>现在就可以做到真正的 O(m)<em>O</em>(<em>m</em>)了,不过感觉还是比直接“离散化+树状数组”麻烦许多……</p>
<p>分析复杂度的时候,注意到分治树总共有 O(logn)<em>O</em>(<em>l<strong>o</strong>g**n</em>)层,每一层分成若干堆操作,不可能有两堆含有同一个操作。</p>
<p>每一层的操作总个数 O(n)<em>O</em>(<em>n</em>),每一堆的复杂度是 O(m)<em>O</em>(<em>m</em>),单层总复杂度是 O(n)<em>O</em>(<em>n</em>),总的复杂度 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)。</p>
<p>为了提供简易CDQ的代码,方便大家对照,我还是写一下:</p>
<p><s>可以看到比树状数组难写很多倍</s>,这题非要严格 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)才行。</p>
<p><a href="https://www.luogu.com.cn/paste/lo2wsva9">代码Link</a> + <a href="https://www.luogu.com.cn/record/30219655">评测记录</a></p>
<hr>
<ul>
<li><strong>例题②</strong> : <a href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a></li>
</ul>
<p>等会,你前面讲到有修改,这怎么是个静态问题啊(完了我连静态都不会做)……</p>
<ul>
<li>
<p><strong>技巧</strong> : 偏序降维 \rightarrow→时间轴</p>
<p>偏序问题是一类比较常见的问题,一般来讲,对某一维<strong>排序</strong>作为时间轴,可以降维并转化成动态问题。</p>
<p>也就是说,按照第一维从小到大加入元素,那么后面的点会被前面的点贡献,就满足了偏序要求。</p>
<p>现在就转化成了 : 支持加点,查询前缀2D矩阵点值和。</p>
<p>不过注意,只有静态问题能这么做,因为你只有一个时间轴。</p>
<p>还有一个问题是,若果有两个点的位置相同,而且比较是 [\leq][≤] 的话,这两个点会互相贡献。</p>
<p>有些时候可以把重( ch\acute ong<em>c<strong>h</strong>o</em>ˊ<em>n**g</em>)点缩成一个,有些时候可以提前补算<strong>从后向前</strong>的贡献,本题采用后者。</p>
<p>如果补算贡献的话,分治中的排序一定要采用<strong>稳定排序</strong>,可以用<code>stable_sort</code>。</p>
</li>
</ul>
<p>每个点分别产生一次修改,一次查询。</p>
<p>一个容易口胡的做法是 : 树套树/2DT,但是常数过大,而且并不好写。</p>
<p>仍然考虑隔板左边的修改对右边询问的贡献(跨越隔板的贡献)。</p>
<p>现在就是静态问题了,直接使用数据结构仍然没有思路,我们考虑再一次“偏序 \rightarrow→时间轴”</p>
<p>将第二维排序之后,现在是个这样的问题 : 一维数组,单点加,前缀求和。</p>
<p>直接树状数组就好了,复杂度 O(mlogm)<em>O</em>(<em>m<strong>l</strong>o<strong>g</strong>m</em>),注意这里不能无脑<code>memset</code>初始化,要把上次的操作撤销来达到清空的目的。</p>
<p>总复杂度就是 O(nlog^2n)<em>O</em>(<em>n<strong>l</strong>o**g</em>2<em>n</em>),代码实现较之其他方法较为简易,常数也不大。</p>
<p>这里顺便提一下,在CDQ分治的时候,内层数据结构的复杂度,往往已经超过外层<strong>直接排序</strong>转化偏序的复杂度,此时直接排序是不会增加复杂度的。</p>
<p><a href="https://www.luogu.com.cn/paste/dm7wdvet">代码Link</a> + <a href="https://www.luogu.com.cn/record/30232913">评测记录</a></p>
<p>当然,这是使用树状数组解决二维静态数点问题,而前面讲了,CDQ分治也能做,而且复杂度为 O(mlogm)<em>O</em>(<em>m<strong>l</strong>o<strong>g</strong>m</em>)(需要归并技巧),一样的复杂度。</p>
<p><a href="https://www.luogu.com.cn/paste/59t6oo3d">代码Link</a> + <a href="https://www.luogu.com.cn/record/30247091">评测记录</a></p>
<ul>
<li>
<p><strong>进阶题①</strong> : [P4169 <a href="https://www.luogu.com.cn/problem/P4169">Violet]天使玩偶/SJY摆棋子</a></p>
<p><strong>题意</strong> : 要求维护一个数据结构,资瓷两种操作:</p>
<ul>
<li>A 在 S<em>S</em>中加点 (x,y)(<em>x</em>,<em>y</em>)</li>
<li>B 给一个观测点 A<em>A</em>,查询目前的 S<em>S</em>内,与 A<em>A</em>最近的哈夫曼距离( dist(A,B)=|A_x-B_x|+|A_y-B_y|<em>d<strong>i</strong>s**t</em>(<em>A</em>,<em>B</em>)=∣<em>A**x</em>−<em>B**x</em>∣+∣<em>A**y</em>−<em>B**y</em>∣)</li>
</ul>
</li>
</ul>
<p>注意到这个绝对值比较难搞,先考虑 S<em>S</em>中在 A<em>A</em>左下方的点:</p>
<p>有 B_x\leq A_x;B_y\leq A_y<em>B**x</em>≤<em>A**x</em>;<em>B**y</em>≤<em>A**y</em> ,可得 dist(A,B)=(A_x+A_y)-(B_x+B_y)<em>d<strong>i</strong>s**t</em>(<em>A</em>,<em>B</em>)=(<em>A**x</em>+<em>A**y</em>)−(<em>B**x</em>+<em>B**y</em>)</p>
<p>点权设为 (B_x+B_y)(<em>B**x</em>+<em>B**y</em>) ,现在就变成了动态前缀2D矩形最大值。</p>
<p>(其他的情况可以旋转坐标系重做得到)</p>
<p>考虑CDQ变成静态问题,又可以排序变成一维动态问题 : 动态前缀最大值。</p>
<p>直接树状数组就做完了,是不是十分<code>naive</code>啊?</p>
<p>这道题比较卡常数,写个归并会快一点。</p>
<p><a href="https://www.luogu.com.cn/paste/dt69emhm">代码Link</a> + <a href="https://www.luogu.com.cn/record/30257944">评测记录</a></p>
<ul>
<li><strong>进阶题②</strong> : [P3769 <a href="https://www.luogu.com.cn/problem/P3769">CH弱省胡策R2]TATT</a></li>
</ul>
<p>首先把重点合并。</p>
<p>定义高维点的比较 : [A\leq B]=[A_x\leq B_x][A_y\leq B_y]...[A_z\leq B_z][<em>A</em>≤<em>B</em>]=[<em>A**x</em>≤<em>B**x</em>][<em>A**y</em>≤<em>B**y</em>]...[<em>A**z</em>≤<em>B**z</em>](就是 A<em>A</em>每一维都小于等于 B<em>B</em>)</p>
<p>这个题目要求我们做这样的一个DP:</p>
<p>dp[i]=1+\max\limits_{P_j\leq P_i}dp[j]<em>d**p</em>[<em>i</em>]=1+<em>P**j</em>≤<em>P**i</em>max<em>d**p</em>[<em>j</em>]</p>
<p>我们可以把前面的 dp<em>d**p</em>值看做修改,那么修改依赖会依赖前面的询问。</p>
<p>我们就必须按照 P<em>P</em>递增的顺序来转移,保证转移时前继 DP<em>D**P</em>值已经正确,否则可能漏解。</p>
<p>我们还是先按照一维排序(第一维相同比第二维,再相同比第三维……),同时也按照这样的顺序转移,就能够保证不会漏解。</p>
<p>问题在于,现在我们的CDQ分治需要换个写法。</p>
<ul>
<li>
<p><strong>技巧</strong> : DP转移强制中序遍历</p>
<p>前面的写法是先处理跨越隔板的贡献,再分治下去。</p>
<p>现在,我们的询问之间也有了依赖关系,必须保证前面的询问回答完,才能准确得到后面询问的贡献。</p>
<p>我们可以对分治树<strong>中序遍历</strong>,也就是说在处理完[l,mid]的所有贡献之后再处理跨越隔板的贡献,此时[l,mid]中的询问已经得到了正确结果。</p>
<p>不过注意,这东西和归并是不兼容的,因为归并要求后序遍历,一个补救的方法是预处理归并存下信息,不过往往会使空间多个 log<em>l<strong>o</strong>g</em>,不推荐。</p>
<p><s>另一个补救的方法是,不使用CDQ分治</s></p>
<p>一般来说这种依赖关系是会传递的,内层问题也应考虑到这一点。</p>
</li>
</ul>
<p>现在我们少了一维,变成了动态问题 : 每次加入一个点,询问3D前缀立方体中的 \maxmax,修改依赖询问。</p>
<p>仍然不会,考虑CDQ降维,再排序,变成了 : 每次加入一个点,询问2D前缀长方体中的 \maxmax,修改依赖询问。</p>
<p>仍然不会,考虑CDQ降维,再排序,变成了 : 每次加入一个点,询问1D前缀 \maxmax,修改依赖询问。</p>
<p>这东西一个树状数组带走就好,再写CDQ反而麻烦。</p>
<p>总复杂度 O(nlog^3n)<em>O</em>(<em>n<strong>l</strong>o**g</em>3<em>n</em>),常数较小。</p>
<p>由于离散化写挂调试一小时,在此警示后人 : 全局变量跳跃使用一定小心。</p>
<p><a href="https://www.luogu.com.cn/paste/fdg9dy56">代码Link</a> + <a href="https://www.luogu.com.cn/record/30282659">评测记录</a></p>
<p>还有很久之前写的3次CDQ嵌套的解法,懒得修了直接丢个<a href="https://www.luogu.com.cn/record/25717026">评测记录</a>算了。</p>
<p>有一道很类似的题目是<a href="https://www.luogu.com.cn/problem/P4849">P4849 寻找宝藏</a>,只不过还要顺便统计方案数。</p>
<p>[ CDQ嵌套+树状数组 ] : <a href="https://www.luogu.com.cn/record/30285665">评测记录</a></p>
<p>[ 3次CDQ嵌套 ] : <a href="https://www.luogu.com.cn/record/19969106">评测记录</a></p>
<ul>
<li>
<p><strong>进阶题③</strong>: <a href="https://www.luogu.com.cn/problem/CF1045G">CF1045G AI robots</a></p>
<p><strong>题意</strong> : 给出 n<em>n</em>个三元组 {x_i,r_i,q_i}<em>x**i</em>,<em>r**i</em>,<em>q**i</em>,以及常数 K<em>K</em></p>
<p>两个三元组 (i,j)(<em>i</em>,<em>j</em>)之间能贡献当且仅当 (x_i-x_j)\leq\min(r_i,r_j)(<em>x**i</em>−<em>x**j</em>)≤min(<em>r**i</em>,<em>r**j</em>)且 |q_i-q_j|\leq K∣<em>q**i</em>−<em>q**j</em>∣≤<em>K</em></p>
<p>问能够贡献的对数。</p>
</li>
</ul>
<p>首先,这是个静态问题,我们需要按某种<strong>顺序</strong>将其变成动态问题。</p>
<p>经过认真的思考,容易发现让看得近的数看得远的比较合理(按视野从大到小排序)。</p>
<p>在所有的约束条件中,只有 |x_i-x_j|\leq\min(r_i,r_j)∣<em>x**i</em>−<em>x**j</em>∣≤min(<em>r**i</em>,<em>r**j</em>)中含有 \minmin,这和传统的偏序问题大不相同。</p>
<p>如果你按照其他的顺序来数,你就会发现一个尴尬的问题 : 数到的元素不一定看得见接收者。</p>
<p>然而,如果按照视野为序,那么能否贡献就只跟统计者的视野有关了。我们把问题转化成了下面的样子:</p>
<p>动态加入三元组 {x_i,r_i,q_i}<em>x**i</em>,<em>r**i</em>,<em>q**i</em>,并查询目前有的三元组中,满足 |x_i-x_j|\leq r_i∣<em>x**i</em>−<em>x**j</em>∣≤<em>r**i</em>且 |q_i-q_j|\leq K∣<em>q**i</em>−<em>q**j</em>∣≤<em>K</em>的个数。</p>
<p>这就是个裸的动态二维数点了,可使用与上文相同的方法解决。</p>
<p>注意需要容斥拆询问。这题值域很大,但是可以只在 q<em>q</em>的一维离散化。</p>
<p>由于这道题是无序对计数,写起来细节较少。</p>
<p>然而这题 K<em>K</em>相当小,貌似可以直接动态开点线段树艹过去……</p>
<p><a href="https://www.luogu.com.cn/paste/3006hihz">代码Link</a> + <a href="https://www.luogu.com.cn/record/30270934">评测记录</a></p>
<ul>
<li><strong>进阶题④</strong> <a href="https://www.luogu.com.cn/problem/CF848C">CF848C Goodbye Souvenir</a></li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/command-block/ds-ji-lu-cf848c-goodbye-souvenir">题解Link</a></p>
<ul>
<li><strong>进阶题⑤</strong> : [P4027 <a href="https://www.luogu.com.cn/problem/P4027">NOI2007]货币兑换</a></li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/command-block/dp-ji-lu-p4027-noi2007-huo-bi-yue-huan">题解Link</a></p>
<ul>
<li><strong>进阶题⑥</strong> : <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2961">BZOJ2961: 共点圆</a></li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/command-block/post-ji-lu-bzoj2961-gong-dian-yuan-4140-gong-dian-yuan-jia-qiang-ban-post">题解Link</a></p>
<ul>
<li><strong>浓缩版</strong>:</li>
</ul>
<p>考虑某种动态问题,静态版本( \texttt{C}C 全在 \texttt{Q}Q 前面)我们会做,而且复杂度只和操作次数相关。</p>
<p>要求可以把 \texttt{C}C 分批次向 \texttt{Q}Q 贡献。</p>
<p>考虑每次在操作中间插一个隔板,只考虑跨越隔板的贡献,此时是静态问题,可以解决。</p>
<p>然后两块之间不再有关系,考虑分治。</p>
<p>一句话来讲 : <strong>以静制动,必须离线</strong></p>
<p>复杂度 : logn<strong>l</strong>o<strong>g</strong>n*∗(查询) + 总大小为 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)的build。</p>
<ul>
<li><strong>技巧①</strong> : 分治中归并,考虑利用两个儿子的信息,更快地建立静态结构,需要强制后序遍历。</li>
<li><strong>技巧②</strong> : 偏序降维 \rightarrow→时间轴,对偏序的某一维排序就变成了动态的低维问题。</li>
<li><strong>技巧③</strong> : 有些DP类问题修改会依赖前面的询问,此时则需要按分治树中序遍历计算贡献。</li>
</ul>
<hr>
<h1 id="3线段树分治">3.线段树分治</h1>
<p>考虑某种奇怪的动态问题,我们有查询 \texttt{Q}Q ,加入元素 \texttt{A}A ,和删除元素 \texttt{D}D 三种操作。</p>
<p>但是,如果没有 \texttt{D}D 操作,我们就会做。</p>
<p>那么我们<strong>可能</strong>可以采用这个分治方法解决问题。</p>
<ul>
<li><strong>算法流程</strong></li>
</ul>
<p>先考虑一个暴力 : 按照时间点开若干个桶,把每个元素的存在<strong>时间段</strong>计算出来。</p>
<p>然后,把 \texttt{A}A 操作扔进对应时间段的桶里(如果已经被删掉了,则不加入)。</p>
<p>对于每个桶,做一遍其中的 \texttt{A}A 就能得到这个时间点的正确状态。</p>
<p>容易发现,这个暴力是以每个 \texttt{A}A 多做 O(n)<em>O</em>(<em>n</em>) 次的代价规避了 \texttt{D}D 操作。</p>
<p>考虑使用线段树优化这个暴力,按照时间轴建立线段树,把每个 \texttt{A}A 分配到对应的区间内。</p>
<p>我们让父节点的状态能够向儿子传递,那么只需要在 O(logn)<em>O</em>(<em>l<strong>o</strong>g**n</em>)个点里放上 \texttt{A}A ,就能让在这个区间里的所有叶节点都受到这个操作的影响。</p>
<p>然后在线段树上 dfs<em>d<strong>f</strong>s</em>,到达每个点的时候先完成这个点所有的 \texttt{A}A ,然后:</p>
<p>向左儿子递归处理,此时左儿子自然继承了父亲的状态。</p>
<p>向右儿子递归处理,此时左儿子自然继承了父亲的状态。</p>
<p>向老爸借了东西,还的时候要纤毫不损,撤销这个点所有的 \texttt{A}A 对状态的影响。</p>
<p>至于怎么撤销,可以认为是把对所有数据的改动记录下来然后还原。</p>
<ul>
<li><strong>例题①</strong> <a href="https://loj.ac/problem/121">Loj#121. 「离线可过」动态图连通性</a></li>
</ul>
<p><strong>题意</strong> : 支持加边删边,询问两点间连通性。</p>
<p>如果没有删边操作,这就是个很简单的并查集。</p>
<p>考虑使用线段树分治,这真就变成了很简单的并查集?</p>
<p>事实上,由于线段树分治会把一个状态传递给两个儿子(类似可持久化的操作树),而并不是经典的一条时间轴,所以均摊分析在线段树分治中会失效。</p>
<p>比如这道题如果写了路径压缩并查集,出题人可以在根节点挂一堆询问,造出一条 O(n)<em>O</em>(<em>n</em>)的链,然后中间什么都不干。</p>
<p>等到叶节点,突然埋伏你一手,让你把它遍历一次,每个叶子 O(n)<em>O</em>(<em>n</em>)总的复杂度就是 O(n^2)<em>O</em>(<em>n</em>2),退化了。</p>
<p>这就需要我们使用复杂度严格(或期望)正确的算法,按秩合并并查集正符合这个要求。</p>
<p>至于操作怎么撤回,可以开个<strong>栈</strong>记录上一次让谁的父亲变为谁,然后倒着做就好了,具体见代码。</p>
<p><a href="https://www.luogu.com.cn/paste/oyqei6qa">代码Link</a> + <a href="https://loj.ac/submission/539322">评测记录</a></p>
<ul>
<li><strong>例题②</strong> : <a href="https://www.luogu.com.cn/problem/P5787">P5787 二分图 /【模板】线段树分治</a></li>
</ul>
<p><strong>题意</strong> : 给出一个无向图,每条边都有一个存在时间区间,总时间为 [1,k][1,<em>k</em>],询问每个时刻该图是不是二分图。</p>
<p>区间就可以看做先加后删,我们先来考虑只有加入的问题。</p>
<p>众所周知,二分图判定的充要条件是 : 没有奇环。</p>
<p>关于路径的奇偶性,我们可以用带权并查集来维护。</p>
<p>每次加入边的时候,如果在联通块内部,查看两个点到根路径长度的奇偶性情况,如果相同,加上新边则形成奇环。</p>
<p>否则,计算出两个根之间的路径奇偶性,赋权并合并。</p>
<p>接下来套用线段树分治即可,注意采用按秩合并。</p>
<p>注意到如果已经形成了奇环,则当前时间区间内就都不可能是二分图了,才做直接跳过即可,可以减小常数。</p>
<p>复杂度 O(nlog^2n)<em>O</em>(<em>n<strong>l</strong>o**g</em>2<em>n</em>), <a href="https://www.luogu.com.cn/paste/58um0hgt">代码Link</a> + <a href="https://www.luogu.com.cn/record/32177260">评测记录</a></p>
<ul>
<li>
<p><strong>例题③</strong> : [P4585 <a href="https://www.luogu.com.cn/problem/P4585">FJOI2015]火星商店问题</a></p>
<p><strong>题意</strong> : 有一排 n<em>n</em>个商店,某个商店会在某个时刻购入权值为 v<em>v</em>的商品。</p>
<p>有若干个顾客,各有一个参数 x<em>x</em></p>
<p>询问在 [l,r][<em>l</em>,<em>r</em>]商店内购买进货时间在 [tl,tr][<em>t**l</em>,<em>t**r</em>]的商品中, v\ {\bf xor}\ x<em>v</em> <strong>x<strong><strong>o</strong></strong>r</strong> <em>x</em>的最大值。</p>
<p>顾客和进货操作的总量不超过 m<em>m</em>,有 n,m\leq 10^5<em>n</em>,<em>m</em>≤105,时限 \texttt{2s}2s.</p>
</li>
</ul>
<p>这题特殊之处在于,商品(修改)在时间轴上是一个点,而询问是一个区间。</p>
<p>采用<strong>逆向思维</strong>,把询问分到线段树上去,然后把商品拿来分治。</p>
<p>将每个商品挂到从根到叶子的点上,这样每个点就会有自己区间内的所有商品,拆区间回答询问即可。</p>
<p>在每个节点处,使商品根据商店位置有序,建立可持久化<code>01Trie</code>,就能够查询区间内的<code>xormax</code>.</p>
<p>( 至于怎么查询,可见 <a href="https://www.luogu.com.cn/problem/P4735">P4735 最大异或和</a> )</p>
<p>这时,由于 \maxmax可以<strong>分体贡献</strong>,我们把挂着的所有询问都拉出来贡献一次即可。</p>
<p>复杂度 O(nlog^2n)<em>O</em>(<em>n<strong>l</strong>o**g</em>2<em>n</em>), <a href="">代码Link</a> + <a href="">评测记录</a> (准备重写)</p>
<ul>
<li><strong>进阶题①</strong> : <a href="https://www.luogu.com.cn/problem/CF576E">CF576E Painting Edges</a></li>
</ul>
<p>对于不同颜色的边可以开多个加权并查集。</p>
<p>这道题的特殊之处在于,无法预知每个修改操作是否执行,也就无法得到每条边的存在区间。</p>
<p>对于一个状态不变的区间,我们分成多段往线段树上挂,显然也不影响正确性。</p>
<p>现在修改操作可以理解为 : 有一个改变颜色的机遇,但是不知道是否会改变。</p>
<p>那么我们把每两个可能的改变操作之间都分段,也无伤大雅。</p>
<p>可以先在同一条边的两个修改之间挂上当前状态,到达询问之后判断是否合法,然后把下一个修改挂上去。</p>
<p><a href="https://www.luogu.com.cn/record/26907938">评测记录</a></p>
<ul>
<li><strong>进阶题②</strong> : <a href="https://www.luogu.com.cn/problem/CF603E">CF603E Pastoral Oddities</a></li>
</ul>
<p>首先有一个结论 : 某个图合法当且仅当所有连通块的大小都是偶数。和本文无关就不再赘述。</p>
<p>我们能够发现,两个块合并,一定不会让奇数的块增多,所以我们加边<strong>多多益善</strong>。</p>
<p>容易想到的方法是<code>kruskal</code>,把边从小到大排序,依次加入,直到合法为止。</p>
<p>现在我们要资瓷动态加边,我们想象一条边什么时候会在决策集合里面 : 加入的时候很优,进入了决策集合,后来随着新边加入被抛弃。</p>
<p>据此容易发现,每条边存在与决策集合中的时间是一个区间。</p>
<p>这让我们看到了线段树分治的希望,可是怎么求出这个区间呢?</p>
<p>考虑从后往前做暴力,显然,每条边第一次加入的时刻就是其区间的末尾。</p>
<ul>
<li>
<p><strong>技巧</strong> : 当操作的状态或者时间区间不确定的时候,可以按某种顺序分治以恰好得到信息</p>
<p>比如上一题,就必须按照从左到右的顺序分治,以从前面的询问得到后面的颜色信息。</p>
<p>更毒瘤的是,本题连时间区间都未知。不过这个区间的左端点我们是知道的。</p>
<p>考虑反过来分治(时间倒流),先递归右儿子,在叶节点处,我们得到目前半成品图的最大边权 w<em>w</em></p>
<p>把所有剩余的边权大于 w<em>w</em>的边尝试加入,对于那些加进去的边,就能得到其存在区间的末尾。</p>
<p>一旦已满足条件就不加了,由于多多益善,中间是不会无故丢掉某条边的,所以每条边只会被考虑一次。</p>
</li>
</ul>
<p>(坑)</p>
<hr>
<h1 id="4整体二分">4.整体二分</h1>
<p>考虑某种奇怪的问题,询问满足单调性,可以二分。</p>
<p>但是不同的 mid<em>m<strong>i</strong>d</em>需要不同的状态来判定,暴力做代价过高。</p>
<p>这时往往要使用整体二分来一起计算。视情况可以带修。</p>
<ul>
<li><strong>算法流程</strong></li>
</ul>
<p>考虑对应的答案区间 [L,R][<em>L</em>,<em>R</em>],取其中点 mid=\lfloor\frac{L+R}{2}\rfloor<em>m<strong>i</strong>d</em>=⌊2<em>L</em>+<em>R</em>⌋</p>
<p>我们把数据结构的状态调整到 mid<em>m<strong>i</strong>d</em>处,然后就可以判定这些询问是大于还是小于 mid<em>m<strong>i</strong>d</em>.</p>
<p>然后把询问分到 [L,mid][<em>L</em>,<em>m<strong>i</strong>d</em>]和 (mid,R](<em>m<strong>i</strong>d</em>,<em>R</em>]中去。</p>
<p>注意到, mid<em>m<strong>i</strong>d</em>的移动总量是 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)的,每个询问判定的次数是 O(logn)<em>O</em>(<em>l<strong>o</strong>g**n</em>)的。</p>
<p>实质上就是最大化询问的共用判定。</p>
<hr>
<ul>
<li><strong>例题①</strong> : [P1527 <a href="https://www.luogu.com.cn/problem/P1527">国家集训队]矩阵乘法</a></li>
</ul>
<p><strong>题意</strong> : 给定一个 N\times N<em>N</em>×<em>N</em>的矩阵,多次询问一个子矩形的第 K<em>K</em>小数。</p>
<p>N\leq 600;q\leq 60000<em>N</em>≤600;<em>q</em>≤60000 ,时限 \texttt{1.5s}1.5s</p>
<p>先将矩阵内的数字离散化并排序。</p>
<p>分治到 [L,R][<em>L</em>,<em>R</em>]时,将不超过 mid<em>m<strong>i</strong>d</em>的数字全部加入二维树状数组(单点<code>+1</code>)</p>
<p>根据上一次的状态加或者删数字。 mid<em>m<strong>i</strong>d</em>的总变化量是 O(n^2logn)<em>O</em>(<em>n</em>2<em>l<strong>o</strong>g**n</em>)的,这部分的复杂度就是 O(n<sup>2log</sup>3n)<em>O</em>(<em>n</em>2<em>l<strong>o</strong>g</em>3<em>n</em>)</p>
<p>然后判定就是矩阵查询,和 K<em>K</em>比较。这部分复杂度是 O(qlog^3n)<em>O</em>(<em>q<strong>l</strong>o**g</em>3<em>n</em>)</p>
<p>由于每个数对单个询问的贡献方式固定,还有另一种写法 :</p>
<p>考虑类似线段树二分,我们进入右子树时会抛弃左子树的信息。</p>
<p>我们把矩阵中的数字带着一起分治,分治到 [L,R][<em>L</em>,<em>R</em>]时,我们只加入 [L,mid][<em>L</em>,<em>m<strong>i</strong>d</em>]的数字,然后判定。</p>
<p>如果 K<em>K</em>大于查询值 c<em>c</em>,则减去 c<em>c</em>,分配到右区间,这样就和大小在左区间的数无关了。</p>
<p>注意判定完毕之后要清空树状数组。</p>
<p>复杂度依然是 O((n<sup>2+q)log</sup>3n)<em>O</em>((<em>n</em>2+<em>q</em>)<em>l<strong>o</strong>g</em>3<em>n</em>),常数较小。</p>
<p>一开始挂了几发,对着代码看了半小时啥也没看出来很自闭,后来拍了才发现是数组开小了……</p>
<p><a href="https://www.luogu.com.cn/paste/p3n39z73">代码Link</a> + <a href="https://www.luogu.com.cn/record/31651595">评测记录</a></p>
<hr>
<ul>
<li><strong>例题②</strong> :[P4175 <a href="https://www.luogu.org/problemnew/show/P4175">CTSC2008]网络管理</a></li>
</ul>
<p><strong>题意</strong> : 给定一棵树,有点权,单点修改和询问路径第 K<em>K</em>小数。</p>
<p>区别在于,这题多了修改。</p>
<p>事实上,我们可以根据时间轴来分析 : 前面的修改能影响后面的询问。</p>
<p>我们在整体二分的时候,把修改也根据权值传下去,同时保证询问和修改的相对顺序不变。</p>
<p>注意要把修改拆分成删除和添加,这两部分可能被分到不同的区间里去。</p>
<p>我们需要树上单点修和路径求和,考虑采用<code>LCT</code>或者树剖。</p>
<ul>
<li>
<p><strong>技巧</strong> : 带修整体二分</p>
<p>如果修改可以向询问分体贡献(类比<code>CDQ</code>),贡献容易合并,我们就可以把修改带着一并二分。</p>
<p>注意,题目中原有的修改可能会在二分的意义下有变化。比如赋值 \rightarrow→删除&amp;加入。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/paste/q1w8bzdj">代码Link</a> + <a href="https://www.luogu.com.cn/record/31682760">评测记录</a></p>
<hr>
<ul>
<li><strong>进阶题①</strong> [P3527 <a href="https://www.luogu.com.cn/problem/P3527">POI2011]MET-Meteors</a></li>
</ul>
<p><strong>题意</strong> : 给一个序列,多次区间加正数,询问每个位置达到 lim[i]<em>l<strong>i</strong>m</em>[<em>i</em>]所等待的操作数。</p>
<p>对时间轴二分即可。要采用带修整体二分的思想,将已经贡献过的操作减去。</p>
<p><a href="https://www.luogu.com.cn/record/31690389">提交记录</a></p>
<ul>
<li><strong>进阶题②</strong> <a href="https://codeforces.com/gym/102354/problem/B">CFgym102354B. Yet Another Convolution</a></li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/command-block/post-shuo-lun-ji-lu-cfgym102354b-yet-another-convolution">题解Link</a></p>
<ul>
<li><strong>进阶题③</strong> <a href="https://www.luogu.com.cn/problem/P5163">P5163 WD与地图</a></li>
</ul>
<p><a href="https://www.luogu.com.cn/blog/command-block/ds-ji-lu-p5163-wd-yu-di-tu">题解Link</a></p>
<h1 id="5猫树分治">5.猫树分治</h1>
<p>考虑某种奇怪的<strong>序列</strong>静态问题,我们并不会做。</p>
<p>但是,如果所有询问的区间有交集,那么我们就能通过下列算法得出答案。</p>
<p>选取所有询问都包含的某个位置,分别向左向右预处理某些东西。</p>
<p>对于询问的回答,只需要在左端点取信息,在右端点取信息,再组合即可。这要求(答案/状态)能够合并。</p>
<p>然后我们套用猫树分治,就能够处理更一般的情况了。</p>
<p>此外,将分治树存下来,往往就能够做到强制在线。</p>
<ul>
<li><strong>算法流程</strong></li>
</ul>
<p>考虑一堆询问区间和对应的状态区间 [L,R][<em>L</em>,<em>R</em>]。</p>
<p>我们取状态区间的中点 mid=\lfloor\frac{L+R}{2}\rfloor<em>m<strong>i</strong>d</em>=⌊2<em>L</em>+<em>R</em>⌋,从 mid<em>m<strong>i</strong>d</em>分别向左右预处理某些信息。</p>
<p>遍历所有询问,如果跨过 (mid,mid+1)(<em>m<strong>i</strong>d</em>,<em>m<strong>i</strong>d</em>+1),则合并左右端点信息来回答。</p>
<p>如果在 [L,mid][<em>L</em>,<em>m<strong>i</strong>d</em>]中,则下放到左儿子。</p>
<p>如果在 [mid+1,R][<em>m<strong>i</strong>d</em>+1,<em>R</em>]中,则下放到右儿子。</p>
<p>继续分治。</p>
<p>(不难发现其实就是序列上的点/边分治,所以上猫树的题目可能可以上点/边分树)</p>
<hr>
<ul>
<li><strong>例题①</strong> : <a href="https://www.luogu.com.cn/problem/P6240">P6240 好吃的题目</a></li>
<li><strong>例题②</strong> : <a href="https://www.luogu.com.cn/problem/CF1100F">CF1100F Ivan and Burgers</a></li>
</ul>
<p><strong>前置芝士</strong> : 线性基,向其中插入的复杂度是 O(\log c)<em>O</em>(log<em>c</em>)的,合并两个线性基是 O(\log^2c)<em>O</em>(log2<em>c</em>)的.</p>
<p>有一个显然的暴力 : 建立线段树,暴力合并 O(\log n)<em>O</em>(log<em>n</em>)个线性基,复杂度 O(n\log n\log c+q\log n\log^2c)<em>O</em>(<em>n</em>log<em>n</em>log<em>c</em>+<em>q</em>log<em>n</em>log2<em>c</em>),</p>
<p>考虑如果所有区间都包含 mid<em>m<strong>i</strong>d</em>,我们从 mid<em>m<strong>i</strong>d</em>向左向右扩展,每个询问只需要合并左右端点的两个线性基即可。</p>
<p>套用猫树分治,额外的代价仅为 O(q\log n)<em>O</em>(<em>q</em>log<em>n</em>),总复杂度为 O(n\log n\log c+q(\log n+\log^2c ))<em>O</em>(<em>n</em>log<em>n</em>log<em>c</em>+<em>q</em>(log<em>n</em>+log2<em>c</em>))</p>
<p>(坑)</p>
<ul>
<li><strong>进阶题①</strong> : [P5576 <a href="https://www.luogu.com.cn/problem/P5576">CmdOI2019]口头禅</a></li>
</ul>
<p>需要SAM技巧,慎入,<a href="https://www.luogu.com.cn/blog/command-block/solution-p5576">题解Link</a></p>
<ul>
<li><strong>进阶题②</strong> : [P6109 <a href="https://www.luogu.com.cn/problem/P6109">Ynoi2009]rprmq</a></li>
</ul>
<p>需要线段树技巧,慎入,<a href="https://www.luogu.com.cn/blog/command-block/ds-ji-lu-p6109-ynoi2009rprmq">题解Link</a></p>
<hr>
<h1 id="6二进制分组">6.二进制分组</h1>
<p>还是考虑某个动态问题,静态版本( \texttt{C}C 全在 \texttt{Q}Q 前面)我们会做,而且复杂度只和操作次数相关。</p>
<p>还要满足可以把 \texttt{C}C 分批次向 \texttt{Q}Q 贡献。</p>
<p>有没有发现这个要求和“CDQ分治”一样啊?</p>
<p>奇妙的是,这种方法往往是能够做到在线的。所以这在效果上就是CDQ的强化版。</p>
<p>实现方法多种多样,不特别讲,在下方例题就可以看见了。</p>
<ul>
<li>
<p><strong>例题①</strong> : <a href="https://www.luogu.com.cn/problem/CF710F">CF710F String Set Queries</a></p>
<p><strong>题意</strong> :</p>
<ul>
<li>支持向集合 S<em>S</em>中加,删字符串。</li>
<li>给出文本串 T<em>T</em>,询问 S<em>S</em>中所有串出现的总次数。</li>
</ul>
<p>强制在线。</p>
</li>
</ul>
<p>加和删本质是同种操作,删可以看成贡献为 -1−1.</p>
<p>先考虑<strong>静态</strong>的问题怎么做。</p>
<p>对 S<em>S</em> 建立AC自动机,在 Fail<em>F<strong>a</strong>i**l</em> 树上下传串个数,把匹配到每个节点能获得的匹配次数求出。</p>
<p>然后对于询问,暴力跳自动机求和即可。</p>
<p>现在考虑在线。</p>
<p>我们新加入一个串的时候,不能直接修改现有的AC自动机,又不能重新建造。</p>
<p>如果我们现在有若干个AC自动机瓜分 S<em>S</em> ,我们将 T<em>T</em> 在每个串上都跑一次即可。</p>
<p>我们可以采用如下的方法来维护这一群AC自动机 :</p>
<ul>
<li>
<p><strong>写法①</strong> : jiry : 2048</p>
<p>加入新串时,查看上一个AC自动机中的<strong>串数</strong>是否与自己相等,如果相等则合并,不断重复这个过程。</p>
<p>实际上写代码的时候,可以一口气找到合并的结束位置,然后一口气合并,可以减小常数。</p>
<p>目前存留的AC机个数,就相当于串数的二进制表示中 11 的个数,为 O(logn)<em>O</em>(<em>l<strong>o</strong>g**n</em>)</p>
<p>如果一个串待在大小 2^i2<em>i</em>的AC机里,就说明他被合并了 i<em>i</em> 次,而 n<em>n</em> 个串最多合出 2^{logn}2<em>l<strong>o</strong>g**n</em> ,每个串被合并的次数也就是 O(logn)<em>O</em>(<em>l<strong>o</strong>g**n</em>)。</p>
</li>
</ul>
<p>这道题不使用这种方法实现,因为下一种写法更方便。</p>
<ul>
<li>
<p><strong>写法②</strong> : 替罪均摊</p>
<p>加入新串时,查看上一个AC自动机中的<strong>串总长</strong>是否小于自己的 \alpha<em>α</em>倍。</p>
<p>如果是,则将两堆合并。</p>
<p>由于每一个AC机总串长都会比上一个至少减小 \alpha<em>α</em>倍,所以总个数就是 O(log_{\alpha}L)<em>O</em>(<em>l<strong>o</strong>g<strong>α</strong>L</em>)的。</p>
<p>重构的复杂度考虑均摊证明,分层考虑势能。</p>
<p>加入新串时,在当前层增加了 len<em>l<strong>e</strong>n</em>的势能(串长)。</p>
<p>合并时,设本层势能为 h<em>h</em>,则消耗的时间为 \Theta((1+\alpha)h)Θ((1+<em>α</em>)<em>h</em>)。合并后,本层势能转移到上一层。</p>
<p>考虑到势能最多会上升 O(log_{\alpha}L)<em>O</em>(<em>l<strong>o</strong>g<strong>α</strong>L</em>)层,而势能与时间之间的兑换是 1:(1+\alpha)1:(1+<em>α</em>) 的,所以重构总复杂度为 O((1+\alpha)Llog_{\alpha}L)<em>O</em>((1+<em>α</em>)<em>L<strong>l</strong>o<strong>g</strong>α**L</em>)</p>
<p>实际上可以微调 \alpha<em>α</em>来实现常数平衡,常取 \alpha=2<em>α</em>=2。</p>
</li>
</ul>
<p><a href="https://www.luogu.com.cn/paste/340cc8qp">代码Link</a></p>
<ul>
<li><strong>例题②</strong> : [P3309 <a href="https://www.luogu.com.cn/problem/P3309">SDOI2014]向量集</a></li>
</ul>
<p>考虑给定的 (x,y)(<em>x</em>,<em>y</em>) 与集合中 (a,b)(<em>a</em>,<em>b</em>) 点积的式子 : ax+by=y(a·\frac{x}{y}+b)<em>a**x</em>+<em>b**y</em>=<em>y</em>(<em>a</em>⋅<em>y**x</em>+<em>b</em>)</p>
<p>相当于我们在维护若干条 y=ax+b<em>y</em>=<em>a**x</em>+<em>b</em> 的直线,每次代入 \frac{x}{y}<em>y**x</em> 当做 x<em>x</em> 求所有直线的值的 \maxmax.</p>
<p>现在问题就变成了 :</p>
<ul>
<li><code>push_back</code>一条直线。</li>
<li>查询某个区间的直线在 x=c<em>x</em>=<em>c</em> 时的最大取值。</li>
</ul>
<p>先考虑静态问题怎么做:</p>
<p>建立线段树,每个节点 [l,r][<em>l</em>,<em>r</em>] 上是向量 [L_l,L_r][<em>L**l</em>,<em>L**r</em>] 形成的凸包。</p>
<p>构造凸包需要排序+单队,使用归并可以省掉排序的 log<em>l<strong>o</strong>g</em>,构造这么一个线段树的复杂度是 O(nlogn)<em>O</em>(<em>n<strong>l</strong>o<strong>g</strong>n</em>)。由于不是每条线段都会在凸壳上,实际常数较小。</p>
<p>现在考虑使用二进制分组来解决,此时使用外层线段树的写法公认比较简洁。</p>
<p>外层写一个线段树,加入直线就是单点修。</p>
<p>假如两个儿子都<strong>满了</strong>,则把自己的凸包build起来。</p>
<p>查询的时候直接在线段树上拆分区间+凸包二分即可(常数较小)。</p>
<p>复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>,这题比较卡常数,建议归并建立凸包。</p>
<p><a href="https://www.luogu.com.cn/paste/cxdeh6em">代码Link</a></p>
<ul>
<li><strong>例题③</strong> : <a href="https://uoj.ac/problem/191">Uoj#191. 【集训队互测2016】Unknown</a>b</li>
</ul>
<p>考虑给定的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 与集合中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 叉积的式子 : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>x</mi><mo>−</mo><mi>a</mi><mi>y</mi><mo>=</mo><mi>x</mi><mo>(</mo><mo>−</mo><mi>a</mi><mo separator="true">⋅</mo><mfrac><mi>y</mi><mi>x</mi></mfrac><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">bx-ay=x(-a·\frac{y}{x}+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">a</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> ，仍然是一次函数问题。</p>
<p>和上一题主要的区别在于，支持在末尾的删除操作。</p>
<p>若某个线段树节点包含有一个被删除的向量，则直接报废。</p>
<p>如果还采用旧的策略，一次删除可能破坏掉一个大块，复杂度退化。</p>
<p>解决办法 ： 在这个区间刚满的时候不 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">build</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span></span></span></span>*这个区间，等到同层的下一个区间也填满的时候再 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">build*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord">∗</span></span></span></span> 这个区间。</p>
<p>这样，显然每层只有至多 22 个未 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>i</mi><mi>l</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">build</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span></span></span></span>的区间，查询复杂度仍然可以保证。</p>
<p>删除时，要越过后一个整个区间才能破坏前面已经被$ build$ 的区间，复杂度仍然均摊正确。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#-1%E5%89%8D%E8%A8%80">-1.前言</a></li>
<li><a href="#0%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">0.常见的数据结构</a></li>
<li><a href="#1%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4">1.逆向思维</a>
<ul>
<li><a href="#11-%E6%97%B6%E9%97%B4%E5%80%92%E6%B5%81">1.1 时间倒流</a></li>
<li><a href="#12-%E6%9F%A5%E8%AF%A2%E7%8A%B6%E6%80%81%E7%9A%84%E4%BA%92%E8%A1%A5">1.2 查询/状态的互补</a></li>
</ul>
</li>
<li><a href="#2cdq%E5%88%86%E6%B2%BB">2.CDQ分治</a></li>
<li><a href="#3%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB">3.线段树分治</a></li>
<li><a href="#4%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86">4.整体二分</a></li>
<li><a href="#5%E7%8C%AB%E6%A0%91%E5%88%86%E6%B2%BB">5.猫树分治</a></li>
<li><a href="#6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E7%BB%84">6.二进制分组</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/xiao-fen-tu-de-yuan-fang-shu/">
              <h3 class="post-title">
                小粉兔的圆方树
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
