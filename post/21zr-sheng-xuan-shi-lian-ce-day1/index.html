<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>21zr省选十连测day1 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1615201045259">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="21zr省选十连测day1 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="rank20,退役了退役了
A. 基础博弈练习题
考场这题玩命打表,n=8的表还是错的...得到了一个n=5的10分../xk
考虑我们转换问题,现在这类玄学毒瘤东西基本要转换成数学模型
考场上想到了类似于区间前缀后缀加减的思路,但是并不知..." />
    <meta name="keywords" content="均摊,ZROI,点分治,各省省选,线段树,动态规划" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1615201045259" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              21zr省选十连测day1
            </h2>
            <div class="post-info">
              <span>
                2020-12-27
              </span>
              <span>
                34 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/yqUZPYWAfQ/" class="post-tag">
                  # 均摊
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/EgVG2tkBI/" class="post-tag">
                  # ZROI
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/C6OfrSnce/" class="post-tag">
                  # 点分治
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/KY7VyyrtD/" class="post-tag">
                  # 各省省选
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/i0TglRCqu/" class="post-tag">
                  # 线段树
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/CJ-ugjBAY/" class="post-tag">
                  # 动态规划
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1FUryNWDCh*2ICNXKHPDOYPiEghRvhVKonhvChM.fmEQN8lCjzANvo5jH7aoDWLCE!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>rank20,退役了退役了</p>
<p>A. 基础博弈练习题</p>
<p>考场这题玩命打表,n=8的表还是错的...得到了一个n=5的10分../xk</p>
<p>考虑我们转换问题,现在这类玄学毒瘤东西基本要转换成数学模型</p>
<p>考场上想到了类似于区间前缀后缀加减的思路,但是并不知道选择另一侧而只是选择了同一侧.....</p>
<h1 id="补集转换可行的撒谎只有1次">补集转换:可行的撒谎只有1次</h1>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">a_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示答案是y的话,我们的A还能能撒几次慌</p>
<p>那么我们会发现,B一次询问一定能够让一个前缀/后缀的数能够撒谎次数-1</p>
<p>就是说,询问细线</p>
<p>111111100|000</p>
<p>如果是是,那么细线前面所有数减1,他们作为答案就不能在撒谎了</p>
<p>而又能发现,这个竖线可以使得那些已经成为0的会变成-1,也就是说<strong>他不可能成为答案了</strong></p>
<p>有了这个转换,双方的任务变成了:</p>
<p>Bob 要最快使得只剩下一个数非空<br>
Alice 要控制每一次减的方向,使得bob最慢</p>
<p>不难发现我们每次操作的是前后缀也就是说</p>
<p>------00000111100000-----</p>
<p>是a数组唯一的形态,-几不重要</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示有i个0,后接j个1,后接k个0的还剩多少次数结束qwq</p>
<p>那么我们就能转移了!</p>
<p>case 1</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>l</mi><mo>+</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp_{i,j,k}=min(max(dp_{i-l,j,k},dp_{l+j,0,0})+1,dp_{i,j,k}),l&lt;i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></p>
<p>case2</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>l</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>l</mi></mrow></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dp_{i,j,k}=min(max(dp_{l,j-l,k},dp_{i,l,j-l})+1,dp_{i,j,k}),l&lt;j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></span></p>
<p>case3</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>l</mi><mo>+</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mi>l</mi></mrow></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">dp_{i,j,k}=min(max(dp_{l+j,0,0},dp_{i,j,k-l})+1,dp_{i,j,k}),l&lt;k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 500;
int n, dp[MAXN][MAXN][MAXN];

inline int solve(int l, int m, int r) {
	if((l == 1 &amp;&amp; m == 0 &amp;&amp; r == 0) || (l == 0 &amp;&amp; m == 1 &amp;&amp; r == 0) || (l == 0 &amp;&amp; m == 0 &amp;&amp; r == 1))return 0; //我知道了
	if(~dp[l][m][r])return dp[l][m][r];
	dp[l][m][r] = 1e9;
	for(int i = 1; i &lt;= l; ++i) {
		// $$dp_{i, j, k} = min(max(dp_{i - l, j, k}, dp_{l, 0, 0}), dp_{i, j, k}), l &lt; i$$
		dp[l][m][r] = min(max(solve(l - i, m, r), solve(i + m, 0, 0)) + 1, dp[l][m][r]);
	}
	for(int i = 1; i &lt;= m; ++i) {
		// $$dp_{i,j,k}=min(max(dp_{l,j-l,k},dp_{i,l,j-l}),dp_{i,j,k}),l&lt;j$$
		dp[l][m][r] = min(max(solve(i, m - i, r), solve(l, i, m - i)) + 1, dp[l][m][r]);
	}
	for(int i = 1; i &lt;= r; ++i) {
		// $$dp_{i,j,k}=min(max(dp_{l,0,0},dp_{i,j,k-l}),dp_{i,j,k}),l&lt;k$$
		dp[l][m][r] = min(max(solve(i + m, 0, 0), solve(l, m, r - i)) + 1, dp[l][m][r]);
	}
	// printf(&quot;%d %d %d %d\n&quot;, l, m, r, dp[l][m][r]);
	return dp[l][m][r];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	memset(dp, -1, sizeof(dp));
	solve(0, n, 0);
	for(int i = 0; i &lt; n; ++i) {
		printf(&quot;%d &quot;, solve(i, n - i, 0));
	}
	// for(int i = 0; i &lt;= n; ++i) {
	// 	for(int j = 0; j &lt;= n; ++j) {
	// 		for(int k = 0; k &lt;= n; ++k) {
	// 			if(~dp[i][j][k]) {
	// 				printf(&quot;%d %d %d %d\n&quot;, i, j, k, dp[i][j][k]);
	// 			}
	// 		}
	// 	}
	// }
	// printf(&quot;%d\n&quot;, dp[0][n][0]);
	return 0;
}


</code></pre>
<p>根据邓老师所说,这个东西有决策单调性,就是固定前两维,第三维单调递增则决策点也单调递增qwq</p>
<p>然后我写了一个,挂了,没法调啊/ll</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 605;
int n;
int dp[MAXN][MAXN][MAXN], f[MAXN][MAXN][MAXN];

inline int solve(int l, int m, int r) {
	if(~dp[l][m][r])return dp[l][m][r];
	if((l == 0 &amp;&amp; m == 0 &amp;&amp; r == 0)) {
		f[l][m][r] = -1;
		return 1e9;
	}
	if((l == 1 &amp;&amp; m == 0 &amp;&amp; r == 0) || (l == 0 &amp;&amp; m == 1 &amp;&amp; r == 0) || (l == 0 &amp;&amp; m == 0 &amp;&amp; r == 1)) {
		f[l][m][r] = -1;
		return 0;
	} //我知道了
	dp[l][m][r] = 1e9;
	f[l][m][r] = -1;
	if(r)
		solve(l, m, r - 1);//不要问我为什么,厂长是我阿福哥
	if(!r) {
		bool flg = 1;
		for(int i = 1; i &lt;= l; ++i) {
			dp[l][m][r] = min(max(solve(l - i, m, r), solve(i + m, 0, 0)) + 1, dp[l][m][r]);
			if(solve(l - i, m, r) &lt;= solve(i + m, 0, 0) ) {
				f[l][m][r] = -i; //变了变了!
				flg = 0;
				break;
			}
		}
		if(flg)
			for(int i = 1; i &lt;= m; ++i) {
				dp[l][m][r] = min(max(solve(i, m - i, r), solve(l, i, m - i)) + 1, dp[l][m][r]);
				if(solve(i, m - i, r) &lt;= solve(l, i, m - i)) {
					f[l][m][r] = i + 10000;
					flg = 0;
					break;
				}
			}
		if(flg)
			for(int i = 1; i &lt;= r; ++i) {
				dp[l][m][r] = min(max(solve(i + m, 0, 0), solve(l, m, r - i)) + 1, dp[l][m][r]);
				if(solve(i + m, 0, 0) &lt;= solve(l, m, r - i)) {
					f[l][m][r] = i;
					flg = 0;
					break;
				}
			}
		if(flg)f[l][m][r] = -1;//我懒惰了
	} else {
		f[l][m][r] = f[l][m][r - 1];
		bool flg = 1;
		if(f[l][m][r] &lt; 0) {
			f[l][m][r] = -f[l][m][r];
			for(int i = max(1, f[l][m][r] - 1); i &lt;= l; ++i) {
				dp[l][m][r] = min(max(solve(l - i, m, r), solve(i + m, 0, 0)) + 1, dp[l][m][r]);
				if(solve(l - i, m, r) &lt;= solve(i + m, 0, 0)) {
					f[l][m][r] = -i;
					flg = 0;
					break;
				}
			}
			if(flg)f[l][m][r] = 10000;
		}
		if(f[l][m][r] &gt; 2000) {
			f[l][m][r] %= 10000;
			for(int i = max(1, f[l][m][r] - 1); i &lt;= m; ++i) {
				dp[l][m][r] = min(max(solve(i, m - i, r), solve(l, i, m - i)) + 1, dp[l][m][r]);
				if(solve(i, m - i, r) &lt;= solve(l, i, m - i)) {
					f[l][m][r] = i + 10000;
					flg = 0;
					break;
				}
			}
			if(flg)f[l][m][r] = 0;
		}
		if(flg)
			for(int i = max(1, f[l][m][r] - 1); i &lt;= r; ++i) {
				dp[l][m][r] = min(max(solve(i + m, 0, 0), solve(l, m, r - i)) + 1, dp[l][m][r]);
				if(solve(i + m, 0, 0) &lt;= solve(l, m, r - i)) {
					f[l][m][r] = i;
					break;
				}
			}
		if(flg)f[l][m][r] = r;

	}
	// printf(&quot;%d %d %d %d %d\n&quot;, l, m, r, dp[l][m][r], f[l][m][r]);
	return dp[l][m][r];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	memset(dp, -1, sizeof(dp));
	solve(0, n, 0);
	for(int i = 0; i &lt; n; ++i) {
		printf(&quot;%d &quot;, solve(i, n - i, 0));
	}
	return 0;
}

</code></pre>
<p>std:</p>
<p>观察到值域很小,所以我们可以考虑翻转这个值域和定义域</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示用i次操作,然后序列中已经有j个0,k个1,后面能有的最多多少个0,可以确定下整个序列的答案</p>
<p>我们怎么转移呢?</p>
<p><strong>翻转回来!</strong></p>
<p>观察之前的转移式子,以其中一个为例</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>v</mi><mo>−</mo><mi>l</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>v</mi><mo>−</mo><mi>l</mi></mrow></msub><mo>)</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow></msub><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mo>&lt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">dp_{u,v,w}=min(max(dp_{l,v-l,w},dp_{u,l,v-l})+1,dp_{u,v,w}),l&lt;v
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span></p>
<p>因为我们的Alice小姐要二者取max,而bob已经根据结论已经知道在前面比后面小的时候取得所有的最小值</p>
<p>也就是说,我们还是只需要看这个分界点处的答案</p>
<p>再到f数组,我们反义决策单调性</p>
<p>是我们在这个地方取到最小值恰好为k的时候,第三维最大可能就是这个w!</p>
<p>也就是说,如果我们找到这个分界点,因为我们这个分界点满足了这次操作能够确定的是尽可能长的第三维(再靠后就无法确定了,因为随着w变大我们分界点也变大),然后再这个分界点处转移我们的f数组就是可以的!</p>
<p>怎么确定分界点?<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><msub><mi>r</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pr_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示在这个状态定义下的分界点位置是什么</p>
<p>也就是说,我们最优转移点是什么</p>
<ol>
<li>均分case,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mo>&gt;</mo><mi>j</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">pr&gt;j+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></li>
</ol>
<p>此时我们后面想要尽可能多的零就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>+</mo><mo>(</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">f_{i-1,j,k}+(1&lt;&lt;i-1)-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>决策点位置在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i-1,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的最后一个0处</p>
<p>000011111000|00000000</p>
<p>因为此时先手选择左边保留,那右边都删掉之后左边显然是可以的</p>
<p>先手选择右边保留,那左边都删掉后多出k个1,然后一凑正好是个二分可以解决的问题</p>
<p>这个case就对应了最优决策点在j+k之后的情况,因为不难发现此时左右是(原定义)dp值相等的</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mo>&lt;</mo><mi>j</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">pr&lt;j+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></li>
</ol>
<p>此时我们想要尽可能多的零就要考虑考虑了,从上一个决策点向后跳,直到不再优为止</p>
<p>而此时决策点一定满足我们之前说的变化过程,就是先是回答大于等于优,再是回答小于优</p>
<p>这意味着什么呢?就是我们之前回答小于答案一定小于k次,因为大于等于的才大于等于k次,才能使得之前的决策点不是最优决策点</p>
<p>这就意味着,在之前砍一刀,一定能够满足前k-1刀可以解决回答小于的答案</p>
<p>这就告诉我们,从之前的决策点向后跳,直到前k-1刀不能够回答小于的答案,此时意味着我们达到了那个最优决策点(毫不留情的告诉你这个点左右切得到的答案是一样的/....),因为他必然要k刀了</p>
<p>其实这个和凸性很相关:一开始可以,一直逼近逼近直到不行qwq</p>
<p>那既然找到了这个决策点,我们再在这个位置切上一刀就是答案了</p>
<p>而这一刀的方向显然是向右的,因为之前我们一直是向左切的,直到这一刀那个max才切换到右边呢qwq</p>
<p>切:是指alice告诉我们大于还是小于....</p>
<p>都知道之后,代码就不难了</p>
<p>code:</p>
<pre><code class="language-cpp">//copy dmy!
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2050;
int n;
int dp[20][MAXN][MAXN];
int pr[20][MAXN][MAXN];

bool chk(int k, int i, int j, int pr) {
	int f[3] = {0, 0, 0};
	if(pr &lt;= i + 1) {
		f[0] = pr - 1 + j;
	} else f[0] = i, f[1] = pr - i - 1, f[2] = j - f[1];
	return dp[k][f[0]][f[1]] &gt;= f[2];
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 0; i &lt; 20; ++i) {
		for(int j = 0; j &lt;= n; ++j) {
			for(int k = n - j; k &gt;= 0; --k) {
				dp[i][j][k] = -1e9;
				if(i == 0) {//零次操作
					if(j + k == 0)dp[i][j][k] = 1;//一个数
					else if(j + k == 1)dp[i][j][k] = 0;//0个数
				} else {
					dp[i][j][k] = dp[i - 1][j][k] + (1 &lt;&lt; (i - 1)) - k;
					if(k == n - j)pr[i][j][k] = 1;
					else pr[i][j][k] = pr[i][j][k + 1];// /jk
					while(chk(i - 1, j, k, pr[i][j][k] + 1) &amp;&amp; pr[i][j][k] &lt;= j + k) {
						pr[i][j][k]++;
					}
					if(!chk(i - 1, j, k, pr[i][j][k]))dp[i][j][k] = -1e9;
					else {
						int qwq = pr[i][j][k];
						int f[3] = {0, 0, 0};
						if(qwq &lt;= j + 1) {
							f[0] = j + 1 - qwq;
							f[1] = k;
						} else {
							f[0] = qwq - j - 1;
							f[1] = k - f[0];
						}
						dp[i][j][k] = max(dp[i][j][k], dp[i - 1][f[0]][f[1]]);
					}
				}
				// printf(&quot;%d %d %d %d\n&quot;, i, j, k, dp[i][j][k]);
			}
		}
	}
	for(int j = 0; j &lt; n; ++j) {
		for(int i = 0; i &lt; 20; ++i) {
			if(dp[i][j][n - j] &gt;= 0) {
				printf(&quot;%d &quot;, i);
				break;
			}
		}
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>代码难度相当大,思维量适中</p>
<p>操作3</p>
<p>我们先发现暴力可以从左向右扫一遍进行规约,然后再从右向左扫一遍进行规约</p>
<p>会发现这样一定可行了,因为这个规约有传递性,如果左边的i位置可以约束到j,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,k也可以,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,而且k更狠</p>
<p>那么一定会有k约束了i,并且继续约束了i之后的j qwq</p>
<p>同理,右边向左边也一样</p>
<p>考虑怎么加速这个暴力的部分,我们发现一个区间规约之后就很优秀了,<s>这么优秀的区间怎么忍心打破呢?</s>,所以我们记录这些区间</p>
<p>现在对于一个操作3,有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo>]</mo><mo separator="true">,</mo><mo>[</mo><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_1,r_1],[l_2,r_2]...[l_i,r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>一车区间满足这个性质呢~~(是一个区间套)~~</p>
<p>于是发现,对于一个区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_{i-1},r_{i-1}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>,只会有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">r_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[l_i,r_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>产生影响,h为其高度</p>
<p>那么影响的范围也应该是最大的x,满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub><mo>&gt;</mo><mi>h</mi><mo>+</mo><mo>(</mo><mi>x</mi><mo>−</mo><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a_x&gt;h+(x-r_{i-1})*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,然后把这一段区间都变成等差数列即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">h+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>为首相,公差为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>为什么对呢?因为a_x一定会被改成那个值,然后又因为这是个优秀的区间,所以整体是个等差数列,所以前面都不行了都要改啊</p>
<p>最后我们要维护</p>
<ul>
<li>
<p>区间和</p>
</li>
<li>
<p>区间赋值等差数列</p>
</li>
<li>
<p>区间加</p>
</li>
<li>
<p>区间二分,查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>x</mi></msub><mo>−</mo><mi>x</mi><mo>∗</mo><mi>k</mi><mo>&gt;</mo><mi>h</mi><mo>−</mo><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>∗</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a_x-x*k&gt;h-r_{i-1}*k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.673611em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>最大的x</p>
<p>线段树二分或者外层二分皆可以,时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>1</mn><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2/1n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">1</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>???好像漏了什么</p>
<p>没错,这些优秀的区间的势能分析</p>
<p>其实不会很差,因为我们只有2,3操作会使得优秀区间数至多+2,而这个+2显然是常数级别的,同时操作2一次会合并许多,复杂度是区间数*log</p>
<p>一开始有n个区间,也就是说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O((n+m)logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>,么得变化??</p>
<p>实现后的一些细节</p>
<p>我们线段树维护等差数列,公差的维护可以把每个数都变成下标<em>公差的形式,然后首相对应的减去下标</em>公差即可</p>
<p>同样的,注意到我们的序列其实满足很不错的性质,就是每次只会在优秀的序列中更改</p>
<p>那么我们只需要找到第一个向右/左不合法的位置即可,而这个位置存在的前提是那个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><msub><mi>r</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">abs
r_{i-1}-l_{i}&gt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>同时,我们一定有向右第一个合法的位置后面都合法这条性质,因为你想如果我们这个位置可以传递约束到j,又能传递约束到不合法的i,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>i,j不连续中间有合法的位置,可以推出最后一定这个区间不是优秀的,,那也就不可能只一次查找完成,也就是说优秀的区间传递性是极大的</p>
<p>综上,我们只需要二分这个合法位置即可</p>
</li>
</ul>
<p>另外线段树二分在本题中是有区间限制和方向限制的的,以findleft(找最小)为例</p>
<p>对于有区间限制的线段树二分,如果我们要找最小的,就在<strong>可行的范围</strong>先尽可能的向左区间走</p>
<p>如果说目前限制正好分割了左右区间,会对于方向限制产生影响</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l......mid.....p....r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p>
<p>要先看mid,p这一段是否完全合法,才能向左走,而如果没有这个限制,我们可以直接用右儿子的最小值判断能不能向左走qwq</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
#define ins insert
#define ls (k&lt;&lt;1)
#define rs (k&lt;&lt;1|1)
#define pii pair&lt;int,int&gt;
#define fi first
#define se second
#define ll long long
using namespace std;
const int MAXN = 4e5 + 7;
int n, m;
ll K;
int w[MAXN];
set&lt;int&gt; st;

struct rec {
	ll sum;
	ll A, B, add, cov;
	int dir;
} tr[MAXN];

inline ll getV(int x, ll cov, int dir) {
	return 1ll * dir * K * x + cov;
}

inline ll getV1(int x, ll cov, int dir) {
	return dir * K * 1ll * x + cov + 1ll * K * x;
}

inline ll getV2(int x, ll cov, int dir) {
	return dir * K * 1ll * x + cov - 1ll * K * x;
}

inline ll getsum(int l, int r, ll cov, int dir) {
	return (getV(l, cov, dir) + getV(r, cov, dir)) * (r - l + 1) / 2;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;22)
	char buf[BUF_SIZE], *p1 = BUF_SIZE + buf, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, BUF_SIZE, 1, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = nc();
		int x = 0;
		int f = 1;
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;

namespace seg {
	inline void calc(int k, int l, int r, ll v) {
		rec &amp;a = tr[k];
		a.add += v;
		a.A += v;
		a.B += v;
		a.sum += (r - l + 1) * v;
	}
	inline void pushdown(int k, int l, int r) {
		rec &amp;a = tr[k], &amp;b = tr[ls], &amp;c = tr[rs];
		if(a.dir) {
			b.dir = a.dir;
			c.dir = a.dir;
			b.cov = a.cov;
			c.cov = a.cov;
			int mid = (l + r) &gt;&gt; 1;
			b.sum = getsum(l, mid, a.cov, a.dir);
			c.sum = getsum(mid + 1, r, a.cov, a.dir);

			b.A = min(getV1(l, a.cov, a.dir), getV1(mid, a.cov, a.dir));
			b.B = min(getV2(l, a.cov, a.dir), getV2(mid, a.cov, a.dir));

			c.A = min(getV1(mid + 1, a.cov, a.dir), getV1(r, a.cov, a.dir));
			c.B = min(getV2(mid + 1, a.cov, a.dir), getV2(r, a.cov, a.dir));

			b.add = 0;
			c.add = 0;
			a.dir = 0;//没用了,我们不调用他了
		}
		if(a.add) {
			int mid = (l + r) &gt;&gt; 1;
			calc(ls, l, mid, a.add);
			calc(rs, mid + 1, r, a.add);
			a.add = 0;
		}
	}//简 直 魔 鬼
	inline void pushup(int k) {
		tr[k].A = min(tr[ls].A, tr[rs].A);
		tr[k].B = min(tr[ls].B, tr[rs].B);
		tr[k].sum = tr[ls].sum + tr[rs].sum;
		return;
	}
	inline ll qry(int k, int l, int r, int L, int R) {
		if(L &lt;= l &amp;&amp; r &lt;= R) {
			return tr[k].sum;
		}
		pushdown(k, l, r);
		int mid = (l + r) &gt;&gt; 1;
		if(R &lt;= mid)return qry(ls, l, mid, L, R);
		else if(L &gt; mid)return qry(rs, mid + 1, r, L, R);
		else return qry(ls, l, mid, L, R) + qry(rs, mid + 1, r, L, R);
	}
	inline void mdf(int k, int l, int r, int L, int R, ll x) {
		if(L &lt;= l &amp;&amp; r &lt;= R) {
			calc(k, l, r, x); // /cy
			return;
		}
		int mid = (l + r) &gt;&gt; 1;
		pushdown(k, l, r);
		if(R &lt;= mid)mdf(ls, l, mid, L, R, x);
		else if(L &gt; mid)mdf(rs, mid + 1, r, L, R, x);
		else {
			mdf(ls, l, mid, L, R, x);
			mdf(rs, mid + 1, r, L, R, x);
		}
		pushup(k);
	}
	inline void mdf2(int k, int l, int r, int L, int R, ll cov, int dir) {
		if(L &lt;= l &amp;&amp; r &lt;= R) {
			rec &amp;a = tr[k];
			a.dir = dir;
			a.cov = cov;
			a.sum = getsum(l, r, cov, dir);
			a.A = min(getV1(l, a.cov, a.dir), getV1(r, a.cov, a.dir));
			a.B = min(getV2(l, a.cov, a.dir), getV2(r, a.cov, a.dir));
			a.add = 0;// /ll
			return;
		}
		pushdown(k, l, r);
		int mid = (l + r) &gt;&gt; 1;
		if(R &lt;= mid)mdf2(ls, l, mid, L, R, cov, dir);
		else if(L &gt; mid)mdf2(rs, mid + 1, r, L, R, cov, dir);
		else {
			mdf2(ls, l, mid, L, R, cov, dir);
			mdf2(rs, mid + 1, r, L, R, cov, dir);
		}
		pushup(k);
	}
	int q;
	inline void findleft(int k, int l, int r, int p, int v) {
		int mid = (l + r) &gt;&gt; 1;
		if(p &lt; r) {
			if(p &gt; mid) {
				findleft(rs, mid + 1, r, p, v); //只能向左走
				if(q != mid + 1)return;
			}
			findleft(ls, l, mid, p, v);
			return;
		}
		if(tr[k].A &gt; v)return q = l, void(); //不行了
		if(l == r)return ;
		pushdown(k, l, r);
		if(tr[rs].A &gt; v)q = mid + 1, findleft(ls, l, mid, p, v);
		else findleft(rs, mid + 1, r, p, v);
	}
	inline void findright(int k, int l, int r, int p, int v) {
		int mid = (l + r) &gt;&gt; 1;
		// printf(&quot;%d %d  %d %d %d\n&quot;, l, mid, r, p, tr[k].B);
		if(p &gt; l) {
			if(p &lt;= mid) {
				findright(ls, l, mid, p, v);
				if(q != mid)return;
			}
			findright(rs, mid + 1, r, p, v);
			return;
		}
		if(tr[k].B &gt; v)return q = r, void();
		if(l == r)return;
		pushdown(k, l, r);
		if(tr[ls].B &gt; v)q = mid, findright(rs, mid + 1, r, p, v);
		else findright(ls, l, mid, p, v);
	}
	inline void build(int k, int l, int r) {
		if(l == r) {
			tr[k].B = w[l] - K * l;
			tr[k].A = w[l] + K * l;
			tr[k].sum = w[l];
			// printf(&quot;%d %lld %d?\n&quot;, l, tr[k].B, k);
			return;
		}
		int mid = (l + r) &gt;&gt; 1;
		build(ls, l, mid);
		build(rs, mid + 1, r);
		pushup(k);
	}
}
using namespace seg;

//这个是右端点
inline void  work(int p, int l, int r) {
	ll A = qry(1, 1, n, p, p);
	ll B = qry(1, 1, n, p + 1, p + 1);
	// printf(&quot;A :%lld B: %lld %lld\n&quot;, A, B, K);
	if(abs(A - B) &lt;= K)return;//没有关系
	if(A &lt; B) {
		q = -1;
		findright(1, 1, n, p + 1, A - p * K);
		// printf(&quot;%d %d %d %d %lld?\n&quot;, p, q, l, r, A - p * K);
		//直接惊恐
		q = min(q, r);
		//得到的位置是不合法的
		mdf2(1, 1, n, p + 1, q, A - K * p, 1); //更改!qwq
	} else {
		q = -1;
		findleft(1, 1, n, p, B + (p + 1) * K);
		// if(q == 1e9)return;
		q = max(q, l); //改多了我直接惊恐
		mdf2(1, 1, n, q, p, B + K * (p + 1), -1);
	}
}

inline void solve(int l, int r) {
	auto fst = st.lower_bound(l);
	auto lst = st.lower_bound(r);
	for(auto it = fst; it != lst; ++it) {
		work(*it, l, r);
		// printf(&quot;L :%d R: %d nw: %d\n&quot;, l, r, *it);
	}
	st.erase(fst, lst);
	if(l &gt; 1)st.ins(l - 1);
	if(r &lt; n)st.ins(r);
	return;
}

inline void solve2(int l, int r, int c) {
	mdf(1, 1, n, l, r, c);
	if(l &gt; 1)st.ins(l - 1);
	if(r &lt; n)st.ins(r);
	return ;
}

inline void init() {
	for(int i = 1; i &lt;= n; ++i)st.ins(i);
	build(1, 1, n);
}

int main() {
	n = read();
	m = read();
	K = read();
	for(int i = 1; i &lt;= n; ++i) {
		w[i] = read();
	}
	init();
	for(int i = 1, op, l, r, c; i &lt;= m; ++i) {
		op = read();
		l = read();
		r = read();
		if(op == 1) {
			printf(&quot;%lld\n&quot;, qry(1, 1, n, l, r));
		}
		if(op == 2) {
			c = read();
			solve2(l, r, c);
		}
		if(op == 3) {
			solve(l, r);
		}
	}
	return 0;
}
/*

5 5 1
5 1 3 4 2
3 3 5
2 3 5 2
1 2 3
3 4 5
1 1 3


*/


</code></pre>
<p>B</p>
<p>又是点分治</p>
<p>首先考虑暴力怎么实现,观察到我们最后停到哪里一定不会走回头路,因为走了回头路还不如在某一步停一下再走更优秀</p>
<p>同时我们也不会先停再走,假设他停了又走,对于边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>从u到v,那么只会使得那些u一侧的怪物更接近他,而v一侧的怪物无论接不接近都会遇上他,所以先停下再走也不行</p>
<p>一定是走到一个点然后驻留一辈子,所以我们可以枚举每个u作为停留点</p>
<p>然后这个贡献怎么办?v的贡献是:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>v</mi></msub><mo>∗</mo><mo>(</mo><mo>⌊</mo><mfrac><mrow><mi>h</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><mi>k</mi></mfrac><mo>⌋</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">a_v*(\lfloor \frac{h-max(dis,1)}{k} \rfloor+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>这个就相当于,我们最后出发的dis个怪物他完蛋了,然后又因为我们是在第一个回合出现,所以下取整会少算一次(第一次)加上去,而如果正好是在这个点本身,可能又会多算一次(正好是倍数的时候),再角去</p>
<p>50有了,这种类似于树上深度的,启示我们使用点分治解决</p>
<p>链:</p>
<p>后i+1个点的贡献已经算出,怎么推得i号点的贡献呢?</p>
<p>考虑观察这个式子,因为我们i+1-&gt;i,会变得是所有dis值,而这个下取整只有在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">h-max(dis,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>是k的倍数的时候会发生变化:正好减少了1</p>
<p>用1当做根,式子变成了$$a_v*(\lfloor \frac{h-dep_{j}+dep_i}{k} \rfloor+1)$$</p>
<p>也就是说,我们维护一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><msub><mi>q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">qwq_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">mod k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>等于深度i的所有的点系数和是什么</p>
<p>然后每次向前移动的时候,我们让i号点的答案对应加上一个数就好,应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>+</mo><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>d</mi><mi>e</mi><msub><mi>p</mi><mi>j</mi></msub><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h+dep_i==dep_j (mod k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>的那个j</p>
<p>树是一样的,我们会发现把这个树点分治后,<strong>同一深度上的点对于某个点的贡献是完全一样的</strong></p>
<p>就是他们后面那个东西是一样的,前面的系数求个和就可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示深度为i这一层的点对于某个点贡献和就好了qwq</p>
<p>于此同时,我们可以继续在深度数组上做这个类似于链的推进过程:</p>
<p>维护深度与i同余的所有点系数和</p>
<p>维护深度为i的点受到其他所有点的影响之和</p>
<p>随着深度变小,不难发现后面的那个变量会变大变大,所以我们一样的从大到小推</p>
<p>注意h可能很大,超过我们能开的数组的范围,此时我们要减少一个k的倍数使得h在maxd范围内,而且要尽可能大</p>
<p>有:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>−</mo><mi>n</mi><mi>k</mi><mo>−</mo><mi>d</mi><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi>x</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">h-nk-d&lt;=mxd
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>−</mo><mi>d</mi><mo>−</mo><mi>m</mi><mi>x</mi><mi>d</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">h-d-mxd&lt;=nk
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mrow><mi>h</mi><mo>−</mo><mi>d</mi><mo>−</mo><mi>m</mi><mi>x</mi><mi>d</mi></mrow><mi>k</mi></mfrac><mo>⌉</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\lceil\frac{h-d-mxd}{k}\rceil=n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>而我们又有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>A</mi><mi>x</mi></mfrac><mo>⌉</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>A</mi><mo>+</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><mi>x</mi></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{A}{x}\rceil=\lfloor \frac{A+x-1}{x}\rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></span></p>
<p>证明如下:</p>
<p>如果A是x的倍数,可以直接打开下取整上取整号,结论显然成立</p>
<p>如果A不是x的倍数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>A</mi><mi>x</mi></mfrac><mo>⌉</mo><mo>=</mo><mo>⌊</mo><mfrac><mi>A</mi><mi>x</mi></mfrac><mo>+</mo><mn>1</mn><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{A}{x}\rceil=\lfloor \frac{A}{x}+1\rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">⌋</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>A</mi><mi>x</mi></mfrac><mo>⌉</mo><mo>=</mo><mo>⌊</mo><mfrac><mrow><mi>A</mi><mo>+</mo><mi>x</mi></mrow><mi>x</mi></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac{A}{x}\rceil=\lfloor \frac{A+x}{x}\rfloor
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></span></p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 32: …+x-1}{x}\rfloor$̲$(因为不是倍数)

code…'>=\lfloor \frac{A+x-1}{x}\rfloor$$(因为不是倍数)

code:

```cpp

#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 3e5 + 7;
int n, K, H, ccnt, rt, N;
int a[MAXN];
vector&lt;int&gt; e[MAXN];
int siz[MAXN], dp[MAXN], vis[MAXN];
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char  buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - &#039;0&#039;;
		return x;
	}
}
using namespace fastIO;
int mxd;
ll suma[MAXN], qwq[MAXN], w[MAXN], sum[MAXN];

inline void getrt(int u, int F) {
	siz[u] = 1;
	dp[u] = 0;
	for(auto v : e[u]) {
		if(v == F || vis[v])continue;
		getrt(v, u);
		siz[u] += siz[v];
		dp[u] = max(dp[u], siz[v]);
	}
	dp[u] = max(dp[u], N - siz[u]);
	if(dp[u] &lt; dp[rt])rt = u;
}

ll ans = 1e18;

inline void getans(int u, int F, int dep) {
	if(dep &gt; H)return ;
	ans = min(ans, sum[u]);
	for(auto v : e[u]) {
		if(v == F)continue;
		getans(v, u, dep + 1);
	}
	return;
}

inline void getdis(int u, int F, int dep) {
	mxd = max(mxd, dep);
	suma[dep] += a[u];
	for(auto v : e[u]) {
		if(vis[v] || v == F)continue;
		getdis(v, u, dep + 1);
	}
}


inline void getw(int u, int F, int dep, int t) {
	sum[u] += w[dep] * t;
	for(auto v : e[u]) {
		if(v == F || vis[v])continue;
		getw(v, u, dep + 1, t);
	}
}

inline void clr() {
	for(int i = 0; i &lt;= mxd; ++i)suma[i] = qwq[i] = w[i] = 0;
	mxd = 0;
}

inline void solve2(int u, int t) {
	mxd = 0;
	getdis(u, u, t == 1 ? 0 : 1);
	mxd = min(mxd, H);
	for(int i = 0; i &lt;= mxd; ++i)qwq[i] = suma[i] + (i &gt;= K ? qwq[i - K] : 0);
	for(int i = 0; i &lt;= mxd; ++i) {
		if((H - mxd - i) &gt;= 0)w[mxd] += suma[i] * ((H - mxd - i) / K + 1);//下取整啊
	}
	for(int i = mxd - 1; i &gt;= 0; --i) {
		w[i] = w[i + 1];
		if(H - i &lt;= mxd)w[i] += qwq[H - i];
		else {
			int qaq = (H - i - mxd + K - 1) / K;
			if(H - qaq * K - i &gt;= 0)w[i] += qwq[H - qaq * K - i];
		}
	}
	if(H % K == 0)w[0] -= qwq[0];
	getw(u, u, t == 1 ? 0 : 1, t);
	clr();
}

inline void solve(int u) {
	vis[u] = 1;
	solve2(u, 1);
	for(auto v : e[u]) {
		if(vis[v])continue;
		solve2(v, -1);
		rt = 0;
		N = siz[v];
		getrt(v, u);
		solve(rt);
	}
	return;
}

int main() {
	n = read();
	K = read();
	H = read();
	for(int i = 1; i &lt;= n; ++i)a[i] = read();
	for(int i = 1, x, y; i &lt; n; ++i) {
		x = read();
		y = read();
		e[x].emplace_back(y);
		e[y].emplace_back(x);
	}
	rt = 0;
	N = n;
	dp[0] = N;
	getrt(1, 1);
	solve(rt);
	getans(1, 1, 0);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

```

耗时1天半完结/kk</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E8%A1%A5%E9%9B%86%E8%BD%AC%E6%8D%A2%E5%8F%AF%E8%A1%8C%E7%9A%84%E6%92%92%E8%B0%8E%E5%8F%AA%E6%9C%891%E6%AC%A1">补集转换:可行的撒谎只有1次</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/bei-er-de-shu-xue-pian-1/">
              <h3 class="post-title">
                贝尔的数学篇
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
