<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>20zr暑期AB班十连测day5 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1608303943190">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="20zr暑期AB班十连测day5 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="A
设dpidp_idpi​表示从点i开始的答案然后求和+最大值
直接写的话有30pts,用一个longlong可以记一下答案,但是这里是不能直接做的
显然DP不能优化,考虑优化转移
两个set比较的复杂度是O(min(S1,S2),log..." />
    <meta name="keywords" content="启发式合并,后缀自动机,动态规划" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1608303943190" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              20zr暑期AB班十连测day5
            </h2>
            <div class="post-info">
              <span>
                2020-08-01
              </span>
              <span>
                16 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/JnCW-H7if/" class="post-tag">
                  # 启发式合并
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/m2-tF6st0/" class="post-tag">
                  # 后缀自动机
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/CJ-ugjBAY/" class="post-tag">
                  # 动态规划
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/4pNOqgOvBLvj4yTC9qc55Vwm**if3ANJ295lJmY88B2is7K6BrQbic5CQAHMjCSQpdE.sMzESms*1yBCpkTc4PDJYiUvqKNP.C4Ze3ckmjo!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>A</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dp_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从点i开始的答案然后求和+最大值</p>
<p>直接写的话有30pts,用一个longlong可以记一下答案,但是这里是不能直接做的</p>
<p>显然DP不能优化,考虑优化转移</p>
<p>两个set比较的复杂度是O(min(S1,S2),logn)的,然后对于合并可以启发式合并,这个是均摊O<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的</p>
<p>为啥写挂了?因为没有启发式合并啊</p>
<p>注意最大的那个数我们找出来后要打个*2标记然后加的时候就直接不考虑他就能保证复杂度不会被卡成O(n^2)了!!</p>
<p>而且我们父亲要继承最大的儿子才行/kk.</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
#define int long long
#define ll long long
const int P = 998244353;
const int MAXN = 1e5 + 7;
const int MAXM = 3e5 + 7;
int n, ccnt;
int home[MAXM], to[MAXM], nxt[MAXM], len[MAXM];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	len[ccnt] = z;
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
	return ans;
}

ll dp[MAXN];
inline void dfs(int u, int F) {
	ll maxson = 0;
	for(int i = home[u]; i ; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		ll val = ksm(2, len[i]);
		dp[u] += dp[v] + val;
		maxson = max(dp[v] + val, maxson);
	}
	dp[u] += maxson;
	return ;
}
//queue?vector?set ba....
inline ll ksm2(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
set&lt;int&gt; st[MAXM]; //I am not afraid of TLE
int id[MAXM], tag[MAXM];
#define ins insert

inline int getf(int x) {
	return id[x] == x ? x : id[x] = getf(id[x]);
}

inline void add(int u, int x) {
	x -= tag[u];
	// printf(&quot;%d?%d\n&quot;, u, x);
	while(st[u].find(x) != st[u].end()) {
		st[u].erase(x);
		++x;
	}
	st[u].ins(x);//qwq?
	// printf(&quot;%d?%d?%d?\n&quot;, u, x, st[u].size());
}

inline int merge(int x, int y) {
	int qaq = min(st[x].size(), st[y].size());
	if(qaq == st[x].size()) {
		swap(st[x], st[y]);
		swap(tag[x], tag[y]);
	}
	// printf(&quot;merge : %d %d %d\n&quot;, x, y, qaq);
	for(auto it : st[y]) {
		add(x, it + tag[y]);
	}//fake启发式合并
	return x;
}

inline int pd(int x, int y) {
	auto itx = st[x].end();
	auto ity = st[y].end();
	if(st[y].size() == 0 &amp;&amp; st[x].size() != 0)return 1;
	else if(st[y].size() == 0 &amp;&amp; st[x].size() == 0)return 0;
	else if(st[x].size() == 0)return 0;
	itx--;
	ity--;
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	while((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; (itx != st[x].begin()) &amp;&amp; (ity != st[y].begin())) {
		// printf(&quot;%d %d\n&quot;, *itx, *ity);
		itx--;
		ity--;
	}
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	if((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; st[x].size() &lt;= st[y].size())//leny&gt;lenx
		return 0;
	else if( (*ity) + tag[y] == (*itx) + tag[x] &amp;&amp; st[y].size() &lt; st[x].size())
		return 1;
	else return ((*itx) + tag[x]) &gt; ((*ity) + tag[y]);
}

inline void dfs2(int u, int F) {
	// printf(&quot;%d %d %d!@#\n&quot;, u, F, id[u]);
	int maxid = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		// printf(&quot;%d???\n&quot;, v);
		dfs2(v, u);
		add(getf(v), len[i]);
		// printf(&quot;%d&amp; %d?\n&quot;, getf(v), len[i]);
		if(getf(v) != getf(maxid) &amp;&amp; pd(getf(v), getf(maxid))) {
			maxid = v;
		}
	}
	// printf(&quot;%d %d??\n&quot;, u, maxid);
	if(maxid)id[u] = getf(maxid);
	tag[getf(u)]++;
	// printf(&quot;%d?\n&quot;,)
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		if(maxid != v) {
			merge(getf(u), getf(v));
			// printf(&quot;%d %d!!\n&quot;, u, v);
		}
	}
	// ll ans = 0;
	// for(auto it : st[getf(u)]) {
	// 	// printf(&quot;%lld\n&quot;, it);
	// 	ans = (ans + ksm2(2, (it + tag[getf(u)])) % (P - 1)) % P;
	// }
	// printf(&quot;%lld\n&quot;, ans);
	return ;
}

inline void solve() {
	for(int i = 1; i &lt;= n; ++i)id[i] = i;
	dfs2(1, 0);
	// puts(&quot;QAQ&quot;);
	ll ans = 0;
	for(auto it : st[getf(1)]) {
		// printf(&quot;%lld\n&quot;, it);
		ans = (ans + ksm2(2, (it + tag[getf(1)])) % (P - 1)) % P;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}


signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2, x, y; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		if(y &gt; 30)flg = 0;
		ct(x, i, y);
		ct(i, x, y);
	}
	// if(flg) {
	// 	dfs(1, 0);
	// 	printf(&quot;%lld\n&quot;, dp[1] % P);
	// } else {
	solve();
	// }
	return 0;
}

我都好调死了
</code></pre>
<p>C</p>
<p>考虑left表示前面加一个字符,right表示后面加一个</p>
<p>然后转移的时候就是在前缀树和后缀树上重新定位一下就能决定我们是在哪个方向加入字符了</p>
<p>就是ch和fa上</p>
<p>所以我们可以强制每个节点在左边加字符(向下走)走到最长的串,算出第一部分的答案,然后再考虑向后面加字符,这个就是一个后缀自动机上拓扑序DP一下</p>
<p>然后如果我们边有长度其实决定了我们可以等等再走,所以转移又会不太一样</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define R register
const int MAXN = 1e6 + 7;
const int MAXM = 5e5 + 7;
using std::max;
char s[MAXM];
int  c[MAXN], a[MAXN];
long long dp[MAXN];
int ch[MAXN][26], fa[MAXN], siz[MAXN], len[MAXN], T, lst;
inline void init() {
	T = lst = 1;
}
inline void ins(char c) {
	R int p = lst, np = lst = ++T;
	len[np] = len[p] + 1;
	siz[np] = 1;
	for(; !ch[p][c] &amp;&amp; p; p = fa[p])ch[p][c] = np;
	if(!p) {
		fa[np] = 1;
	} else {
		R int q = ch[p][c];
		if(len[q] == len[p] + 1) {
			fa[np] = q;
		} else {
			R int nq = ++T;
			len[nq] = len[p] + 1;
			memcpy(ch[nq], ch[q], sizeof(ch[nq]));
			fa[nq] = fa[q];
			fa[q] = fa[np] = nq;
			for(; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
		}
	}

}


int main() {
	scanf(&quot;%s&quot;, s + 1);
	int n = strlen(s + 1);
	init();
	R int i;
	for(i = 1; i &lt;= n; ++i) {
		ins(s[i] - 'a');
	}
	for(i = 1; i &lt;= T; ++i) {
		c[len[i]]++;
	}
	for(i = 1; i &lt;= n; ++i) {
		c[i] += c[i - 1];
	}
	for(i = T; i &gt;= 1; --i) {
		a[c[len[i]]--] = i;
	}
	for(i = T; i &gt;= 2; --i) {
		siz[fa[a[i]]] += siz[a[i]];
	}
	dp[1] = 0;
	R int u, F, v;
	for(i = 1; i &lt;= T; ++i) {
		u = a[i];
		F = fa[u];
		dp[u] = max(dp[u], dp[F] + (long long)siz[u] * (len[u] - len[F]));
		for(F = 0; F &lt; 26; ++F) {
			if((v = ch[u][F]) != 0) {
				dp[v] = max(dp[v], dp[u] + (long long)siz[v] * (len[v] - len[u]));
			}
		}
	}
	printf(&quot;%lld\n&quot;, dp[lst]);
	return 0;
}

</code></pre>
<p>B</p>
<p>是个多项式算法都给您放过去</p>
<p>考场上我神仙的遇上了土豆电池T掉了</p>
<p>一个序列有多种划分方式,但是我们只需满足一种,所以就可以考虑容斥了!</p>
<p>然后对于前中后三段其实是可以考虑各种情况然后状压DP的....</p>
<p>然后考虑dp,dp_{i,j}表示前i个数经过了j个互不相等的数</p>
<p>1/231/321/32</p>
<p>则要经过dp(1,1)-&gt;dp(4,3)-&gt;dp(3,3)-&gt;dp(9,2)</p>
<p>这样子就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mo>&gt;</mo><mo>=</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp(a,a)-&gt;dp(b,k)-&gt;dp(n,&gt;=b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>如果n比较大,中间会有很长一段令人相同的限制,这些都一样就可以快速幂把它优化掉</p>
<p>就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>k</mi><msup><mo>)</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>f</mi><mi>i</mi><mo>−</mo><mi>e</mi><mi>d</mi></mrow><mi>k</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">P(k,k)^{\frac {n-fi-ed} {k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.28389em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.03389em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9584142857142857em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4623857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>枚举fi,ed暴力用之前的dp计算fi和ed的方案数,中间再乘上这个即可qwq,然后记得要容斥就要乘上方案数</p>
<p>因为我们有一个fi就能算出ed了,所以只有本质不同的k个fi作为限制,然后用于容斥qwq</p>
<p>然后我们就可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>∗</mo><mo>(</mo><msup><mi>k</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">2^k*(k^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然后又会发现我们有个第一段a,他要最大,就能转移到的最小的c最优</p>
<p>而且maxa能转移到minb,maxb能转移到minc,b是k<sub>2k或n-k</sub>n</p>
<p>这样每个状态都是O(k)种</p>
<p>然后我们发现他们可以通过一些长度小于k的方案数</p>
<p>从1-&gt;3,3-&gt;k-2再从k-2-&gt;1一直循环就是可以加速的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>k</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>实际状态数很少,压一压状态还可以更少??</p>
<p>对于n&lt;=k的情况我们只需要枚举最大值和最小值然后前i个要求互补相同,后n-i个要求互不相同,i&lt;n时有这样的而i&gt;n的时候我们有(n,k)n!?</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596268289265.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596268283405.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596268271417.png" alt="" loading="lazy"></figure>
<p>其实就是想我们有很多刀,然后通过拓扑dp从小到大一刀一刀的加入</p>
<p>考虑我们每次计入相邻两刀的计算方案,然后在统计答案的时候加入每一段的不同的限制</p>
<p>具体可以分成好几段</p>
<ol>
<li>开头的刀刀之间 + 中途的加速部分的几段</li>
<li>开头到第一刀</li>
<li>最后一套限制到第一块加速开始的一段</li>
<li>最后一套最后一刀和n的一段</li>
</ol>
<p>具体看代码吧,讲的相当清楚了/....\</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXW = 66;
const int P = 998244353;
int T;
int n, k, ans, tot;
int f[MAXW][MAXW][MAXW], fpre[MAXW][MAXW][MAXW];
int dp[MAXW][MAXW][MAXW][MAXW], g[MAXW][MAXW], lst[MAXW];
inline void init() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	memset(f, 0, sizeof(f));
	memset(fpre, 0, sizeof(fpre));
	memset(g, 0, sizeof(g));
	memset(dp, 0, sizeof(dp));
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}


inline void initg() {
	int frm, stp, nw;
	//预处理部分,
	//第二维stp表示i,而nw表示j
	//frm是已知了前面一些数不同的填涂方案
	for(frm = 0; frm &lt;= k; frm++) {
		f[frm][0][frm] = 1;
		for(stp = 0; stp &lt;= k; ++stp) {
			for(nw = 0; nw &lt;= k; ++nw) {
				if(f[frm][stp][nw]) {
					for(int nxt = 1; nxt &lt;= nw; ++nxt)
						add(f[frm][stp + 1][nxt], f[frm][stp][nw]);
					add(f[frm][stp + 1][nw + 1],
						1ll * (k - nw) * f[frm][stp][nw] % P);
					// printf(&quot;frm:%d stp:%d now:%d f:%d\n&quot;, frm, stp, nw, f[frm][stp][nw]);
				}
			}
		}
	}
	for(int i = 0; i &lt;= k; ++i) {
		for(int j = 0; j &lt;= k; ++j) {
			for(int t = k; t &gt;= 0; --t) {
				fpre[i][j][t] = f[i][j][t] + fpre[i][j][t + 1];
				if(fpre[i][j][t] &gt;= P)fpre[i][j][t] -= P;
				//fpre是f的后缀和
				//就是至少t个不相同
			}
		}
	}
	for(int i = 0; i &lt; k; ++i) {
		for(int j = 0; j &lt; k; ++j) {
			if(i &lt; j) {
				//这个是考虑两个中间的刀数
				//中间的限制是j-i
				int num = (n - j &gt;= 0 ? (n - j) / k : 0);
				//然后会被统计num次
				g[i][j] = ksm(f[k][j - i][k], num);
			} else {//i&gt;=j
				//这个是考虑两个之外的限制
				//每k个之间夹得之外的....|----|.....
				//....的部分
				//就是k-(i-j)
				//会被统计num次
				int num = (n - j - k &gt;= 0 ? (n - j - k) / k : 0);
				g[i][j] = ksm(f[k][j + k - i][k], num);
			}
		}
	}
	for(int i = 0; i &lt; k; ++i) {
		//论取模是如何自闭的
		//其实就是(n-i)%k....
		int x = (n - i &gt;= 0 ? n - ((n - i) / k * k + i) : n);
		lst[i] = x;
		// printf(&quot;i=%d lst=%d\n&quot;, i, lst[i]);
	}
}

inline void solve() {
	for(int i = 0; i &lt; k; ++i) {
		add(dp[i][i][lst[i]][lst[i]], 1);
	}
	ll ans = 0;
	for(int i = 0; i &lt; k; ++i) {//第一块中最后一套限制i,i
		for(int fst = 0; fst &lt;= i; ++fst) {//第一块中第一套限制fst,fst
			for(int mx = 0; mx &lt; k; ++mx) {//最后一个数的最后一套限制,n,&gt;=mx!!!
				for(int mn = 0; mn &lt; k; ++mn) {//最后一块中第一套限制,n,&gt;=mn
					if(dp[i][fst][mx][mn]) {
						int nw = dp[i][fst][mx][mn];
						if(i &lt;= n) {
							int coef = 1ll * nw * f[0][i][i] % P * g[i][fst] % P;
							//首先第一步把i的限制加入然后再把第一块之外的限制加入
							if(k + fst &lt;= n)
								coef = 1ll * coef * f[i][fst + k - i][k] % P;
							//如果k+fst&lt;=n,说明我们至少存在中间限制的刀法
							//就是...fst-----i***|*fst+k----i+k.....
							//中间*部分的限制
							if(n - mn &lt;= k)
								coef = 1ll * coef * fpre[n - mn][mn][mx] % P;
							//n-mn步是我们已知的,然后再填mn步使得mx个满足
							else  coef = 1ll * coef * fpre[k][mn][mx] % P;
							//...mn......n解决最后一段,大于k所以安心走
							ans += coef;
							if(ans &gt; P)ans -= P;
						} else
							ans = (ans + 1ll * nw * f[0][n][n]) % P;
						//i&gt;n直接容斥,让他满足这套限制
						for(int nxt = i + 1; nxt &lt; k; ++nxt) {//下一套限制
							add(dp[nxt][fst][max(mx, lst[nxt])][min(mn, lst[nxt])],//这个转移非常能定夺mn,mx一切意义
								1ll * (P - nw) * g[i][nxt] % P//-nw * go i,nxt表示我们新加入了一刀,并计算了中间的贡献
							   );
						}
					}
				}
			}
		}
	}
	printf(&quot;%lld\n&quot;, ans);
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		init();
		initg();
		solve();
	}
	return 0;
}


</code></pre>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/">
              <h3 class="post-title">
                20zr暑期AB班十连测day4
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
