<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>20省选Day4 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1614035802567">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="20省选Day4 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="A. [21省选day4]出题人
有毒啊
就是说我们先神仙问题转换一下
显然我们对于n个点连出n条边使得每条边都满足限制的case,一个点能消掉一个环是相当优秀的case,就是不会更劣
所以考虑偶数,他们一定用n/2n/2n/2自选两次干掉..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1614035802567" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              20省选Day4
            </h2>
            <div class="post-info">
              <span>
                2021-02-09
              </span>
              <span>
                22 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="a-21省选day4出题人">A. [21省选day4]出题人</h1>
<p>有毒啊</p>
<p>就是说我们先神仙问题转换一下</p>
<p>显然我们对于n个点连出n条边使得每条边都满足限制的case,一个点能消掉一个环是相当优秀的case,就是不会更劣</p>
<p>所以考虑偶数,他们一定用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>自选两次干掉</p>
<p>剩下的就是奇数的情况,考虑我们想制作菜肴一样给他们连出一个环.....</p>
<p>等等?怎么感觉要连出n个环啊??</p>
<p>等等?好像我们有一个万金油:0</p>
<p>有了0,其他所有的东西都可以和0成环解决了!</p>
<p>同时?你会发现如果我们b能满足一个性质加起来为a,我们钦定其中一个是0也不是问题啊</p>
<p>所以考虑再转换假如环长为k</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_i=b_i+b_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_{k+1}=b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>那么你会发现无论如何都有</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mo>∗</mo><mo>∑</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum a_i=2*\sum b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后坏了,你会发现这个东西好像很不能做啊,但是说接着发现</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi mathvariant="normal">∣</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">2|k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>!!!!</p>
<p>这个信息告诉我们:我们一定存在一种排列a的方案,使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>3</mn></msub><mo>+</mo><msub><mi>a</mi><mn>5</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mn>4</mn></msub><mo>+</mo><msub><mi>a</mi><mn>6</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">a_1+a_3+a_5...=a_2+a_4+a_6...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>因为说你会发现左右两边拆开后都等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>!</p>
<p>也就差不多找到方法了:如果我们能找到大小和权值和相同的两个集合A,B,将他们拿出来错开,钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b_1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,然后根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_1=b_1+b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,迭代构造即可</p>
<p>然后剩下的,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>枚举可行的组合即可</p>
<p>解决这个找集合可以折半搜索,就是先整个划分开,然后每个元素要么分入1要么分入2要么不分入,对于一个最后的状态,记录<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mi mathvariant="normal">∣</mi><mi>B</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|A|-|B|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span></span></span></span>以及整个权值和即可qwq</p>
<p>然后右边一样匹配即可</p>
<p>一开始我这个sb写成了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>3</mn><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>∗</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(3^{n/2}*n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<p>但实际上我们可以在过程中记录信息吐了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=123;
const int P=19260817;
const ll B=123450;
const int MAXV=P;

int n,m,mx,qcnt;
int home[P],nxt[MAXV];
ll w[MAXV],flw[MAXV],to[MAXV];
int ccnt,cnt1,cnt2,flg;
ll a[MAXN],b[MAXN],q1[MAXN],q2[MAXN];

inline void ct(int u,ll x,ll y,ll z) {
	ccnt++;
	nxt[ccnt]=home[u];
	to[ccnt]=x;
	w[ccnt]=y;
	flw[ccnt]=z;
	home[u]=ccnt;
}

inline void add(ll Sc,ll cc,ll rc) {
	int x=(Sc*B%P+cc+P)%P;
//	if(qcnt&gt;MAXV) {
//		printf(&quot;%d\n&quot;,qcnt);
//		exit(0);
//	}
//	assert(rc&gt;=0);
	for(int i=home[x]; i; i=nxt[i]) {
		ll v=to[i], g=w[i];
//		qcnt++;
		if(v==Sc &amp;&amp; g==cc) {
			return ;//²»ÐèÒªÔÙ²åÈë
		}
	}
//	qcnt++;
	ct(x,Sc,cc,rc);
	return;
}

inline void trs(ll S1,ll S2) {
	m=0;
//	printf(&quot;%d %d\n&quot;,S1,S2);
	for(int i=1; i&lt;=n; ++i) {
		if(!(a[i]%2==0))b[++m]=a[i];
	}
	mx=m/2;
	for(int i=0; i&lt;mx; ++i) {
		if((S1 &gt;&gt; (i&lt;&lt;1) &amp;3) ==1)q1[++cnt1]=b[i+1];
		if((S1 &gt;&gt; (i&lt;&lt;1) &amp;3) ==2)q2[++cnt2]=b[i+1];
	}
	for(int i=1; i&lt;=(m+1)/2; ++i) {
		swap(b[i],b[i+mx]);
//		printf(&quot;%d &quot;,b[i]);
	}
	mx=(m+1)/2;
	for(int i=0; i&lt;mx; ++i) {
		if((S2 &gt;&gt; (i&lt;&lt;1) &amp;3) ==1) {
			q1[++cnt1]=b[i+1];
//			printf(&quot;%d %d\n&quot;,i,b[i+1]);
		}
		if((S2 &gt;&gt; (i&lt;&lt;1) &amp;3) ==2) {
			q2[++cnt2]=b[i+1];
//			printf(&quot;%d %d\n&quot;,i,b[i+1]);
		}
	}
	return ;
}

inline int qry(ll Sc,ll cc,ll rc) {
	int x=(Sc*B%P+cc+P)%P;
	for(int i=home[x]; i; i=nxt[i]) {
		ll v=to[i],g=w[i];
//		qcnt++;
		if(v==Sc &amp;&amp; g==cc) {
			if(flw[i]==0 &amp;&amp; rc==0)continue;//¿Õ¼¯²éÕÒµ½ÁË¿Õ¼¯£¡
//			printf(&quot;%d %d %d %d\n&quot;,v,g,Sc,cc);
			trs(flw[i],rc);
			return 1;
		}
	}
	return 0;
}

inline void dfs1(int u,ll S,ll sum,ll cnt) {
	if(u==mx) {//½áÊø£¬Ñ¹Èëhash
//		ll cnt1=0,cnt2=0,sum1=0,sum2=0;
//		for(int i=0; i&lt;mx; ++i) {
//			if(((S&gt;&gt;(i&lt;&lt;1)) &amp;3)==1) {
//				cnt1++;
//				sum1+=b[i+1];
//			}
//			if(((S&gt;&gt;(i&lt;&lt;1)) &amp;3)==2) {
//				cnt2++;
//				sum2+=b[i+1];
//			}
//		}
//		printf(&quot;%d %d %d %d %d!!\n&quot;,S,sum1,sum2,cnt1,cnt2);
		//¼ÇÂ¼µÚÒ»¸ö¼¯ºÏ-µÚ¶þ¸ö¼¯ºÏµÄÐÅÏ¢qwq
		add(sum,cnt,S);//Ë«¹Ø¼ü×Ö
		return ;
	}
	dfs1(u+1,S,sum,cnt);
	dfs1(u+1,S^(1ll&lt;&lt;(u&lt;&lt;1)),sum+b[u+1],cnt+1);
	dfs1(u+1,S^(2ll&lt;&lt;(u&lt;&lt;1)),sum-b[u+1],cnt-1);
	return;
}


inline void dfs2(int u,ll S,ll sum,ll cnt) {
	if(flg)return;

	if(u==mx) {
//		ll cnt1=0,cnt2=0,sum1=0,sum2=0;
//		for(int i=0; i&lt;mx; ++i) {
//			if(((S&gt;&gt;(i&lt;&lt;1)) &amp; 3)==1) {
//				cnt1++;
//				sum1+=b[i+1];
//			}
//			if(((S&gt;&gt;(i&lt;&lt;1)) &amp; 3)==2) {
//				cnt2++;
//				sum2+=b[i+1];
//			}
//		}
//		printf(&quot;%d %d %d %d %d ??\n&quot;,S,cnt1,cnt2,sum1,sum2);
		if(qry(sum,cnt,S)) {
			flg=1;
			return;
		}
		return ;
	}
	dfs2(u+1,S,sum,cnt);
	dfs2(u+1,S^(1ll&lt;&lt;(u&lt;&lt;1)),sum-b[u+1],cnt-1);
	dfs2(u+1,S^(2ll&lt;&lt;(u&lt;&lt;1)),sum+b[u+1],cnt+1);
	return;
}

inline void solve1() {
	puts(&quot;Yes&quot;);
	int rc=0;
	for(int i=1; i&lt;=n; ++i) {
		if(a[i]%2==0) {
			rc=i;
			b[i]=a[i]/2;
			break;
		}
	}
	for(int i=1; i&lt;=n; ++i) {
		printf(&quot;%lld &quot;,a[i]-b[rc]);
	}
	puts(&quot;&quot;);
	for(int i=1; i&lt;=n; ++i)printf(&quot;%d %d\n&quot;,i,rc);
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%lld&quot;,&amp;a[i]);
	}
	for(int i=1; i&lt;=n; ++i) {
		if(!(a[i]%2==0))b[++m]=a[i];
//		printf(&quot;%d ?\n&quot;,b[i]);
	}
	if(m!=n)return solve1(),0;
	mx=m/2;
	dfs1(0,0,0,0);//¿¼ÂÇÁËÇ°i¸öÎïÆ·£¬È»ºóµ±Ç°ÎïÆ·Ñ¡ÔñµÄ×´Ì¬ÊÇS qaq
//	if(n==30) {
//		puts(&quot;qwq&quot;);
//		return 0;
//	}
	for(int i=1; i&lt;=(m+1)/2; ++i) {
		swap(b[i],b[i+mx]);
//		printf(&quot;%d\n&quot;,b[i]);
	}
	mx=(m+1)/2;
	flg=0;
	dfs2(0,0,0,0);//ÕÒµ½ÁËÂð£¿
//	printf(&quot;%d?\n&quot;,qcnt);
	if(!flg)return puts(&quot;No&quot;),0;
	//¹¹ÔìÕâ¸öbÊý×é
	b[1]=0;
	assert(cnt1==cnt2);
//	printf(&quot;%d %d ??\n&quot;,cnt1,cnt2);
	for(int i=1; i&lt;cnt1+cnt2; ++i) {
//		printf(&quot;%d %d %d %d\n&quot;,q1[(i+1)/2],q2[(i)/2],b[i],i);
		if(i&amp;1) {
			b[i+1]=q1[(i+1)/2]-b[i];
		} else {
			b[i+1]=q2[i/2]-b[i];
		}
	}
	for(int j=1; j&lt;=n; ++j) {
		bool flg=1;
		for(int i=1; i&lt;=cnt1; ++i) {
			if((a[j]==q1[i]) || (a[j]==q2[i])) {
				flg=0;
				break;
			}
		}
//		printf(&quot;%d %d %d\n&quot;,j,a[j],flg);
		if(flg) {
			cnt2++;
//			printf(&quot;%d %d\n&quot;,cnt1,cnt2);
			b[cnt1+cnt2]=a[j];
		}
	}
//	for(int i=1; i&lt;=n; ++i)printf(&quot;%d &quot;,a[i]);
	puts(&quot;Yes&quot;);
	for(int i=1; i&lt;=n; ++i)printf(&quot;%lld &quot;,b[i]);
	puts(&quot;&quot;);
	for(int i=1; i&lt;=n; ++i) {
		bool flg=1;
		for(int j=1; j&lt;=n; ++j) {
			for(int k=1; k&lt;=n; ++k) {
				if(b[j]+b[k]==a[i]) {
					printf(&quot;%d %d&quot;,j,k);
					flg=0;
					break;
				}
			}
			if(!flg)break;
		}
		puts(&quot;&quot;);
	}
	return 0;
}
/*
30
1 -21 33 -45 57 -69 79 -89 99
111 111 121 131 141 151 161 171 181 191
2019 2117 2215 2313 2411 2511 2611 2711 2811 2911 3011
*/
</code></pre>
<h1 id="b-21省选day4彩色挂饰">B. [21省选day4]彩色挂饰</h1>
<p>一开始没看见所有挂饰无色...qaq</p>
<p>考虑树形dp推广开,就是建立圆方树</p>
<p>然后对于一个方点,他的父亲一定是一个圆点,而且是割点</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{u,c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>就表示圆点u的颜色为c或者方点u的父亲颜色为c的时候的最小连通块数是什么</p>
<p>然后转移对于圆点你会发现他的儿子都是方点,那么直接</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>+</mo><msub><mo>∑</mo><mi>v</mi></msub><mo>(</mo><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{u,c}=1+\sum_{v} (f_{v,c}-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>因为我们会减少一个点的代价啊qwq</p>
<p>然后对于方点的转移QAQ我们要对于这个点双状压了,首先设他代表的点双是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>v</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">v_0...v_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是他在圆方树上的父亲</p>
<p>那么你会发现我们可以预处理每个方点的他的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>那些是相互联通的,具体的,枚举一个集合S</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">S&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>,压位表示出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">A_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点x的相邻的在一个点双内的点是哪些,然后转移直接枚举最小编号的那个除掉再&amp;这个点的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">A_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>即可qwq</p>
<p>$C(S) = ⋁ x∈S (C(S / {x}) ∧ (S ∩ Ax ≠ ∅)) $</p>
<p>于是能够得到一个连通块染一种颜色的最小代价G,枚举一个颜色c,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>c</mi></msub><mo>(</mo><mn>1</mn><mo>+</mo><mo>∑</mo><mi>i</mi><mo>∈</mo><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">min_c(1+\sum i\in (f_{i,c}-1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>然后对于不连通的S,显然就是正无穷啊</p>
<p>最后考虑dp出整个的方案数,用子集卷积<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>表示一个S连通块染的最小代价</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mi>G</mi><mo>(</mo><mi>T</mi><mo>)</mo><mo>+</mo><mi>h</mi><mo>(</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">h(S)=\min G(T)+h(S/T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>g</mi><mrow><mi>T</mi><mo separator="true">,</mo><mi>c</mi></mrow></msub><mo>+</mo><mi>H</mi><mo>(</mo><mi>m</mi><mi>S</mi><mi mathvariant="normal">/</mi><mi>T</mi><mo>)</mo><mo separator="true">,</mo><msub><mi>v</mi><mn>0</mn></msub><mo>∈</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{u,c}=min(g_{T,c}+H(mS/T),v_0 \in T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p>g数组是我们这个连通块染上颜色c的代价,显然,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">mS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>是全集</p>
<h1 id="dp不清空辅助数组爆零两行泪">DP不清空辅助数组爆零两行泪</h1>
<p>然后小心我们如果是菊花图,他的方点的父亲每次枚举一遍复杂度是不对的</p>
<p>所以保证每个点只在父亲处被枚举一次即可</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define pb push_back
#define int long long
using namespace std;
#define lowbit(x) (x&amp;(-x))
const int MAXN=1e6+2e5+7;
const int inf=1e9+7;
const int MAXK=22;
int n,m,mK,mS,a[MAXN],ccnt;
int nxt[MAXN],to[MAXN],home[MAXN];

inline  void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

vector&lt;int&gt; G[MAXN];
int dfn[MAXN],low[MAXN],dep,st[MAXN],tp,cnt;

inline void tarjan(int u) {
	low[u]=dfn[u]=++dep;
	st[++tp]=u;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
			if(low[v]==dfn[u]) {
				++cnt;
				for(int x=0; x!=v; --tp) {
					x=st[tp];
					G[cnt].pb(x);
					G[x].pb(cnt);
				}
				G[u].pb(cnt);
				G[cnt].pb(u);
			}
		} else low[u]=min(low[u],dfn[v]);
	}
	return;
}
const int MAXS=4505;
int f[MAXN][MAXK],g[MAXS][MAXK],H[MAXN],Gh[MAXN],A[MAXN],avi[MAXN];
int tot,vis[MAXN],vis2[MAXN],q[MAXN],p,rc;

inline void init(int x) {
	tot=0;
	for(int v : G[x]) {
		vis[v]=tot;
		vis2[tot]=v;
		++tot;
	}
	for(int v : G[x]) {
		if(v==rc)continue;
		for(int i=home[v]; i; i=nxt[i]) {
			int q=to[i];
			if(~vis[q]) {
				A[v]|=(1&lt;&lt;vis[q]);
				A[q]|=(1&lt;&lt;vis[v]);
			}
		}
	}//init lin yu
	return ;
}

inline void getG() {
	int ML=(1&lt;&lt;tot)-1;
	for(int S=0; S&lt;=ML; ++S) {
		p=0;
		if(S-lowbit(S)==0)avi[S]=1;
		else {
			avi[S]=0;
			for(int i=0; i&lt;tot; ++i)if(S&gt;&gt;i&amp;1)avi[S]|=(avi[S^(1&lt;&lt;i)]&amp;((S&amp;A[vis2[i]])!=0));
		}
		for(int i=0; i&lt;tot; ++i)if(S&gt;&gt;i&amp;1)q[++p]=vis2[i];
		Gh[S]=inf;
		if(avi[S]) {
			for(int i=1; i&lt;=mK; ++i) {
				g[S][i]=1;
				for(int j=1; j&lt;=p; ++j) {
					g[S][i]+=f[q[j]][i]-1;
				}
				Gh[S]=min(Gh[S],g[S][i]);
			}
		} else for(int i=1; i&lt;=mK; ++i)g[S][i]=inf;
	}
	return ;
}

inline void out(int S) {
	for(int i=0; i&lt;tot; ++i) {
		if(S&gt;&gt;i&amp;1)printf(&quot;%lld &quot;,vis2[i]);
	}
	puts(&quot;&quot;);
}

inline void getH() {
	H[0]=0;
	int ML=(1&lt;&lt;tot)-1;
	for(int S=1; S&lt;=ML; ++S) {
		H[S]=inf;
		for(int T=S; T!=-1; T=(T-1)&amp;S) {
			H[S]=min(H[S],H[T]+Gh[S^T]);
			if(T==0)break;
		}
	}
	return ;
}

inline void getf(int u) {
	int ML=(1&lt;&lt;tot)-1;
	for(int i=1; i&lt;=mK; ++i) {
		f[u][i]=inf;
		for(int S=0; S&lt;=ML; ++S)if(S&gt;&gt;vis[rc]&amp;1)f[u][i]=min(H[ML^S]+g[S][i],f[u][i]);
	}
	return;
}

inline void getclear(int u) {
	int ML=(1&lt;&lt;tot)-1;
	for(int S=0; S&lt;=ML; ++S) {
		H[S]=Gh[S]=avi[S]=vis2[S]=0;
		for(int k=1; k&lt;=mK; ++k)
			g[S][k]=0;
	}
	for(auto v : G[u]) {
		vis[v]=-1;
		A[v]=0;//我他妈的
	}
}

inline void dfs(int u,int F) {
	if(u&lt;=n) {
		for(int k=1; k&lt;=mK; ++k) {
			if(k!=a[u] &amp;&amp; a[u])f[u][k]=inf;
			else f[u][k]=1;
		}
		for(auto v : G[u]) {
			if(v==F)continue;
			dfs(v,u);
		}
		for(auto v : G[u]) {
			if(v==F)continue;
			for(int k=1; k&lt;=mK; ++k)
				f[u][k]+=f[v][k]-1;
		}
	} else {
		for(auto v : G[u]) {
			if(v==F)continue;
			dfs(v,u);
		}
		rc=F;
		init(u);//init v message
		getG();
		getH();
		getf(u);
		getclear(u);
	}
	return;
}

signed main() {
	scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;mK,&amp;mS);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%lld&quot;,&amp;a[i]);
	}
	cnt=n;
	for(int i=1,x,y; i&lt;=m; ++i) {
		scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);
		ct(x,y);
		ct(y,x);
	}
	for(int i=1; i&lt;=n; ++i)if(!dfn[i])tarjan(i);
	memset(vis,-1,sizeof(vis));
	dfs(1,0);
	int ans=inf;
	for(int i=1; i&lt;=mK; ++i)ans=min(ans,f[1][i]);
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}
</code></pre>
<p>没压行前又是4kb吐了</p>
<h1 id="c-21省选day4逆转函数">C. [21省选day4]逆转函数</h1>
<p>首先对于暴力我们可以枚举回文中心然后枚举回文半径这样子</p>
<p>正解怎么做?</p>
<p>观察m=2的部分分我们可以知道这个和每个位置的回文中心最长回文半径有关系!</p>
<p>考虑manacher qwq</p>
<p>首先将问题转换的具有回文串性质</p>
<p>首先合法串的定义是没有发生冲突的串</p>
<p>发现我们可以知道,如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>要成为一个合法串的话,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l+1,r-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>至少要满足是一个合法串吧qwq</p>
<p>然后对于l和r位置,至少l对应的位置是r,那么l之后最近的一个位置(假设为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">nl</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>),他对应的字符也应该是r</p>
<p>然后有数学归纳可知这样一直是成立的</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mo>&gt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">nl&gt;r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>,此时不难发现l是新出现的字符,不需要管</p>
<p>知道这个性质我们同样可以计算对于一个串,有多少位置是已经固定映射多少位置没有</p>
<p>当加入的nl,nr为新字符(前驱后继在区间外的话)就让这个值减少</p>
<p>然后同样的,我们也能很轻易的在扩展字符串的时候维护整个回文串的答案了!</p>
<p>再看看manacher套上去</p>
<p>对于md为最长回文中心的情况,如果i&gt;mx,此时我们是暴力扩展这个i的回文串,显然可以得到那个答案</p>
<p>然后如果i&lt;mx,而且可以直接复制i的对应点j的半径(就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mi>r</mi><mi>a</mi><msub><mi>d</mi><mi>j</mi></msub><mo>&gt;</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">j-rad_j&gt;=l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>)就直接复制</p>
<p>否则,你会发现我们可以暴力缩短这个j的回文半径来得到新的串的答案qwq</p>
<p>此时我们要保证复杂度正确啊QAQ</p>
<p>你会发现如果我们每次做不改变回文中心的话,同时无法向后方扩展的话,下一次又双叒叕要跳一次就TLE了QAQ</p>
<p>那么每次我们让回文中心向后移动,你就会发现即使我们花掉了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mx-md</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span></span></span></span>的代价,但是我们又让这个距离减少了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mx-md)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>,所以均摊向右还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>次qwq</p>
<p>先咕着</p>
<pre><code class="language-cpp">//By dawn light
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 7e5 + 7;
const int P = 998244353;
int n, m, a[MAXN], N, b[MAXN], nv[MAXN];
int pre[MAXN], suf[MAXN], tmpv[MAXN], rad[MAXN];
ll f[MAXN];
inline void init() {
	f[0] = 1;
	for(int i = 1; i &lt;= m; ++i)f[i] = f[i - 1] * m % P;
	for(int i = 1; i &lt;= n; ++i)b[i * 2 - 1] = a[i];
	N = 2 * n - 1;
	for(int i = 1; i &lt;= N; ++i) {
		if(!(i &amp; 1)) {
			b[i] = 1234567;
			pre[i] = -1;
			suf[i] = N + 1;
		}
	}
	for(int i = 1; i &lt;= N; i += 2) {
		pre[i] = tmpv[b[i]];
		tmpv[b[i]] = i;
	}
	for(int i = 1; i &lt;= n; ++i)tmpv[a[i]] = N + 1;
	for(int i = N; i &gt;= 1; i -= 2) {
		suf[i] = tmpv[b[i]];
		tmpv[b[i]] = i;
	}
	return ;
}

ll ans, sum[MAXN];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	init();

	for(int i = 1, mx = 0, md = -1; i &lt;= N; ++i) {
		int l, r;
		if(i &lt; mx) {
			int dyi = 2 * md - i;
			l = dyi - rad[dyi];
			r = dyi + rad[dyi];
			sum[i] = sum[dyi];
			nv[i] = nv[dyi];
			while(r - l + 1 &gt; 2 * (mx - i) + 1) {//你这个长度不太行啊
				if(b[l] != 1234567 &amp;&amp; b[r] != 1234567) {
					sum[i] = (sum[i] - f[m - nv[i]] + P) % P;
					nv[i] -= (suf[l] &gt; r);
					nv[i] -= (pre[r] &lt;= l); //记右不记左
				}
				l++;
				r--;
			}
			int qwq = (r - l + 1) / 2;
			r = i + qwq;
			l = i - qwq;
		} else {//i&gt;mx
			l = i;
			r = i;
			if(i &amp; 1) {
				sum[i] = f[m - 1];
				nv[i] = 1;
			}//如果是偶数位置,根本就不算贡献
		}
		while(l &gt; 1 &amp;&amp; r &lt; N &amp;&amp; (suf[l - 1] &gt; r + 1 || b[r + 1] == b[l + r - suf[l - 1]]) &amp;&amp; (pre[r + 1] &lt; l - 1 || b[l - 1] == b[l + r - pre[r + 1]])) {
			l--;
			r++;
			if(b[l] != 1234567 &amp;&amp; b[r] != 1234567) {
				nv[i] += (suf[l] &gt; r);
				nv[i] += (pre[r] &lt;= l);
				sum[i] = (sum[i] + f[m - nv[i]]) % P;
			}
		}
		sum[i] = (sum[i] % P + P) % P;
		ans = (ans + sum[i]) % P;
		rad[i] = r - i;
		if(r &gt;= mx) {
			mx = r;
			md = i;
		}
	}
	ans = (ans % P + P) % P;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#a-21%E7%9C%81%E9%80%89day4%E5%87%BA%E9%A2%98%E4%BA%BA">A. [21省选day4]出题人</a></li>
<li><a href="#b-21%E7%9C%81%E9%80%89day4%E5%BD%A9%E8%89%B2%E6%8C%82%E9%A5%B0">B. [21省选day4]彩色挂饰</a></li>
<li><a href="#dp%E4%B8%8D%E6%B8%85%E7%A9%BA%E8%BE%85%E5%8A%A9%E6%95%B0%E7%BB%84%E7%88%86%E9%9B%B6%E4%B8%A4%E8%A1%8C%E6%B3%AA">DP不清空辅助数组爆零两行泪</a></li>
<li><a href="#c-21%E7%9C%81%E9%80%89day4%E9%80%86%E8%BD%AC%E5%87%BD%E6%95%B0">C. [21省选day4]逆转函数</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/21zr-sheng-xuan-di-yi-lun-ji-xun-day4/">
              <h3 class="post-title">
                21zr省选第一轮集训day4
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
