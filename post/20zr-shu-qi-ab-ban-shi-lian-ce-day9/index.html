<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>20zr暑期AB班十连测day9 | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1610375931149">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="20zr暑期AB班十连测day9 | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="

A
zhq切掉了
u和v xor起来最大那么如果不他在两条链上答案就就是u和vxor起来的答案
那么相当于只有两条链啊,对于包括u和v的两条链,那么我们就可以考虑这两个链不加入,然后其他的点都加进去,然后随着链下降我们会加入一些新点,这..." />
    <meta name="keywords" content="矩阵的秩,线性代数,Trie,构造" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1610375931149" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              20zr暑期AB班十连测day9
            </h2>
            <div class="post-info">
              <span>
                2020-08-05
              </span>
              <span>
                11 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/2cTavMwwK/" class="post-tag">
                  # 矩阵的秩
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/X6S24_qtkk/" class="post-tag">
                  # 线性代数
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/Pc0nIo3FuH/" class="post-tag">
                  # Trie
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/nuL1JOWcod/" class="post-tag">
                  # 构造
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcS6*y0aCtoxMGhYccn7Mqiba.6XRkutTBVX6RsUJHnC9ozi1FedwR6qrtCKT.MMSxdWdngwGfaM2QciplFhqhH8!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <figure data-type="image" tabindex="1"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm0SOkVW2obInHocXot*aVjuHsZ4*isoWzDeZ2xEnbp4kt4c2.mlEj*WHKJ79Hmlrdc!/r" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1I2UcDYqmlQb0.SVBuJnWFJUtVNhaMuUAHZISyj70ItxcinVPqFNQZjoimuOzNwHk!/r" alt="" loading="lazy"></figure>
<p>A</p>
<p>zhq切掉了</p>
<p>u和v xor起来最大那么如果不他在两条链上答案就就是u和vxor起来的答案</p>
<p>那么相当于只有两条链啊,对于包括u和v的两条链,那么我们就可以考虑这两个链不加入,然后其他的点都加进去,然后随着链下降我们会加入一些新点,这都问题不大</p>
<p>O(nw)极其好写</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#define ll long long
using namespace std;
const int MAXM = 1e6 + 7;
const int MAXN = 5e5 + 7;
map&lt;ll, int&gt;  mp;
int n, fa[MAXN], ccnt, ansu, ansv;
int home[MAXN], nxt[MAXM], to[MAXM];
ll a[MAXN], ans[MAXN], Nans, tmpans;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

const int MAXT = 1e7 + 7;
struct rec {
	int ch[MAXT][2];
	int siz[MAXT];
	int T, root;
	inline void ins(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			if(!ch[u][t])ch[u][t] = ++T;
			siz[u]++;
			u = ch[u][t];
		}
		siz[u]++;
		return ;
	}
	inline void del(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			siz[u]--;
			u = ch[u][t];
		}
		siz[u]--;
		return;
	}
	inline ll query(ll V) {
		ll qwq = 0;
		int u = root;
		for(ll i = 60; i &gt;= 0; --i) {
			int t = V &gt;&gt; i &amp; 1;
			if(!ch[u][t ^ 1])u = ch[u][t];
			else if(siz[ch[u][t ^ 1]] &gt;= 1)
				u = ch[u][t ^ 1], qwq |= (1ll &lt;&lt; i);
			else u = ch[u][t];
		}
		return qwq;
	}
} T2;

inline void init() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ll tmp = T2.query(a[i]);
		T2.ins(a[i]);
		if(tmp &gt; Nans) {
			ansu = i;
			ansv = mp[tmp ^ a[i]];
			Nans = tmp;
		}
	}
	// printf(&quot;%d %d %d?\n&quot;, Nans, ansu, ansv);
	return ;
}

inline void add(int u, int F) {
	tmpans = max(T2.query(a[u]), tmpans);
	T2.ins(a[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		add(v, u);
	}
}

int tp, tk[MAXN];
inline void solve(int x) {
	memset(T2.ch, 0, sizeof(T2.ch));
	T2.T = 1;
	T2.root = 1;
	memset(T2.siz, 0, sizeof(T2.siz));
	tp = 0;
	while(x != 0) {
		tk[++tp] = x;
		x = fa[x];
	}
	tmpans = 0;
	for(int i = tp; i &gt;= 1; --i) {
		int u = tk[i];
		// printf(&quot;!%d \n&quot;, u);
		ans[u] = tmpans;
		for(int k = home[u]; k; k = nxt[k]) {
			int v = to[k];
			if(v == tk[i - 1] || v == fa[u])continue;
			// printf(&quot;%d?\n&quot;, v);
			add(v, u);
			//插入顺便更新答案qwq
		}
		tmpans = max(tmpans, T2.query(a[u]));
		T2.ins(a[u]);
	}
	return ;
}

inline void solve2() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ans[i] = Nans;
		T2.ins(a[i]);
		Nans = max(Nans, T2.query(a[i]));
	}
	for(int i = 1; i &lt;= n; ++i)
		printf(&quot;%lld\n&quot;, ans[i]);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;fa[i]);
		if(fa[i] != i - 1)flg = 0;
		ct(i, fa[i]);
		ct(fa[i], i);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		mp[a[i]] = i;
	}
	if(flg) {
		solve2();
		return 0;
	}
	memset(ans, -1, sizeof(ans));
	init();//get u,v
	solve(ansu);
	// puts(&quot;--------&quot;);
	solve(ansv);
	for(int i = 1; i &lt;= n; ++i)
		if(ans[i] != -1)printf(&quot;%lld\n&quot;, ans[i]);
		else printf(&quot;%lld\n&quot;, Nans);
	return 0;
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1nlwmcC*RLBJETPoIOfL2XIWbfFg2sJ90eAUvTHvz1LHwQiDUpVNklFj5D6c3f6Uc!/r" alt="" loading="lazy"></figure>
<p>B</p>
<p>构造</p>
<p>角上X&lt;=4</p>
<p>边上加角上我们可以最多的能放就放放出答案</p>
<p>X+Y&lt;=4+R-y/2</p>
<p>就是小于等于2* R/2 +2* C/2 +4</p>
<p>点数小于等于边数-1</p>
<p>总边数减去黑格删去的边数角落边界和内部黑格删去的不同</p>
<p>x+2Y+3Z&lt;=(R-1)(C-1)</p>
<p>3(X+Y+Z)&lt;=2R/2+2C/2+4</p>
<p>当然这个上界可能取不到</p>
<p>n=3k 上界是n^2/3</p>
<p>n=6k+1,6k+5 n^2+2/3</p>
<p>n=6k+2,6k+4 n^2+1/3</p>
<p>如果9要取到等号边界要放满5个格子...</p>
<p>然后根据连通性我们边界上都要是</p>
<p>然后偶数就可以...由题解构造...</p>
<p>先定下中间的部分,再一步步扩张,是构造的基本思路</p>
<p>间行种植可以帮助我们解决扩张</p>
<p>而中间的部分...只能自己慢慢试了....</p>
<p>n=6k</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596635791017.png" alt="" loading="lazy"></figure>
<p>n=6k+1</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1596635812577.png" alt="" loading="lazy"></figure>
<p>n=6k+2</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1596635825763.png" alt="" loading="lazy"></figure>
<p>n=6k+3</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1596635841225.png" alt="" loading="lazy"></figure>
<p>n=6k+4</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1596635856427.png" alt="" loading="lazy"></figure>
<p>n=6k+5</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1596635865367.png" alt="" loading="lazy"></figure>
<p>当然最简单的6k也可以使用</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1596635881086.jpg" alt="" loading="lazy"></figure>
<p>其实这个启发我们网格构造题可以考虑从中间起手扩展</p>
<p>但是中间的起手一定要花大点的...两倍差不多</p>
<p>C</p>
<p>考虑把所有d压成一个d维向量S记在每个点上....</p>
<p>然后对于一个向量,他的出边就是随机一个权值然后*该点向量然后再</p>
<p>对于一个点,他的最小割就是所有入边形成的线性空间的秩...就是基底</p>
<p>那会发现最小割大小不超过3,则构成这个点向量的秩数就不超过3...</p>
<p>求秩就是求线性基的大小,所有的入边构成一个线性基,然后考虑用这个线性基去求这个向量的秩数...</p>
<p>然后我们不要每次拿所有的入边去做,每次削成一个线性基,然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=\sum{w_{i,j}*e_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>就解决了</p>
<p>首先秩小于等于最小割啊....另外我们由于随机所以大概率对吗</p>
<p>其实就是入边是一些不同的线性组合构成的就大概率能保证这个点也是对的...</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
const int MAXN = 2e5 + 7;
const int MAXM = 1e6 + 7;
const int P = 998244353;
int n, K, m;
int vis[MAXN], home[MAXN], nxt[MAXM], to[MAXM], first[MAXN], ccnt;
int c[MAXN], que[MAXM], d[MAXN], ans[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void ct2(int x, int y) {
	ccnt++;
	nxt[ccnt] = first[x];
	first[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	vis[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		dfs(v);
	}
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

struct rec {
	int a[12];
	inline rec &amp;operator+=(const rec &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (a[i] + x.a[i]) % P;
		}
		return *this;
	}
	inline rec operator+(const rec &amp;x) const {
		rec c = *this;
		c += x;
		return c;
	}
	inline rec &amp;operator*=(const ll &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (1ll * x * a[i]) % P;
		}
		return *this;
	}
	inline rec operator *(const int &amp;x) const {
		rec c = *this;
		c *= x;
		return c;
	}
} b[MAXN];

struct _list {
	int n;
	vector&lt;rec&gt; V;
	inline int gs() {
		int n = V.size();
		for(int i = 0; i &lt; n; ++i)b[i] = V[i];
		//拿b消元才行
		for(int i = n; i &lt; max(n, K); ++i) {
			for(int j = 0; j &lt; K; ++j) {
				b[i].a[j] = 0;//init
			}
		}
		n = max(n, K);
		//个数和列数取最大
		V.clear();
		for(int i = 0; i &lt; K; ++i) {
			c[i] = 0;
		}
		for(int i = 0; i &lt; K; ++i) {
			if(!b[i].a[i]) {
				//如果这个对角线是空的...
				for(int j = 0; j &lt; n; ++j) {
					if(!c[j] &amp;&amp; b[j].a[i]) {
						swap(b[i], b[j]);
						//交换两行
						//就是我们之后的的有一个没有被动过的这个位置有数
						break;
					}
				}
			}
			if(!b[i].a[i])continue;
			c[i] = 1;
			V.push_back(b[i]);
			//加入这一行
			//说明这一行有东西啊
			int t = P - ksm(b[i].a[i], P - 2);
			//求下逆
			for(int j = 0; j &lt; n; ++j) {
				if(j != i &amp;&amp; b[j].a[i]) {
					//高斯消元
					int c = 1ll * t * b[j].a[i] % P;
					//乘上这个再加就可以使他变为0
					b[j] = b[j] + b[i] * c;
					//一行加一列
				}
			}
		}
		return V.size();
	}
} a[MAXN];

inline int mrand() {
	return (rand() &lt;&lt; 16)^rand() + rand();
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1, u, v; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct2(v, u);
	}
	dfs(1);
	// puts(&quot;qwq&quot;);
	for(int u = 1; u &lt;= n; ++u) {
		for(int i = first[u]; i; i = nxt[i]) {
			int v = to[i];
			if(vis[v])
				d[u]++;
		}
	}


	// for(int i = 1; i &lt;= n; ++i)
	// 	printf(&quot;%d\n&quot;, d[i]);
	srand(114514);
	for(int i = home[1]; i; i = nxt[i])++K;
	// b[1].a[1] = 1;
	// b[1] *= 2;
	// b[1] += b[1];
	// printf(&quot;%d\n&quot;, b[1].a[1]);
	// printf(&quot;%d\n&quot;, K);
	int N = 0, head = 1, tail = 1;
	que[tail] = 1;
	while(head &lt;= tail) {
		int u = que[head];
		// printf(&quot;%d*&amp;\n&quot;, u);
		++head;
		if(u != 1)
			ans[u] = a[u].gs();
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			rec t;
			for(int k = 0; k &lt; K; ++k)
				t.a[k] = 0;
			if(u == 1)
				t.a[N++] = 1;//初始基底
			else {
				for(int i = 0; i &lt; a[u].V.size(); ++i) {
					t = t + a[u].V[i] * (mrand() % P);
				}
			}
			a[v].V.push_back(t);
			d[v]--;
			if(!d[v])que[++tail] = v;
			//拓扑
		}
	}
	for(int i = 2; i &lt;= n; ++i)
		printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}

</code></pre>
<p>强烈推荐弹丸论破</p>
<p>尤其是狛枝凪斗的希望教...</p>

              </div>
              <div class="toc-container">
                
              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day8/">
              <h3 class="post-title">
                20zr暑期AB班十连测day8
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
