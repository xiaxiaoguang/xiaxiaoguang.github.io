<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CF571D Campus | 夏晓光(loveJY)的博客</title>
<link rel="shortcut icon" href="https://xiaxiaoguang.github.io/favicon.ico?v=1600960513162">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xiaxiaoguang.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CF571D Campus | 夏晓光(loveJY)的博客 - Atom Feed" href="https://xiaxiaoguang.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="IOI2020集训队作业
唔母,这个算是比较简单的一道题了,我也是能找到跟着自己的思路做的解法qwq
龙王桔梗赛高!

有一个长度为 nnn 的序列，初始全为 000。
有两类对下标的集合，初始时每一类各有 nnn 个集合，编号为 iii ..." />
    <meta name="keywords" content="启发式合并,处理标记,并查集,集训队作业" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xiaxiaoguang.github.io">
  <img class="avatar" src="https://xiaxiaoguang.github.io/images/avatar.png?v=1600960513162" alt="">
  </a>
  <h1 class="site-title">
    夏晓光(loveJY)的博客
  </h1>
  <p class="site-description">
    仍要向下扎根,向上结果
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://xiaxiaoguang.github.io/post/you-lian" class="menu">
          友链
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CF571D Campus
            </h2>
            <div class="post-info">
              <span>
                2020-04-04
              </span>
              <span>
                5 min read
              </span>
              
                <a href="https://xiaxiaoguang.github.io/tag/JnCW-H7if/" class="post-tag">
                  # 启发式合并
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/QXUXHAEng/" class="post-tag">
                  # 处理标记
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/o6mxNma8_/" class="post-tag">
                  # 并查集
                </a>
              
                <a href="https://xiaxiaoguang.github.io/tag/HzrxzC7K1/" class="post-tag">
                  # 集训队作业
                </a>
              
            </div>
            
              <img class="post-feature-image" src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/4pNOqgOvBLvj4yTC9qc55eZblvvJKQf3OyBcSQwT0*6Q3up.M8AH93xOrvoQ0QpDcD*IYqNw2UuG1F4ngNPcYGuBX.SGLMm*wXZKVqqo7yE!/r" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>IOI2020集训队作业</p>
<p>唔母,这个算是比较简单的一道题了,我也是能找到跟着自己的思路做的解法qwq</p>
<p>龙王桔梗赛高!<img src="https://xiaxiaoguang.github.io/post-images/1586008392070.jpg" alt="" loading="lazy"></p>
<ul>
<li>有一个长度为 nnn 的序列，初始全为 000。</li>
<li>有两类对下标的集合，初始时每一类各有 nnn 个集合，编号为 iii 的集合里有下标 iii。</li>
<li>一共有 mmm 个操作，操作有五种：<br>
U x y 将第一类编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的集合合并到编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的集合里。<br>
M x y 将第二类编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的集合合并到编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的集合里。<br>
A x 将第一类编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的集合中的所有下标在序列中对应的数加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的集合大小。<br>
Z x 将第二类编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的集合中的所有下标在序列中对应的数设为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。<br>
Q x 询问序列中下标为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的位置上的数。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n,m \le 5 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>看到集合合并而且没有拆分,自然而然想到启发式合并</p>
<p>又因为我们是单点查询而且是合并下标,所以不需要高级数据结构吧...就用并查集</p>
<p>然后我们想先考虑第一类集合怎么做</p>
<p>只需要在根上打一个标记,然后两级河合并的时候直接把要接到另一个根上的那个根标记减去另一个根上的标记就好,这样我们把一个点到根路径上经过所有点求个前缀和就一定是答案了</p>
<p>好的,现在我们要兼容赋值操作/kk</p>
<p>一个不难的想法是利用时间戳,我们每个赋值操作毕竟赋的值是一样的,所以我们可以在根上放时间戳,然后从节点到根的路径求一个最大时间就是我们这个点被赋值的最近时间啦</p>
<p>然而这个东西还是不能够兼容之前的加法标记,因为每个点的具体时间不一样.....</p>
<p>等等,我们是不是可以出卖复杂度更暴力的解决一下?或者我们忘记了并查集的什么性质吗?按秩合并???</p>
<h2 id="树高均摊log">树高均摊log!</h2>
<p>对了,有了这个操作也就意味我们第一个向上跳均摊log次,然后这nlogn次我们每次不用直接拿标记,而是把每次标记带着时间戳都记下来,然后直接在这些标记里面二分就好</p>
<p>时间复杂度很低,O(nlog^2n),二分虽然是满的但其他的不是啊</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
const int MAXN = 1e6 + 7;
int gs[MAXN], fs[MAXN], n, m;
int f[MAXN], g[MAXN], ft[MAXN], gt[MAXN];
char opt[5];

int find(int *f, int x) {
    while(x ^ f[x])x = f[x];
    return x;
}

inline void merge(int *f, int *siz, int *t, int x, int y, int k) {
    x = find(f, x);
    y = find(f, y);
    if(siz[x] &lt; siz[y])swap(x, y);
    siz[x] += siz[y];
    //好像是启发式/kk也只能启发式了
    f[y] = x;
    t[y] = k;
    //两棵树都是启发式合并的过程
}
int cls[MAXN];
vector&lt;pair&lt;int, ll&gt; &gt; add[MAXN];
#define MP make_pair

int main() {
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; ++i)fs[f[i] = g[i] = i] = gs[i] = 1, add[i].push_back(MP(-1, 0));
    for(int i = 1; i &lt;= m; ++i) {
        scanf(&quot;%s&quot;, opt);
        int x, y;
        scanf(&quot;%d&quot;, &amp;x);
        switch(opt[0]) {
        case 'U': scanf(&quot;%d&quot;, &amp;y), merge(f, fs, ft, x, y, i); break;
        case 'M': scanf(&quot;%d&quot;, &amp;y), merge(g, gs, gt, x, y, i); break;
        case 'A': {
            int k = find(f, x);
            add[k].push_back(MP(i, fs[k] + add[k].back().second));
            //这个我们在这个点上面,打下一个前缀和标记
            //然后第一维时间戳
            break;
        }
        case 'Z': {
            int k = find(g, x);
            cls[k] = i;
            break;
        }
        case 'Q': {
            int fx = x, tag = cls[x];
            while(g[fx] != fx) {
                if(cls[g[fx]] &gt; gt[fx])tag = max(tag, cls[g[fx]]);
                //取max,找到最大的那个时间戳
                fx = g[fx];
            }
            fx = x;
            int l = lower_bound(add[x].begin(), add[x].end(), MP(tag, 0ll)) - add[x].begin();
            ll ans = add[x].back().second - add[x][l - 1].second;
            //二分原来的点的标记
            while(f[fx] != fx) {
                int tf = f[fx];
                l = lower_bound(add[tf].begin(), add[tf].end(), MP(max(tag, ft[fx]), 0ll)) - add[tf].begin();
                ans += add[tf].back().second - add[tf][l - 1].second;
                fx = f[fx];
                //一路向上跳父亲并且累加标记
                //注意是前缀和哦
            }
            printf(&quot;%lld\n&quot;, ans);
        }
        }
    }
    return 0;
}
</code></pre>
<p>果然数据结构还是很好懂的?/kk</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%A0%91%E9%AB%98%E5%9D%87%E6%91%8Alog">树高均摊log!</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xiaxiaoguang.github.io/post/cf568c-new-language/">
              <h3 class="post-title">
                CF568C New Language
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1c71f40d2d18a0ac8466',
    clientSecret: '06ff9ddda58d869438ab8631f697626850a7e875',
    repo: 'Xiaoguangcomment',
    owner: 'xiaxiaoguang',
    admin: ['xiaxiaoguang'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://xiaxiaoguang.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
