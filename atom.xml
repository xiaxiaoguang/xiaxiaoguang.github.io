<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-10-03T12:06:41.534Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化听课 (Day3)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day3/">
        </link>
        <updated>2020-10-03T08:03:07.000Z</updated>
        <content type="html"><![CDATA[<p>zhx的DP</p>
<p>T1</p>
<p>n*n网格,每个格子有个数,有m个限制就是不能从权值为i的走到权值为j的</p>
<p>一条路径的权值是从起点到终点穿起来</p>
<p>然后起点任意问走k步能得到最大的数多少</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n,k&lt;=100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>每个变化的限制就写入状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示我现在走了i步走到j(j,k)的最大数是多少</p>
<p>转移考虑下一步,显然会发现我们从相邻最大的那个走过来</p>
<p>存的时候直接用字符串即可?</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601712864582.png" alt="" loading="lazy"></figure>
<p>第一个问题是选出一些不相交的区间</p>
<p>显然可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示考虑了前i块地,然后i被种的最大收益</p>
<p>首先按照右端点排序即可</p>
<p>转移?考虑我们如果没有区间右端点的地一定不先考虑,然后我们枚举这个右端点处的区间是什么,设为[l,r]</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>+</mo><msub><mi>f</mi><mrow><mn>1...</mn><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mi>r</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_r=max(p_i+f_{1...l},f_r)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>树状数组或缀和优化</p>
<p>第二个问题我们可以先设计一个n^2状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑前i块地,然后已经开荒了i-&gt;j位置,j之前的不管</p>
<p>转移</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j}-a_i+w
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f_{i,i}=f_{i-1,0}-a_i+w
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}=max f_{i-1,j}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>w是右端点在i的区间且左端点大于等于j的价值和</p>
<p>首先不难发现这个转移可以线段树优化?区间加?</p>
<p>zhx官方做法:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示最右种地区间编号为i,然后讨论之前区间和现在区间的关系</p>
<p>枚举一个r表示上一个被种的地盘</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>&lt;</mo><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r&lt;l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>显然没有地被种过,直接开荒,和上个题一样</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mi>r</mi><mo>&lt;</mo><mo>=</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i&lt;=r&lt;=r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>现在之前种的最靠右的在中间某个地方</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Double subscript at position 24: …=f_r+P_i+(sum_r_̲i-sum_{r-1})
'>f_{r_i}+=f_r+P_i+(sum_r_i-sum_{r-1})
</p>
<p>都是一个区间最大值的查询,可以优化到log</p>
<ol start="3">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>&gt;</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r&gt;r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>会发现这个区间白给了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><msub><mi>f</mi><mi>r</mi></msub><mo>+</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{r}=f_{r}+p_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>做完了,区间加</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601715268736.jpg" alt="" loading="lazy"></figure>
<p>首先一定可以预处理别的位置对于中间四个位置我们放什么获得的代价</p>
<p>然后可以考虑中间之间的怎么搞定</p>
<p>九维dp</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 22: …,k,l,m,n,o,p,q}$̲$表示考虑了前i个数,然后四个…'>f_{i,j,k,l,m,n,o,p,q}$$表示考虑了前i个数,然后四个位置上放了j,k,l,m数,然后n,o,p,q为点四个数有没有这个i

转移的时候$O(2^4)$枚举即可

![](https://xiaxiaoguang.github.io/post-images/1601719787708.png)

先有一个6维的背包dp

$$f_{i,j,k,l,m,n}$$表示考虑选了i个...j个...k个...l个...有无队长,代价和为n的最大价值

考虑a+1个人选或不选,成不成为队长

然后这个能算出最优答案,但是不好计数,因为队长会自闭

我不当队长和当队长都自闭了

在加一维表示还有多少人能不能当队长??

一定假了,复杂度上天而且还要再记一些

我们仔细思考这个东西挂掉因为当不当队长时的算重

所以我们可以发现钦定队长就能解决

把所有人排一下序,然后一个队伍中第11个人一定是队长了

![](https://xiaxiaoguang.github.io/post-images/1601720899691.jpg)

显然要算贡献

然后考虑合并的时候怎么算新贡献

中间的边权会被算$n_i*n_j$

然后$f_{i}$表示第i棵树的答案

但是你要直到某棵树内部走到某个点的路径权值之和

但是$g_{i,j}$表示i棵树内部所有点走到j的距离之和

答案就是$f[k]=f[i]+f[j]+n_i*n_j*c+g_{i,a}*n_j+g_{j,b}*n_i$

这样可以求出第k棵树的答案

然后怎么求出g数组?

$g_{i,j}$表示从第i棵树出发到j点距离?

首先右边内棵树上独自的贡献咋算啊,显然这个已经记录了

然后你会发现我们算另一棵树就要$$g_{c,d}$$(走到头上关键点)

然后+中间那条边的贡献,显然是$n_c*l$,每个点出发走到j

然后我们再考虑这个从某个关键点到另一个关键点的距离?$h_{a,b,j}*n_c$

h怎么更新?如果在一棵树直接更新,在两棵树就从一颗加上关键点+l来转移

然后这个关键点的大小?映射.....

显然我们写记忆化搜索就不需要映射了?

直径?显然我们有点集直径合并的性质Qwq,关键点就只剩下几个了

![](https://xiaxiaoguang.github.io/post-images/1601723477077.png)

$f_{i,j}$表示点i为根的子树里面有j只鹰,然后这个东西可以想象转移

1. j-1飞走

f_{i,j}=f_{i,j-1}*一个系数

显然...

2. j飞进去

会发现,我们要决定飞入那个子树....

然后我们不知道没课子树有多少鹰

$n_1+n_2+....n_k==sth$

$g_{i,j,k}$表示考虑了前i课子树已经飞入l只鹰,k是0/1变量,表示我们第j只鹰定没定

每次dp一个儿子的时候考虑这个儿子飞进去多少,然后是否飞进去

如果不飞过去,我们直接背包求和

如果飞进去我们还要乘$f_{v,n_v+1}$

插板法/se orzljh

先枚举那个儿子飞入,然后枚举第j只鹰停留时多少个儿子

$$f_{i,j}=\sum_{r=1}^k 1/k \sum_{n_r=0}^{j-2} f_{p_r,n_r+1}</p>
<p>还不够,我们里面还有一个方案数,也就是说实际上概率不是这个</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi><munderover><mo>∑</mo><mrow><msub><mi>n</mi><mi>r</mi></msub><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>f</mi><mrow><msub><mi>p</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>r</mi></msub><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mi>r</mi></mrow><mrow><mi>j</mi><mo>−</mo><mn>2</mn></mrow></mfrac><mo fence="true">)</mo></mrow><msubsup><mfrac><mn>1</mn><mi>k</mi></mfrac><mi>r</mi><mi>n</mi></msubsup><msup><mfrac><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></mfrac><mrow><mi>i</mi><mo>−</mo><mn>2</mn><mo>−</mo><msub><mi>n</mi><mi>r</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum_{r=1}^k 1/k \sum_{n_r=0}^{j-2} f_{p_r,n_r+1} *\binom{nr}{j-2}{\frac 1 k}^n_r\frac{k-1}{k}^{i-2-n_r}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2259900000000004em;vertical-align:-1.3672129999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000006em;"><span style="top:-1.8828870000000002em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3672129999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.536034em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3757319999999997em;"><span style="top:-1.9643000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.77434em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7357em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.586004em;"><span style="top:-3.82434em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>之前背包的式子也要写概率QAQ</p>
<p>TC Open 2014 Round 1B P3</p>
<p><s>老师太懒没写</s></p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601725617786.png" alt="" loading="lazy"></figure>
<p>显然状压不太行</p>
<p>优化状压?你会发现我们不需要太多信息</p>
<p><strong>只需要知道是否是某个数的倍数</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示我们<strong>选了i个数</strong>,gcd为j的先手是否必胜</p>
<p>转移考虑</p>
<ol>
<li>选择j的倍数</li>
</ol>
<p>看看有多少数是j的倍数c,然后如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">i&lt;c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
<p>我们可以再选一个j的倍数,gcd不变</p>
<ol start="2">
<li>不选择j的倍数</li>
</ol>
<p>那之前一定没有选择过他</p>
<p>转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>j</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i+1][gcd(j,a_k)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p>
<p>然后博弈论DP就解决了</p>
<p>orzwyz</p>
<p>n个点,深度为k的二叉树有多少种</p>
<p>考虑转移?枚举右子树多少点,然后深度是什么</p>
<p>先钦定左子树达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum_{k=1}^{k-1}f_{k,j-1}\sum_{d=0}^{i-1}f_{i-1-k,d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1382260000000004em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.836113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后我们还要加上右子树成为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>啊/ll</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">+\sum_{d=0}^{j-1}f[k][d] f_{i-1-k,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.16089em;vertical-align:-1.302113em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000001em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>可以前缀和优化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>此时你会发现我们可以优化状态,直接dp前缀和</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i深度小于等于j的方案数</p>
<p>然后转移$$\sum_{k=0}^{i-1}f_{k,j-1}*f_{i-1-k,j-1}$$</p>
<p>finished</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第三场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-san-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-san-chang/">
        </link>
        <updated>2020-10-03T06:02:56.000Z</updated>
        <content type="html"><![CDATA[<p>昨天挂10,今天挂20QAQ</p>
<p>A</p>
<p>1e6!全部写出来五十万位的数/se</p>
<p>高精度期望80pts</p>
<p>做法一:</p>
<p>会发现我们只需要比较大小</p>
<p>那么我们可以用个能够比较大小的映射函数</p>
<p>开根号显然我们还要算好几百位的数</p>
<p>比如对数函数!</p>
<p>logN!=log1+log2+log3....+log(n)</p>
<p>也就是说我们1e6个数全部求一个阶乘然后搞一个前缀和数组,这个和的第i项就是n!取对数</p>
<p>然后只需要枚举一个k,看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>−</mo><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_n-S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的大小关系</p>
<p>做法二:</p>
<p>结论 : 左边的阶乘不会大于右边的阶乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><msup><mn>6</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1e6^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>倍</p>
<p>显然如果大于我们就可以把左边的一个分给右边并保证仍成立</p>
<p>所以可以记录左边的倍数比右边打多少</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
#define ll long long
using namespace std;
const int MAXN = 2e6 + 7;
db f[MAXN];
ll g[MAXN];
int n;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	if(n == 1) {
		return puts(&quot;1&quot;), 0;
	}
	if(n == 2) {
		return puts(&quot;2&quot;), 0;
	}
	if(n == 3) {
		return puts(&quot;3&quot;), 0;
	}
	f[3] = 6;
	g[3] = 3;//前三个,初始化一下
	for(ll i = 4; i &lt;= n; ++i) {
		f[i] = f[i - 1];
		g[i] = g[i - 1];
		while(f[i] / i &lt; 1 &amp;&amp; g[i] &lt; i) {
			++g[i];
			f[i] = f[i] * g[i] * g[i];
		}
		f[i] /= i;
	}
	printf(&quot;%lld\n&quot;, g[n]);
	return 0;
}

</code></pre>
<p>扩展:组合数问题</p>
<p>首先杨辉三角最下面一行的中间是最大的,而且次大的一定在最大的相邻位置</p>
<p>所以这k个数我们只需要用一个大根堆比较然后依次选下去就好了</p>
<p>然后我们从大根堆取k次就是前k大的组合数</p>
<p>显然比较大小不能取模,我们可以对其取对数</p>
<p>然后</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">C_{n,m}=logn!-logm!-log(n-m)!
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></span></p>
<p>B</p>
<p>先处理字符串,把整个拓扑图建出来</p>
<p>然后n^2去pick每个即可...</p>
<p>模拟建图处理字符串的时候可以分阶段来搞...然后有一个:;就换阶段,这样比较好写</p>
<p>注意把所有字符串按照字典序pick出来然后分配下点的编号</p>
<p>写模拟一定要代码优美一些</p>
<p>全考场切的最快?</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑按照依赖关系建图
//会发现是一个拓扑排序
//然后我们有一些时间轴,每个时间轴都可以向后推进
//然后时间轴要任务的时候我们可以把所有点按照深度和名字进行排序
//然后就可以做了?
//名字字符集为小写大写数字,要是不是就撕了zhx
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e3 + 7;
const int MAXM = 3e5 + 7;
#define ll long long
string s, a, b;
map&lt;string, int&gt; mp;
int T, ccnt, home[MAXN], nxt[MAXM], to[MAXM], in[MAXN];

priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt; &gt;  hp;
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;  heap;
int vis[MAXN], tim[MAXN], Sm;
struct NODE {
	int id, ft;
	bool operator&lt;(const NODE x)const {
		return ft == x.ft ? id &gt; x.id : ft &gt; x.ft;
	}
} e[MAXN];

priority_queue&lt;NODE&gt; task;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	in[y]++;
}

int main() {
	freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; s;
	int flg = 0;
	//正在进行第几个阶段?
	//任务的名字为第二关键字??
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == '/') {
			hp.push(a);
			a.clear();
			flg = -1;
			continue;
		}
		if(s[i] == ';') {
			hp.push(a);
			a.clear();
			flg = 0;
			continue;
		}
		if(s[i] == ':') {
			flg = 1;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		}
	}
	a.clear();
	while(!hp.empty()) {
		a = hp.top();
		hp.pop();
		cout &lt;&lt; a &lt;&lt; endl;
		mp[a] = ++T;
	}
	a.clear();
	flg = 0;
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == ';') {
			flg = 0;
			a.clear();
			continue;
		}
		if(s[i] == ':') {
			flg++;
			continue;
		}
		if(s[i] == '/') {//上四挡
			flg = 4;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		} else if(flg == 1) {
			if(s[i] == '[') {
				continue;
			}
			if(s[i] == ',' || s[i] == ']') {
				if(b.empty())continue;
				ct(mp[b], mp[a]);
				b.clear();
				continue;
			}
			b.push_back(s[i]);
		} else if(flg == 2) {
			tim[mp[a]] = tim[mp[a]] * 10 + s[i] - '0';
			cout &lt;&lt; a &lt;&lt; endl;
			//快读即可
		}
		if(flg == 4) {
			Sm = Sm * 10 + s[i] - '0';
			if(Sm &gt; T)break;
		}
	}
	for(int i = 1; i &lt;= T; ++i)e[i].id = i;
	//有多少任务就有多少点
	int fed = 0;
	while(fed &lt; Sm) {
		++fed;
		heap.push(0);
		//每个机器最早结束时间
	}
	fed = 0;
	while(fed &lt; T) {
		for(int i = 1; i &lt;= T; ++i) {
			if(in[i] == 0 &amp;&amp; !vis[i]) {
				vis[i] = 1;
				task.push(e[i]);
				//把这个点放入qwq里
			}
		}
		int t = heap.top();
		heap.pop();
		NODE u = task.top();
		task.pop();
		for(int i = home[u.id]; i; i = nxt[i]) {
			int v = to[i];
			e[v].ft = max(e[v].ft,  tim[u.id] + max(t, u.ft));
			//考虑我们这个任务结束的时间应该是这个任务开始做的时间+做这个任务的时间
			//前者显然和机器开工时间与开始做时间最大值有关
			in[v]--;
		}
		fed++;
		heap.push(max(t, u.ft) + tim[u.id]);
	}
	int ans = 0;
	while(!heap.empty()) {
		ans = max(ans, heap.top());
		heap.pop();
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

abc:[a1,a2]:10;AB1:[]:2;AB2:[]:3;ab1:[AB1,AB2]:3;ab3:[AB2]:4;a2:[ab1,ab3,AB2]:2;a1:[ab1]:3/3


*/
</code></pre>
<p>C</p>
<p>挂了20QAQAQAQ</p>
<p>对于长度为1,我们可以直接暴力</p>
<p>对于长度&lt;=10,我们可以直接复制粘贴到一样长</p>
<p>考场上直接TLE/ll</p>
<p>注意50!整除任何你想要的,所以不用考虑余数</p>
<p>均为质数</p>
<p>3,5的情况?</p>
<p>010010010010010<br>
100111001110011</p>
<p>-&gt;</p>
<p>110121011120021</p>
<p>你会发现第一个串会和第二个字符串每一位都有重叠的操作!!</p>
<p>那么其实相当于(2个0+1个1)*(2个0+3个1)=4个0+8个1+3个2??</p>
<p>因为一定会有重复!</p>
<p><s>生成函数??</s></p>
<p>当两字符串互质时,我们只关心彼此间0/1的个数!</p>
<p>然后我们最后相当于多个二项式相乘!!</p>
<p>...可以分治FFT优化</p>
<p>然鹅,如果不互质就萎了</p>
<p>分块匹配!!!</p>
<p>lcm 4,6 =12</p>
<p>4 4 4 4-&gt; 1 2 1 2 1 2<br>
6 6 -&gt;      1 2 3 1 2 3</p>
<p>设最大公因数为g</p>
<p>10 01 10 01 10 01<br>
01 00 11 01 00 11</p>
<p>你会发现4的每一块的第一位都不可能和6的第二位产生影响</p>
<p>然后我们可以继续,取出4的第二位和六的每一块的第二位乘起来</p>
<p>然后得到两个多项式系数求和?</p>
<p>这两个答案求和就是我们想要的答案,可以发现多项式的指数可能变小?</p>
<p>扩展到n个?你会发现我们要小心gcd!QAQ</p>
<p>如果一个字符串含有2,3,5,7,作为因子那么我们就把它扩展到32<em>27</em>25*49的形式</p>
<p>但是如果包含了大于7的因子,他的平方一定大于50,所以只会包括一个大于7的</p>
<p>怎么扩?</p>
<p>每个p拓展到12p,因为我们最大只能有4</p>
<p>这样做完之后,我们最大公约数为12(或者更大一个p)</p>
<p>所有数我们可以按照12进行分组,然后做12次多项式乘法就好了</p>
<p>然后会发现我们可以做了!</p>
<p>D</p>
<p>显然我们可以枚举中间的那个j,然后计算左右两边的贡献,就是左边那些大于他的和右边那些大于他的都可以拼起来</p>
<p>然后你会发现我们这个贡献好像就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i*(n-k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就是有多少区间包括他</p>
<p>做完了,树状数组维护即可</p>
<p>注意翻转值域的时候不要出现0</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 5e5 + 7;
const int P = 1e9 + 7;
int n, a[MAXN];
ll ans;
struct rec {
#define lowbit(x) (x&amp;(-x))
	ll tr[MAXN];
	inline void add(int x, ll V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline ll qry(int x) {
		ll ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} bt1, bt2;

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int M = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		M = max(M, a[i]);
	}
	++M;
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], n - i + 1);
	}
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], -n + i - 1);
		add(ans, bt1.qry(M - a[i] - 1) * bt2.qry(M - a[i] - 1) % P);
		bt2.add(M - a[i], i);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第二场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/">
        </link>
        <updated>2020-10-02T06:27:49.000Z</updated>
        <content type="html"><![CDATA[<p>QAQ</p>
<p>T2被降智</p>
<p>A</p>
<p>二分答案</p>
<p>判断的时候我们先让之前(如果有灯)就放光放过去,照亮一些路灯</p>
<p>然后再找到第一个照不亮的我们从哪个点向后找第二个要照亮的路灯就好了</p>
<p>时间复杂度O(nlogn)</p>
<p>考场空间开小?成为全场唯一90</p>
<h1 id="以后15倍空间一定要开">以后1.5倍空间一定要开!!!</h1>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 2e5 + 7;

int n, k, a[MAXN];

inline int chk(int x) {
	int lstl = 0;
	int lstu = 1;
	lstu = 1;
	lstl = 1;
	while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
		++lstl;
	}
	lstu = lstl + 1;
	for(int i = 2; i &lt;= k; ++i) {
		while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n) {
			++lstu;
		}
		lstl = lstu;
		while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
			++lstl;
		}
		lstu = lstl + 1;
	}
	while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n)
		++lstu;
	return lstu &gt; n;
}

signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);
	a[n + 1] = 2e9;
	a[0] = -2e9;
	int	L = 0, R = 2e9, ans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	while(L &lt;= R) {
		int mid = (L + R) &gt;&gt; 1;
		if(chk(mid)) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}


</code></pre>
<p>B</p>
<p>惨</p>
<p>首先n^2很easy</p>
<p>然后考虑怎么观察来优化</p>
<p>你会发现我们就算交换很鬼畜也会有很多不动的位置</p>
<p>比如12345对于2交换一次</p>
<p>21435</p>
<p>1,3,5都没有变</p>
<p>但是数组整个下标其实向后平移了一位,然后有一些特殊位置要暴力修改....</p>
<p>做法就很显然了...开个2n的数组就行了</p>
<p>然后每次我们交换交换特殊位置...QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 3e6 + 7;
int n, p[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)p[i] = i;
	for(int i = 2; i &lt;= n; ++i) {
		int nw = 0;
		for(int j = 1; j &lt;= n; j += i) {
			swap(nw, p[j + i - 2]);
		}
		p[i + n - 1] = nw;

	}
	for(int i = n; i &lt; 2 * n; ++i) {
		printf(&quot;%d &quot;, p[i]);
	}
	puts(&quot;&quot;);
	return 0;
}

</code></pre>
<p>C</p>
<p>随便dp即可</p>
<p>单指针计数可以实现快速判断最近的是哪个</p>
<p>同时计算一段贡献也很basic</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 205;
const int MAXK = 32;
ll a[MAXN], sum[MAXN], b[MAXN], suf[MAXN];
int n, k;
ll f[MAXN][MAXK][2];
inline ll cst1(int l, int r) {//l light -&gt;r
	return sum[r] - sum[l - 1] - 1ll * (r - l + 1) * a[l];
}

inline ll cst2(int l, int r) {//r light -&gt; l
	return suf[l] - suf[r + 1] - 1ll * (r - l + 1) * b[r];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for(int i = 1; i &lt;= n; ++i) {
		b[i] = a[n] - a[i];
	}
	for(int i = n; i &gt;= 1; --i) {
		suf[i] = suf[i + 1] + b[i];
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= min(i, k); ++j) {
			if(j != 1) {
				int lstu = i;
				for(int k = i - 1; k &gt;= 1; --k) {
					while(a[i] - a[lstu - 1] &lt; a[lstu - 1] - a[k]) --lstu;
					f[i][j][1] = min(f[i][j][1], f[k][j - 1][1] + cst1(k, lstu - 1) + cst2(lstu, i));
				}
			} else {
				f[i][j][1] = min(f[i][j][1], cst2(1, i));
			}
			for(int k = i - 1; k &gt;= 1; --k)
				f[i][j][0] = min(f[i][j][0], f[k][j][1] + cst1(k, i));
		}
	}
	printf(&quot;%lld\n&quot;, min(f[n][k][0], f[n][k][1]));
	return 0;
}


</code></pre>
<p>D</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树到i距离为j的点数有多少个</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树中满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dis(LCA(x,y),x)=dis(LCA(x,y),y)=dis(LCA(x,y),i)+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><br>
的有多少个</p>
<p>你会发现g数组更新其实很简单</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>g</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}+=g_{v,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j+1}+=f_{v,j}*f_{i,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>第二行相当于加入了新的三元组</p>
<p>f转移一样简单</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
const int MAXM = 2e5 + 7;
int home[MAXN], nxt[MAXM], to[MAXM], ccnt, n;
ll a[MAXN], ans;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int fa[MAXN];
ll sum1[MAXN][5], sum2[MAXN][5];

inline void dfs1(int u, int F) {
	fa[u] = F;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		sum1[u][1] += a[v];
		sum1[u][3] += sum1[u][2] * sum1[v][1];
		sum1[u][2] += sum1[v][1] * sum2[u][2];
		sum2[u][2] += sum1[v][1];
	}
	return;
}

signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	dfs1(1, 0);
	//case 1
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[fa[u]];
		if(v == 0)continue;
		ans += a[v] * sum1[u][2];
	}
	//case 2
	for(int u = 1; u &lt;= n; ++u) {
		ans += sum1[u][3];
	}
	//case 3
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[u];
		if(v == 0)continue;
		ll tp = sum1[v][1] - a[u];
		ans += tp * sum1[u][2];
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化听课(Day 1+2)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/">
        </link>
        <updated>2020-10-01T10:36:57.000Z</updated>
        <content type="html"><![CDATA[<p>枚举</p>
<p>for,或者while,或者do_while?/se</p>
<p>基本所有代码都要包括....</p>
<p>水仙花数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log_{10}n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>搜索</p>
<p>显然</p>
<p>坐等例题</p>
<p>NOI1999</p>
<p>n很小唉</p>
<p>可以考虑搜索出蛋糕最小表面积</p>
<p>用了多少总体积,到了第几层,半径和高</p>
<p>那么我们来剪枝!</p>
<p>可行性剪枝</p>
<ol>
<li>半径和高递减</li>
<li>如果这一层用最优的方法去放都不能满足总体积就return</li>
</ol>
<p>也就是半径1高度1-&gt;半径2高度2......</p>
<ol start="3">
<li>如果这一层用最劣的方法都能放下就不搜</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>1...</mn><mi>R</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>2...</mn></mrow><annotation encoding="application/x-tex">R-1,H-1...R-2,H-2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>说明我们之前的决策sb了</p>
<p>最优性剪枝</p>
<ol start="4">
<li>当前表面积和+剩下的最小表面积都不能凑齐超过答案就return</li>
</ol>
<p>你会发现当体积一定的时候剩下最小表面积应该能搞出来?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup><mi>h</mi></mrow><annotation encoding="application/x-tex">V=\pi r^2 h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>2</mn><mi>π</mi><mi>r</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">S=2\pi r h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p>r最大为.....</p>
<p>然后能算出对应的h,就可以找到最小表面积了</p>
<p>相当于估价函数吧</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601623513084.png" alt="" loading="lazy"></figure>
<p>显然可以暴力吧...<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mn>13</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,a[13]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后面值为i的有多少张</p>
<p>不过状态有点多,会发现我们无论如何只看面值是否相同</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mn>5</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,b[5]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mopen mtight">[</span><span class="mord mtight">5</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后重复i次的有多少面值</p>
<p>转移的时候选下一个是什么...?</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601623817582.png" alt="" loading="lazy"></figure>
<p>枚举下最多多少个数k</p>
<p>搜搜当前最小的分母</p>
<p>你会发现如果我们最小分母的k倍小于剩下的数和就一定不可能可以剪一刀</p>
<p>就能跑出来了</p>
<p>k短路可以A*,能MLE呢</p>
<p>咕咕咕函数</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601624926960.png" alt="" loading="lazy"></figure>
<p>A*是8-最多的格子个数</p>
<p>状态无限所以要ID</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601624963620.png" alt="" loading="lazy"></figure>
<p>我们又有无限个状态</p>
<p>估价函数是有多少位置不同-1</p>
<p>然后这个东西是因为最后一步可以还原两个棋子</p>
<p>题目告诉我们要枚举答案QAQ</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601625355953.png" alt="" loading="lazy"></figure>
<p>不显然可以折半</p>
<p>把方案折半,前12种的有一些,前13种的有一些</p>
<p>然后考虑三个人的数如何快速判断相等</p>
<p>第一个搜索中三个人的和我们可以两个做差,然后得到一个大小为2的差分数组</p>
<p>然后考虑拼在一起的时候是要第二个从右向左差分去查</p>
<p>显然可以手写哈希表来查存</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601626675300.png" alt="" loading="lazy"></figure>
<p>爬山即可</p>
<p>每次向所有方向中能降低权值最小的走</p>
<p>可以考虑一个呜噜呜噜的判断方向做法</p>
<p>就是所有向量求和?的和向量方向</p>
<p>模拟退火</p>
<p>设置一个棒棒的估价函数</p>
<p>然后一个降温温度</p>
<p>然后一个可能跳出去的判断方法</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>T</mi><mo>)</mo><mo>&gt;</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">/</mi><mi>R</mi><mi>A</mi><mi>N</mi><msub><mi>D</mi><mi>M</mi></msub><mi>A</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">exp(delta/T)&gt;rand()/RAND_MAX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>T值越小这个里面的值绝对值越大,而del显然是负数,那么del越小越容易交换</p>
<p>同样的,如果我们最大化,只需要变一下符号即可</p>
<p>整数划分</p>
<p>钦定前面大于后面</p>
<p>屑</p>
<p>背包问题</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601627563786.png" alt="" loading="lazy"></figure>
<p>可以考虑按照性价比排序进行搜索,这样容易剪枝</p>
<p>因为性价比是递减的,如果当前性价比下(买小数个)凑出的答案都不够优秀就return</p>
<p>货郎担</p>
<p>状压可以解决20了</p>
<p>直接搜还是蛮难的...</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1601628286924.png" alt="" loading="lazy"></figure>
<p>背包问题</p>
<p>所以下一个面额是什么可以搜索出来</p>
<p>然后我们拼一拼的时候可以背包来做.....看不能延伸</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1601628498620.png" alt="" loading="lazy"></figure>
<p>奇偶最短路的实现方法就是每个点拆成奇数点和偶数点然后连边随便连一连</p>
<p>最后只有一个源点出发跑一跑bfs最短路就行了</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1601628939205.png" alt="" loading="lazy"></figure>
<p>整除</p>
<p>奇数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>+</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">a+b|(a^n+b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>偶数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>−</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)|(a^n-b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1601633671957.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1601633621961.png" alt="" loading="lazy"></figure>
<p>总-不合法</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1601633767276.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1601635787049.png" alt="" loading="lazy"></figure>
<p>推推石子得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi>i</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n {i/gcd(i,n)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mrow><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{d|n} \sum_{k=1}^{n/d} {k*[gcd(k,n/d)==1]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.47701em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}\sum_{k=1}^{n}k*[gcd(k,n)=1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>后面这个式子显然是phi函数可以做到的</p>
<p>显然i与n互质,n-i与n互质</p>
<p>所以所有和n互质的数的和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>∗</mo><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\phi(d)*d/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>做完了,可以预处理最小质因数做到log</p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1601637832702.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo>=</mo><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^n[gcd(i,n)==d]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^{n/d}[gcd(i,n/d)==1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.4770100000000004em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>d</mi><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum_{d|n}d\phi(d)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p>
<p>卢卡斯定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n,m)%P=C(n%P,m%P)*C(n/P,m/P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>n用m进制分解,然后各位的数对应求组合数然后相乘???</p>
<p>gcd,lcm</p>
<p>gcd二除法</p>
<p>b=0,gcd=a</p>
<ol>
<li>两数都为偶数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">=2*gcd(a/2,b/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<ol start="2">
<li>二数都为奇数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a-b,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<ol start="3">
<li>一奇一偶</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a/2,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>多元一次方程输出方案</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1601641712364.png" alt="" loading="lazy"></figure>
<p>显然我们考虑如果能前n-1个构造出和第n个数剩余系下所有数就能表示M</p>
<p>然后这个条件就是互质</p>
<p>显然因为我们所有数和最后那个数互质也就是说我们n-1的情况还可以继续变小</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1601641834634.png" alt="" loading="lazy"></figure>
<p>具体构造起来可能是O(nlogn)的....</p>
<p>中国剩余定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><munder><mo>∏</mo><mi>i</mi></munder><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N=\prod_{i} m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i=N/m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">K_i*c_i=1 (mod m_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x=\sum_{i=1}^n a_ic_iK_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>正确性显然</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1601644946874.png" alt="" loading="lazy"></figure>
<p>有人想生成函数?</p>
<p>考虑插板法可以计算没有n限制下的解</p>
<p>有限制可以容斥</p>
<p>那么我们考虑至少一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x_i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>很好算,只需要k-n即可</p>
<p>然后我们钦定有多少大于n,k就减去多少个n</p>
<figure data-type="image" tabindex="19"><img src="https://xiaxiaoguang.github.io/post-images/1601646314122.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://xiaxiaoguang.github.io/post-images/1601646334844.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://xiaxiaoguang.github.io/post-images/1601646665421.png" alt="" loading="lazy"></figure>
<p>设i维的j维面有f个,然后转移会发现一条线能成为一个面,而一个面能成为两个面</p>
<p>即i-1维的j维元素*2,j-1维元素成为j维元素...</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><mn>2</mn><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j}*2+f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<figure data-type="image" tabindex="22"><img src="https://xiaxiaoguang.github.io/post-images/1601646591718.png" alt="" loading="lazy"></figure>
<p>规律不好找/jk</p>
<figure data-type="image" tabindex="23"><img src="https://xiaxiaoguang.github.io/post-images/1601647626994.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1568. [2020提高组十连测day5]白银御行]]></title>
        <id>https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/</id>
        <link href="https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/">
        </link>
        <updated>2020-10-01T07:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>哇偶...</p>
<p>畸形第k大-&gt;</p>
<p>二分答案</p>
<p>多次询问-&gt;</p>
<p>整体二分</p>
<p>然后考虑怎么把矩阵相交变成数点问题</p>
<p>两个矩阵相交的条件可以是在两维都要区间相交</p>
<p>而转换...最好用的消除条件的方法就是容斥</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601537501647.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601537631151.png" alt="" loading="lazy"></figure>
<p>所以也就是说我们按照这个条件去处理每一层的整体二分过程就好了</p>
<p>问题在于代码有好多好多细节QAQ</p>
<p>堪比接水果</p>
<p>注意 :</p>
<ol>
<li>
<p>多开几个数组处理每一层询问和修改的分开</p>
</li>
<li>
<p>注意最后值域收缩到一个点那些点的答案就是这个值</p>
</li>
<li>
<p>注意最小化所以&lt;=分左边</p>
</li>
</ol>
<p>code:</p>
<pre><code class="language-cpp">
//Finished by dawn light
//as difficult as frute
//qwq orzmyh!
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7 + 1e4;
using namespace std;

int n, m;
struct mat {
	int r1, c1, r2, c2, z, id;
	bool operator&lt;(const mat &amp;x)const {
		return c1 == x.c1 ? z &lt; x.z : c1 &lt; x.c1;
	}
} e[MAXN], ask[MAXN], mdq[MAXN * 2], a[MAXN], b[MAXN];

struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN * 2];
	inline void mdf(int x, int V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tr;
int tp[MAXN];

inline void pd1(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, -1);
		}
}

inline void pd2(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd3(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd4(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void fz(int vL, int vR, int L, int R, int l, int r) {
	if(vL == vR) {
		for(int i = l; i &lt;= r; ++i) {
			tp[ask[i].id] = vL;
		}
		return;
	}
	int M = (vL + vR) &gt;&gt; 1;
	for(int i = l; i &lt;= r; ++i)tp[ask[i].id] = 0;
	pd1(L, R, l, r, M);
	pd2(L, R, l, r, M);
	pd3(L, R, l, r, M);
	pd4(L, R, l, r, M);
	int T1 = 0;
	int T2 = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(tp[ask[i].id] &gt;= ask[i].z) {
			a[++T1] = ask[i];
		} else {
			b[++T2] = ask[i];
			b[T2].z -= tp[ask[i].id];
		}
	}
	int tmp1 = l + T1 - 1;
	for(int i = l; i &lt;= tmp1; ++i) {
		ask[i] = a[i - l + 1];
	}
	for(int i = tmp1 + 1; i &lt;= r; ++i) {
		ask[i] = b[i - tmp1];
	}
	T1 = 0;
	T2 = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= M) {
			a[++T1] = e[i];
		} else {
			b[++T2] = e[i];
		}
	}
	int tmp2 = L + T1 - 1;
	for(int i = L; i &lt;= tmp2; ++i) {
		e[i] = a[i - L + 1];
	}
	for(int i = tmp2 + 1; i &lt;= R; ++i) {
		e[i] = b[i - tmp2];
	}
	if(l &lt;= tmp1)fz(vL, M, L, tmp2, l, tmp1);
	if(r &gt;= tmp1 + 1)fz(M + 1, vR, tmp2 + 1, R, tmp1 + 1, r);
	return ;
}

inline void solve2() {
	fz(1, n + 1, 1, n, 1, m);
	for(int i = 1; i &lt;= m; ++i) {
		if(tp[i] &gt; n)puts(&quot;-1&quot;);
		else printf(&quot;%d\n&quot;, tp[i]);
	}
	return ;
}
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;22)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
int main() {
	n = read();
	m = read();
	for(int i = 1; i &lt;= n; ++i) {
		e[i].r1 = read();
		e[i].c1 = read();
		e[i].r2 = read();
		e[i].c2 = read();
		e[i].id = i;
	}
	for(int i = 1; i &lt;= m; ++i) {
		ask[i].r1 = read();
		ask[i].c1 = read();
		ask[i].r2 = read();
		ask[i].c2 = read();
		ask[i].z = read();
		ask[i].id = i;
	}
	solve2();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第一场)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/">
        </link>
        <updated>2020-10-01T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>屑</p>
<p>A</p>
<p>考虑必胜策略的构造</p>
<p>假设我有最后一张牌</p>
<p>如果对方选取i,我就选择i+1</p>
<p>然后考虑我们这样做一定能有一个牌权</p>
<p>如果对方先手而且我的牌不比他多就能靠这个牌权取胜</p>
<p>所以:</p>
<p>奇数+奇先手必胜</p>
<p>奇数+偶先手必胜</p>
<p>偶数 偶必胜</p>
<p>n=2先手必胜</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
int T;
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--&gt;0) {
		int op;
		cin&gt;&gt;s;
		scanf(&quot;%d&quot;,&amp;op);
		if(s.size()==1 &amp;&amp; s[s.size()-1]=='2') {
			printf(&quot;%d\n&quot;,op);
		} else if((s[s.size()-1]-'0')%2==0)puts(&quot;1&quot;);
		else {
			if(op==0)puts(&quot;0&quot;);
			else puts(&quot;1&quot;);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>发现我们可以在线/se</p>
<p>举个例子:</p>
<p>染色一行,那么我们如果染蓝色,看看这一行最近一次染得是蓝色还是红色</p>
<p>如果染的蓝色,那么我们查询这个上次到这次时间区域染列红色的个数,那些会变蓝,对应加上</p>
<p>如果染的是红色,那么我们查询这次到上次时域染的行蓝色的个数,那些会不变,加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">m-cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>直接暴力分类讨论要8中,所以我在代码中压缩了行列的区别</p>
<p>考场心态炸裂QAQ</p>
<p>不该打grakn forces2020</p>
<p>齐神的O(n)做法</p>
<p>每一行每一列按照染色的最后时间排序</p>
<p>然后就会发现上述过程可以排序双指针了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int MAXN=1e6+7;
using namespace std;
int n,m,k;
ll ans;
int col[2][MAXN],tim[2][MAXN];
//color time
const int MAXT=2e6+7;
struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXT];
	inline void mdf(int x,int v) {
		for(; x&lt;=k; x+=lowbit(x))tr[x]+=v;
	}
	inline ll qry(int x) {
		ll ret=0;
		for(; x; x-=lowbit(x))ret+=tr[x];
		return ret;
	}
} tr[2][2];//first h,l second r,b

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int main() {
	n=read();
	m=read();
	k=read();
	ans=1ll*n*m;
	for(int i=1,x,y,z; i&lt;=k; ++i) {
		x=read();
		z=read();
		y=read();
		if(y==0) {//红色
			if(col[x][z]==0) {//base red paint red
				ans += tr[x^1][1].qry(i)-tr[x^1][1].qry(tim[x][z]);
			} else {//base blue paint ret
				if(x==1) {
					ans += (n-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
				} else ans += (m-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
			}
            		} else {//蓝色
			if(col[x][z]==1) {
				ans -= tr[x^1][0].qry(i)-tr[x^1][0].qry(tim[x][z]);
			} else {//红色？？
				if(x==0)
					ans -= (m-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
				else ans -= (n-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
			}
		}
		if(tim[x][z]!=0) {
			tr[x][col[x][z]].mdf(tim[x][z],-1);
		}
		tr[x][y].mdf(i,1);
		col[x][z]=y;
		tim[x][z]=i;
	}
	ans=1ll*n*m-ans;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>nth_element</p>
<p>QAQ降智了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=12345;
int n,Q,a[MAXN],v[MAXN];

struct rec {
	ll W;
	int id;
	bool operator&lt;(const rec &amp;x)const {
		return W==x.W?id&lt;x.id:W&gt;x.W;
	}
} p[MAXN];

int t,k;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; ++i)scanf(&quot;%d%d&quot;,&amp;v[i],&amp;a[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for(int i=1; i&lt;=Q; ++i) {
		scanf(&quot;%d%d&quot;,&amp;t,&amp;k);
		for(int i=0; i&lt;n; ++i) {
			p[i].W=1ll*a[i]+1ll*v[i]*t;
			p[i].id=i+1;
		}
		nth_element(p,p+k-1,p+n);
		printf(&quot;%d\n&quot;,p[k-1].id);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>考虑DP,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示看了前i个A数前j个B数能够得到的最小划分代价</p>
<p>然后转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的,因为要枚举上一行上一列是什么</p>
<p>然后转移能优化吗QAQ?</p>
<p>你会发现:</p>
<blockquote>
<p>结论：存在一个最优解的每次删数，至少有一段长度是1</p>
</blockquote>
<p>因为我们有一段都大于1的</p>
<p>我们可以拆成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>a</mi><mo>+</mo><mi>y</mi><mi>b</mi><mo>&lt;</mo><mo>=</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">xa+yb&lt;=(x+y)*(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>所以整完了,转移式子变得可以优化</p>
<p>实现的时候有一维可以直接前缀最小值</p>
<p>另一维...好像按理说也是可以的,不过我的实现是使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>数组</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 2005;
int n, m;
int A[MAXN], B[MAXN];
ll f[MAXN][MAXN], suma[MAXN], sumb[MAXN];
ll minxa[MAXN][MAXN], minxb[MAXN];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		A[i]--;
		suma[i] = suma[i - 1] + A[i];
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;B[i]);
		B[i]--;
		sumb[i] = sumb[i - 1] + B[i];
	}
	if(n &lt; m) {
		swap(n, m);
		swap(A, B);
		swap(suma, sumb);
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	memset(minxa, 0x3f3f3f3f, sizeof(minxa));
	memset(minxb, 0x3f3f3f3f, sizeof(minxb));
	minxa[0][0] = 0;
	for(int i = 1; i &lt;= m; ++i)minxa[0][i] = 0;
	minxb[0] = 0;
	f[0][0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			f[i][j] = min(f[i][j], minxa[i - 1][j - 1] + A[i] * sumb[j]);
			f[i][j] = min(f[i][j], minxb[j - 1] + B[j] * suma[i]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			minxa[i][j] = min(minxa[i][j - 1], f[i][j] - A[i + 1] * sumb[j]);
			minxb[j] = min(minxb[j], f[i][j] - B[j + 1] * suma[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n][m]);
	return 0;
}
/*
3 4
2 4 3
2 6 6 4
*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1567. [2020提高组十连测day5]藤原千花]]></title>
        <id>https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/</id>
        <link href="https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/">
        </link>
        <updated>2020-09-27T15:01:31.000Z</updated>
        <content type="html"><![CDATA[<p>马耀华的比赛题A</p>
<p>太重要了所以这场比赛题我将拆成三篇博客讲述</p>
<p>http://www.zhengruioi.com/problem/1567</p>
<p>线图....QAQ他的点数是按照组合数级别上涨的...</p>
<p>真的来说是图中多少条长为k的路径...</p>
<p>详情请见zjoi 线图那道题</p>
<p>考场时没有判断一个点然后挂掉了QAQ</p>
<p>现在来看是什么我都没有判断就挂掉了....</p>
<h1 id="暴力">暴力</h1>
<p>k=0,判断是否连通&amp;&amp;是否是每个点度数都为偶数</p>
<p>k=1,你会发现新图中一个点是原图中两个点的度数和-2</p>
<p>那么我们就可以把所有新图中的点度数算出来然后和k=0一样了</p>
<p>然鹅...不严谨的我没有想到这样一个可爱的情况:</p>
<p>1孤零零的站在那里,第一次线图他消失了</p>
<p>所以要特殊判断一个点...</p>
<h1 id="正解">正解:</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>首先k=0的判据:所有点度数为偶数一定还成立</p>
<p>然后根据k=1我们可以发现:如果所有点度数奇偶性相同也可以</p>
<p>那....所有点度数都为奇数的图能否由线图导出?</p>
<p>你会发现可以,此时只需要所有边两侧的点度数奇偶性不同</p>
<p>那...这样好像可以递归下去,这样的图又能否由线图导出?</p>
<p>然后你又会发现这样的图好像一定是一个二分图...</p>
<p>也就是说我们不存在奇环,至少三元环</p>
<p>再一想,一旦一个图中某个点度数为3就会出现这样一个三元环!就暴毙了</p>
<p>不过好像左边一个点右边两个点的完全二分图也满足这个性质而且能够导出??.....QAQ</p>
<p><strong>但是至少这种情况是特殊的</strong></p>
<p>即,它属于那种能够越变越小的特殊线图:链</p>
<p>每进行一次,链的长度会缩短1</p>
<h2 id="判no判据">判No判据</h2>
<h3 id="存在长度大于k的链">存在长度大于k的链</h3>
<p>缩不完</p>
<h3 id="存在长度等于k的链而且有其他剩下的连通块">存在长度等于k的链,而且有其他剩下的连通块</h3>
<p>长度等于k的链会变成一个点</p>
<p>至少剩下两个连通块</p>
<h3 id="存在多个长度等于k的链">存在多个长度等于k的链</h3>
<p>QAQ这个其实和上面一样</p>
<p>但是判断起来可不一样啊</p>
<h3 id="不存在点">不存在点</h3>
<p>QAQ这个卡了我一会..</p>
<p>题目定义</p>
<h3 id="存在不止一个连通块">存在不止一个连通块</h3>
<p>QAQ这个又卡了我一会....</p>
<p>注意有些链可能缩没了</p>
<h3 id="上面都没触犯结果三个图性质都没满足">上面都没触犯,结果三个图性质都没满足</h3>
<p>这个最好判断qwq</p>
<h2 id="判yes判据">判Yes判据</h2>
<h3 id="最后只剩下存在长为k的链">最后只剩下存在长为k的链</h3>
<p>一个点也行</p>
<h3 id="满足一个图性质">满足一个图性质</h3>
<p>显然</p>
<p>于是我们大胆实践</p>
<p>就用2h完成了这道题!!!</p>
<p>附赠第一发AC的代码/se</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int n, m, k;
struct rec {
	int x, y;
} e[MAXN];
int f[MAXN], in[MAXN];
inline int getf(int x) {
	return f[x] == x ? x : f[x] = getf(f[x]);
}

inline void pd1() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(getf(i) != getf(1))return (void)puts(&quot;No&quot;);
	}
	for(int i = 1; i &lt;= n; ++i) {
		//		printf(&quot;%d %d?\n&quot;,i,in[i]);
		if(in[i] &amp; 1)return (void)puts(&quot;No&quot;);
	}
	return (void)puts(&quot;Yes&quot;);
}//k equal 0

//one node
inline void pd2() {
	static int siz[MAXN];
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		siz[getf(i)]++;
	}
	int cnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(siz[i] &gt; 1) {
			++cnt;
		}
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	if(cnt == 0)return (void)puts(&quot;No&quot;);
	for(int i = 1; i &lt;= m; ++i) {
		if((in[e[i].x] + in[e[i].y]) &amp; 1)return (void)puts(&quot;No&quot;);
	}
	puts(&quot;Yes&quot;);
	return ;
}

int home[MAXN], nxt[MAXN], to[MAXN], ccnt;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int flg, mx;
int dep[MAXN], vis[MAXN];
//du shu is 2
//with out circle
//lian tong kuai!
inline void dfs(int u, int F) {
	if(!flg)return ;
	vis[u] = 1;
	mx = max(mx, dep[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		//		printf(&quot;%d-&gt; %d %d in? %d\n&quot;,u,v,vis[v],in[v]);
		if(vis[v])flg = 0;
		else {
			if(in[v] != 1 &amp;&amp; in[v] != 2)flg = 0;
			dep[v] = dep[u] + 1;
			dfs(v, u);
		}
	}
}

int visp[MAXN];
inline void dfs2(int u, int F) {
	visp[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		if(to[i] == F)continue;
		dfs2(to[i], u);
	}
}

//if k &gt; maxlen lian ,can1
//if graph is jishu or graph is jioutu,can2
inline void pd3() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
		ct(e[i].x, e[i].y);
		ct(e[i].y, e[i].x);
	}
	int cnt = 0;
	int flg2 = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(in[i] == 0) {
			visp[i] = 1;
			continue;
		}
		if(!vis[getf(i)] &amp;&amp; in[i] == 1) { //is himself
			// printf(&quot;%d?%d\n&quot;, i, in[i]);
			flg = 1;
			mx = 0;
			dfs(i, 0);
			if(!flg) continue;
			if(mx &gt; k)return (void)puts(&quot;No&quot;);
			else if(mx == k) {
				if(!flg2)return (void)puts(&quot;No&quot;);
				flg2 = 0; //cunzai!
				dfs2(i, 0);
			} else dfs2(i, 0);
		}
	}
	// puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(!visp[i] &amp;&amp; i == getf(i)) {
			cnt++;
			//				printf(&quot;%d \n&quot;,i);
		}
	}
	// printf(&quot;%d %d\n&quot;, cnt, flg2);

	if(flg2 &amp;&amp; cnt == 0)return (void)puts(&quot;No&quot;);
	// printf(&quot;%d %d\n&quot;, flg2, cnt);
	if(!flg2 &amp;&amp; cnt == 0) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qwq&quot;);
		return (void)puts(&quot;Yes&quot;);
	} else if(!flg2) {//too....
		return (void)puts(&quot;No&quot;);
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if(!(in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg)return (void)puts(&quot;Yes&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if((in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;QAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	flg = 1;
	for(int i = 1; i &lt;= m; ++i) {
		if(visp[e[i].x] || visp[e[i].y])continue;
		if(!((in[e[i].x] &amp; 1) ^ (in[e[i].y] &amp; 1))) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	return (void)puts(&quot;No&quot;);
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].x, &amp;e[i].y);
	}
	if(k == 0) {
		return pd1(), 0;
	}//qaq
	if(k == 1) {
		return pd2(), 0;
	}//qwq
	pd3();//QAQAQAQ
	return 0;
}

/*

12 10 2
1 2
3 4

5 6
6 7
7 8
8 5

9 10
10 11
11 12
12 9

*/


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/">
        </link>
        <updated>2020-09-25T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>浪费生命的3h30min...</p>
<p>A</p>
<p>map</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>比较巧妙</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
//const int MAXN=1e5+7;
int n,m;
map&lt;int,int&gt; mp;
int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y,opt; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;opt);
		if(opt==1) {
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			mp[x]=y;
		} else {
			scanf(&quot;%d&quot;,&amp;x);
			if(mp.find(x)==mp.end()) {
				puts(&quot;0&quot;);
			} else printf(&quot;%d\n&quot;,mp[x]);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>每个点记录状压2^k的状态</p>
<p>然后发现边长为1</p>
<p>可以广度优先搜索</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int,int&gt;
#define se second
#define fi first
#define mkp(x,y) (make_pair(x,y))
const int MAXS=1100;
const int MAXN=5007;
const int MAXM=6007;
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

int n,ccnt,m,k,hd,tl;
int home[MAXN],nxt[MAXM],to[MAXM],w[MAXM],hve[MAXN];

int f[MAXN][MAXS],vis[MAXN][MAXS];//f_uS表示点u在已经有了S之后能不能走过去。。。
pii que[MAXS*MAXN];//不能炸吧。。。

inline void ct(int x,int y,int z) {
	++ccnt;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
	w[ccnt]=z;
}

inline void solve() {
	memset(f,0x3f3f3f3f,sizeof(f));
	f[1][hve[1]]=0;
	vis[1][hve[1]]=1;
	hd=tl=1;
	que[hd]=mkp(1,hve[1]);
	while(hd&lt;=tl) {
		int u=que[hd].fi,S=que[hd].se;
		hd++;
		if(u==n)break;
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i],q=w[i];
			int nS=S|hve[v];
			if(!vis[v][nS] &amp;&amp; ((q&amp;S)==q)) {
				vis[v][nS]=1;
				que[++tl]=mkp(v,nS);
				f[v][nS]=f[u][S]+1;
			}
		}
	}
	int ans=1e9;
	for(int i=0; i&lt;MAXS; ++i)ans=min(ans,f[n][i]);
	if(ans==1e9)printf(&quot;No Solution&quot;);
	else printf(&quot;%d\n&quot;,ans);
	return;
}

int main() {
//	freopen(&quot;test1.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);

	n=read();
	m=read();
	k=read();
	for(int i=1,x; i&lt;=n; ++i) {
		for(int j=0; j&lt;k; ++j) {
			x=read();
			hve[i]|=(x&lt;&lt;j);
		}
	}
	for(int i=1,x,y,z; i&lt;=m; ++i) {
		x=read();
		y=read();
		z=0;
		for(int j=0,p; j&lt;k; ++j) {
			p=read();
			z|=(p&lt;&lt;j);
		}
		ct(x,y,z);//qaq
	}
	solve();//bfs
	return 0;
}


</code></pre>
<p>C</p>
<p>一个质数能被分解成两个质数的乘积</p>
<p>当且仅当质因数指数和为2</p>
<p>问题变得显然,线性筛每个数最小质因子即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e7+7;
int q;
int sum[MAXN];
int pri[MAXN],isp[MAXN],mpr[MAXN];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void init() {
	int tot=0;
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			pri[++tot]=i;
			mpr[i]=i;
		}
		for(int j=1; j&lt;=tot &amp;&amp; i * pri[j] &lt; MAXN; ++j) {
			isp[i*pri[j]]=1;
			mpr[i*pri[j]]=min(pri[j],mpr[i]);
			if(i%pri[j]==0) {
				mpr[i*pri[j]]=pri[j];
				continue;
			}
		}
	}
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			sum[i]=sum[i-1]+1;
		} else {
			int x=i;
			x/=mpr[x];
			x/=mpr[x];
			if(x==1) {
				sum[i]=sum[i-1]+1;
			} else sum[i]=sum[i-1];
		}
	}
	return;
}

int main() {
//	freopen(&quot;test2.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	init();
	q=read();
	for(int i=1,l,r; i&lt;=q; ++i) {
		l=read();
		r=read();
		printf(&quot;%d\n&quot;,sum[r]-sum[l-1]);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>树上链交!</p>
<p>首先判断有没有空集,就是看两者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>的深度哪个更浅</p>
<p>然后把浅的那个LCA和另外两个端点再做LCA,如果有一个等于本身就说明LCA在另外的链上</p>
<p>然后链交大小?</p>
<p>设两条路径为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">LCA(x,u),LCA(x,v),LCA(u,y),LCA(v,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>四个点按照dfs序排下序,然后选取最后两个求dis即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=4e5+7;
int n,q,qwq,depp,ccnt;
int siz[MAXN],dfn[MAXN],dep[MAXN],fa[MAXN],son[MAXN],top[MAXN];
int home[MAXN],nxt[MAXN],to[MAXN];
int a[10];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void dfs1(int u,int F) {
	siz[u]=1;
	dfn[u]=++depp;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dep[v]=dep[u]+1;
		fa[v]=u;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]&gt;siz[son[u]])son[u]=v;
	}
	return ;
}

inline void dfs2(int u,int topf) {
	top[u]=topf;
	if(!son[u])return ;
	dfs2(son[u],topf);
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==fa[u] || v==son[u])continue;
		dfs2(v,v);
	}
}

inline int LCA(int x,int y) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]&lt;dep[top[y]])
			x^=y^=x^=y;
		x=fa[top[x]];
	}
	if(dep[x]&gt;dep[y])x^=y^=x^=y;
	return x;
}

inline bool cmp(const int &amp;x,const int &amp;y) {
	return dfn[x]&lt;dfn[y];
}

inline int DIS(int x,int y) {
	return dep[x]+dep[y]-2*dep[LCA(x,y)];
}

//this is a completely 链交大小
inline void solve(int u,int v,int x,int y) {
	a[1]=LCA(u,x);
	a[2]=LCA(u,y);
	a[3]=LCA(v,x);
	a[4]=LCA(v,y);
	sort(a+1,a+5,cmp);
	printf(&quot;%d\n&quot;,DIS(a[3],a[4])+1);
	return;
}

int main() {
//	freopen(&quot;test3.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	q=read();
	qwq=read();
	for(int i=1,x,y; i&lt;n; ++i) {
		x=read();
		y=read();
		ct(x,y);
		ct(y,x);
	}
	dep[1]=1;
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1,x,y,z; i&lt;=q; ++i) {
		x=read();
		y=read();
		z=read();
		solve(x,y,z,y);//直接链交走人了。。。
	}
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 【LGR-076】洛谷 ⑨ 月月赛 I & Cnoi2020 ]]></title>
        <id>https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/</id>
        <link href="https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/">
        </link>
        <updated>2020-09-24T14:55:05.000Z</updated>
        <content type="html"><![CDATA[<p>呃呃呃本来想打的然后因为数学物理考试咕咕咕了...</p>
<p>说实话都是纸老虎仔细想想就切掉了....</p>
<p>P6832 [Cnoi2020]子弦</p>
<p>可以冲sam吗?.....1e7不太能啊</p>
<p>答案显然就是每个最短的串的出现次数</p>
<p>即统计a~z出现次数</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e7 + 8;
char s[MAXN];
int cnt[50], ans;
int main() {
	scanf(&quot;%s&quot;, s);
	int n = strlen(s);
	for(int i = 0; i &lt; n; ++i) {
		cnt[s[i] - 'a']++;
	}
	for(int i = 0; i &lt; 26; ++i)ans = max(ans, cnt[i]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
<p>P6833 [Cnoi2020]雷雨</p>
<p>一开始就发现了正解然后心里暗示自己是错误的/cy</p>
<p>显然可以做三遍最短路:第一遍是从最上层任意一个点出发到剩下所有点的,第二遍是从红魔馆,第三遍是迷途竹林</p>
<p>然后枚举中间点三者求和即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nmlog(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>因为点数和边数同阶所以dijkstra可过</p>
<p>spfa???老哥这是<strong>网格图</strong>啊</p>
<p>code:</p>
<p>咕咕咕</p>
<p>P6834 [Cnoi2020]梦原</p>
<p>纸老虎1</p>
<p>先想想给出一个树的形态咋做吧....</p>
<p>显然一定每次选极大连通块??</p>
<p>然后如果是链上好像就是积木大赛???</p>
<p>差分数组所有正值加起来???</p>
<p>啊啊啊这好像树上是一样的....</p>
<p>然后树形态不固定好像也会了....</p>
<p>因为显然一个值会在1/k个区间出现啊,他的贡献就是value*1/k</p>
<p>用一个二维数点,求区间比一个数大的数的和/数的出现次数</p>
<p>离线+树状数组即可</p>
<p>注意特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>此时概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>讲述写代码的时候一个sb错误:树状数组的add和取模优化的add重了QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int n,k;
ll fac[MAXN],ifac[MAXN],inv[MAXN];
struct rec {
	int x,id;
	bool operator&lt;(const rec &amp;w) const {
		return x&lt;w.x;
	}
} a[MAXN];

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
const int MAXT=2e6+7;
struct BIT {
#define lowbit(x) (x&amp;-x)
	ll tr[MAXT];
	inline ll qry(int x) {
		ll ret=0;
		if(x==0)return 0;
		for(; x; x-=lowbit(x)) {
			add(ret,tr[x]);
		}
		return ret;
	}
	inline void mdf(int x,ll V) {
		for(; x&lt;=n; x+=lowbit(x))add(tr[x],V);
	}
} tr1,tr2;

inline ll ksm(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&amp;1)ans=ans*x%P;
		x=x*x%P;
		y&gt;&gt;=1;
	}
	return ans;
}

inline void init() {
	fac[0]=1;
	for(int i=1; i&lt;=k; ++i)fac[i]=1ll*fac[i-1]*i%P;
	ifac[k]=ksm(fac[k],P-2);
	ifac[0]=ifac[1]=1;
	for(int i=k-1; i&gt;=2; --i)ifac[i]=1ll*ifac[i+1]*(i+1)%P;
	for(int i=1; i&lt;=k; ++i) {
		inv[i]=1ll*fac[i-1]*ifac[i]%P;
	}
	return ;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf,*pend=buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

signed main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	k=read();
	for(int i=1; i&lt;=n; ++i) {
		a[i].x=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	init();
	ll ans=0;
	for(int i=1; i&lt;=n; ++i) {
		if(a[i].id==1) {
			add(ans,a[i].x);
			tr1.mdf(a[i].id,a[i].x);
			tr2.mdf(a[i].id,1);
			continue;
		}
		int L=max(1ll,a[i].id-k);
		int sum=tr1.qry(a[i].id-1)-tr1.qry(L-1);
		int num=tr2.qry(a[i].id-1)-tr2.qry(L-1);
		add(ans,1ll*(num*a[i].x%P-sum+P)%P*inv[a[i].id-L]%P);
		tr1.mdf(a[i].id,a[i].x);
		tr2.mdf(a[i].id,1);
		//一个统计个数一个统计sum
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}

/*

5 4
1 2 3 4 5

*/


</code></pre>
<p>P6835 [Cnoi2020]线形生物</p>
<p>哇偶!</p>
<p>我:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i走到n的期望值</p>
<p>ljh:太棒了你可以高斯消元!</p>
<p>我:QAQ!</p>
<p>ljh随手在黑板上写了几个式子,然后切掉了!</p>
<p>我:!!!!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>走到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的期望步数</p>
<p>由期望的线性性质我们可以得到答案就是求个和</p>
<p>怎么求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>sum表示f数组前缀和</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></mfrac><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=\frac 1 {in[i]}*(\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+f_i+1)+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>然后我们随便化简一下</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]!=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>做完了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int id,n,m;
ll f[MAXN],sum[MAXN];

int home[MAXN],nxt[MAXN],to[MAXN],ccnt,in[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}

int main() {
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;=m; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		in[x]++;
	}
	for(int i=1; i&lt;=n; ++i) {
		in[i]++;
	}
	//dp！
	ll ans=0;
	for(int u=1; u&lt;=n; ++u) {
		f[u]=1;
		sum[u]=sum[u-1];
		if(in[u]==1) { //只有一步QAQ
			add(ans,1);
			add(sum[u],f[u]);
			continue;
		}
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			add(f[u],(sum[u]-sum[v-1]+1+P)%P);
		}
		add(sum[u],f[u]);
		add(ans,f[u]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr提高组十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/">
        </link>
        <updated>2020-09-22T15:05:50.000Z</updated>
        <content type="html"><![CDATA[<p>阴间的dmy</p>
<p>http://www.zhengruioi.com/contest/703</p>
<p>A</p>
<p>提高组D2T1送分题</p>
<p>但是题面不够长所以qwq</p>
<p>做法:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第一个串匹配到i第二个串匹配到j的最小代价</p>
<p>然后转移:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>!</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i!=b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{i,j}=min(f_{i-1,j-1},min(f_{i-1,j},f_{i,j-1}))+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i==b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>优化:因为答案不会超过50,所以第二维有用的只有100个状态</p>
<p>直接用这些dp即可</p>
<p>其实本题造数据很难把</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+7;
int n;
int f[MAXN][105];
char s[MAXN],t[MAXN];
int main() {
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%s&quot;,t+1);
	int n1=strlen(s+1);
	int n2=strlen(t+1);
	if(n1&lt;n2) {
		swap(n1,n2);
		swap(s,t);
	}
	if(n1-n2&gt;50)return printf(&quot;-1&quot;),0;
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0][50]=0;
	for(int i=1; i&lt;=n1; ++i) {
		for(int j=50; j&gt;=-50; --j) {
			int p=i-j;
			if(p&lt;0 || p&gt;n2)continue;
			if(s[i]==t[p]) {
				f[i][j+50]=f[i-1][j+50];
			} else {
				f[i][j+50]=min(f[i][j+1+50],min(f[i-1][j-1+50],f[i-1][j+50]))+1;
			}
		}
	}
	if(f[n1][n1-n2+50]&gt;50)return printf(&quot;-1&quot;),0;
	printf(&quot;%d\n&quot;,f[n1][n1-n2+50]);
	return 0;
}


</code></pre>
<p>B</p>
<p>神仙数学题</p>
<p>你考虑维护两个L,R是2的幂次,同时满足形式:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111111</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111111(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111112</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111112(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>然后考虑合法成为答案的数x一定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之间</p>
<p>那么这个数字的幂次要尽可能的小于是想到再维护两个和这个差不多的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>Lx表示把前200位拿出来的前缀幂次最小值,<strong>如果不够两百位我们后面用0补齐两百位</strong></p>
<p>Rx表示把前两百位拿出来的前缀幂次最大值<strong>不够两百位也是用零补齐</strong></p>
<p>然后每次用x*Lx,如果正好大于L就是答案,否则我们如果小于Rx就留下更新然后不乘了</p>
<p>否则然后更新一次后我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo>∗</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx*Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>这个值去考虑更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>如果大于Rx更新Rx否则更新Lx</p>
<h2 id="因为我们lxrx的性质他一定满足大于或小于">因为我们Lx,Rx的性质他一定满足大于或小于!</h2>
<p>那你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">LxRx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>的形式都是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000000000</mn><mo>(</mo><mi>x</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1000000000(x个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9999999999</mn><mo>(</mo><mi>y</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9999999999(y个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>所以仔细思考一下我们一定能倍增出第一个合法的了</p>
<p>然后做完了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 100005 /*rem*/
#define mod 998244353
#define db double
#define vi vector&lt;int&gt;
#define pb push_back
#define mp make_pair
#define pi pair&lt;int, int&gt;
#define fi first
#define se second
using namespace std;
ll ksm(ll a, ll b) {
   if (!b) return 1;
   ll ns = ksm(a, b &gt;&gt; 1);
   ns = ns * ns % mod;
   if (b &amp; 1) ns = ns * a % mod;
   return ns;
}
const int mxs = 230; /*reme*/
void upd(vi &amp;a) {
	for (int i = 0; i &lt; a.size(); i++)
		if (a[i] &gt;= 10) {
			if (i == a.size() - 1)
				a.pb(a[i] / 10);
			else a[i + 1] += a[i] / 10;
			a[i] %= 10;
		}	
	if (a.size() &gt; mxs) {
		for (int j = 0; j &lt; mxs; j++)
			a[j] = a[a.size() - mxs + j];
		a.resize(mxs);
	} 
}
void otp(vi a) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		cout &lt;&lt; a[i];
	cout &lt;&lt; endl;
}
vi operator * (vi &amp;a, vi &amp;b) {
	vi c(a.size() + b.size() - 1);
	for (int i = 0; i &lt; c.size(); i++) c[i] = 0;
	for (int i = 0; i &lt; a.size(); i++)
		for (int j = 0; j &lt; b.size(); j++)
			c[i + j] += a[i] * b[j];
	upd(c);
//	cout &lt;&lt;&quot;NUL&quot; &lt;&lt; endl;
//	otp(a), otp(b), otp(c);
	return c;
}
bool operator &lt; (vi &amp;a, vi &amp;b) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		if (a[i] != b[i]) return a[i] &lt; b[i];
	return 0;
} 
vi operator + (vi &amp;a, vi &amp;b) {
	vi c(max(a.size(), b.size()));
	for (int i = 0; i &lt; c.size(); i++) {
		c[i] = 0;
		if (i &lt; a.size())
			c[i] += a[i];
		if (i &lt; b.size())
			c[i] += b[i];
	}
	upd(c);
	return c;
}
struct pw {
	vi a;
	vi b; // ��
	pw(){a.clear(), b.clear();}
	pw(vi x, vi y) {
		a = x, b = y;
	} 
	pw operator * (pw c) {
		
		return pw(a * c.a, b + c.b);
	}
};
pw L, R, cur;
vi lb, mx;
char inp[mxs];
void otp(pw a) {
	otp(a.a), otp(a.b);
}
int main() {
//	freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);
	int l;
	cin &gt;&gt; l;
	for (int i = 0; i &lt; l; i++)
		inp[i] = '1';
	vi u, v;
	for (int i = 0; i &lt; mxs - 1; i++)
		u.pb(0);
	u.pb(2), v.pb(1);	
	for (int i = 0; i &lt; mxs - l; i++)
		lb.pb(0), mx.pb(9);
	for (int i = l - 1; i &gt;= 0; i--)
		lb.pb(inp[i] - '0'), mx.pb(inp[i] - '0'); 
	L = pw(u, v);
	R = pw(u, v);		
	v[0] = 0, u[mxs - 1] = 1;
	cur = pw(u, v);
	while (1) {
	//	otp(L), otp(R);
		while (1) {
			pw ed = cur * L;
		//	otp(ed);
			if (cur.a &lt; ed.a &amp;&amp; ed.a &lt; mx) {
				cur = ed;
				if (!(cur.a &lt; lb)) {
					for (int i = cur.b.size() - 1; i &gt;= 0; i--)
						cout &lt;&lt; cur.b[i];
					cout &lt;&lt; endl;
					return 0;
				}
			}
			else break;
		}
		while (1) {
			pw nr = L * R;
			if (nr.a[mxs - 1] == 1) {
				L = nr;
				break;
			}
			else R = nr;
		}
	}
	return 0;
}



不是自己写的
</code></pre>
<p>C</p>
<p>倒序染色</p>
<p>然后你会发现我们每次还没有染色的相邻的不能染同一种颜色</p>
<p>其他的随便染上当前颜色即可</p>
<p>这个k的构造方式就是每次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">n-n/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">3</span></span></span></span>的迭代到0的次数....</p>
<p>可以证明最后这样染出颜色的方案一定不会存在一个区间的没有出现次数为1的</p>
<p>因为不管怎么样你都会被一个新颜色叉掉</p>
<p>倒序是因为前面的限制严,要用出现次数少的颜色</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
int n, k, a[MAXN];
//考虑用一种颜色染大于sum/3的灯然后我们递归剩下的解决
//我们要小心任何时刻都不能有相临相同的?
int b[MAXN], vis[MAXN], c[MAXN];
vector&lt;int&gt;  near[MAXN];
set&lt;int&gt; st;
inline void init() {
	st.clear();
	st.insert(n + 1);
	st.insert(0);
	for(int i = 1; i &lt;= n; ++i) {
		near[i].clear();
	}
	for(int i = 1; i &lt;= n; ++i)
		if(!vis[i]) {
			auto qwq1 = st.lower_bound(i);
			auto qwq2 = st.upper_bound(i);
			// printf(&quot;%d?%d\n&quot;, qwq1, qwq2);
			// near[a[i]].push_back(*qwq2);
			// near[*qwq2].push_back(a[i]);
			qwq1--;
			near[i].push_back(*qwq1);
			near[i].push_back(*qwq2);
			near[*qwq1].push_back(i);
			near[*qwq2].push_back(i);
			st.insert(i);
		}
	for(int i = 1; i &lt;= n; ++i) {
		if(!vis[i]) {
			sort(near[i].begin(), near[i].end());
			near[i].erase(unique(near[i].begin(), near[i].end()), near[i].end());
			// printf(&quot;%d\n&quot;, i);
			// for(auto v : near[i]) {
			// 	printf(&quot;%d &quot;, v);
			// }
			// puts(&quot;??&quot;);
		}
	}
	return ;
}

inline void solve(int l, int r, int dep) {
	if(l &gt; r)return;
	// printf(&quot;%d %d %d\n&quot;, l, r, dep);
	init();
	int limit = ceil((double)(r - l + 1) / 3);
	// if(limit == 0)limit = 1;
	for(int i = r; i &gt;= l; --i) {
		int p = a[i];
		if(!vis[p]) {
			bool flg = 1;
			// printf(&quot;in- &gt; %d\n&quot;, p);
			for(auto v : near[p]) {
				if(b[v] == dep) {
					// printf(&quot;%d %d???\n&quot;, v, dep);
					flg = 0;
				}
			}
			if(flg) {
				vis[p] = 1;
				b[p] = dep;
				limit--;
				// printf(&quot;%d %d\n&quot;, p, dep);
			}
		}
		if(!limit)break;
	}
	int tot = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(!vis[a[i]]) {
			// printf(&quot;%d?\n&quot;, i);
			c[++tot] = a[i];
		}
	}
	// printf(&quot;tot-&gt;%d\n&quot;, tot);
	for(int i = l; i &lt;= l + tot - 1; ++i) {
		// printf(&quot;%d\n&quot;, c[i - l + 1]);
		a[i] = c[i - l + 1];
	}
	// if(l = l + tot - 1)
	solve(l, l + tot - 1, dep + 1);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	init();
	solve(1, n, 1);
	for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, b[i]);
	puts(&quot;&quot;);
	return 0;
}

/*

3 3
1  2  3

4 3
4 3 2 1

*/



</code></pre>
]]></content>
    </entry>
</feed>