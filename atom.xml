<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-03-14T15:04:18.688Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CF504E Misha and LCP on Tree]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf504e-misha-and-lcp-on-tree/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf504e-misha-and-lcp-on-tree/">
        </link>
        <updated>2020-03-14T14:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<ul>
<li>给定一棵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个节点的树，每个节点有一个小写字母。</li>
<li>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 组询问，每组询问为树上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">c \to d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>组成的字符串的最长公共前缀。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n \le 3 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">m \le 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>树上字符串QAQ先考虑序列上怎么做吧</p>
<p>相当于区间最长公共前缀,可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>二分哈希值来做</p>
<p>放到树上好像就是怎么快速得到一段路径的哈希值</p>
<p>这是一个trick呢,维护每个节点到根的正串(root-&gt;x)hash值和反串(x-&gt;root)hash值</p>
<p>那么从x-&gt;y路径hash值就是先找到LCA,然后dep[x]-dep[LCA]这么长的反串hash值截取出来,然后把dep[y]-dep[LCA]这么长的正串hash值截取出来,二者拼接一下就行了</p>
<p>不过截取是实现不了的,所以我们考虑用二分时的树上k级祖先来代替</p>
<p>比如二分到前L位置,那么先判断L在x-&gt;LCA还是LCA-&gt;y上,然后一个k级祖先把它找到拿k级祖先处的字符串来比较就可以了</p>
<p>看代码吧qwq</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define lg2(x)(31-__builtin_clz(x))
using namespace std;
#define ll long long

const int MAXN=3e5+7;
const int md1=1004535809,md2=167772161;
int base1,base2;
int _1[MAXN],_2[MAXN],n,m;
int i1[MAXN],i2[MAXN];
char s[MAXN];
int home[MAXN],ccnt;
int mxd[MAXN],toph[MAXN],tail[MAXN],sonh[MAXN],fa[MAXN],len[MAXN],F[20][MAXN],dep[MAXN],idx,dfn[MAXN];
int *up[MAXN],*down[MAXN];
int st[20][MAXN&lt;&lt;1];

inline int inv(int a,const int &amp;P) {
	ll ans=1,b=P-2;
	while(b) {
		if(b&amp;1)ans=ans*a%P;
		a=1ll*a*a%P;
		b&gt;&gt;=1;
	}
	return ans;
}
struct edge {
	int to,nxt;
} e[MAXN&lt;&lt;1];

struct data {
	int s1,s2;
	int len;
	inline void push_front(char c) {
		s1=(s1+1ll*c*_1[len])%md1,s2=(s2+1ll*c*_2[len++])%md2;
	}
	inline void push_back(char c) {
		s1=(1ll*s1*base1+c)%md1,s2=(1ll*s2*base2+c)%md2,++len;
	}
	inline data operator+(const data &amp;rhs)const {
		return (data) {
			(1ll*s1*_1[rhs.len]+rhs.s1)%md1,(1ll*s2*_2[rhs.len]+rhs.s2)%md2,len+rhs.len
		};
	}
	inline bool operator==(const data &amp;rhs)const {
		return s1==rhs.s1&amp;&amp;s2==rhs.s2&amp;&amp;len==rhs.len;
	}
} a[MAXN],b[MAXN];

inline void dfs(int nw) {
	st[0][dfn[nw]=++idx]=nw;
	sonh[nw]=0,mxd[nw]=dep[nw];//mxd就是maxdep
	a[nw]=a[fa[nw]],b[nw]=b[fa[nw]];
	a[nw].push_back(s[nw]),b[nw].push_front(s[nw]);
	for(int i=home[nw]; i; i=e[i].nxt) {
		int v=e[i].to;
		if(!dep[v]) {
			dep[v]=dep[nw]+1;
			fa[v]=F[0][v]=nw;
			dfs(v);
			st[0][++idx]=nw;
			if(mxd[v]&gt;mxd[nw])mxd[nw]=mxd[v],sonh[nw]=v;
		}
	}
}
inline void dfs2(int nw) {
	tail[toph[nw]]=nw;
	len[toph[nw]]=dep[nw]-dep[toph[nw]]+1;
	if(sonh[nw])toph[sonh[nw]]=toph[nw],dfs2(sonh[nw]);
	for(int i=home[nw]; i; i=e[i].nxt) {
		int v=e[i].to;
		if(dep[v]&gt;dep[nw]&amp;&amp;v!=sonh[nw])dfs2(toph[v]=v);
		//标准长链剖分
	}
}

inline int kfa(int x,int k) {
	if(dep[x]&lt;=k)return 0;
	if(k==0)return x;
	const int lg=lg2(k);
	x=F[lg][x],k-=1&lt;&lt;lg;
	if(!k)return x;
	const int dlt=dep[x]-dep[toph[x]];
	if(dlt&gt;=k)return down[toph[x]][dlt-k];
	return up[toph[x]][k-dlt];
}

inline int LCA(int x,int y) {
	if(dfn[x]&gt;dfn[y])swap(x,y);
	x=dfn[x],y=dfn[y];
	int lg=lg2(y-x+1);
	int a=st[lg][x],b=st[lg][y-(1&lt;&lt;lg)+1];
	return (dep[a]&lt;dep[b])?a:b;
}

inline void init() {
	for(int i=1; i&lt;19; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			F[i][j]=F[i-1][F[i-1][j]];//倍增处理
		}
	}
	for(int i=1; i&lt;=n; ++i) {
		if(toph[i]==i) {
			int h=len[i];
			up[i]=new int[h+2];
			down[i]=new int [h+2];//动态开空间处理
			*up[i]=*down[i]=i;
			for(int j=1,nw=fa[i]; j&lt;=h&amp;&amp;nw; ++j,nw=fa[nw]) {
				up[i][j]=nw;
			}
			for(int j=1,nw=sonh[i]; j&lt;=h&amp;&amp;nw; ++j,nw=sonh[nw]) {
				down[i][j]=nw;
			}
		}
	}
	for(int i=1; i&lt;20; ++i) {
		for(int j=1; j&lt;=2*n; ++j) {
			int x=st[i-1][j],y=st[i-1][j+(1&lt;&lt;i-1)];
			st[i][j]=(dep[x]&lt;dep[y])?x:y;//st±í¿ì°¡
		}
	}
}

inline data get(int u,int v) {
	const data &amp;x=b[u],&amp;y=b[v];
	return (data) {
		1ll*(x.s1-y.s1+md1)*i1[y.len]%md1,1ll*(x.s2-y.s2+md2)*i2[y.len]%md2,x.len-y.len//暴力截取
	};
}

inline data get_(int u,int v) {
	const data&amp;x=a[u],&amp;y=a[v];
	return (data) {
		(y.s1-1ll*x.s1*_1[y.len-x.len]%md1+md1)%md1,(y.s2-1ll*x.s2*_2[y.len-x.len]%md2+md2)%md2,y.len-x.len//暴力截取2
	};
}

int main() {
	srand(time(0));
	base1=rand()%100+200,base2=rand()%300+400;
	scanf(&quot;%d%s&quot;,&amp;n,s+1);
	_1[0]=_2[0]=i1[0]=i2[0]=1;
	for(int i=1; i&lt;=n; ++i)_1[i]=1ll*_1[i-1]*base1%md1,_2[i]=1ll*_2[i-1]*base2%md2;
	i1[1]=inv(base1,md1);
	i2[1]=inv(base2,md2);
	for(int i=2; i&lt;=n; ++i) {
		i1[i]=1ll*i1[i-1]*i1[1]%md1,i2[i]=1ll*i2[i-1]*i2[1]%md2;
	}
	for(int i=1; i&lt;n; ++i) {
		int u,v;
		scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
		e[++ccnt]=(edge) {v,home[u]},home[u]=ccnt;
		e[++ccnt]=(edge) {u,home[v]},home[v]=ccnt;
	}
	dfs(dep[1]=1),dfs2(toph[1]=1);
	init();
	//for(int i=1;i&lt;=n;++i)printf(&quot;%d %d %d\n&quot;,dep[i],toph[i],fa[i]);
	//puts(&quot;qwq&quot;);
	for(scanf(&quot;%d&quot;,&amp;m); m--;) {
		int u1,v1,u2,v2;
		scanf(&quot;%d%d%d%d&quot;,&amp;u1,&amp;v1,&amp;u2,&amp;v2);
		int L1=LCA(u1,v1),L2=LCA(u2,v2);
	//	printf(&quot;%d %d\n&quot;,L1,L2);
		const int D1=dep[u1]+dep[v1]-2*dep[L1]+1,D2=dep[u2]+dep[v2]-2*dep[L2]+1;//找到长度
		int l=1,r=min(D1,D2),ans=0;
		while(l&lt;=r) {
			const int mid=l+r&gt;&gt;1;
			const data _x=dep[u1]-mid+1&gt;=dep[L1]?get(u1,kfa(u1,mid)):get(u1,L1)+get_(fa[L1],kfa(v1,D1-mid));//要么在LCA左边路径,要么左边全部和右边k级祖先反串
			const data _y=dep[u2]-mid+1&gt;=dep[L2]?get(u2,kfa(u2,mid)):get(u2,L2)+get_(fa[L2],kfa(v2,D2-mid));
			if(_x==_y)l=(ans=mid)+1;
			else r=mid-1;
		}//即可
		printf(&quot;%d\n&quot;,ans);
	}
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF516D Drazil and Morning Exercise]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf516d-drazil-and-morning-exercise/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf516d-drazil-and-morning-exercise/">
        </link>
        <updated>2020-03-14T14:01:09.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>不扯那些玄乎的直接看题</p>
<p>题目描述：一棵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个点的树，设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>u</mi><mo>)</mo><mo>=</mo><msub><mi>max</mi><mo>⁡</mo><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow></msub><mtext>dis</mtext><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d(u)=\max_{v\in V}\text{dis}(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">dis</span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，每次询问一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，求一个最大的联通子图<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>∈</mo><mi>L</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>d</mi><mo>(</mo><mi>u</mi><mo>)</mo><mo>−</mo><mi>d</mi><mo>(</mo><mi>v</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">\forall u,v\in L,|d(u)-d(v)|\leq l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>;输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>L</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|L|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">L</span><span class="mord">∣</span></span></span></span>.</p>
<p>数据范围：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mi>w</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup><mo separator="true">,</mo><mi>l</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>11</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">n\leq 10^5,w\leq 10^6,l\leq 10^{11},q\leq 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></p>
<p>首先我们有个很直接的想法是求出树的直径,因为这样就能快速求出d值了</p>
<p><s>其实单求dis值就是普及难度吧</s></p>
<p>然后我们再考虑q这么小,一定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>一组</p>
<p>再加上最大减去最小能联想到什么?莫队?但<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>一组?尺取!</p>
<p>但是不能瞎尺取,我们再利用一下d的性质</p>
<p><code>仔细一想:dis值从直径中点开始向四周递减!</code></p>
<p>那么有了这个就可以保证以中点为根,从根到叶子的dis值递增</p>
<p>就意味着如果我们把点权排个序,然后在上面用区间尺取,从maxdis向外弹出,相当于从连通块中删除叶子,就能保证我们尺取的区间覆盖答案的连通块</p>
<p>怎么快速判断尺取的区间连通块?这是并查集问题</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=BUF_SIZE+buf,*pend=BUF_SIZE+buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline ll read() {
		ll x=0,f=1;
		register char s=nc();
		for(; !isdigit(s); s=nc())if(s=='-')f=-1;
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x*f;
	}
}
using namespace fastIO;

const int MAXN=1e5+7;
int n,ans;
struct rec {
	int to,nxt,w;
} e[MAXN*2];
int home[MAXN],tot,rt,fa[MAXN],p[MAXN],siz[MAXN],vis[MAXN];
ll dis[MAXN],d[MAXN];

inline void add(int w,int u,int v) {
	e[++tot]=(rec) {
		v,home[u],w
	};
	home[u]=tot;
	e[++tot]=(rec) {
		u,home[v],w
	};
	home[v]=tot;
}

void dfs(int u,int fa) {
	d[u]=max(d[u],dis[u]);
	if(dis[u]&gt;dis[rt])rt=u;
	for(int i=home[u]; i; i=e[i].nxt) {
		int v=e[i].to;
		if(v!=fa)dis[v]=dis[u]+e[i].w,dfs(v,u);
	}//这里做一下dp,找到距离最远者
}

int find(int x) {
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}

void merge(int x,int y) {
	x=find(x);
	y=find(y);
	if(x==y)return ;
	if(siz[y]&gt;siz[x])swap(x,y);
	siz[x]+=siz[y];//启发式合并
	ans=max(ans,siz[x]);
	fa[y]=x;
}

bool cmp(const int &amp;a, const int &amp;b) {
	return d[a]&lt;d[b];
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	for(int i=1; i&lt;n; ++i)add(read(),read(),read());
	dfs(1,0);
	int tmp=rt;
	dis[rt]=0;
	rt=0;
	dfs(tmp,0);//找 到 直 径
	//并完成d
	dis[rt] =0;
	dfs(rt,0);

	for(int i=1; i&lt;=n; ++i)p[i]=i;
	sort(p+1,p+n+1,cmp);
	//把点按照d值排序
	int q=read();
	ll lim;
	while(q--&gt;0) {
		lim=read();
		for(int i=1; i&lt;=n; ++i)fa[i]=i,siz[i]=1,vis[i]=0;
		//init
		ans=1;
		for(int k=n,j=n; k&gt;=1; --k) {
			while(d[p[j]]&gt;d[p[k]]+lim) {
				//j这个点不行
				//弹出来
				--siz[find(p[j])];
				--j;
				//换下一个的啦
			}
			vis[p[k]]=1;
			//相当于我们左端点靠枚举,右端点尺取
			for(int i=home[p[k]]; i; i=e[i].nxt) {
				int v=e[i].to;
				if(vis[v])merge(p[k],v);
				//merge一下表示那些点都归我管
				//主要是为了ans的更新---取最大连通块
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF512D Fox And Travelling]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf512d-fox-and-travelling/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf512d-fox-and-travelling/">
        </link>
        <updated>2020-03-14T10:07:50.000Z</updated>
        <content type="html"><![CDATA[<p>第一篇博客</p>
<p>IOI2020集训队作业</p>
<p>首先我们考虑环中的点一定不会被遍历,然后我们就可以把环中点扔掉</p>
<p>紧接着我们有一些有根树和无根树,有根树就是树中唯一和环相连的,因为这样的点只能在在最后选</p>
<p>那么有根树上怎么树上背包呢?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>∗</mo><mi>f</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]+=f[x][j]*f[y][k]%P*(C(j+k,j))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p>
<p>相当于我们有个长度为j+k的序列向里面放一个长度为j的序列和一个长度为k的序列,肯定先硬点j个位置</p>
<p>无根树?枚举那个点做根然后有根树dp</p>
<p>最后不同的数背包+组合数合起来</p>
<p>注意无根树中一个j个点方案会被多算siz-j次</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=107;
const int P=1e9+9;
int n,m,d[MAXN],w[MAXN],b[MAXN],s[MAXN],S;
vector&lt;int&gt; e[MAXN];
ll p[MAXN],v[MAXN],vp[MAXN],f[MAXN][MAXN],ans[MAXN];

inline int read() {
	int x=0,f=1;
	char s=getchar();
	for(; !isdigit(s); s=getchar());
	for(; isdigit(s); s=getchar())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
	return x;
}

inline ll C(int a,int b) {
	return p[a]*vp[b]%P*vp[a-b]%P;
}

void dfs(int x,int o,int &amp;s) {
	b[x]=o,++s;//拉出每个点所属的跟
	for(unsigned int i=0; i&lt;e[x].size(); ++i) {
		int y=e[x][i];
		if(!d[y]&amp;&amp;!b[y])dfs(y,o,s);
	}
	return ;
}

inline void dp(int x,int fa) {
	s[x]=1,f[x][0]=1;
	for(unsigned int i=0; i&lt;e[x].size(); ++i) {
		int y=e[x][i];
		if(b[x]!=b[y]||y==fa)continue;
		dp(y,x);
		for(int j=0; j&lt;s[y]; ++j)f[x][s[x]+j]=0;
		for(int j=s[x]-1; ~j; --j) {//注意这里要减1
			for(int k=1; k&lt;=s[y]; ++k) {
				f[x][j+k]=(f[x][j+k]+f[x][j]*f[y][k]%P*(C(j+k,j))%P)%P;
				//同一棵树上相当于dp了顺序
			}
		}
		s[x]+=s[y];//siz的意思
	}
	f[x][s[x]]=f[x][s[x]-1];//只能这么转移了
}

inline void get(int x) {
	dp(x,0);
	for(int i=0; i&lt;=s[x]; ++i)f[0][i]=(f[0][i]+f[x][i])%P;
	//卷一下 
}

inline ll ksm(ll x,int y) {
	ll ans=1;
	while(y) {
		if(y&amp;1)ans=ans*x%P;
		x=x*x%P;
		y&gt;&gt;=1;
	}
	return ans;
}

int main() {
	n=read();
	m=read();
	p[0]=v[0]=1;
	for(int i=1; i&lt;=n; ++i)p[i]=p[i-1]*i%P;
	vp[n]=ksm(p[n],P-2);
	for(int i=n; i; --i)v[i]=p[i-1]*vp[i]%P,vp[i-1]=vp[i]*i%P;
//三种逆元?
//阶乘,逆阶乘逆元,单数
	for(int i=1,x,y; i&lt;=m; ++i)x=read(),y=read(),e[x].push_back(y),e[y].push_back(x),++d[x],++d[y];
	queue&lt;int&gt; q;
	for(int i=1; i&lt;=n; ++i)if(d[i]&lt;=1)w[i]=1,q.push(i);
	//叶子结点!w是vis数组
	while(q.size()) {
		int x=q.front();
		q.pop();
		for(unsigned int i=0; i&lt;e[x].size(); ++i) {
			int y=e[x][i];
			if(--d[y]&lt;=1&amp;&amp;!w[y])w[y]=1,q.push(y);//当前的叶子节点
		}
	}
	for(int i=1; i&lt;=n; ++i)
		if(d[i] == 1)dfs(i,i,s[i]);//从这些点出发dfs,统计大小和父亲
	for(int i=1; i&lt;=n; ++i)if(!d[i]&amp;&amp;!b[i])dfs(i,i,s[i]);//我不联通的呢
	ans[0]=1;
	for(int i=1; i&lt;=n; ++i)
		if(i==b[i]) {
			int o=s[i];
			if(d[i]==1)get(i);
			else {
				for(int j=1; j&lt;=n; ++j)
					if(b[j]==i)get(j);//遍历这整棵树做根
				for(int j=0; j&lt;=o; ++j)f[0][j]=f[0][j]*v[o-j]%P;
				//j个点的方案会被多算o-j次,因为在枚举o-j剩下的点做根的时候又会算一遍
			}
			for(int j=S; ~j; --j) {
				for(int k=1; k&lt;=o; ++k) {
					ans[j+k]=(ans[j+k]+ans[j]*f[0][k]%P*C(j+k,j)%P)%P;//0一定要走了
				}
			}
			//这里背包一下
			for(int j=0; j&lt;=o; ++j)f[0][j]=0;
			//清空一下
			S+=o;
		}
	for(int i=0; i&lt;=n; ++i)printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博主所说]]></title>
        <id>https://xiaxiaoguang.github.io/post/bo-zhu-suo-shuo/</id>
        <link href="https://xiaxiaoguang.github.io/post/bo-zhu-suo-shuo/">
        </link>
        <updated>2020-03-14T00:16:32.000Z</updated>
        <content type="html"><![CDATA[<p>目前在洛谷博客上的老东西可能会搬过来,不过大概率不会的</p>
<p>但是新东西还是会在这上面写</p>
<p>不为什么,因为花了1h搭建</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://xiaxiaoguang.github.io/post/hello-gridea/</id>
        <link href="https://xiaxiaoguang.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>