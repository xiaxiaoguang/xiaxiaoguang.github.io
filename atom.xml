<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-10-05T12:17:38.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化讲课(Day 5)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-jiang-ke-day-5/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-jiang-ke-day-5/">
        </link>
        <updated>2020-10-05T06:42:21.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601880403208.png" alt="" loading="lazy"></figure>
<p>菜啊</p>
<p>异或粽子的做法</p>
<p>前缀和</p>
<p>维护所有右端点当且最小左端点,然后我们每次找全局的右端点-左端点最大值</p>
<p>取出一个就把区间左右边的add进堆里</p>
<p>这样一直做下去直到找齐k个</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601880494617.png" alt="" loading="lazy"></figure>
<p>显然这个东西在排序意义下就是取中位数</p>
<p>那么就是动态维护区间中位数</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601882617595.png" alt="" loading="lazy"></figure>
<p>显然可以线段树二分,从最左侧到最右侧一次放广告,找到最左边第一个能放广告的位置,就把放进去剪掉空余</p>
<p>一直模拟到n即可</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601882696048.png" alt="" loading="lazy"></figure>
<p>还是要维护一下的,前缀最大空房间位置,后缀最大空房间位置,然后一个区间总的最大空房间</p>
<p>然后线段树二分,能向左就向左</p>
<p>合并的时候两边最大和中间最大取max</p>
<p>然后修改直接把那些区间拿出来改改</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601883312053.png" alt="" loading="lazy"></figure>
<p>堵塞的交通都是有毛病的题</p>
<p>维护一个区间左边一列连通性,右边一列连通性,区间连通块数</p>
<p>然后合并时候,我们考虑下左右连通新联通情况</p>
<p>同一连通块可以用一个编号存下</p>
<p>然后中间连通信息可以推出新的左右连通信息!</p>
<p>我们最多5个二进制位可以记录一个编号,那么20个数也可以用两个longlong存下,左边一个右边一个</p>
<p>合并的时候直接分配新标号</p>
<p>同时我们也可以计算出新减少的连通块数,因为但凡中间能够产生一次新的合并就要-1</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601886002030.png" alt="" loading="lazy"></figure>
<p>偶数次???好像奇数次我们很会做</p>
<p>会发现我们是可以数据结构的</p>
<p>那么我们首先可以算出所有不同的数异或和</p>
<p>然后我们查出一个异或和之后异或上奇数的异或和即可</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601887892141.png" alt="" loading="lazy"></figure>
<p>线段树维护那个EI/se</p>
<p>然后合并的时候也是异或一下</p>
<p>考虑每一位拿出来,然后新的式子是:</p>
<p>(^^<sup>+</sup>^<sup>+</sup>^<sup>+)</sup>(+ + + +)</p>
<p>显然第i位加起来的信息可以处理,每一位异或起来有多少1可以处理,每一位有多少一可以处理</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1601892854693.png" alt="" loading="lazy"></figure>
<p>默念口诀:</p>
<p>导函数值单增最大化单调栈</p>
<p>导函数值单减最大化单调队列</p>
<p>证明?</p>
<p>你考虑我们时间点只可能越来优,但是一开始可能还不到那个时间</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1601894416862.png" alt="" loading="lazy"></figure>
<p>一开始想三个数组每个元素找一个最小的出现位置,然后三个lst最小出现位置求和</p>
<p>这样假了</p>
<p>14567892<br>
3333332</p>
<p>n^2显然可以枚举两个第三个单调变化</p>
<p>然后我们考虑枚举第一个,然后快速<strong>查询</strong>二三个数组的答案,<br>
那么我们就能快速解决了</p>
<p>先考虑从后向前删除,因为加入限制显然比撤销限制更好做</p>
<p>把A数组每个值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,钦点一个(x,y),x表示在第二个数组中最早出现的位置,y表示第三个数组最早出现的位置</p>
<p>然后我们要做的就是有最小的矩形把所有点都覆盖了</p>
<p>并不这样的,我们是要用最少的矩形把所有<strong>权值</strong>都覆盖了</p>
<p>但是由于我们每个点可能有相同的权值,所有很自闭</p>
<p>那么我们就仔细观察一下可能成为决策的那些点</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1601894934975.png" alt="" loading="lazy"></figure>
<p>就是那些<strong>拐点</strong>!</p>
<p>为什么?</p>
<p>因为别忘了,我们的数组是<strong>小于等于</strong>,而现在点只是小于</p>
<p>选一个拐点就选了左及下方所有点</p>
<p>所以我们会发现这个拐点的右上方矩阵一定没有用了,因为不存在一个更早的元素</p>
<p>所以我们现在要维护的是:</p>
<ol>
<li>一个类似于凸包的阶梯</li>
<li>所有拐点答案最大值</li>
</ol>
<p>做法:</p>
<p>用set维护阶梯,即可,插入一个点会把那些都小于等于它的删掉,做法就是找到第一维大于他的然后向前跳,直到第二维不满足了</p>
<p>当然也要看第一个第一维大于他的</p>
<p>用heap维护答案也很显然,被删掉就lazypop,加入就push</p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1601896182256.png" alt="" loading="lazy"></figure>
<p>显然这个题可以魔法森林</p>
<p>枚举一维,LCT一维</p>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1601896586064.png" alt="" loading="lazy"></figure>
<p>显然这个题可以根号平衡</p>
<p>O(1)修改,O(\sqrtn)查询</p>
<p>然后大小分块第一个</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1601897052737.png" alt="" loading="lazy"></figure>
<p>我的做法:</p>
<p>序列分块,时域分块</p>
<p>首先每个区间可以分块,记录答案</p>
<p>会发现修改后我们每个块暴力打标记即可</p>
<p>然后每个时域可以分块,当我们查到边角块的时候,暴力下放根号次修改即可</p>
<p>然后你会发现我们要每根号次重构,总复杂度就是什么<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtm at position 4: O(n\̲s̲q̲r̲t̲m̲+m\sqrtn)'>O(n\sqrtm+m\sqrtn)</span></p>
<p>std:</p>
<p>上述做法愚蠢在于我们不能快速得到一些a的值</p>
<p>考虑我们把a分个块,然后你会发现修改一个a的值可以做到<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtn at position 1: \̲s̲q̲r̲t̲n̲'>\sqrtn</span></p>
<p>然后查询一个a的值可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mn>1</mn><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">O1 qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></p>
<p>然后函数我们也暴力分块就好了</p>
<p>做完了</p>
<p>小z的袜子</p>
<p>?</p>
<p>莫队的一个优化,奇偶分治</p>
<p>但是不要用了,飞哥亲口说的</p>
<p>就是左端点分块,相同右端点直接单增</p>
<p>优化就是左边的块是奇数的时候按照升序排序,否则按照降序排序</p>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1601899038885.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1601899052301.png" alt="" loading="lazy"></figure>
<p>其实就是康拓展开的写法,考虑先停到哪个位置,然后我们再计算后面的贡献就好了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第五场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-wu-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-wu-chang/">
        </link>
        <updated>2020-10-05T06:01:41.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>首先分析下题目性质</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>只比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>天多1</p>
<p>然后只比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>多2</p>
<p>那么会发现i要花费的天数可以是想化一些天追上i-1,然后在追上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的前提下去追<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>...</p>
<p>那么如果我们没追上i-1就追上i-2的话...<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>也一定可以用哪个时间追上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>这个东西就比较显然....相邻取min</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 1e6 + 7;

int n, a[MAXN], ans;

signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	ans = 1e15;
	for(int i = 1; i &lt; n; ++i) {
		ans = min(ans, a[i] - a[i + 1]);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>B</p>
<p>曼哈顿距离,屑啊</p>
<p>显然我们前n/2大的都要在左边,后n/2大的在右边</p>
<p>那么我们只需要看看那些位置不满足这个性质,然后把他们任意交换就好了</p>
<p>因为是曼哈顿距离....所以就是后n/2前n/2大的下标之和-前n/2后n/2大的下标之和</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
#define ll long long
ll ans;
int n;
struct  rec {
	int x, id;
	bool operator&lt;(const rec &amp;w)const {
		return x &lt; w.x;
	}
} a[MAXN];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].x);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	for(int i = 1; i &lt;= n / 2; ++i) {
		if(a[i].id &gt; n / 2) {
			ans += a[i].id;
		}
	}
	for(int i = n / 2 + 1; i &lt;= n; ++i) {
		if(a[i].id &lt;= n / 2) {
			ans -= a[i].id;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>显然我们直接排序然后k个分一组是错误的,因为我们切换字符可以直接砍掉一堆</p>
<p>但是这个东西是可以在trie树上做的</p>
<p>我们把所有串插入trie然后在上面dfs即可,统计每个子树和,然后我们回溯的时候如果子树中够k个就凑一下</p>
<p>因为这样做能保证每个组尽可能的深的地方匹配,所以是对的</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>26</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*26)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e6 + 7;
int n, k;
char s[MAXN];
int rt = 1, T = 1;
int ch[MAXN][27];
int ed[MAXN];
inline void ins(char *s, int L) {
	int nw = rt;
	for(int i = 0; i &lt; L; ++i) {
		int t = s[i] - 'a';
		if(!ch[nw][t]) {
			ch[nw][t] = ++T;
		}
		nw = ch[nw][t];
	}
	ed[nw]++;//kk
	return ;
}

ll ans;
inline void dfs(int u, int dep) {
	for(int i = 0; i &lt; 26; ++i) {
		if(ch[u][i]) {
			dfs(ch[u][i], dep + 1);
			ed[u] += ed[ch[u][i]];
		}
	}
	ans += 1ll * dep * (ed[u] / k);
	ed[u] %= k;
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%s&quot;, s);
		int l = strlen(s);
		ins(s, l);
	}
	dfs(1, 0);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>D</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><msqrt><mrow><mo>∑</mo><mi>K</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">k&gt;\sqrt{\sum{K}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30500499999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.934995em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-2.894995em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30500499999999997em;"><span></span></span></span></span></span></span></span></span></p>
<p>考虑直接暴力,可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>K</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(K(n+m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>做法就是把每个位置修改一下然后再考虑m次暴力即可</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><msqrt><mrow><mo>∑</mo><mi>K</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">k&lt;\sqrt{\sum{K}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30500499999999997em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.934995em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span><span style="top:-2.894995em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30500499999999997em;"><span></span></span></span></span></span></span></span></span></p>
<p>考虑快速回答询问</p>
<p>显然的是这个询问不会很快...此时会发现我们能够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">k^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>二维数点了</p>
<p>李队有一个O(1)回答的做法,好像是根号平衡啊</p>
<p>就是考虑用前缀和分块,然后我们修改复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>二维平面上我们就直接扫描线扫过去</p>
<p>可以离线做到一个log,复杂度<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sqrtQ at position 5: O(Q \̲s̲q̲r̲t̲Q̲ ̲log)'>O(Q \sqrtQ log)</span></p>
<p>code:</p>
<pre><code class="language-cpp">
//数据处理题
//超高校级的幸运
//如果数据随机,\sum_K会减少的很快,暴力就快
//如果构造去他妈的
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 5e5 + 7;
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int n, m, q, Bas, ccnt;
int home[MAXN], nxt[MAXN], tl[MAXN], tr[MAXN], ans[MAXN];
int q1[MAXN], q2[MAXN], t1, t2, a[MAXN];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	tl[ccnt] = y;
	tr[ccnt] = z;
}

const int BIG = 1e7 + 8;

struct rec {
	int u, v, x, y;
	rec(int u = 0, int v = 0, int x = 0, int y = 0) : u(u), v(v), x(x), y(y) {};
	bool operator&lt;(const rec &amp;w) const {
		return u == w.u ? x &lt; w.x : u &lt; w.u;
	}
} e[MAXN], qry[MAXN], mda[BIG];

inline void solve1() {
	for(int i = 1; i &lt;= t1; ++i) {
		int id = q1[i];
		for(int k = home[qry[id].v]; k; k = nxt[k]) {
			int L = tl[k];
			int R = tr[k];
			for(int  j = L; j &lt;= R; ++j)
				a[j] = i;
		}
		for(int j = 1; j &lt;= m; ++j) {
			if(a[e[j].u] == i &amp;&amp; a[e[j].v] == i) {
				ans[qry[id].v] = 1;
				break;
			}
		}
	}
	return ;
}

struct bit {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN];
	inline void add(int x, int V) {
		for(; x &lt;= n; x += lowbit(x))
			tr[x] += V;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tre;
#define  lowbit(x) (x&amp;(-x))
inline void solve2() {
	int tot = 0;
	for(int t = 1; t &lt;= t2; ++t) {
		int i = q2[t];
		for(int j = home[qry[i].v]; j; j = nxt[j]) {
			for(int k = j; k; k = nxt[k]) {
				mda[++tot] = (rec) {
					tl[k] - 1, tl[j], tr[j], -qry[i].v
				};
				mda[++tot] = (rec) {
					tr[k], tl[j], tr[j], qry[i].v
				};
			}
		}
	}
	for(int i = 1; i &lt;= m; ++i) {
		mda[++tot] = (rec) {
			e[i].u, e[i].v, -1
		};
	}
	sort(mda + 1, mda + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mda[i].x == -1) {
			tre.add(mda[i].v, 1);
		} else if(mda[i].y &gt; 0) {
			if(mda[i].v == 1)ans[mda[i].y] += tre.qry(mda[i].x);
			else ans[mda[i].y] += tre.qry(mda[i].x) - tre.qry(mda[i].v - 1);
		} else {
			mda[i].y = -mda[i].y;
			if(mda[i].v == 1)ans[mda[i].y] -= tre.qry(mda[i].x);
			else ans[mda[i].y] -= tre.qry(mda[i].x) - tre.qry(mda[i].v - 1);

		}
	}
	return ;
}
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	n = read();
	m = read();
	q = read();
	for(int i = 1; i &lt;= m; ++i) {
		e[i].u = read();
		e[i].v = read();
		if(e[i].u &gt; e[i].v)swap(e[i].u, e[i].v);
	}
	for(int i = 1; i &lt;= q; ++i) {
		qry[i].u = read();
		qry[i].v = i;
		for(int j = 1, x, y; j &lt;= qry[i].u; ++j) {
			x = read();
			y = read();
			ct(i, x, y);
		}
	}
	Bas = 1e4;
	int res	 = 4e6; //循环展开
	sort(qry + 1, qry + q + 1);
	int i = q;
	int cnt = 1e8 / max(n, m);
	for(; i &gt;= 1; --i) {
		if(qry[i].u * qry[i].u &gt;= Bas &amp;&amp; cnt) {
			q1[++t1] = i;
			--cnt;
		} else {
			break;
		}
	}
	int j = 1;
	for(; j &lt;= i; ++j) {
		if(res) {
			q2[++t2] = j;
			res = max(0, res - qry[j].u * qry[j].u);
		} else {
			q1[++t1] = j;
		}
	}
	solve1();//暴力1
	solve2();//暴力2
	for(int i = 1; i &lt;= q; ++i) {
		if(ans[i])printf(&quot;GG\n&quot;);
		else printf(&quot;SAFE\n&quot;);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化讲课(Day 4)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-jiang-ke-day-4/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-jiang-ke-day-4/">
        </link>
        <updated>2020-10-04T07:55:39.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601798652801.png" alt="" loading="lazy"></figure>
<p>我们肯定可以按照拓扑序删点</p>
<p>然后先删掉有n-1个点链的,再依次删下去</p>
<p>floyed传递闭包,得到连通性</p>
<p>然后我们考虑一个点能被多少点到达,同时能到达多少点</p>
<p>如果这个加起来为n-1,那我一定能确定他的排名,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601798662083.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601805994918.jpg" alt="" loading="lazy"></figure>
<p>大于等于最长路小于等于最短路</p>
<p>这个显然可以用点表示前缀和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>−</mo><mi>c</mi><mo>&lt;</mo><mo>=</mo><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">S_i-c&lt;=S_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后就能建出图了!</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601806374206.png" alt="" loading="lazy"></figure>
<p>经典题了</p>
<p>显然我们只要知道每个长为1的区间的奇偶性</p>
<p>那么显然我只要知道r-1和r的奇偶关系</p>
<p>显然一个区间查询可以知道前缀和区间l-1和r的奇偶性</p>
<p>然后我们可以通过奇偶性推导,也就是说一个连通块里的都是可以相互推出的</p>
<p>那么就做完了qwq我们只需要把每条边连接l-1和r,然后最小生成树即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">sum_0=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>已知,剩下都可以推导出</p>
<p>tarjan求LCA</p>
<p>离线O(n)</p>
<p>维护并查集</p>
<p>回溯的时候我们再把儿子和父亲合并</p>
<p>然后你会发现我们dfs到点x,之后再某一时刻dfs到y的时候,我们一定没有回溯到lca以上的位置</p>
<p>这样我们就可以在并查集里面查询x的祖先是什么即可</p>
<p>也就是说,我们把询问挂在dfn序大的那个点上,然后回溯到那个点,查询另一个点在并查集里的祖先</p>
<p>正确原因就是dfs过程不会回溯到LCA以上的祖先</p>
<p>严格次小生成树</p>
<p>考虑建出最小生成树然后拿非树边去替换</p>
<p>查询路径最小值</p>
<p>这样做的问题是我们得出的可能会因为非树边和最小树边相等而错掉</p>
<p>所以我们还要记录一个最小的</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601808370203.png" alt="" loading="lazy"></figure>
<p>做法一</p>
<p>二分答案,然后会发现我们要把那些大于mid的都搞掉</p>
<p>会发现把他们交集的最大边干掉即可</p>
<p>做法二</p>
<p>上述过程不需要二分</p>
<p>我们一定要改最大链,然后再在最大链和次大链改最大的....</p>
<p>直到所有的都被判断一次,其中一个一定是ans</p>
<p>即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>m</mi><mi>x</mi><mo>[</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">min(max(len[1]-mx[k+1],len[k]))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>树链判交</p>
<p>一定要有一个lca在另一个链上</p>
<p>而一个点在链上的充分条件就是要有一个端点做lca等于他,另一个端点做lca等于他</p>
<p>树链求交</p>
<p>(u,v),(x,y)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(u,x),lca(u,y),lca(v,x),lca(v,y)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></p>
<p>四个点中dfn序最大的两个就是新链两个端点</p>
<p>为啥呢?我也不太懂</p>
<p>正确的前提是树链判交成立</p>
<p>拓扑排序计数</p>
<p>显然...</p>
<p>拓扑图最小链覆盖等于最长反链</p>
<p>最长反链：最大的点集，点集中任意两个点无法互相到达</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601811457873.png" alt="" loading="lazy"></figure>
<p>向右下一堆链变成向左上最长链</p>
<p>然后这个东西相当于最长左上链可以动态规划</p>
<p>鬼知道为什么这么小</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601812155573.png" alt="" loading="lazy"></figure>
<p>做法还是很妙的</p>
<p>首先我们建立源汇点然后最长路径等于s-&gt;t的最长路-2</p>
<p>从sbfs一遍得到f,从tbfs一遍得到z</p>
<p>然后你会发现我们枚举一个点断开的过程可以维护</p>
<p>就是考虑按照拓扑序断开点,然后左边划分给拓扑序小于x的集合,右边维护拓扑序大于他的集合</p>
<p>那么整体的答案就是左边集合与右边集合右边的一个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub><mo>+</mo><msub><mi>g</mi><mi>z</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_x+g_z-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>实现的时候,我们断掉这个点分入右边可以用枚举出边然后把每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">pair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>用堆删除</p>
<p>然后我们同时可能会加入一些新的贡献(就是点x和右边集合的)</p>
<p>这个也可以堆</p>
<p>二分图最大匹配=二分图最小点覆盖</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第四场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-si-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-si-chang/">
        </link>
        <updated>2020-10-04T06:07:47.000Z</updated>
        <content type="html"><![CDATA[<p>D实在不会orzljhwyz</p>
<p>A</p>
<p>显然可以二分答案变成判定问题</p>
<p>然后考虑解决一下怎么两两可达,显然有向图是强联通分量,所有点在一个强联通分量就行</p>
<p>当然也可以从一出发能到达所有点,然后反图中从所有点出发能到达1就行</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 6e4 + 7;
const int MAXM = 3e5 + 7;
int n, m, ccnt, mid;
struct  rec {
	int x, y, z;
	bool operator&lt;(const rec &amp;w)const {
		return z &lt; w.z;
	}
} e[MAXM];

int home[MAXN], nxt[MAXM], to[MAXM];
int dfn[MAXN], low[MAXN], fl[MAXN];
int bel[MAXN], st[MAXN], tp, depp;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	return;
}
inline void init() {
	memset(dfn, 0, sizeof(dfn));
	memset(fl, 0, sizeof(fl));
	memset(low, 0, sizeof(low));
	memset(home, 0, sizeof(home));
	memset(bel, 0, sizeof(bel));
	ccnt = 0;
	tp = 0;
	depp = 0;
}
inline void tarjan(int u) {
	st[++tp] = u;
	dfn[u] = low[u] = ++depp;
	fl[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!dfn[v]) {
			tarjan(v);
		} else if(!fl[v])continue;
		low[u] = min(low[u], low[v]);
	}
	if(low[u] == dfn[u]) {
		while(st[tp] != u) {
			int v = st[tp];
			--tp;
			bel[v] = u;
			fl[v] = 0;
		}
		--tp;
		bel[u] = u;
		fl[u] = 0;
	}
	return ;
}

inline int chk(int x) {
	init();
	for(int i = 1; i &lt;= x; ++i) {
		ct(e[i].x, e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(!dfn[i]) {
			tarjan(i);
		}
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(bel[i] != bel[1]) {
			return 0;
		}
	}
	return 1;
}

int main() {
	n = read();
	m = read();
	for(int i = 1; i &lt;= m; ++i) {
		e[i].x = read();
		e[i].y = read();
		e[i].z = read();
	}
	sort(e + 1, e + m + 1);
	int l = 1, r = m, ans = -1;
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			ans = mid;
		} else {
			l = mid + 1;
		}
	}
	printf(&quot;%d\n&quot;, e[ans].z);
	return 0;
}



</code></pre>
<p>B</p>
<p>NOIP树上计数都是...</p>
<p>首先有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">nq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>做法,就是从一个端点开始dfs,然后我们考虑dfs到另一个点的时候就可知道路径了</p>
<p>那么我们维护一个到根的a的和,然后用每个b去乘上a的和即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i==b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow></munder><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>a</mi><mi>j</mi></msub></mrow></mrow><annotation encoding="application/x-tex">\sum_{i&lt;j}{a_i*a_j}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这个式子可以求出(x,y)路径所有a的和*所有a的和,然后减去每个数自己的平方和</p>
<p>然后你发现我们算了两边,可以除以二就是答案</p>
<p>std:</p>
<p>考场做法:</p>
<p>考虑我们跨过lca的很好算,就是右边的b的和*左边的a的和</p>
<p>但是会发现两个点在一边的不太好搞?</p>
<p>于是可以统计一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a_i*sumb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span></span></span></span>即(每个点i*到根的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的和)的前缀和</p>
<p>然后你会发现在x的那一边的就可以算了,相当于这个前缀和相减然后再减去lca以上多算的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后y那一边会发现变得和y相关而不是lca相关??</p>
<p>灵机一动会发现这个如果我们维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><mi>m</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">b_i*suma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span></span></span></span>就能变换成x那边a的那种形式了</p>
<p>所以这三部分求和就是答案了</p>
<p>树上倍增std做法?</p>
<p>可以避免前缀和?</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e5 + 7;
const int MAXM = 4e5 + 7;
int n, ccnt, home[MAXN], nxt[MAXM], to[MAXM], m;
int fa[MAXN], a[MAXN], b[MAXN];
ll suma[MAXN], sumb[MAXN], sumab[MAXN], sumba[MAXN];
int son[MAXN], siz[MAXN], top[MAXN], dep[MAXN];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs1(int u) {
	suma[u] += a[u];
	sumb[u] += b[u];
	sumab[u] += 1ll * a[u] * sumb[fa[u]];
	sumba[u] += 1ll * b[u] * suma[fa[u]];
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		suma[v] = suma[u];
		sumb[v] = sumb[u];
		sumab[v] = sumab[u];
		sumba[v] = sumba[u];
		dep[v] = dep[u] + 1;
		dfs1(v);
		siz[u] += siz[v];
		if(siz[son[u]] &lt; siz[v])son[u] = v;
	}
	return ;
}

inline void dfs2(int u, int topf) {
	top[u] = topf;
	if(!son[u])return ;
	dfs2(son[u], topf);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == son[u])continue;
		dfs2(v, v);
	}
}

inline int LCA(int x, int y) {
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])swap(x, y);
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])swap(x, y);
	return x;
}

inline ll getans(int x, int y) {
	int z = LCA(x, y);
	ll ans = 0;
	ans += sumab[x] - sumab[z] - sumb[fa[z]] * (suma[x] - suma[z]);
	ans += sumba[y] - sumba[z] - suma[fa[z]] * (sumb[y] - sumb[z]);
	ans += (suma[x] - suma[z]) * (sumb[y] - sumb[z]);
	return ans;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 2; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;fa[i]);
		ct(fa[i], i);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;b[i]);
	}
	dfs1(1);
	dfs2(1, 1);
	for(int i = 1, x, y; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		printf(&quot;%lld\n&quot;, getans(x, y));
	}
	return 0;
}

</code></pre>
<p>C</p>
<p>显然可以动态规划?</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k,l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个格子,第i个染了j这种颜色然后有没有用那一次,用了的话长多少</p>
<p>转移<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>或者前缀和优化都可以,都屑屑屑</p>
<p>仔细想这个l没有用,我们只需要考虑k是直接染完还是之前就染完就好了,没有必要拖到后面再染</p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个格子,第i个染了j这种颜色然后有没有用那一次</p>
<p>第一个转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>!</mo><mo>=</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i-1,col!=j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可以转移来,用个前缀最小值和后缀最小值优化一下就好了</p>
<p>然后我们又有一个转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{k,col==j,0}+sum_{i,j}-sum_{k,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>这个k是一段区间,可以单调队列优化</p>
<p>老师讲的我们可以枚举一段区间和颜色,然后再考虑左右两边都不能选相同就做完了</p>
<p>code:</p>
<pre><code class="language-cpp">
//前缀和优化 + 单调队列优化
//可以做到O(nm)
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
const int MAXN = 2050;
const ll inf = 1e18;
int n, m, K, w[MAXN][MAXN];
ll dp[MAXN][MAXN][2], sum[MAXN][MAXN];
ll mip[MAXN][MAXN][2], mis[MAXN][MAXN][2];
int que[MAXN][MAXN * 2], fr[MAXN], ed[MAXN];
int main() {
	n = read();
	m = read();
	K = read();
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			w[i][j] = read();//i - &gt; j
			sum[i][j] = sum[i - 1][j] + w[i][j];
		}
	}
	memset(dp, 0x3f3f3f3f, sizeof(dp));
	memset(mis, 0x3f3f3f3f, sizeof(mis));
	memset(mip, 0x3f3f3f3f, sizeof(mip));
	for(int i = 1; i &lt;= m; ++i) {
		dp[0][i][0] = 0;
		mip[0][i][0] = 0;
		mis[0][i][0] = 0;
		fr[i] = ed[i] = 1;//一开始有决策0
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			while(que[j][fr[j]] &lt; i - K + 1 &amp;&amp; fr[j] &lt;= ed[j]) {
				++fr[j];
			}//过时决策
		}
		for(int j = 1; j &lt;= m; ++j) {
			dp[i][j][0] = min(dp[i][j][0], min(mip[i - 1][j - 1][0], mis[i - 1][j + 1][0]) + w[i][j]);
			//0的转移- &gt; 直接继承,前缀和优化
			dp[i][j][1] = min(dp[i][j][1], min(mip[i - 1][j - 1][1], mis[i - 1][j + 1][1]) + w[i][j]);
			//在此之前我们就已经有了
			if(fr[j] &lt;= ed[j]) {
				int k = que[j][fr[j]];
				dp[i][j][1] = min(dp[k][j][0] + sum[i][j] - sum[k][j], dp[i][j][1]);
			}
			//从这里另起一段
		}
		for(int j = 1; j &lt;= m; ++j) {
			mip[i][j][0] = min(mip[i][j - 1][0], dp[i][j][0]);
			mip[i][j][1] = min(mip[i][j - 1][1], dp[i][j][1]);
		}
		for(int j = m; j &gt;= 1; --j) {
			mis[i][j][0] = min(mis[i][j + 1][0], dp[i][j][0]);
			mis[i][j][1] = min(mis[i][j + 1][1], dp[i][j][1]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			while(dp[que[j][ed[j]]][j][0] - sum[que[j][ed[j]]][j] &gt;= dp[i][j][0] - sum[i][j] &amp;&amp; fr[j] &lt;= ed[j]) {
				--ed[j];
			}//不优决策,下一秒i至少比她好看
			++ed[j];
			que[j][ed[j]] = i;//加入决策i
		}
	}
	ll ans = inf;
	for(int i = 1; i &lt;= m; ++i)ans = min(dp[n][i][0], min(dp[n][i][1], ans));
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>D</p>
<p>考场上使用IDA*写了20/kk</p>
<p>然后出考场人均70/ll</p>
<p>首先这个题不需要AC自动机上计数什么毒瘤东西,因为所有串长都相同</p>
<p>我们会发现如果把所有的串写出来的话,我们可以计算出从一个串到另一个串的代价</p>
<p>然后如果把这个东西建成一张图</p>
<p>那么好像答案就是把所有的好串都经过一遍的最短路径....</p>
<p>TSP哎QAQ</p>
<p>显然我们坏串就是不被经过的点,能预处理出来</p>
<p>然后状压一下有哪些点是已经被经过的,最后停留在那个点,然后我们下一个点走到那个关键点预处理一下即可</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>∗</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2*2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>TSP状压注意下标平移的问题,以及初始化</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e5 + 7;
int n, m, k;
int bd[MAXN], g[MAXN];
int vis[MAXN];
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], w[MAXN];

inline void ct(int x, int y, int z) {
	if(bd[x] || bd[y])return ;//bad
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	w[ccnt] = z;
}
int T = 1;
struct machine {
	int ch[MAXN][5], fa[MAXN], rt = 1;
	inline void ins(char *c, int l, int id) {
		int nw = 1;
		for(int i = 0; i &lt; l; ++i) {
			int t = c[i] - '1';
			if(!ch[nw][t])ch[nw][t] = ++T;
			nw = ch[nw][t];
		}
		if(id)g[id] = nw;
		else bd[nw] = 1;
	}
	inline void init() {
		static queue&lt;int&gt; q;
		for(int i = 0; i &lt; 4; ++i) {
			if(ch[rt][i]) {
				fa[ch[rt][i]] = rt;
				q.push(ch[rt][i]);
			} else
				ch[rt][i] = rt;
		}
		while(!q.empty()) {
			int u = q.front();
			q.pop();
			for(int i = 0; i &lt; 4; ++i) {
				if(ch[u][i]) {
					fa[ch[u][i]] = ch[fa[u]][i];
					q.push(ch[u][i]);
				} else ch[u][i] = ch[fa[u]][i];
			}
		}
		for(int i = 1; i &lt;= T; ++i) {
			for(int j = 0; j &lt; 4; ++j) {
				ct(i, ch[i][j], j + 1);
			}
		}
		return;
	}
} ac;
#define pii pair&lt;int,int&gt;
#define mkp(x,y) (make_pair(x,y))
#define fi first
#define se second
char s[123];
int dis[21][MAXN];

inline void dij(int *dis, int s) {
	static priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;
	for (int i = 1; i &lt;= T; ++i)dis[i] = 1e9, vis[i] = 0;
	q.push(mkp(dis[s] = 0, s));
	while(!q.empty()) {
		int u = q.top().se;
		q.pop();
		if(vis[u])continue;
		vis[u] = 1;
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			if(bd[v])continue;
			if(dis[v] &gt; dis[u] + w[i]) {
				dis[v] = dis[u] + w[i];
				q.push(mkp(dis[v], v));
			}
		}
	}
	return ;
}

int f[20][(1 &lt;&lt; 20) + 5];

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%s&quot;, s);
		ac.ins(s, k, i);
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%s&quot;, s);
		ac.ins(s, k, 0);
	}
	ac.init();
	dij(dis[0], 1);
	for(int i = 1; i &lt;= n; ++i) {
		dij(dis[i], g[i]);
	}
	memset(f, 0x3f, sizeof(f));
	int MS = (1 &lt;&lt; n) - 1;
	for(int i = 0; i &lt; n; ++i) {
		f[i][(1 &lt;&lt; i)] = dis[0][g[i + 1]];
	}
	for(int S = 1; S &lt;= MS; ++S) {
		for(int i = 0; i &lt; n; ++i) {
			if(f[i][S] &gt; 1e9)continue;
			if(S &gt;&gt; i &amp; 1) {
				for(int j = 0; j &lt; n; ++j) {
					if(S &gt;&gt; j &amp; 1)continue;
					f[j][S | (1 &lt;&lt; j)] = min(f[j][S | (1 &lt;&lt; j)], f[i][S] + dis[i + 1][g[j + 1]]);
				}
			}
		}
	}
	int ans = 1e9;
	for(int i = 0; i &lt; n; ++i)ans = min(ans, f[i][MS]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
<p>code抄袭吴队爽</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化听课 (Day3)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day3/">
        </link>
        <updated>2020-10-03T08:03:07.000Z</updated>
        <content type="html"><![CDATA[<p>zhx的DP</p>
<p>T1</p>
<p>n*n网格,每个格子有个数,有m个限制就是不能从权值为i的走到权值为j的</p>
<p>一条路径的权值是从起点到终点穿起来</p>
<p>然后起点任意问走k步能得到最大的数多少</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n,k&lt;=100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>每个变化的限制就写入状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示我现在走了i步走到j(j,k)的最大数是多少</p>
<p>转移考虑下一步,显然会发现我们从相邻最大的那个走过来</p>
<p>存的时候直接用字符串即可?</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601712864582.png" alt="" loading="lazy"></figure>
<p>第一个问题是选出一些不相交的区间</p>
<p>显然可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示考虑了前i块地,然后i被种的最大收益</p>
<p>首先按照右端点排序即可</p>
<p>转移?考虑我们如果没有区间右端点的地一定不先考虑,然后我们枚举这个右端点处的区间是什么,设为[l,r]</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>+</mo><msub><mi>f</mi><mrow><mn>1...</mn><mi>l</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mi>r</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_r=max(p_i+f_{1...l},f_r)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>树状数组或缀和优化</p>
<p>第二个问题我们可以先设计一个n^2状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑前i块地,然后已经开荒了i-&gt;j位置,j之前的不管</p>
<p>转移</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j}-a_i+w
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">f_{i,i}=f_{i-1,0}-a_i+w
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}=max f_{i-1,j}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>w是右端点在i的区间且左端点大于等于j的价值和</p>
<p>首先不难发现这个转移可以线段树优化?区间加?</p>
<p>zhx官方做法:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示最右种地区间编号为i,然后讨论之前区间和现在区间的关系</p>
<p>枚举一个r表示上一个被种的地盘</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>&lt;</mo><msub><mi>l</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r&lt;l_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>显然没有地被种过,直接开荒,和上个题一样</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mi>r</mi><mo>&lt;</mo><mo>=</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i&lt;=r&lt;=r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>现在之前种的最靠右的在中间某个地方</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Double subscript at position 24: …=f_r+P_i+(sum_r_̲i-sum_{r-1})
'>f_{r_i}+=f_r+P_i+(sum_r_i-sum_{r-1})
</p>
<p>都是一个区间最大值的查询,可以优化到log</p>
<ol start="3">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>&gt;</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r&gt;r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
<p>会发现这个区间白给了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><msub><mi>f</mi><mi>r</mi></msub><mo>+</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{r}=f_{r}+p_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>做完了,区间加</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601715268736.jpg" alt="" loading="lazy"></figure>
<p>首先一定可以预处理别的位置对于中间四个位置我们放什么获得的代价</p>
<p>然后可以考虑中间之间的怎么搞定</p>
<p>九维dp</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 22: …,k,l,m,n,o,p,q}$̲$表示考虑了前i个数,然后四个…'>f_{i,j,k,l,m,n,o,p,q}$$表示考虑了前i个数,然后四个位置上放了j,k,l,m数,然后n,o,p,q为点四个数有没有这个i

转移的时候$O(2^4)$枚举即可

![](https://xiaxiaoguang.github.io/post-images/1601719787708.png)

先有一个6维的背包dp

$$f_{i,j,k,l,m,n}$$表示考虑选了i个...j个...k个...l个...有无队长,代价和为n的最大价值

考虑a+1个人选或不选,成不成为队长

然后这个能算出最优答案,但是不好计数,因为队长会自闭

我不当队长和当队长都自闭了

在加一维表示还有多少人能不能当队长??

一定假了,复杂度上天而且还要再记一些

我们仔细思考这个东西挂掉因为当不当队长时的算重

所以我们可以发现钦定队长就能解决

把所有人排一下序,然后一个队伍中第11个人一定是队长了

![](https://xiaxiaoguang.github.io/post-images/1601720899691.jpg)

显然要算贡献

然后考虑合并的时候怎么算新贡献

中间的边权会被算$n_i*n_j$

然后$f_{i}$表示第i棵树的答案

但是你要直到某棵树内部走到某个点的路径权值之和

但是$g_{i,j}$表示i棵树内部所有点走到j的距离之和

答案就是$f[k]=f[i]+f[j]+n_i*n_j*c+g_{i,a}*n_j+g_{j,b}*n_i$

这样可以求出第k棵树的答案

然后怎么求出g数组?

$g_{i,j}$表示从第i棵树出发到j点距离?

首先右边内棵树上独自的贡献咋算啊,显然这个已经记录了

然后你会发现我们算另一棵树就要$$g_{c,d}$$(走到头上关键点)

然后+中间那条边的贡献,显然是$n_c*l$,每个点出发走到j

然后我们再考虑这个从某个关键点到另一个关键点的距离?$h_{a,b,j}*n_c$

h怎么更新?如果在一棵树直接更新,在两棵树就从一颗加上关键点+l来转移

然后这个关键点的大小?映射.....

显然我们写记忆化搜索就不需要映射了?

直径?显然我们有点集直径合并的性质Qwq,关键点就只剩下几个了

![](https://xiaxiaoguang.github.io/post-images/1601723477077.png)

$f_{i,j}$表示点i为根的子树里面有j只鹰,然后这个东西可以想象转移

1. j-1飞走

f_{i,j}=f_{i,j-1}*一个系数

显然...

2. j飞进去

会发现,我们要决定飞入那个子树....

然后我们不知道没课子树有多少鹰

$n_1+n_2+....n_k==sth$

$g_{i,j,k}$表示考虑了前i课子树已经飞入l只鹰,k是0/1变量,表示我们第j只鹰定没定

每次dp一个儿子的时候考虑这个儿子飞进去多少,然后是否飞进去

如果不飞过去,我们直接背包求和

如果飞进去我们还要乘$f_{v,n_v+1}$

插板法/se orzljh

先枚举那个儿子飞入,然后枚举第j只鹰停留时多少个儿子

$$f_{i,j}=\sum_{r=1}^k 1/k \sum_{n_r=0}^{j-2} f_{p_r,n_r+1}</p>
<p>还不够,我们里面还有一个方案数,也就是说实际上概率不是这个</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi><munderover><mo>∑</mo><mrow><msub><mi>n</mi><mi>r</mi></msub><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>f</mi><mrow><msub><mi>p</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>r</mi></msub><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mi>r</mi></mrow><mrow><mi>j</mi><mo>−</mo><mn>2</mn></mrow></mfrac><mo fence="true">)</mo></mrow><msubsup><mfrac><mn>1</mn><mi>k</mi></mfrac><mi>r</mi><mi>n</mi></msubsup><msup><mfrac><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><mi>k</mi></mfrac><mrow><mi>i</mi><mo>−</mo><mn>2</mn><mo>−</mo><msub><mi>n</mi><mi>r</mi></msub></mrow></msup></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum_{r=1}^k 1/k \sum_{n_r=0}^{j-2} f_{p_r,n_r+1} *\binom{nr}{j-2}{\frac 1 k}^n_r\frac{k-1}{k}^{i-2-n_r}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2259900000000004em;vertical-align:-1.3672129999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000006em;"><span style="top:-1.8828870000000002em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3672129999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.536034em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3757319999999997em;"><span style="top:-1.9643000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.77434em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7357em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.586004em;"><span style="top:-3.82434em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>之前背包的式子也要写概率QAQ</p>
<p>TC Open 2014 Round 1B P3</p>
<p><s>老师太懒没写</s></p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601725617786.png" alt="" loading="lazy"></figure>
<p>显然状压不太行</p>
<p>优化状压?你会发现我们不需要太多信息</p>
<p><strong>只需要知道是否是某个数的倍数</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示我们<strong>选了i个数</strong>,gcd为j的先手是否必胜</p>
<p>转移考虑</p>
<ol>
<li>选择j的倍数</li>
</ol>
<p>看看有多少数是j的倍数c,然后如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">i&lt;c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
<p>我们可以再选一个j的倍数,gcd不变</p>
<ol start="2">
<li>不选择j的倍数</li>
</ol>
<p>那之前一定没有选择过他</p>
<p>转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>j</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i+1][gcd(j,a_k)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></p>
<p>然后博弈论DP就解决了</p>
<p>orzwyz</p>
<p>n个点,深度为k的二叉树有多少种</p>
<p>考虑转移?枚举右子树多少点,然后深度是什么</p>
<p>先钦定左子树达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=\sum_{k=1}^{k-1}f_{k,j-1}\sum_{d=0}^{i-1}f_{i-1-k,d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1382260000000004em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.836113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后我们还要加上右子树成为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>啊/ll</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><munderover><mo>∑</mo><mrow><mi>d</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>[</mo><mi>d</mi><mo>]</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">+\sum_{d=0}^{j-1}f[k][d] f_{i-1-k,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.16089em;vertical-align:-1.302113em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000001em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>可以前缀和优化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>此时你会发现我们可以优化状态,直接dp前缀和</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i深度小于等于j的方案数</p>
<p>然后转移$$\sum_{k=0}^{i-1}f_{k,j-1}*f_{i-1-k,j-1}$$</p>
<p>finished</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第三场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-san-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-san-chang/">
        </link>
        <updated>2020-10-03T06:02:56.000Z</updated>
        <content type="html"><![CDATA[<p>昨天挂10,今天挂20QAQ</p>
<p>A</p>
<p>1e6!全部写出来五十万位的数/se</p>
<p>高精度期望80pts</p>
<p>做法一:</p>
<p>会发现我们只需要比较大小</p>
<p>那么我们可以用个能够比较大小的映射函数</p>
<p>开根号显然我们还要算好几百位的数</p>
<p>比如对数函数!</p>
<p>logN!=log1+log2+log3....+log(n)</p>
<p>也就是说我们1e6个数全部求一个阶乘然后搞一个前缀和数组,这个和的第i项就是n!取对数</p>
<p>然后只需要枚举一个k,看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub><mo>−</mo><msub><mi>S</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">S_n-S_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的大小关系</p>
<p>做法二:</p>
<p>结论 : 左边的阶乘不会大于右边的阶乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><msup><mn>6</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1e6^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>倍</p>
<p>显然如果大于我们就可以把左边的一个分给右边并保证仍成立</p>
<p>所以可以记录左边的倍数比右边打多少</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
#define ll long long
using namespace std;
const int MAXN = 2e6 + 7;
db f[MAXN];
ll g[MAXN];
int n;
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	if(n == 1) {
		return puts(&quot;1&quot;), 0;
	}
	if(n == 2) {
		return puts(&quot;2&quot;), 0;
	}
	if(n == 3) {
		return puts(&quot;3&quot;), 0;
	}
	f[3] = 6;
	g[3] = 3;//前三个,初始化一下
	for(ll i = 4; i &lt;= n; ++i) {
		f[i] = f[i - 1];
		g[i] = g[i - 1];
		while(f[i] / i &lt; 1 &amp;&amp; g[i] &lt; i) {
			++g[i];
			f[i] = f[i] * g[i] * g[i];
		}
		f[i] /= i;
	}
	printf(&quot;%lld\n&quot;, g[n]);
	return 0;
}

</code></pre>
<p>扩展:组合数问题</p>
<p>首先杨辉三角最下面一行的中间是最大的,而且次大的一定在最大的相邻位置</p>
<p>所以这k个数我们只需要用一个大根堆比较然后依次选下去就好了</p>
<p>然后我们从大根堆取k次就是前k大的组合数</p>
<p>显然比较大小不能取模,我们可以对其取对数</p>
<p>然后</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>!</mo><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">C_{n,m}=logn!-logm!-log(n-m)!
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></span></p>
<p>B</p>
<p>先处理字符串,把整个拓扑图建出来</p>
<p>然后n^2去pick每个即可...</p>
<p>模拟建图处理字符串的时候可以分阶段来搞...然后有一个:;就换阶段,这样比较好写</p>
<p>注意把所有字符串按照字典序pick出来然后分配下点的编号</p>
<p>写模拟一定要代码优美一些</p>
<p>全考场切的最快?</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑按照依赖关系建图
//会发现是一个拓扑排序
//然后我们有一些时间轴,每个时间轴都可以向后推进
//然后时间轴要任务的时候我们可以把所有点按照深度和名字进行排序
//然后就可以做了?
//名字字符集为小写大写数字,要是不是就撕了zhx
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e3 + 7;
const int MAXM = 3e5 + 7;
#define ll long long
string s, a, b;
map&lt;string, int&gt; mp;
int T, ccnt, home[MAXN], nxt[MAXM], to[MAXM], in[MAXN];

priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt; &gt;  hp;
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;  heap;
int vis[MAXN], tim[MAXN], Sm;
struct NODE {
	int id, ft;
	bool operator&lt;(const NODE x)const {
		return ft == x.ft ? id &gt; x.id : ft &gt; x.ft;
	}
} e[MAXN];

priority_queue&lt;NODE&gt; task;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	in[y]++;
}

int main() {
	freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	cin &gt;&gt; s;
	int flg = 0;
	//正在进行第几个阶段?
	//任务的名字为第二关键字??
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == '/') {
			hp.push(a);
			a.clear();
			flg = -1;
			continue;
		}
		if(s[i] == ';') {
			hp.push(a);
			a.clear();
			flg = 0;
			continue;
		}
		if(s[i] == ':') {
			flg = 1;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		}
	}
	a.clear();
	while(!hp.empty()) {
		a = hp.top();
		hp.pop();
		cout &lt;&lt; a &lt;&lt; endl;
		mp[a] = ++T;
	}
	a.clear();
	flg = 0;
	for(int i = 0; i &lt; (int)s.size(); ++i) {
		if(s[i] == ';') {
			flg = 0;
			a.clear();
			continue;
		}
		if(s[i] == ':') {
			flg++;
			continue;
		}
		if(s[i] == '/') {//上四挡
			flg = 4;
			continue;
		}
		if(!flg) {
			a.push_back(s[i]);
		} else if(flg == 1) {
			if(s[i] == '[') {
				continue;
			}
			if(s[i] == ',' || s[i] == ']') {
				if(b.empty())continue;
				ct(mp[b], mp[a]);
				b.clear();
				continue;
			}
			b.push_back(s[i]);
		} else if(flg == 2) {
			tim[mp[a]] = tim[mp[a]] * 10 + s[i] - '0';
			cout &lt;&lt; a &lt;&lt; endl;
			//快读即可
		}
		if(flg == 4) {
			Sm = Sm * 10 + s[i] - '0';
			if(Sm &gt; T)break;
		}
	}
	for(int i = 1; i &lt;= T; ++i)e[i].id = i;
	//有多少任务就有多少点
	int fed = 0;
	while(fed &lt; Sm) {
		++fed;
		heap.push(0);
		//每个机器最早结束时间
	}
	fed = 0;
	while(fed &lt; T) {
		for(int i = 1; i &lt;= T; ++i) {
			if(in[i] == 0 &amp;&amp; !vis[i]) {
				vis[i] = 1;
				task.push(e[i]);
				//把这个点放入qwq里
			}
		}
		int t = heap.top();
		heap.pop();
		NODE u = task.top();
		task.pop();
		for(int i = home[u.id]; i; i = nxt[i]) {
			int v = to[i];
			e[v].ft = max(e[v].ft,  tim[u.id] + max(t, u.ft));
			//考虑我们这个任务结束的时间应该是这个任务开始做的时间+做这个任务的时间
			//前者显然和机器开工时间与开始做时间最大值有关
			in[v]--;
		}
		fed++;
		heap.push(max(t, u.ft) + tim[u.id]);
	}
	int ans = 0;
	while(!heap.empty()) {
		ans = max(ans, heap.top());
		heap.pop();
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

abc:[a1,a2]:10;AB1:[]:2;AB2:[]:3;ab1:[AB1,AB2]:3;ab3:[AB2]:4;a2:[ab1,ab3,AB2]:2;a1:[ab1]:3/3


*/
</code></pre>
<p>C</p>
<p>挂了20QAQAQAQ</p>
<p>对于长度为1,我们可以直接暴力</p>
<p>对于长度&lt;=10,我们可以直接复制粘贴到一样长</p>
<p>考场上直接TLE/ll</p>
<p>注意50!整除任何你想要的,所以不用考虑余数</p>
<p>均为质数</p>
<p>3,5的情况?</p>
<p>010010010010010<br>
100111001110011</p>
<p>-&gt;</p>
<p>110121011120021</p>
<p>你会发现第一个串会和第二个字符串每一位都有重叠的操作!!</p>
<p>那么其实相当于(2个0+1个1)*(2个0+3个1)=4个0+8个1+3个2??</p>
<p>因为一定会有重复!</p>
<p><s>生成函数??</s></p>
<p>当两字符串互质时,我们只关心彼此间0/1的个数!</p>
<p>然后我们最后相当于多个二项式相乘!!</p>
<p>...可以分治FFT优化</p>
<p>然鹅,如果不互质就萎了</p>
<p>分块匹配!!!</p>
<p>lcm 4,6 =12</p>
<p>4 4 4 4-&gt; 1 2 1 2 1 2<br>
6 6 -&gt;      1 2 3 1 2 3</p>
<p>设最大公因数为g</p>
<p>10 01 10 01 10 01<br>
01 00 11 01 00 11</p>
<p>你会发现4的每一块的第一位都不可能和6的第二位产生影响</p>
<p>然后我们可以继续,取出4的第二位和六的每一块的第二位乘起来</p>
<p>然后得到两个多项式系数求和?</p>
<p>这两个答案求和就是我们想要的答案,可以发现多项式的指数可能变小?</p>
<p>扩展到n个?你会发现我们要小心gcd!QAQ</p>
<p>如果一个字符串含有2,3,5,7,作为因子那么我们就把它扩展到32<em>27</em>25*49的形式</p>
<p>但是如果包含了大于7的因子,他的平方一定大于50,所以只会包括一个大于7的</p>
<p>怎么扩?</p>
<p>每个p拓展到12p,因为我们最大只能有4</p>
<p>这样做完之后,我们最大公约数为12(或者更大一个p)</p>
<p>所有数我们可以按照12进行分组,然后做12次多项式乘法就好了</p>
<p>然后会发现我们可以做了!</p>
<p>每组有12位,要做12次乘法</p>
<p>然后一共有n/12组</p>
<p>每组的第一个数之间做多项式乘法</p>
<p>复杂度瓶颈在于扩展1e6的....</p>
<p>打码通过精加工变得好快/jk</p>
<p>code:</p>
<pre><code class="language-cpp">
//From Dawn light
//first kill!
//orzzhx
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1000;
const int MAXT = 105;
const int MAXS = 55;
const int P = 1e9 + 7;
int n, la, lc;
string s[MAXT];
ll fac[MAXT];
int L[MAXT], a[MAXT][MAXS], vis[MAXN], B[50][MAXN];
ll A[MAXN];
ll D[MAXN], E[MAXN];

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}


ll c[MAXN];
inline void mul(ll *a, ll *b, int &amp;la, int lb) {
	memset(c, 0, sizeof(c));
	for(int i = 0; i &lt; lb; ++i) {
		for(int j = 0; j &lt; la; ++j) {
			add(c[i + j], b[i] * a[j] % P);
		}
	}
	la = la + lb - 1;
	for(int i = 0; i &lt; la; ++i)a[i] = c[i];
	return ;
}

const int Bas = 1058400;
int C[Bas + 3];

inline void init() {
	fac[0] = 1;
	for(int i = 1; i &lt;= 50; ++i)fac[i] = fac[i - 1] * i % P;
	for(int i = 1; i &lt;= n; ++i) {
		L[i] = s[i].size();
		for(int k = 0; k &lt; L[i]; ++k)a[i][k] = s[i][k] - '0';
		int tmp = L[i];
		while(tmp % 2 == 0)tmp /= 2;
		while(tmp % 3 == 0)tmp /= 3;
		while(tmp % 5 == 0)tmp /= 5;
		while(tmp % 7 == 0)tmp /= 7;
		if(tmp == 1) {
			vis[0] = 1;
			for(int k = 0; k &lt; Bas; ++k)C[k]+=a[i][k % L[i]];
		} else {
			int tl = tmp * 12;
			vis[tmp] = 1;
			for(int k = 0; k &lt; tl; ++k)B[tmp][k]+= a[i][k % L[i]];
		}
	}
	bool flg = vis[0];
	for(int t = 0; t &lt; 12; ++t) {
		la = 0;vis[0] &amp;= flg;memset(A, 0, sizeof(A));
		for(int k = t; k &lt; Bas; k += 12) {A[C[k]]++;la = max(la, C[k] + 1);}
		for(int i = 1; i &lt;= 50; ++i) 	{
			if(!vis[i]) continue;
			memset(E, 0, sizeof(E));
			lc = 0;
			for(int k = t; k &lt; i * 12; k += 12) {E[B[i][k]]++;lc = max(lc, B[i][k] + 1);}
			if(!vis[0]) {vis[0] = 1; la = lc; for(int k = 0; k &lt; lc; ++k)A[k] = E[k]; continue;}
			mul(A, E, la, lc);
		}
		for(int k = 0; k &lt; la; ++k)add(D[k], A[k]);
	}
	vis[0] &amp;= flg;
	return ;
}
inline bool cmp(const string x, const string y) {
	return x.size() &lt; y.size();
}
signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)cin &gt;&gt; s[i];
	sort(s + 1, s + n + 1, cmp);
	init();
	int qwq = fac[50];
	if(vis[0])qwq = qwq * ksm(Bas, P - 2) % P; else qwq = qwq * ksm(12, P - 2) % P;
	for(int i = 1; i &lt;= 50; ++i)if(vis[i])qwq = qwq * ksm(i, P - 2) % P;
	for(int i = 0; i &lt;= n; ++i)printf(&quot;%lld\n&quot;, 1ll * D[i] * qwq % P);
	return 0;
}



</code></pre>
<p>D</p>
<p>显然我们可以枚举中间的那个j,然后计算左右两边的贡献,就是左边那些大于他的和右边那些大于他的都可以拼起来</p>
<p>然后你会发现我们这个贡献好像就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">i*(n-k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>就是有多少区间包括他</p>
<p>做完了,树状数组维护即可</p>
<p>注意翻转值域的时候不要出现0</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 5e5 + 7;
const int P = 1e9 + 7;
int n, a[MAXN];
ll ans;
struct rec {
#define lowbit(x) (x&amp;(-x))
	ll tr[MAXN];
	inline void add(int x, ll V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline ll qry(int x) {
		ll ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} bt1, bt2;

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int M = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		M = max(M, a[i]);
	}
	++M;
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], n - i + 1);
	}
	for(int i = 1; i &lt;= n; ++i) {
		bt1.add(M - a[i], -n + i - 1);
		add(ans, bt1.qry(M - a[i] - 1) * bt2.qry(M - a[i] - 1) % P);
		bt2.add(M - a[i], i);
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第二场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/">
        </link>
        <updated>2020-10-02T06:27:49.000Z</updated>
        <content type="html"><![CDATA[<p>QAQ</p>
<p>T2被降智</p>
<p>A</p>
<p>二分答案</p>
<p>判断的时候我们先让之前(如果有灯)就放光放过去,照亮一些路灯</p>
<p>然后再找到第一个照不亮的我们从哪个点向后找第二个要照亮的路灯就好了</p>
<p>时间复杂度O(nlogn)</p>
<p>考场空间开小?成为全场唯一90</p>
<h1 id="以后15倍空间一定要开">以后1.5倍空间一定要开!!!</h1>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 2e5 + 7;

int n, k, a[MAXN];

inline int chk(int x) {
	int lstl = 0;
	int lstu = 1;
	lstu = 1;
	lstl = 1;
	while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
		++lstl;
	}
	lstu = lstl + 1;
	for(int i = 2; i &lt;= k; ++i) {
		while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n) {
			++lstu;
		}
		lstl = lstu;
		while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
			++lstl;
		}
		lstu = lstl + 1;
	}
	while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n)
		++lstu;
	return lstu &gt; n;
}

signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);
	a[n + 1] = 2e9;
	a[0] = -2e9;
	int	L = 0, R = 2e9, ans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	while(L &lt;= R) {
		int mid = (L + R) &gt;&gt; 1;
		if(chk(mid)) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}


</code></pre>
<p>B</p>
<p>惨</p>
<p>首先n^2很easy</p>
<p>然后考虑怎么观察来优化</p>
<p>你会发现我们就算交换很鬼畜也会有很多不动的位置</p>
<p>比如12345对于2交换一次</p>
<p>21435</p>
<p>1,3,5都没有变</p>
<p>但是数组整个下标其实向后平移了一位,然后有一些特殊位置要暴力修改....</p>
<p>做法就很显然了...开个2n的数组就行了</p>
<p>然后每次我们交换交换特殊位置...QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 3e6 + 7;
int n, p[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)p[i] = i;
	for(int i = 2; i &lt;= n; ++i) {
		int nw = 0;
		for(int j = 1; j &lt;= n; j += i) {
			swap(nw, p[j + i - 2]);
		}
		p[i + n - 1] = nw;

	}
	for(int i = n; i &lt; 2 * n; ++i) {
		printf(&quot;%d &quot;, p[i]);
	}
	puts(&quot;&quot;);
	return 0;
}

</code></pre>
<p>C</p>
<p>随便dp即可</p>
<p>单指针计数可以实现快速判断最近的是哪个</p>
<p>同时计算一段贡献也很basic</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 205;
const int MAXK = 32;
ll a[MAXN], sum[MAXN], b[MAXN], suf[MAXN];
int n, k;
ll f[MAXN][MAXK][2];
inline ll cst1(int l, int r) {//l light -&gt;r
	return sum[r] - sum[l - 1] - 1ll * (r - l + 1) * a[l];
}

inline ll cst2(int l, int r) {//r light -&gt; l
	return suf[l] - suf[r + 1] - 1ll * (r - l + 1) * b[r];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for(int i = 1; i &lt;= n; ++i) {
		b[i] = a[n] - a[i];
	}
	for(int i = n; i &gt;= 1; --i) {
		suf[i] = suf[i + 1] + b[i];
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= min(i, k); ++j) {
			if(j != 1) {
				int lstu = i;
				for(int k = i - 1; k &gt;= 1; --k) {
					while(a[i] - a[lstu - 1] &lt; a[lstu - 1] - a[k]) --lstu;
					f[i][j][1] = min(f[i][j][1], f[k][j - 1][1] + cst1(k, lstu - 1) + cst2(lstu, i));
				}
			} else {
				f[i][j][1] = min(f[i][j][1], cst2(1, i));
			}
			for(int k = i - 1; k &gt;= 1; --k)
				f[i][j][0] = min(f[i][j][0], f[k][j][1] + cst1(k, i));
		}
	}
	printf(&quot;%lld\n&quot;, min(f[n][k][0], f[n][k][1]));
	return 0;
}


</code></pre>
<p>D</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树到i距离为j的点数有多少个</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树中满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dis(LCA(x,y),x)=dis(LCA(x,y),y)=dis(LCA(x,y),i)+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><br>
的有多少个</p>
<p>你会发现g数组更新其实很简单</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>g</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}+=g_{v,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j+1}+=f_{v,j}*f_{i,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>第二行相当于加入了新的三元组</p>
<p>f转移一样简单</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
const int MAXM = 2e5 + 7;
int home[MAXN], nxt[MAXM], to[MAXM], ccnt, n;
ll a[MAXN], ans;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int fa[MAXN];
ll sum1[MAXN][5], sum2[MAXN][5];

inline void dfs1(int u, int F) {
	fa[u] = F;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		sum1[u][1] += a[v];
		sum1[u][3] += sum1[u][2] * sum1[v][1];
		sum1[u][2] += sum1[v][1] * sum2[u][2];
		sum2[u][2] += sum1[v][1];
	}
	return;
}

signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	dfs1(1, 0);
	//case 1
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[fa[u]];
		if(v == 0)continue;
		ans += a[v] * sum1[u][2];
	}
	//case 2
	for(int u = 1; u &lt;= n; ++u) {
		ans += sum1[u][3];
	}
	//case 3
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[u];
		if(v == 0)continue;
		ll tp = sum1[v][1] - a[u];
		ans += tp * sum1[u][2];
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化听课(Day 1+2)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/">
        </link>
        <updated>2020-10-01T10:36:57.000Z</updated>
        <content type="html"><![CDATA[<p>枚举</p>
<p>for,或者while,或者do_while?/se</p>
<p>基本所有代码都要包括....</p>
<p>水仙花数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log_{10}n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>搜索</p>
<p>显然</p>
<p>坐等例题</p>
<p>NOI1999</p>
<p>n很小唉</p>
<p>可以考虑搜索出蛋糕最小表面积</p>
<p>用了多少总体积,到了第几层,半径和高</p>
<p>那么我们来剪枝!</p>
<p>可行性剪枝</p>
<ol>
<li>半径和高递减</li>
<li>如果这一层用最优的方法去放都不能满足总体积就return</li>
</ol>
<p>也就是半径1高度1-&gt;半径2高度2......</p>
<ol start="3">
<li>如果这一层用最劣的方法都能放下就不搜</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>1...</mn><mi>R</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>2...</mn></mrow><annotation encoding="application/x-tex">R-1,H-1...R-2,H-2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>说明我们之前的决策sb了</p>
<p>最优性剪枝</p>
<ol start="4">
<li>当前表面积和+剩下的最小表面积都不能凑齐超过答案就return</li>
</ol>
<p>你会发现当体积一定的时候剩下最小表面积应该能搞出来?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup><mi>h</mi></mrow><annotation encoding="application/x-tex">V=\pi r^2 h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>2</mn><mi>π</mi><mi>r</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">S=2\pi r h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p>r最大为.....</p>
<p>然后能算出对应的h,就可以找到最小表面积了</p>
<p>相当于估价函数吧</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601623513084.png" alt="" loading="lazy"></figure>
<p>显然可以暴力吧...<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mn>13</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,a[13]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后面值为i的有多少张</p>
<p>不过状态有点多,会发现我们无论如何只看面值是否相同</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mn>5</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,b[5]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mopen mtight">[</span><span class="mord mtight">5</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后重复i次的有多少面值</p>
<p>转移的时候选下一个是什么...?</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601623817582.png" alt="" loading="lazy"></figure>
<p>枚举下最多多少个数k</p>
<p>搜搜当前最小的分母</p>
<p>你会发现如果我们最小分母的k倍小于剩下的数和就一定不可能可以剪一刀</p>
<p>就能跑出来了</p>
<p>k短路可以A*,能MLE呢</p>
<p>咕咕咕函数</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601624926960.png" alt="" loading="lazy"></figure>
<p>A*是8-最多的格子个数</p>
<p>状态无限所以要ID</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601624963620.png" alt="" loading="lazy"></figure>
<p>我们又有无限个状态</p>
<p>估价函数是有多少位置不同-1</p>
<p>然后这个东西是因为最后一步可以还原两个棋子</p>
<p>题目告诉我们要枚举答案QAQ</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601625355953.png" alt="" loading="lazy"></figure>
<p>不显然可以折半</p>
<p>把方案折半,前12种的有一些,前13种的有一些</p>
<p>然后考虑三个人的数如何快速判断相等</p>
<p>第一个搜索中三个人的和我们可以两个做差,然后得到一个大小为2的差分数组</p>
<p>然后考虑拼在一起的时候是要第二个从右向左差分去查</p>
<p>显然可以手写哈希表来查存</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601626675300.png" alt="" loading="lazy"></figure>
<p>爬山即可</p>
<p>每次向所有方向中能降低权值最小的走</p>
<p>可以考虑一个呜噜呜噜的判断方向做法</p>
<p>就是所有向量求和?的和向量方向</p>
<p>模拟退火</p>
<p>设置一个棒棒的估价函数</p>
<p>然后一个降温温度</p>
<p>然后一个可能跳出去的判断方法</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>T</mi><mo>)</mo><mo>&gt;</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">/</mi><mi>R</mi><mi>A</mi><mi>N</mi><msub><mi>D</mi><mi>M</mi></msub><mi>A</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">exp(delta/T)&gt;rand()/RAND_MAX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>T值越小这个里面的值绝对值越大,而del显然是负数,那么del越小越容易交换</p>
<p>同样的,如果我们最大化,只需要变一下符号即可</p>
<p>整数划分</p>
<p>钦定前面大于后面</p>
<p>屑</p>
<p>背包问题</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601627563786.png" alt="" loading="lazy"></figure>
<p>可以考虑按照性价比排序进行搜索,这样容易剪枝</p>
<p>因为性价比是递减的,如果当前性价比下(买小数个)凑出的答案都不够优秀就return</p>
<p>货郎担</p>
<p>状压可以解决20了</p>
<p>直接搜还是蛮难的...</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1601628286924.png" alt="" loading="lazy"></figure>
<p>背包问题</p>
<p>所以下一个面额是什么可以搜索出来</p>
<p>然后我们拼一拼的时候可以背包来做.....看不能延伸</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1601628498620.png" alt="" loading="lazy"></figure>
<p>奇偶最短路的实现方法就是每个点拆成奇数点和偶数点然后连边随便连一连</p>
<p>最后只有一个源点出发跑一跑bfs最短路就行了</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1601628939205.png" alt="" loading="lazy"></figure>
<p>整除</p>
<p>奇数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>+</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">a+b|(a^n+b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>偶数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>−</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)|(a^n-b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1601633671957.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1601633621961.png" alt="" loading="lazy"></figure>
<p>总-不合法</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1601633767276.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1601635787049.png" alt="" loading="lazy"></figure>
<p>推推石子得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi>i</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n {i/gcd(i,n)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mrow><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{d|n} \sum_{k=1}^{n/d} {k*[gcd(k,n/d)==1]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.47701em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}\sum_{k=1}^{n}k*[gcd(k,n)=1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>后面这个式子显然是phi函数可以做到的</p>
<p>显然i与n互质,n-i与n互质</p>
<p>所以所有和n互质的数的和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>∗</mo><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\phi(d)*d/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>做完了,可以预处理最小质因数做到log</p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1601637832702.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo>=</mo><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^n[gcd(i,n)==d]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^{n/d}[gcd(i,n/d)==1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.4770100000000004em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>d</mi><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum_{d|n}d\phi(d)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p>
<p>卢卡斯定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n,m)%P=C(n%P,m%P)*C(n/P,m/P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>n用m进制分解,然后各位的数对应求组合数然后相乘???</p>
<p>gcd,lcm</p>
<p>gcd二除法</p>
<p>b=0,gcd=a</p>
<ol>
<li>两数都为偶数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">=2*gcd(a/2,b/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<ol start="2">
<li>二数都为奇数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a-b,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<ol start="3">
<li>一奇一偶</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a/2,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>多元一次方程输出方案</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1601641712364.png" alt="" loading="lazy"></figure>
<p>显然我们考虑如果能前n-1个构造出和第n个数剩余系下所有数就能表示M</p>
<p>然后这个条件就是互质</p>
<p>显然因为我们所有数和最后那个数互质也就是说我们n-1的情况还可以继续变小</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1601641834634.png" alt="" loading="lazy"></figure>
<p>具体构造起来可能是O(nlogn)的....</p>
<p>中国剩余定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><munder><mo>∏</mo><mi>i</mi></munder><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N=\prod_{i} m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i=N/m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">K_i*c_i=1 (mod m_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x=\sum_{i=1}^n a_ic_iK_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>正确性显然</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1601644946874.png" alt="" loading="lazy"></figure>
<p>有人想生成函数?</p>
<p>考虑插板法可以计算没有n限制下的解</p>
<p>有限制可以容斥</p>
<p>那么我们考虑至少一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x_i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>很好算,只需要k-n即可</p>
<p>然后我们钦定有多少大于n,k就减去多少个n</p>
<figure data-type="image" tabindex="19"><img src="https://xiaxiaoguang.github.io/post-images/1601646314122.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://xiaxiaoguang.github.io/post-images/1601646334844.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://xiaxiaoguang.github.io/post-images/1601646665421.png" alt="" loading="lazy"></figure>
<p>设i维的j维面有f个,然后转移会发现一条线能成为一个面,而一个面能成为两个面</p>
<p>即i-1维的j维元素*2,j-1维元素成为j维元素...</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><mn>2</mn><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j}*2+f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<figure data-type="image" tabindex="22"><img src="https://xiaxiaoguang.github.io/post-images/1601646591718.png" alt="" loading="lazy"></figure>
<p>规律不好找/jk</p>
<figure data-type="image" tabindex="23"><img src="https://xiaxiaoguang.github.io/post-images/1601647626994.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1568. [2020提高组十连测day5]白银御行]]></title>
        <id>https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/</id>
        <link href="https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/">
        </link>
        <updated>2020-10-01T07:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>哇偶...</p>
<p>畸形第k大-&gt;</p>
<p>二分答案</p>
<p>多次询问-&gt;</p>
<p>整体二分</p>
<p>然后考虑怎么把矩阵相交变成数点问题</p>
<p>两个矩阵相交的条件可以是在两维都要区间相交</p>
<p>而转换...最好用的消除条件的方法就是容斥</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601537501647.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601537631151.png" alt="" loading="lazy"></figure>
<p>所以也就是说我们按照这个条件去处理每一层的整体二分过程就好了</p>
<p>问题在于代码有好多好多细节QAQ</p>
<p>堪比接水果</p>
<p>注意 :</p>
<ol>
<li>
<p>多开几个数组处理每一层询问和修改的分开</p>
</li>
<li>
<p>注意最后值域收缩到一个点那些点的答案就是这个值</p>
</li>
<li>
<p>注意最小化所以&lt;=分左边</p>
</li>
</ol>
<p>code:</p>
<pre><code class="language-cpp">
//Finished by dawn light
//as difficult as frute
//qwq orzmyh!
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7 + 1e4;
using namespace std;

int n, m;
struct mat {
	int r1, c1, r2, c2, z, id;
	bool operator&lt;(const mat &amp;x)const {
		return c1 == x.c1 ? z &lt; x.z : c1 &lt; x.c1;
	}
} e[MAXN], ask[MAXN], mdq[MAXN * 2], a[MAXN], b[MAXN];

struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN * 2];
	inline void mdf(int x, int V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tr;
int tp[MAXN];

inline void pd1(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, -1);
		}
}

inline void pd2(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd3(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd4(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void fz(int vL, int vR, int L, int R, int l, int r) {
	if(vL == vR) {
		for(int i = l; i &lt;= r; ++i) {
			tp[ask[i].id] = vL;
		}
		return;
	}
	int M = (vL + vR) &gt;&gt; 1;
	for(int i = l; i &lt;= r; ++i)tp[ask[i].id] = 0;
	pd1(L, R, l, r, M);
	pd2(L, R, l, r, M);
	pd3(L, R, l, r, M);
	pd4(L, R, l, r, M);
	int T1 = 0;
	int T2 = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(tp[ask[i].id] &gt;= ask[i].z) {
			a[++T1] = ask[i];
		} else {
			b[++T2] = ask[i];
			b[T2].z -= tp[ask[i].id];
		}
	}
	int tmp1 = l + T1 - 1;
	for(int i = l; i &lt;= tmp1; ++i) {
		ask[i] = a[i - l + 1];
	}
	for(int i = tmp1 + 1; i &lt;= r; ++i) {
		ask[i] = b[i - tmp1];
	}
	T1 = 0;
	T2 = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= M) {
			a[++T1] = e[i];
		} else {
			b[++T2] = e[i];
		}
	}
	int tmp2 = L + T1 - 1;
	for(int i = L; i &lt;= tmp2; ++i) {
		e[i] = a[i - L + 1];
	}
	for(int i = tmp2 + 1; i &lt;= R; ++i) {
		e[i] = b[i - tmp2];
	}
	if(l &lt;= tmp1)fz(vL, M, L, tmp2, l, tmp1);
	if(r &gt;= tmp1 + 1)fz(M + 1, vR, tmp2 + 1, R, tmp1 + 1, r);
	return ;
}

inline void solve2() {
	fz(1, n + 1, 1, n, 1, m);
	for(int i = 1; i &lt;= m; ++i) {
		if(tp[i] &gt; n)puts(&quot;-1&quot;);
		else printf(&quot;%d\n&quot;, tp[i]);
	}
	return ;
}
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;22)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
int main() {
	n = read();
	m = read();
	for(int i = 1; i &lt;= n; ++i) {
		e[i].r1 = read();
		e[i].c1 = read();
		e[i].r2 = read();
		e[i].c2 = read();
		e[i].id = i;
	}
	for(int i = 1; i &lt;= m; ++i) {
		ask[i].r1 = read();
		ask[i].c1 = read();
		ask[i].r2 = read();
		ask[i].c2 = read();
		ask[i].z = read();
		ask[i].id = i;
	}
	solve2();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第一场)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/">
        </link>
        <updated>2020-10-01T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>屑</p>
<p>A</p>
<p>考虑必胜策略的构造</p>
<p>假设我有最后一张牌</p>
<p>如果对方选取i,我就选择i+1</p>
<p>然后考虑我们这样做一定能有一个牌权</p>
<p>如果对方先手而且我的牌不比他多就能靠这个牌权取胜</p>
<p>所以:</p>
<p>奇数+奇先手必胜</p>
<p>奇数+偶先手必胜</p>
<p>偶数 偶必胜</p>
<p>n=2先手必胜</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
int T;
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--&gt;0) {
		int op;
		cin&gt;&gt;s;
		scanf(&quot;%d&quot;,&amp;op);
		if(s.size()==1 &amp;&amp; s[s.size()-1]=='2') {
			printf(&quot;%d\n&quot;,op);
		} else if((s[s.size()-1]-'0')%2==0)puts(&quot;1&quot;);
		else {
			if(op==0)puts(&quot;0&quot;);
			else puts(&quot;1&quot;);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>发现我们可以在线/se</p>
<p>举个例子:</p>
<p>染色一行,那么我们如果染蓝色,看看这一行最近一次染得是蓝色还是红色</p>
<p>如果染的蓝色,那么我们查询这个上次到这次时间区域染列红色的个数,那些会变蓝,对应加上</p>
<p>如果染的是红色,那么我们查询这次到上次时域染的行蓝色的个数,那些会不变,加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">m-cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>直接暴力分类讨论要8中,所以我在代码中压缩了行列的区别</p>
<p>考场心态炸裂QAQ</p>
<p>不该打grakn forces2020</p>
<p>齐神的O(n)做法</p>
<p>每一行每一列按照染色的最后时间排序</p>
<p>然后就会发现上述过程可以排序双指针了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int MAXN=1e6+7;
using namespace std;
int n,m,k;
ll ans;
int col[2][MAXN],tim[2][MAXN];
//color time
const int MAXT=2e6+7;
struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXT];
	inline void mdf(int x,int v) {
		for(; x&lt;=k; x+=lowbit(x))tr[x]+=v;
	}
	inline ll qry(int x) {
		ll ret=0;
		for(; x; x-=lowbit(x))ret+=tr[x];
		return ret;
	}
} tr[2][2];//first h,l second r,b

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int main() {
	n=read();
	m=read();
	k=read();
	ans=1ll*n*m;
	for(int i=1,x,y,z; i&lt;=k; ++i) {
		x=read();
		z=read();
		y=read();
		if(y==0) {//红色
			if(col[x][z]==0) {//base red paint red
				ans += tr[x^1][1].qry(i)-tr[x^1][1].qry(tim[x][z]);
			} else {//base blue paint ret
				if(x==1) {
					ans += (n-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
				} else ans += (m-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
			}
            		} else {//蓝色
			if(col[x][z]==1) {
				ans -= tr[x^1][0].qry(i)-tr[x^1][0].qry(tim[x][z]);
			} else {//红色？？
				if(x==0)
					ans -= (m-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
				else ans -= (n-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
			}
		}
		if(tim[x][z]!=0) {
			tr[x][col[x][z]].mdf(tim[x][z],-1);
		}
		tr[x][y].mdf(i,1);
		col[x][z]=y;
		tim[x][z]=i;
	}
	ans=1ll*n*m-ans;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>nth_element</p>
<p>QAQ降智了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=12345;
int n,Q,a[MAXN],v[MAXN];

struct rec {
	ll W;
	int id;
	bool operator&lt;(const rec &amp;x)const {
		return W==x.W?id&lt;x.id:W&gt;x.W;
	}
} p[MAXN];

int t,k;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; ++i)scanf(&quot;%d%d&quot;,&amp;v[i],&amp;a[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for(int i=1; i&lt;=Q; ++i) {
		scanf(&quot;%d%d&quot;,&amp;t,&amp;k);
		for(int i=0; i&lt;n; ++i) {
			p[i].W=1ll*a[i]+1ll*v[i]*t;
			p[i].id=i+1;
		}
		nth_element(p,p+k-1,p+n);
		printf(&quot;%d\n&quot;,p[k-1].id);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>考虑DP,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示看了前i个A数前j个B数能够得到的最小划分代价</p>
<p>然后转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的,因为要枚举上一行上一列是什么</p>
<p>然后转移能优化吗QAQ?</p>
<p>你会发现:</p>
<blockquote>
<p>结论：存在一个最优解的每次删数，至少有一段长度是1</p>
</blockquote>
<p>因为我们有一段都大于1的</p>
<p>我们可以拆成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>a</mi><mo>+</mo><mi>y</mi><mi>b</mi><mo>&lt;</mo><mo>=</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">xa+yb&lt;=(x+y)*(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>所以整完了,转移式子变得可以优化</p>
<p>实现的时候有一维可以直接前缀最小值</p>
<p>另一维...好像按理说也是可以的,不过我的实现是使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>数组</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 2005;
int n, m;
int A[MAXN], B[MAXN];
ll f[MAXN][MAXN], suma[MAXN], sumb[MAXN];
ll minxa[MAXN][MAXN], minxb[MAXN];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		A[i]--;
		suma[i] = suma[i - 1] + A[i];
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;B[i]);
		B[i]--;
		sumb[i] = sumb[i - 1] + B[i];
	}
	if(n &lt; m) {
		swap(n, m);
		swap(A, B);
		swap(suma, sumb);
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	memset(minxa, 0x3f3f3f3f, sizeof(minxa));
	memset(minxb, 0x3f3f3f3f, sizeof(minxb));
	minxa[0][0] = 0;
	for(int i = 1; i &lt;= m; ++i)minxa[0][i] = 0;
	minxb[0] = 0;
	f[0][0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			f[i][j] = min(f[i][j], minxa[i - 1][j - 1] + A[i] * sumb[j]);
			f[i][j] = min(f[i][j], minxb[j - 1] + B[j] * suma[i]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			minxa[i][j] = min(minxa[i][j - 1], f[i][j] - A[i + 1] * sumb[j]);
			minxb[j] = min(minxb[j], f[i][j] - B[j + 1] * suma[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n][m]);
	return 0;
}
/*
3 4
2 4 3
2 6 6 4
*/



</code></pre>
]]></content>
    </entry>
</feed>