<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-04-20T14:58:37.734Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CF576E Painting Edges]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf576e-painting-edges/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf576e-painting-edges/">
        </link>
        <updated>2020-04-20T14:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>不是上午发的那货能叫博客吗?也太简单了吧</p>
<p>所以这里再补一篇....虽然考砸了但还是要学下去啊</p>
<ul>
<li>给定一张 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边的无向图。</li>
<li>一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色，一开始，每条边都没有颜色。</li>
<li>定义合法状态为仅保留染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色中的任何一种颜色的边，图都是一张二分图。</li>
<li>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次操作，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次操作将第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​ 条边的颜色染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>但并不是每次操作都会被执行，只有当执行后仍然合法，才会执行本次操作。</li>
<li>你需要判断每次操作是否会被执行。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n,m,q \le 5 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">k \le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>。</li>
</ul>
<p>其实第一眼就应该看出来是一道[模板]线段树分治啊</p>
<ol>
<li>每条边可能出现可能消失,满足在时间轴上出现是一个区间</li>
<li>询问是否为二分图啊</li>
</ol>
<p>这样的一看就是线段树分治</p>
<p>具体怎么做?</p>
<p>我们按照dfs序去遍历线段树</p>
<p>然后记录从当且叶子到根的每个点的f数组状态,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>在线段树上遇到一条边我们就加入这条边,从一个点离开时我们再把这个边的影响删掉</p>
<p>就是方便我们回溯</p>
<p>这样在叶子结点就是具体的每个时刻可以用来回答答案啦</p>
<p>请仔细研读代码</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 5e5 + 7;
int n, m, k, q;
struct E {
	int u, v, c;
} e[MAXN];

struct P {
	int e, c;
} p[MAXN];

vector&lt;int&gt; chan[MAXN];
vector&lt;int&gt;::iterator pos[MAXN];

struct Dsuontree {
	int fa[MAXN];
	bool fw[MAXN];
	short h[MAXN];
	bool check(int id) {
		int u = e[id].u, v = e[id].v, w = 0;
		while(fa[u])w ^= fw[u], u = fa[u];
		while(fa[v])w ^= fw[v], v = fa[v];
		// w的奇偶性反应了,如果为偶数就存在奇环
		return u != v || w;//如果为奇数就没了啊!奇环...
	}
	E merge(int u, int v) {
		int w = 1;
		while(fa[u])w ^= fw[u], u = fa[u];
		while(fa[v])w ^= fw[v], v = fa[v];
		//我们得到u,v两个点的祖先以及异或和
		if(u == v)return (E) {
			0
		};//妈耶,和个毛
		h[u] &gt; h[v] ? swap(u, v) : void(), fa[u] = v, fw[u] = w;//这个w是因为我们路径压缩之后的
		//按秩合并啊
		return (E) {
			u, v, (h[u] == h[v]) ? h[v]++ : h[v]
		};
		//如果相同我们秩加1
	}
} dsu[51];

struct seg {
	vector&lt;E&gt; t[4 * MAXN], rec[202];
	void ins(int k, int d) {
		rec[d].clear();
		for(int i = 0; i &lt; t[k].size(); ++i) {
			rec[d].push_back(dsu[t[k][i].c].merge(t[k][i].u, t[k][i].v));
			//把k号节点记录的所有边添加进d号状态里面
		}
	}
	void del(int k, int d) {
		for(int i = t[k].size() - 1; i &gt;= 0; --i) {
			if(!rec[d][i].u)continue;
			int u = rec[d][i].u, v = rec[d][i].v, c = t[k][i].c;
			dsu[c].fa[u] = dsu[c].fw[u] = 0;//直接清掉...因为我们一定merge的是树根
			dsu[c].h[v] = rec[d][i].c;//然后v直接恢复秩
		}
	}
	void modi(int l, int r, int k, int st, int en, E v) {
		if(st &gt; r || en &lt; l)return ;
		if(st &lt;= l &amp;&amp; en &gt;= r)return t[k].push_back(v);//区间放线段
		int mid = l + r &gt;&gt; 1;
		modi(l, mid, k &lt;&lt; 1, st, en, v);
		modi(mid + 1, r, k &lt;&lt; 1 | 1, st, en, v);
	}
	void work(int l, int r, int k, int d) {
		ins(k, d);//插入线段
		if(l == r) {
			int id = p[l].e;
            //找到边
			++pos[id];
            //看看边该是哪个颜色了
			dsu[p[l].c].check(id) ? (puts(&quot;YES&quot;), e[id].c = p[l].c) : (puts(&quot;NO&quot;));//询问特定颜色中的情况,删边显然不会影响啊
			return modi(1, q, 1, l + 1, (*pos[id]) - 1, e[id]), del(k, d);
            //从l+1开始,这条边一直到*pos的时间,他都是这个颜色啊!
            //并且记得回溯时删除/kk
		}
		int mid = (l + r) &gt;&gt; 1;
		work(l, mid, k &lt;&lt; 1, d + 1);
		work(mid + 1, r, k &lt;&lt; 1 | 1, d + 1); //向左右子树递归啊,调用更多状态记录
		del(k, d);//回溯时删掉
	}
} seg;

int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;q);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	for(int i = 1; i &lt;= q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;p[i].e, &amp;p[i].c), chan[p[i].e].push_back(i);
        //每条边上放下这个改变时间
	}
	for(int i = 1; i &lt;= m; ++i) {
		chan[i].push_back(q + 1), pos[i] = chan[i].begin();
        //每条边先初始化
	}
	seg.work(1, q, 1, 0);
	return 0;
}

</code></pre>
<p><s>zzz?</s></p>
<p>我也不想颓</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3763 [TJOI2017]DNA]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3763-tjoi2017dna/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3763-tjoi2017dna/">
        </link>
        <updated>2020-04-20T01:46:08.000Z</updated>
        <content type="html"><![CDATA[<p>TJOI2017DxTx</p>
<p>铁憨憨又进了一波新图片qwq</p>
<p>然后这道题在我的任务计划里躺了太久很不爽就做掉吧</p>
<ul>
<li>给你两个串,问有多少个l,r满足在第一个串中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>l</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{l...r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与第二个串至多相差不超过三个字符,且<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 12: r-l+1=len_S_̲{2}'>r-l+1=len_S_{2}</span></li>
<li>字符集小于4</li>
</ul>
<p>哇偶,一看所有子串类型题就是SAM啦</p>
<p>我们先把SAM给建出来,然后从根节点开始往下搜,dfs函数中记录一下用了几个点,然后长度是什么</p>
<p>一旦长度刚好大于<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 7: {len_S_̲2}'>{len_S_2}</span>我们就加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中这个子串出现的次数</p>
<p>非常简单的一个搜索就可以了.....复杂度为啥是对的呢?QWQ</p>
<p>具体实现看看代码吧w<s>所以我们就考制胡窜这样的吗???</s></p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

const int MAXN = 1e6 + 7;
char s[MAXN];
int ans, m, val[MAXN];
namespace SAM {
	int cnt[MAXN &lt;&lt; 1], fa[MAXN &lt;&lt; 1], ch[MAXN &lt;&lt; 1][4], len[MAXN &lt;&lt; 1], lst, T;
	int a[MAXN], c[MAXN];
	inline void init() {
		memset(SAM::ch, 0, sizeof(ch));
		memset(SAM::cnt, 0, sizeof(cnt));
		T = lst = 1;
	}
	inline void ins(int c) {
		int p = lst;
		int np = lst = ++T;
		len[np] = len[p] + 1;
		cnt[np] = 1;//endpos
		for(; p &amp;&amp; !ch[p][c]; p = fa[p])ch[p][c] = np;
		if(!p) {
			fa[np] = 1;
		} else {
			int q = ch[p][c];
			if(len[q] == len[p] + 1)fa[np] = q;
			else {
				int nq = ++T;
				len[nq] = len[p] + 1;
				memcpy(ch[nq], ch[q], sizeof(ch[q]));
				for(; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
				fa[nq] = fa[q];
				fa[q] = fa[np] = nq;
			}
		}
	}
	inline void sort() {
		memset(a, 0, sizeof(a));
		for(int i = 1; i &lt;= T; ++i)++a[len[i]];
		for(int i = 1; i &lt;= T; ++i)a[i] += a[i - 1];
		for(int i = 1; i &lt;= T; ++i)c[a[len[i]]--] = i;
		for(int i = T; i; --i) {
			int p = c[i];
			// printf(&quot;%d %d\n&quot;, p, fa[p]);
			cnt[fa[p]] += cnt[p];
			//子树中本质不同子串个数
		}
	}
	inline void dfs(int u, int len, int j) {
		if(len &gt; m)return (void)(ans += cnt[u]);//就是这样...
		// printf(&quot;%d %d %d?\n&quot;, u, len, j);
		for(int i = 0; i &lt; 4; ++i) {
			if(!ch[u][i])continue;
			if(val[s[len]] == i)dfs(ch[u][i], len + 1, j);
			else if(j &lt; 3)dfs(ch[u][i], len + 1, j + 1);//不同?限制不能多选
		}
	}
};



int main() {
	val['T'] = 0;
	val['A'] = 1;
	val['C'] = 2;
	val['G'] = 3;
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	while(T--) {
		SAM::init();
		ans = 0;
		scanf(&quot;%s&quot;, s + 1);
		int L = strlen(s + 1);
		for(int i = 1; i &lt;= L; ++i)SAM::ins(val[s[i]]);
		SAM::sort();
		scanf(&quot;%s&quot;, s + 1);
		m = strlen(s + 1);
		SAM::dfs(1, 1, 0);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4262 [Code+#3]白金元首与莫斯科]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4262-code3bai-jin-yuan-shou-yu-mo-si-ke/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4262-code3bai-jin-yuan-shou-yu-mo-si-ke/">
        </link>
        <updated>2020-04-19T14:31:14.000Z</updated>
        <content type="html"><![CDATA[<p>国家队队长李佳衡推荐插头DP练习题</p>
<p>不用多说啥吧qwq ,元首<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>d</mi><mi>o</mi><mi>l</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">Adolf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>永在qwq</p>
<ul>
<li>1*2多米诺骨牌合法放置方案数,存在基础障碍位置</li>
<li>你需要确定n*m每个位置额外成为障碍时的答案</li>
</ul>
<p>一看就很自闭,所以我们考虑枚举每个位置是否为障碍</p>
<p>然后设计下状态,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>表示我目前在(i,j),长度为i+1的轮廓线插头状态</p>
<ol>
<li>如果这个线是横的,那么1是下插头,0为没有插头</li>
<li>如果这个线是竖的,那么1是右插头,0是没</li>
</ol>
<p>eg:<img src="https://xiaxiaoguang.github.io/post-images/1587307200743.png" alt="" loading="lazy"></p>
<p>然后考虑转移</p>
<p>case1:这个格子是个障碍</p>
<p>只有在都没有插头的时候才能转移</p>
<p>case2:这个格子健全,但是同时有下和右插头</p>
<p>命没了</p>
<p>case3:只有右插头||只有下插头</p>
<p>转移后竖线和这个横线都变成没插头状态</p>
<p>case4:没插头</p>
<p>如果右边不是障碍,那么可以右,同理可以放下</p>
<p>当然,也可以空出这个格子qwq</p>
<p>然后...好像没啥了啊</p>
<p>等等,你发现他TLE了</p>
<p>那么我们考虑优化枚举每个点的过程,我们从下到上和刚刚完全反着的做一遍,就可以通过上DP数组和下DP数组来拼出每个点做障碍的答案</p>
<p>具体的,枚举到的点(i,j)只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>S</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][S]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>的S和K都没有插头才能乘起来</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
const int MAXN = 18;
const int P = 1e9 + 7;
using namespace std;
int n, m, ma[20][20];
int f[MAXN][MAXN][270000];
int g[MAXN][MAXN][270000];
int ans[20][20];

void modify(int &amp;a, int b) {
	a += b;
	if(a &gt; P)a -= P;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			scanf(&quot;%d&quot;, &amp;ma[i][j]);
			ma[i][j] ^= 1;
            //强行^1
		}
	}
	int max_state = (1 &lt;&lt; m + 1) - 1;
	f[0][m][0] = 1;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 0; j &lt;= max_state; ++j) {
			modify(f[i][0][j &lt;&lt; 1], f[i - 1][m][j]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			for(int k = 0; k &lt;= max_state; ++k) {
				int val = f[i][j - 1][k];
				if(!val)continue;
				int pl1 = (k &gt;&gt; j - 1) &amp; 1;
				int pl2 = (k &gt;&gt; j) &amp; 1;
				if(!ma[i][j]) {
					if(!pl1 &amp;&amp; !pl2)modify(f[i][j][k], val);
					//case 1,障碍
				} else if(!pl1 &amp;&amp; !pl2) {
					modify(f[i][j][k], val);
					//case 4,不放
					if(ma[i + 1][j])modify(f[i][j][k ^ (1 &lt;&lt; j - 1)], val);//放右插头
					if(ma[i][j + 1])modify(f[i][j][k ^ (1 &lt;&lt; j)], val);
                    //放下插头
				} else if(!pl1 &amp;&amp; pl2) {
					modify(f[i][j][k ^ (1 &lt;&lt; j)], val);
                    //只能放个空了,这个是为了去掉
				} else if(pl1 &amp;&amp; !pl2) {
					modify(f[i][j][k ^ (1 &lt;&lt; j - 1)], val);
				}

			}
		}
	}
	g[n + 1][1][0] = 1;
	for(int i = n; i &gt; 0; --i) {//反着
		for(int j = 0; j &lt;= max_state; ++j)modify(g[i][m + 1][j &gt;&gt; 1], g[i + 1][1][j]);
		for(int j = m; j &gt; 0; --j) {//反着
			for(int k = 0; k &lt;= max_state; ++k) {
				int val = g[i][j + 1][k];
                //从+1推
				if(!val)continue;
				int pl1 = (k &gt;&gt; j - 1) &amp; 1;
				int pl2 = (k &gt;&gt; j) &amp; 1;
				if(!ma[i][j]) {
					if(!pl1 &amp;&amp; !pl2)modify(g[i][j][k], val);
				} else if(!pl1 &amp;&amp; !pl2) {
					modify(g[i][j][k], val);
					if(ma[i - 1][j])modify(g[i][j][k ^ (1 &lt;&lt; j)], val);
					if(ma[i][j - 1])modify(g[i][j][k ^ (1 &lt;&lt; j - 1)], val);
				} else if(!pl1 &amp;&amp; pl2) {
					modify(g[i][j][k ^ (1 &lt;&lt; j)], val);
				} else if(pl1 &amp;&amp; !pl2)
					modify(g[i][j][k ^ (1 &lt;&lt; j - 1)], val);
			}
		}
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			if(!ma[i][j])continue;
			int now = max_state ^ (1 &lt;&lt; j - 1) ^ (1 &lt;&lt; j);
			for(int k = now; k; k = (k - 1)&amp;now)//调用子集即可
				modify(ans[i][j], 1ll * f[i][j - 1][k] * g[i][j + 1][k] % P);
                //显然可以组合,当且仅当他们是一样的
			modify(ans[i][j], 1ll * f[i][j - 1][0]*g[i][j + 1][0] % P);
            //0也是好选择,减子集弄不到0
		}
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			printf(&quot;%d &quot;, ans[i][j]);
		}
		puts(&quot;&quot;);
	}
	return 0;
}
</code></pre>
<p>唉,学OI的热情下降?我博客图都很慢更新了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF575I Robots protection]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf575i-robots-protection/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf575i-robots-protection/">
        </link>
        <updated>2020-04-18T14:33:34.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>一日不更博,一日不睡觉</p>
<p><s>话说已经堕落到这种程度了吗</s></p>
<ul>
<li>你需要在平面直角坐标系上进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次操作。</li>
<li>每次操作有两种，要么放置一个两条直角边平行于坐标轴的等腰直角三角形，要么查询某一个点被多少个三角形覆盖。</li>
<li>每个等腰直角三角形可以用四个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>r</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dir,x,y,len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 确定，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>r</mi><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dir \in [1,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>表示三角形的方向，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 表示直角的顶点坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">len</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span></span></span></span> 表示直角边的长度。</li>
<li>保证所有点的坐标都是整数且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\in [1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \le 5 \times 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">q \le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
<p>看上去是做不了的,直接暴力有0分的好成绩,所以我们考虑翻题解</p>
<p>又是二维树状数组/jk/jk/jk?</p>
<p>然后这里你会发现我们要维护斜坐标系的一个标记加减,也就是说我们单纯的一个直角区域内的加减不满足了</p>
<p>所以我们要用斜二测画法,满足y坐标变成原来的1/2</p>
<p>这样我们能满足这样的角的标记</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1587221573526.png" alt="" loading="lazy"></figure>
<p>然后这样还是不太够,我们再把x变成原来的1/2,我们又可以满足</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1587221652258.png" alt="" loading="lazy"></figure>
<p>又因为显然等腰直角三角形满足的性质就只会设计这几个角啊</p>
<p>然后我们有罪恶的下图,按照下图去打标记统计前缀和就好了</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1587221850625.png" alt="" loading="lazy"></figure>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define lowbit(x) (x&amp;(-x))
using namespace std;
const int MAXN = 1e4 + 7, MAXM = 1e5 + 7;
int n, m, op[MAXM], dir[MAXM], x[MAXM], y[MAXM], c[MAXM], ans[MAXM];
int X, Y, bit[MAXN][MAXN], stx[MAXM], sty[MAXM], stz[MAXM], top;

inline void add(int x, int y, int z) {
	stx[++top] = x;
	sty[top] = y;
	stz[top] = z;
	for(int i = x; i &lt;= X; i += lowbit(i)) {
		for(int j = y; j &lt;= Y; j += lowbit(j)) {
			bit[i][j] += z;
		}
	}
}

inline int ask(int x, int y) {
	int z = 0;
	for(int i = x; i; i -= lowbit(i)) {
		for(int j = y; j; j -= lowbit(j)) {
			z += bit[i][j];
		}
	}
	return z;
}

inline void clear() {
	while(top) {
		add(stx[top], sty[top], -stz[top]);
		top -= 2;
	}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;op[i]);
		if(op[i] == 1)
			scanf(&quot;%d%d%d%d&quot;, &amp;dir[i], &amp;x[i], &amp;y[i], &amp;c[i]);
		else {
			scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]);
		}
	}
	
	X = n;
	Y = n;
	for(int i = 1; i &lt;= m; ++i) {
		if(op[i] == 1) {
			if(dir[i] == 1)add(x[i], y[i], 1);
			if(dir[i] == 2)add(x[i], y[i] + 1, -1);
			if(dir[i] == 3)add(x[i] + 1, y[i], -1);
			if(dir[i] == 4)add(x[i] + 1, y[i] + 1, 1);
		} else {
			ans[i] += ask(x[i], y[i]);
		}
	}
	clear();

	X = n + n;
	Y = n;
	for(int i = 1; i &lt;= m; ++i) {
		if(op[i] == 1) {
			if(dir[i] == 1)
				add(x[i] + y[i] + c[i] + 1, y[i], -1);
			if(dir[i] == 4)
				add(x[i] + y[i] - c[i], y[i] + 1, -1);
		} else {
			ans[i] += ask(x[i] + y[i], y[i]);
		}
	}
	clear();

	X = n;
	Y = n + n;
	for(int i = 1; i &lt;= m; ++i) {
		if(op[i] == 1) {
			if(dir[i] == 1)
				add(n - x[i] + 2, x[i] + y[i] + c[i] + 1, 1);
			if(dir[i] == 4)
				add(n - x[i] + 1, x[i] + y[i] - c[i], 1);
		} else {
			ans[i] += ask(n - x[i] + 1, x[i] + y[i]);
		}
	}
	clear();

	X = n + n;
	Y = n;
	for(int i = 1; i &lt;= m; ++i) {
		if(op[i] == 1) {
			if(dir[i] == 2)
				add(n + x[i] - y[i] + c[i] + 2, y[i] + 1, 1);
			if(dir[i] == 3)
				add(n + x[i] - y[i] - c[i] + 1, y[i], 1);
		} else {
			ans[i] += ask(n + x[i] - y[i] + 1, y[i]);
		}
	}
	clear();

	X = n;
	Y = n + n;
	for(int i = 1; i &lt;= m; ++i) {
		if(op[i] == 1) {
			if(dir[i] == 2)
				add(x[i], n - x[i] + y[i] - c[i] + 1, 1);
			if(dir[i] == 3)
				add(x[i] + 1, n - x[i] + y[i] + c[i] + 2, 1);
		} else {
			ans[i] += ask(x[i], n - x[i] + y[i] + 1);
		}
	}
	clear();
	for(int i = 1; i &lt;= m; ++i)
		if(op[i] == 2)printf(&quot;%d\n&quot;, ans[i]);

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF576D Flights for Regular Customers]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf576d-flights-for-regular-customers/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf576d-flights-for-regular-customers/">
        </link>
        <updated>2020-04-17T12:29:51.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>小清新的一道题,因为不需要灵机一动</p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></p>
<p>题意翻译</p>
<ul>
<li>给定一张 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 条边的有向图。</li>
<li>一开始你在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号节点，你要走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 号节点去。</li>
<li>只有当你已经走过了至少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi mathvariant="normal">​</mi></msub><mi>i</mi></mrow><annotation encoding="application/x-tex">d_​i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">​</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span></span></span></span> 条边时，你才能走第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 条边。</li>
<li>问最少要走多少步，或判断无法到达。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>150</mn></mrow><annotation encoding="application/x-tex">n,m \le 150</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">d_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>看完题我们一定会对n,m比较小感到诧异</p>
<p>因为这样子至少走过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>条边这个限制就会变得鸡肋,我们可以矩阵快速幂啊!</p>
<p>那么做法也就呼之欲出了</p>
<p>我们把原来的边按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>拍下序,然后从小到大处理</p>
<p>然后考虑枚举每条边,然后把它加入原来的矩阵中,然后用快速幂让这个矩阵自己乘自己乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_{i+1}-d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>次</p>
<p>再依次这样做,可以判断能否到达</p>
<p>如果要看最少走多少条边我们可以考虑如果两个相邻的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>值小于n就暴力做一下,否则就先做n次看能不能到达,之后再快速幂做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">d_i+1-d_i-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次,因为剩下的一定也不会使他们到达了</p>
<p>发现每个点要么是0要么是1,就可以用bitset来写矩阵乘法,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">/\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>,否则过不去</p>
<p>code:</p>
<pre><code class="language-cpp">//From Dawn light
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using std::sort;
using std::bitset;
int n, m;
bitset&lt;160&gt;a[160], b[160], T[160];
struct rec {
	int from, to, w;
	bool operator&lt;(const rec &amp;x)const {
		return w &lt; x.w;
	}
} edge[160];

void times(bitset&lt;160&gt; *a, bitset&lt;160&gt; *b) {
	bitset&lt;160&gt; res[160];
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			if(a[i][j])res[i] |= b[j];
		}
	}
	for(int i = 1; i &lt;= n; ++i)a[i] = res[i];
}

inline void ksm(bitset&lt;160&gt; *a, int b) {
	bitset&lt;160&gt; res[160];
	for(int i = 1; i &lt;= n; ++i)res[i][i] = 1;
	while(b) {
		if(b &amp; 1)times(res, a);
		times(a, a);
		b &gt;&gt;= 1;
	}
	for(int i = 1; i &lt;= n; ++i)a[i] = res[i];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;edge[i].from, &amp;edge[i].to, &amp;edge[i].w);
	}
	sort(edge + 1, edge + m + 1);
	for(int i = 1; i &lt;= n; ++i) {
		a[i][i] = 1;
	}
	int now = 0;
	if(edge[1].w &gt; 0)return puts(&quot;Impossible&quot;), 0;

	// puts(&quot;QWQ&quot;);
	for(int i = 1; i &lt; m; ++i) {
		T[edge[i].from][edge[i].to] = 1;
		// printf(&quot;%d?\n&quot;, i);
		if(edge[i].w == edge[i + 1].w)continue;
		// printf(&quot;??&quot;);
		for(int j = 1; j &lt;= n + 1 &amp;&amp; now &lt; edge[i + 1].w; ++j, ++now) {
			// printf(&quot;%d &quot;, j);
			times(a, T);
			if(a[1][n] == 1)return printf(&quot;%d\n&quot;, now + 1), 0;
		}
		// puts(&quot;&quot;);
		for(int j = 1; j &lt;= n; ++j) {
			b[j] = T[j];
		}
		ksm(b, edge[i + 1].w - now);
		times(a, b);
		now = edge[i + 1].w;
	}
	// puts(&quot;QWQW&quot;);
	T[edge[m].from][edge[m].to] = 1;
	for(int j = 1; j &lt;= n + 1; ++j, now++) {
		times(a, T);
		if(a[1][n] == 1)return printf(&quot;%d\n&quot;, now + 1), 0;
	}
	return puts(&quot;Impossible&quot;), 0;
}


</code></pre>
<p>是不是很模板啊</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4363 [九省联考2018]一双木棋chess]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4363-jiu-sheng-lian-kao-2018yi-shuang-mu-qi-chess/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4363-jiu-sheng-lian-kao-2018yi-shuang-mu-qi-chess/">
        </link>
        <updated>2020-04-15T06:49:34.000Z</updated>
        <content type="html"><![CDATA[<p>九省联考D1T1</p>
<p>哇偶,状压DP我果然还是不会的,要多做些才行呢</p>
<p>如果考场考了是不是就TAT了啊</p>
<p>简要题意没有了</p>
<p>上去直接考虑n=2m=2,发现可以手算所有决策</p>
<p>以及还有n=10m=1,会发现我们只能从左到右放</p>
<p>然后没了,正解吧</p>
<p>轮廓线DP</p>
<p>一种挺奇妙的DP状态设计方式啊!</p>
<p>我们把n+m-1个行和列压起来,然后这一位为0表示轮廓线是横着的边,如果为1就表示轮廓线为竖着的边</p>
<p>被轮廓线围住的三角形就是放棋子的格子</p>
<p>然后你会发现这个状态的设计很不错,因为他充分利用了每个信息------这个棋盘一定满足放置是一个从右上到左下的三角形</p>
<p>而且我们可以通过0/1来定位棋子具体在哪一个格子,从而实现转移qwq</p>
<p>eg:</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1586936687539.png" alt="" loading="lazy"></figure>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0, f = 1;
		register char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;
const int MAXN = 10;
const int P = 1e9 + 7;

int a[MAXN][MAXN], b[MAXN][MAXN];

int f[1 &lt;&lt; (MAXN &lt;&lt; 1)];

int dfs(int sta, bool who, int n, int m) {
	if(~f[sta])return f[sta];
	f[sta] = who ? -P : P;
	int x = n, y = 0;
	for(int i = 0; i &lt; n + m - 1; ++i) {
		if(sta &gt;&gt; i &amp; 1)x--;
		else y++;
		if((sta &gt;&gt; i &amp; 3) != 1)
			continue;
		int nxt = sta ^ (3 &lt;&lt; i);
		if(who)
			f[sta] = max(f[sta], dfs(nxt, who ^ 1, n, m) + a[x][y]);
		else
			f[sta] = min(f[sta], dfs(nxt, who ^ 1, n, m) - b[x][y]);
	}
	return f[sta];
}


int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	int n = read(), m = read();
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; m; ++j) {
			a[i][j] = read();
		}
	}
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; m; ++j) {
			b[i][j] = read();
		}
	}
	memset(f, -1, sizeof(f));
	f[((1 &lt;&lt; n) - 1) &lt;&lt; m] = 0;
	printf(&quot;%d\n&quot;, dfs((1 &lt;&lt; n) - 1, 1, n, m));
}

</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>l</mi><mi>j</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">Orzljh
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">h</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4364 [九省联考2018]IIIDX]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4364-jiu-sheng-lian-kao-2018iiidx/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4364-jiu-sheng-lian-kao-2018iiidx/">
        </link>
        <updated>2020-04-14T09:26:06.000Z</updated>
        <content type="html"><![CDATA[<p>九省联考D1T2</p>
<p>吐槽这样的<img src="https://xiaxiaoguang.github.io/post-images/1586856430229.png" alt="" loading="lazy">弱者只会弄水题</p>
<p>另外![](/.......)....本来这里应该有张p站的图的</p>
<ul>
<li>给你一颗树和一些权值,要求你给这个树分权值,满足父亲的权值小于儿子而且按照bfs序越靠前的点权值越大,输出方案</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span></p>
<p>首先我们有个一眼的做法就是考虑直接贪心,就是给编号最小的儿子最大的siz个去组方案</p>
<p>先把权值按照从大到小排序能快一点</p>
<p>然而如果出现权值相等的情况就命没了,eg 4 2.0 1 1 2 1</p>
<p>你会这样划分<img src="https://xiaxiaoguang.github.io/post-images/1586856792627.png" alt="" loading="lazy"></p>
<p>然后命没了</p>
<p>所以我们要改改这个做法</p>
<p>为什么不对?因为我们是按照dfs序去划分,而题面中都提示你按照bfs序去做了</p>
<p>所以我们再想直接按照bfs序去做要怎么搞</p>
<p>也就是说我们要同时维护父亲预留大小和查询这个点的最大可能性</p>
<p>线段树</p>
<ul>
<li>1.维护前缀有多少个点可以选</li>
</ul>
<p>没了</p>
<p>然后你会发现一个之前贪心不用搞的事情,就是我们相等的权值一定要尽可能右边的,因为线段树上相等的一列按照这个方法做是右边更优左边更劣的...当然这是在同一层的视角下</p>
<p>update:将完课后被神仙队友爆锤,一堆锅....还现场模拟代码/xk/xk/xk</p>
<p>你会发现我们可能会出现选完一个点预留好了然后又去选了左边使得预留不够吗?</p>
<p>不可能,因为我们二分<strong>只看右边啊</strong></p>
<p>你会发现如果我们出现一个点为0的情况而我们二分到了这个点吗?</p>
<p>此时看代码会自动+1,这个+1也是为了处理这个而来的</p>
<p>消极.</p>
<p>谁知道呢?</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
const int MAXN = 5e5 + 7;
const int inf = 1e9;
using namespace std;
struct rec {
    int mn, del;
} tr[MAXN &lt;&lt; 2];
int n, N;
double k;
int a[MAXN], b[MAXN], ans[MAXN], siz[MAXN], fa[MAXN], cnt[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
    static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
    inline char nc() {
        if(p1 == pend) {
            p1 = buf;
            pend = buf + fread(buf, 1, BUF_SIZE, stdin);
        }
        return *p1++;
    }
    inline int read() {
        int x = 0, f = 1;
        char s = nc();
        for(; !isdigit(s); s = nc())if(s == '-')f = -1;
        for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
        return x * f;
    }
}
using namespace fastIO;

inline bool cmp(int a, int b) {
    return a &gt; b;
}

inline void add(int x, int delta) {
    tr[x].del += delta;
    tr[x].mn += delta;
}

inline void up(int x) {
    tr[x].mn = min(tr[x &lt;&lt; 1].mn, tr[x &lt;&lt; 1 | 1].mn);
}

inline void down(int x) {
    add(x &lt;&lt; 1, tr[x].del);
    add(x &lt;&lt; 1 | 1, tr[x].del);
    tr[x].del = 0;
}

inline void build(int k, int l, int r) {
    if(l == r) {
        tr[k].mn = l;
        return ;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(k &lt;&lt; 1, l, mid);
    build(k &lt;&lt; 1 | 1, mid + 1, r);
    up(k);
}

inline int query(int k, int l, int r, int qwq) {
    if(l == r) {
        return (tr[k].mn &gt;= qwq ? l : l + 1);
    }
    down(k);
    int mid = (l + r) &gt;&gt; 1;
    if(qwq &lt;= tr[k &lt;&lt; 1 | 1].mn)return query(k &lt;&lt; 1, l, mid, qwq);
    else return query(k &lt;&lt; 1 | 1, mid + 1, r, qwq);
}

inline void update(int k, int l, int r, int L, int R, int D) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        tr[k].mn += D;
        tr[k].del += D;
        return ;
    }
    down(k);
    int mid = (l + r) &gt;&gt; 1;
    if(L &lt;= mid)update(k &lt;&lt; 1, l, mid, L, R, D);
    if(R &gt; mid)update(k &lt;&lt; 1 | 1, mid + 1, r, L, R, D);
    up(k);
}

int main() {
    // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%lf&quot;, &amp;k);
    for(int i = 1; i &lt;= n; ++i)a[i] = read();// printf(&quot;%d?\n&quot;, a[i]);
    sort(a + 1, a + n + 1, cmp);
    for(int i = n - 1; i; i--) {
        // printf(&quot;%d %d\n&quot;, a[i], a[i + 1]);
        if(a[i] == a[i + 1])cnt[i] = cnt[i + 1] + 1;
        else cnt[i] = 0;
    }
    for(int i = 1; i &lt;= n; ++i) {
        fa[i] = (int)floor(i / k);
        // printf(&quot;%d \n&quot;, fa[i]);
        siz[i] = 1;
    }
    for(int i = n; i; --i) {
        siz[fa[i]] += siz[i];
        // printf(&quot;%d?\n &quot;, siz[i]);
        //统计子树和
        //SAM基操
    }
    build(1, 1, n);
    for(int i = 1; i &lt;= n; ++i) {
        // printf(&quot;%d %d?\n&quot;, fa[i], siz[fa[i]] - 1);
        if(fa[i] &amp;&amp; fa[i] != fa[i - 1])
            update(1, 1, n, ans[fa[i]], n, siz[fa[i]] - 1);
        int x = query(1, 1, n, siz[i]);
        // printf(&quot;%d %d\n&quot;, x, cnt[x]);

        x += cnt[x];
        // printf(&quot;%d ?&quot;, x);
        cnt[x]++;
        // printf(&quot;%d \n&quot;, cnt[x]);

        ans[i] = x;
        update(1, 1, n, x, n, -siz[i]);
    }
    for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, a[ans[i]]);
    return 0;
}
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6381 『MdOI R2』Odyssey]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6381-mdoi-r2-odyssey/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6381-mdoi-r2-odyssey/">
        </link>
        <updated>2020-04-13T14:52:12.000Z</updated>
        <content type="html"><![CDATA[<p>洛谷四月月赛Div1T1</p>
<p>哇偶,看来我T1就不会做qwq</p>
<p>然后一个30暴力就把自己带走了</p>
<p>若正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 满足：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的积是一个正整数的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次方，即存在正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><msup><mi>c</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">ab=c^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>那么我们称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 为一组完美数对。</p>
<p>有一个包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个结点和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 条边的有向无环图，这张图中的每条边都有权值和长度两个属性。</p>
<p>如果一条路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 满足以下条件之一，则称其为一条完美路径：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 中仅包含一条边。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 从其起点开始依次为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>3</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>e</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">e_1, e_2, e_3, \ldots e_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mtext> </mtext><mo>(</mo><mi>p</mi><mo>≥</mo><mn>2</mn><mo>)</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p\ (p\ge 2)p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord mathdefault">p</span></span></span></span> 条边，对于任意的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\leq i\leq p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的权值和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">e_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>​ 的权值组成完美数对。</p>
<p>你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。</p>
<p>先不用说k=1或者n&lt;=10了</p>
<p>k&lt;=2?</p>
<p>我们发现有这样一个不难发现的规律,就是直接对于每个边的权值每个质因数因子%2,那么要求乘起来等于2?,然后你会发现如果要从一条边走向另一条边就一定这两条边权值相等</p>
<p>所以我们枚举每个权值,然后拿权值等于我们枚举的边去跑拓扑排序就好了</p>
<p>k&lt;=10?</p>
<p>之前的结论其实还是有用的,进行之前那个取模之后,你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a+b==k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a&lt;k,b&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,所以你会发现对于一个a只有一个唯一的b对吧</p>
<p>那么我们就可以和之前一样枚举一个权值,然后拿所有权值等于a和b的边去跑一个0/1状态的拓扑排序,这个很简单,因为毕竟只有两个状态</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
const int MAXN = 3e5 + 7;
struct rec {
	rec(int a = 0, int b = 0, int c = 0, int d = 0) {
		x = a, y = b, w = c, l = d;
	}
	int x, y, w, l;
};
int n, m, k, ans, ccnt, x, y, w, l, cnt;
int home[MAXN], to[MAXN], nxt[MAXN], in[MAXN];
int r[MAXN], vis[MAXN], dp[MAXN][2], f[MAXN];
queue&lt;int&gt; q;
vector&lt;rec&gt; v[MAXN];

bool cmp(rec a, rec b) {
	return r[a.x] &lt; r[b.x];
}

void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	in[y]++;
}

pair&lt;int, int&gt; proc (int a) {
	ll res1 = 1, res2 = 1;
	for(int i = 2; i * i &lt;= a; ++i) {
		int tmp = 0;
		while(a % i == 0) {
			tmp++, a /= i;
		}
		if(tmp % k) {
			for(int j = 1; j &lt;= tmp % k; ++j) {
				res1 = (res1 * i);
			}
			for(int j = 1; j &lt;= k - tmp % k; ++j) {
				res2 = (res2 * i &gt; 100000 ? 0 : res2 * i);
			}
		}
	}
	if(k != 1)res1 *= a;
	for(int j = 2; j &lt;= k; ++j) {
		res2 = (res2 * a &gt; 100000 ? 0 : res2 * a);
	}
	return make_pair((int)res1, (int)res2);
}

void topo() {
	for(int i = 1; i &lt;= n; ++i) {
		if(!in[i]) {
			q.push(i);
			r[i] = ++cnt;
		}
	}
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i = home[u]; i; i = nxt[i]) {
			if(--in[to[i]] == 0) {

				q.push(to[i]);
				r[to[i]] = ++cnt;
			}
		}
	}
	return;
}


int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d%d&quot;, &amp;x, &amp;y, &amp;w, &amp;l);
		pair&lt;int, int&gt; tmp = proc(w);
		if(tmp.second) {
			v[min(tmp.first, tmp.second)].push_back(rec(x, y, tmp.first, l));
			f[min(tmp.first, tmp.second)] = max(tmp.first, tmp.second);
		} else {
			ans = max(ans, l);
		}
		ct(x, y);
	}
	topo();
	for(int i = 1; i &lt;= 100000; ++i) {
		int len = v[i].size();
		if(len == 0)continue;
		sort(v[i].begin(), v[i].end(), cmp);
		for(int j = 0; j &lt; len; ++j) {
			if(vis[v[i][j].x] != i) {
				dp[v[i][j].x][0] = dp[v[i][j].x][1] = 0, vis[v[i][j].x] = i;
			}
			if(vis[v[i][j].y] != i) {
				dp[v[i][j].y][0] = dp[v[i][j].y][1] = 0, vis[v[i][j].y] = i;
			}
			if(v[i][j].w == i) {
				dp[v[i][j].y][0] = max(dp[v[i][j].y][0], dp[v[i][j].x][1] + v[i][j].l);
			}
			if(v[i][j].w == f[i]) {
				dp[v[i][j].y][1] = max(dp[v[i][j].y][1], dp[v[i][j].x][0] + v[i][j].l);
			}
			ans = max(ans, max(dp[v[i][j].y][0], dp[v[i][j].y][1]));
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6383 『MdOI R2』Resurrection]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6383-mdoi-r2-resurrection/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6383-mdoi-r2-resurrection/">
        </link>
        <updated>2020-04-13T08:54:51.000Z</updated>
        <content type="html"><![CDATA[<p>洛谷4月月赛Div1T2</p>
<p>这道题确实真思维题</p>
<p>突然想起NOIP出的树上的数...辣么一道毒瘤思维题....我好怕啊</p>
<p>所以还是要善良</p>
<p>显然的东西:</p>
<p>根,肯定要定在n号点,要不然题目中给出的奇特性质就用不上了</p>
<p><s>之后你会发现从每个点到根他的祖先编号递增?</s></p>
<p>不显然的东西:</p>
<p>上去直接猜结论:</p>
<blockquote>
<p>任意两条新树中的边放在原树中不会相交</p>
</blockquote>
<p>即:<img src="https://xiaxiaoguang.github.io/post-images/1586768771730.png" alt="" loading="lazy">不会出现</p>
<p>考虑证明这个结论是充要的</p>
<p>必要性...显然吧,如果图中第1,3个点想要连边,那么在1上的那条边被断开的时候1<sub>3不能有边断开,而且3</sub>父亲的边一定要断开,所以和2~4矛盾啊</p>
<p>再考虑怎么构造出一种合法方案,这样就充分了</p>
<p>然后我们把根放入一个堆里,做一下流程</p>
<ul>
<li>从堆中取出编号最小的节点,断开原树中与父亲连边,再把他新树中的儿子节点加入集合</li>
</ul>
<p>这样构造的一定合法</p>
<p>所以每个点都会向他的祖先连边,而且如果向x级祖先连边那么1~x-1级祖先他的子树中点就都不能连</p>
<p>考虑f[i][j]表示i向上有j个可以连边的祖先,子树里连边的方案数,那么我们枚举一下x,然后i-&gt;x连一条边,这样子树里的点就都不能向1~x-1连</p>
<p>方程就是这样的</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></munderover><munder><mo>∏</mo><mrow><mi>v</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow></munder><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f[i][j]=\sum_{x=1}^{j}\prod_{v\in son(u)}f_{v,j-(x-1)+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.3747820000000006em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>转移可以前缀和优化</p>
<p>没了</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define CT const int&amp;
#define ll long long
const int P = 998244353;
const int MAXN = 3456;
int n, u, v, f[MAXN][MAXN], p[MAXN], ccnt;
int home[MAXN*2], to[MAXN*2], nxt[MAXN*2];

inline void ct(CT x, CT y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

void dfs(int u, int fa) {
	// printf(&quot;%d?\n&quot;, u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v != fa)
			dfs(v, u);
	}
	for(int j = 0; j &lt;= n; ++j)p[j] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa)continue;
		for(int j = 0; j &lt;= n; ++j) {
			p[j] = 1ll * p[j] * f[v][j] % P;
		}
	}
	for(int i = 1; i &lt;= n; ++i)
		p[i] = (p[i] + p[i - 1]) % P;
	//求一个前缀和
	for(int i = 0; i &lt;= n; ++i)
		f[u][i] = (p[i + 1] - (u == n ? p[0] : p[1]) + P) % P;
	//因为是前缀和所以要减掉p_1
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct(v, u);
	}
	dfs(n, 0);
	printf(&quot;%d\n&quot;, f[n][0]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4428 [BJOI2018]二进制]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4428-bjoi2018er-jin-zhi/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4428-bjoi2018er-jin-zhi/">
        </link>
        <updated>2020-04-13T03:44:54.000Z</updated>
        <content type="html"><![CDATA[<p>BJOI2018D1T2</p>
<p>不得不说人家BJOI的题一个个都是神仙,给人全新的做题体验---暴力出奇迹???</p>
<p>简要题意:</p>
<ul>
<li>查询一段另一区间有多少个子区间满足重排之后能构成一个%3=0的二进制数</li>
</ul>
<p>一看就不可做,20pts跑路,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p>
<p>50pts...可能是每个询问我们都DP一次吗?然后DP可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>??</p>
<p>好吧直接开正解</p>
<blockquote>
<p>&quot;传说中的动态dp？反正极其毒瘤就是了&quot;</p>
</blockquote>
<p>肯定先要推结论的,我一开始想直接找出0/1串的规律,挂了....</p>
<p>所以我们缩小到每个元素的性质而不是直接找整体的</p>
<ul>
<li>对于1个1,如果他在奇数位置,那他会对答案贡献2,如果在偶数位置则会对答案贡献1,最后要求贡献%3=0</li>
</ul>
<p>这个结论很显然对吧,因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">偶</mi><mi mathvariant="normal">数</mi></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2^{偶数}\equiv 1(mod 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">偶</span><span class="mord cjk_fallback mtight">数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">奇</mi><mi mathvariant="normal">数</mi></mrow></msup><mo>≡</mo><mn>2</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2^{奇数} \equiv 2(mod 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">奇</span><span class="mord cjk_fallback mtight">数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p>
<p>那么我们考虑下合法的情况?....如果1的个数是偶数,那么一定可以,因为我们可以奇偶平分啊</p>
<p>如果1的个数是奇数?必须满足奇数的个数是偶数个数多至少3,为什么呢?否则我们奇偶配对后一定%3=1/2对吧</p>
<p>而大于3?如果是5,那么显然我们可以给偶数放个1,就又变成多3的情况,如果是4?你不觉得1的个数是偶数了吗?</p>
<p>所以综上所述,这个不太行,我们要补集转化</p>
<p>我们先想1的个数一定是奇数对吧,而且我们要满足能够构造出奇数比偶数多3?</p>
<ul>
<li>1.只有1个1</li>
<li>2.奇数个1,而且0的个数小于等于1</li>
</ul>
<p>否则我们有2个零?就一定可以构造出奇数比偶数多的假象</p>
<p>eg: 3个1,2个0 10101,7个1,2个0,101011111</p>
<p>这样我们就来快速找到一个区间的答案吧!动态DP啊!或者说DP过程分治化并记录?线段树!</p>
<p>我们要记录什么信息呢?包含不包含左右端点,4中情况第一维,有奇数个1还是偶数个,有0/1还是1/1,有0/1还是1/0,共四维,怎么转移啊?</p>
<p>所以我们把两个问题分开计数,然后最后减去算重的 部分就好</p>
<p>第一个线段树上存这样的dp数组<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Dp_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>其中i的定义和一开始的定义一样</p>
<p>j表示这个区间有奇数个1或者偶数个1</p>
<p>k表示这个区间有0个0或1个0</p>
<p>另一个线段树存这样的dp数组</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mi mathvariant="normal">​</mi></mrow><annotation encoding="application/x-tex">Dp_{i,j}​</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">​</span></span></span></span></p>
<p>i的定义还是和开始的定义一样，</p>
<p>j表示这个区间有0个1或者1个1</p>
<p>考虑第一个条件的转移我们需要对于每个节点维护:</p>
<ul>
<li>前缀零的个数,后缀零的个数</li>
<li>包括了1个1的前缀和后缀的个数</li>
</ul>
<p>那你会发现因为我们要计算跨过中间点的答案,所以就是左边0后缀0*右边前驱只有1个1的前缀+右边同理就是答案</p>
<p>然后再考虑第二种情况</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 为线段后缀中满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\bmod 2 = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的数量。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 统计前缀，对称地是类似的。</p>
<p>那么你枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><msub><mi>R</mi><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo separator="true">,</mo><mi>B</mi><mi mathvariant="normal">.</mi><msub><mi>L</mi><mrow><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A.R_{a, b}, B.L_{c, d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 考虑能否产生贡献：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a+c \le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">b + d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 为奇数，那么则可以产生对答案有他们俩乘积的贡献。</li>
</ul>
<p>还有一个重复的就是1的个数和10/01的个数会被减重复对吧,这个直接用一个树状数组就能维护</p>
<p>然后没什么了,其他细节也不会,学个大概qwq</p>
<p>真的太难了</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5 + 10;
typedef long long ll;
int n, mk, m;
int a[MAXN];

struct linetree1 {
	ll v[4 * MAXN][4][2][2];
	inline void merge(int p, int p1, int p2) { //非常恶心的merge函数
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++) //加法转移们
				v[p][0][i][k] = v[p1][0][i][k] + v[p2][0][i][k] + v[p1][2][i][k] + v[p2][1][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][1][i][k] = v[p1][3][i][k] + v[p1][1][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][2][i][k] = v[p2][3][i][k] + v[p2][2][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][3][i][k] = 0;
		for(int i = 0; i &lt;= 1; i++) //乘法转移,这里for枚举p1,p2各选多少个0
			for(int j = 0; i + j &lt;= 1; j++) //手动枚举了奇偶性的转移
				v[p][0][0][i + j] += v[p1][2][0][i] * v[p2][1][0][j] + v[p1][2][1][i] * v[p2][1][1][j],
									 v[p][0][1][i + j] += v[p1][2][0][i] * v[p2][1][1][j] + v[p1][2][1][i] * v[p2][1][0][j],
											 v[p][1][0][i + j] += v[p1][3][0][i] * v[p2][1][0][j] + v[p1][3][1][i] * v[p2][1][1][j],
													 v[p][1][1][i + j] += v[p1][3][0][i] * v[p2][1][1][j] + v[p1][3][1][i] * v[p2][1][0][j],
															 v[p][2][0][i + j] += v[p1][2][0][i] * v[p2][3][0][j] + v[p1][2][1][i] * v[p2][3][1][j],
																	 v[p][2][1][i + j] += v[p1][2][0][i] * v[p2][3][1][j] + v[p1][2][1][i] * v[p2][3][0][j],
																			 v[p][3][0][i + j] += v[p1][3][0][i] * v[p2][3][0][j] + v[p1][3][1][i] * v[p2][3][1][j],
																					 v[p][3][1][i + j] += v[p1][3][0][i] * v[p2][3][1][j] + v[p1][3][1][i] * v[p2][3][0][j];
	}
	inline void modify(int p, int l, int r, int pos) {
		if(r - l == 1) {
			if(a[r]) {
				v[p][3][1][0] = 1;
				v[p][3][0][1] = 0;
			} else {
				v[p][3][0][1] = 1;
				v[p][3][1][0] = 0;
			}
			return ;
		}
		int mid = (l + r) / 2;
		if(pos &lt;= mid) {
			modify(p &lt;&lt; 1, l, mid, pos);
		} else {
			modify(p &lt;&lt; 1 | 1, mid, r, pos);
		}
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
	}
	inline void query(int p, int l, int r, int dl, int dr) {
		if(dl == l &amp;&amp; dr == r) {
			if(mk == 0) {
				for(int i = 0; i &lt;= 3; ++i) {
					for(int j = 0; j &lt;= 1; ++j) {
						for(int k = 0; k &lt;= 1; ++k) {
							v[0][i][j][k] = v[p][i][j][k];
						}
					}
				}
				mk = 1;
			} else {
				for(int i = 0; i &lt;= 3; ++i) {
					for(int j = 0; j &lt;= 1; ++j) {
						for(int k = 0; k &lt;= 1; ++k) {
							v[4 * n + 1][i][j][k] = v[0][i][j][k];
						}
					}
				}
				merge(0, 4 * n + 1, p);
			}
			return ;
		}
		int mid = (l + r) / 2;
		if(dl &lt; mid) {
			query(p &lt;&lt; 1, l, mid, dl, min(dr, mid));
		}
		if(mid &lt; dr) {
			query(p &lt;&lt; 1 | 1, mid, r, max(dl, mid), dr);
		}
	}
	inline ll cquery(int l, int r) {
		for(int i = 0; i &lt;= 3; ++i) {
			for(int j = 0; j &lt;= 1; ++j) {
				for(int k = 0; k &lt;= 1; ++k) {
					v[0][i][j][k] = 0;
				}
			}
		}
		mk = 0;
		query(1, 0, n, l, r);
		ll ret = 0;
		for(int i = 0; i &lt;= 3; ++i)ret += v[0][i][1][0] + v[0][i][1][1];
		return ret;
	}
	inline void build(int p, int l, int r) {
		if(r - l == 1) {
			// printf(&quot;%d %d %d %d\n&quot;, p, l, r, a[r]);
			if(a[r]) {
				v[p][3][1][0] = 1;
			} else {
				v[p][3][0][1] = 1;
			}
			return;
		}
		int mid = (l + r) / 2;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid, r);
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
	}
} lt1;

struct linetree2 {
	ll v[4 * MAXN][4][2];
	inline void merge(int p, int p1, int p2) {
		for(int i = 0; i &lt;= 1; ++i)v[p][0][i] = v[p1][0][i] + v[p2][0][i] + v[p1][2][i] + v[p2][1][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][1][i] = v[p1][3][i] + v[p1][1][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][2][i] = v[p2][3][i] + v[p2][2][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][3][i] = 0;

		for(int i = 0; i &lt;= 1; i++)
			for(int j = 0; i + j &lt;= 1; j++) {
				v[p][0][i + j] += v[p1][2][i] * v[p2][1][j];

				v[p][1][i + j] += v[p1][3][i] * v[p2][1][j];

				v[p][2][i + j] += v[p1][2][i] * v[p2][3][j];

				v[p][3][i + j] += v[p1][3][i] * v[p2][3][j];
			}
	}
	inline void modify(int p, int l, int r, int pos) {
		if(r - l == 1) {
			if(a[r]) {
				v[p][3][1] = 1;
				v[p][3][0] = 0;
			} else {
				v[p][3][0] = 1;
				v[p][3][1] = 0;
			}
			return ;
		}
		int mid = (l + r) &gt;&gt; 1;
		if(pos &lt;= mid) {
			modify(p &lt;&lt; 1, l, mid, pos);
		} else {
			modify(p &lt;&lt; 1 | 1, mid, r, pos);
		}
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
		return ;
	}

	inline void query(int p, int l, int r, int dl, int dr) {
		if(dl == l &amp;&amp; dr == r) {
			if(mk == 0) {
				for(int i = 0; i &lt;= 3; ++i)
					for(int j = 0; j &lt;= 1; ++j) {
						v[0][i][j] = v[p][i][j];
					}
				mk = 1;
			} else {
				for(int i = 0; i &lt;= 3; ++i)
					for(int j = 0; j &lt;= 1; ++j) {
						v[4 * n + 1][i][j] = v[0][i][j];
					}
				merge(0, 4 * n + 1, p);
			}
			return ;
		}
		int mid = (l + r) &gt;&gt; 1;
		if(dl &lt; mid) {
			query(p &lt;&lt; 1, l, mid, dl, min(dr, mid));
		}
		if(mid &lt; dr) {
			query(p &lt;&lt; 1 | 1, mid, r, max(dl, mid), dr);
		}
	}
	inline ll cquery(int l, int r) {
		for(int i = 0; i &lt;= 3; ++i) {
			for(int j = 0; j &lt;= 1; ++j) {
				v[0][i][j] = 0;
			}
		}
		mk = 0;
		query(1, 0, n, l, r);
		ll ret = 0;
		for(int i = 0; i &lt;= 3; ++i)ret += v[0][i][1];
		return ret;
	}
	inline void build(int p, int l, int r) {
		if(r - l == 1) {
			// printf(&quot;%d %d %d %d\n&quot;, p, l, r, a[r]);
			if(a[r]) {
				v[p][3][1] = 1;
			} else {
				v[p][3][0] = 1;
			}
			return ;
		}
		int mid = (l + r) / 2;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid, r);
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);

	}
} lt2;

struct treearray {
	int ta[MAXN];
	inline void c(int x, int t) {
		for(; x &lt;= n; x += x &amp; (-x))ta[x] += t;
	}
	inline int d(int x) {
		int r = 0;
		for(; x &gt; 0; x -= x &amp; (-x))r += ta[x];
		return r;
	}
	inline ll q(int l, int r) {
		return d(r) - d(l);
	}
} tr1, tr2;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	lt1.build(1, 0, n);
	lt2.build(1, 0, n);
	for(int i = 1; i &lt;= n; ++i) {
		if(a[i]) {
			tr1.c(i, 1);
		}
		if(a[i]^a[i + 1] &amp;&amp; i != n) {
			tr2.c(i, 1);
		}
	}
	scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1, t, l, r; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;t);
		// printf(&quot;%d?\n&quot;, i);
		//puts(&quot;QWQ&quot;);
		if(t == 1) {
			scanf(&quot;%d&quot;, &amp;l);
			a[l] ^= 1;
			lt1.modify(1, 0, n, l);
			// puts(&quot;QAQ&quot;);

			lt2.modify(1, 0, n, l);
			// puts(&quot;QAQ&quot;);
			tr1.c(l, (a[l]) ? 1 : -1);
			if(l != n) {
				tr2.c(l, (a[l]^a[l + 1]) ? 1 : -1);
			}
			if(l != 1) {
				tr2.c(l - 1, (a[l - 1]^a[l]) ? 1 : -1);
			}
		} else {
			scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
			ll len = r - l + 1;
			printf(&quot;%lld\n&quot;, len * (len + 1) / 2 - lt1.cquery(l - 1, r) - lt2.cquery(l - 1, r) + tr1.q(l - 1, r) + tr2.q(l - 1, r - 1));
			// printf(&quot;%d &quot;, lt1.cquery(l - 1, r));
			// printf(&quot;%d &quot;, lt2.cquery(l - 1, r));
			// printf(&quot;%d &quot;, tr1.q(l - 1, r));
			// printf(&quot;%d &quot;, tr2.q(l - 1, r - 1));
			// puts(&quot;QAQ&quot;);

		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>