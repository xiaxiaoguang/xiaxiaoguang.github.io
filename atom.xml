<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-08-11T13:17:17.638Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[SDSCDay4]]></title>
        <id>https://xiaxiaoguang.github.io/post/sdscday4/</id>
        <link href="https://xiaxiaoguang.github.io/post/sdscday4/">
        </link>
        <updated>2020-08-11T06:59:30.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>沙比提</p>
<p>B</p>
<p>我们设最大值位置为x,然后建新点y1y2,然后优化建边就好了</p>
<p>对于更大的数据,可以线段树优化建图</p>
<p>然后两个15%的提示需要不同的建图方式</p>
<p>最大值可以用笛卡尔树去建图</p>
<p>两边要去中间最小值?这个直接建两排后缀优化的</p>
<p>-&gt;-&gt;-&gt;-&gt;<br>
<code></code> <code></code> <code></code> <code></code></p>
<blockquote>
<p>-&gt;-&gt;-&gt;-</p>
</blockquote>
<p>然后会发现最短路径一定会先找中间一个然后再到后面</p>
<p>所以就做完了...</p>
<p>C</p>
<p>对于一个三角形,两侧的图要么是一棵树,要么是两个树,两个情况分别设状态</p>
<p>所以我们要处理[l,r]这条边两侧的点,所以就会发现我们可以按照极角排序然后对于一个三角形就能很快找到了</p>
<p>合法状态数和边数等价所以直接DP即可</p>
<p>网络流</p>
<p>T1</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1597143209777.png" alt="" loading="lazy"></figure>
<p>发现答案是合法的就是存在可行循环流</p>
<p>循环流的充要条件是入度等于出度</p>
<p>所以考虑我们手动模拟一下我们走这个的过程,前c次走这个可以节省花费</p>
<p>对于一个初始数字为C的边考虑连(C,-1),(inf,1),后面那个代表我们可以修大这个数</p>
<p>从1到n  求个最小费用流即可</p>
<p>T2</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1597143870679.png" alt="" loading="lazy"></figure>
<p>发现白色格子可以二染色不妨设为红蓝</p>
<p>所以每个瓷砖一定会包括红黑蓝三颜色</p>
<p>然后我们就可以建立三排点的图(三列点,然后不同列的点之间有边)跑最大流</p>
<p>其中红色的连黑色的,黑色的连蓝色的</p>
<p>然后黑色的拆下点保证只用一次</p>
<p>然后红连S,蓝连T即可</p>
<p>T3</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1597143892255.png" alt="" loading="lazy"></figure>
<p>问题等价于每次选一组不相交线段,选k次问最大收益</p>
<p>所以可以考虑从左到右连边,然后容量为inf然后S到最左端点容量为k</p>
<p>每个线段左端点到右端点连容量为1,费用为价值的边求最大费用最大流</p>
<p>T4</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1597144164592.png" alt="" loading="lazy"></figure>
<p>发现一个能量源中决定了所有不合法的就是围绕能量源相邻和相对的两个水晶</p>
<p>然后对于能量源周围的六方格黑白染色,会发现一个能量源使得黑白不能同时出现,所以就可以最小割了</p>
<p>用流量代替权值</p>
<p>S-&gt;(权值)-&gt;黑-&gt;(inf)-&gt;能量入点-&gt;(权值)-&gt;能量出点-&gt;(inf)-&gt;白-&gt;(权值)-&gt;T</p>
<p>也就是说我们选择割掉那个都可以</p>
<p>T5</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1597144358901.png" alt="" loading="lazy"></figure>
<p>方法一是直接最小割,就是白点向周围灰点连边这样</p>
<p>令白格权值为1,灰格权值为-1,那么选白格就必须选周围灰格,问题就变成了最大权闭合子图,其+一开始灰格数即答案</p>
<p>T6</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1597144475051.png" alt="" loading="lazy"></figure>
<p>棋盘黑白染色,对于黑点连S,白点连T</p>
<p>然后非关键点向S/T连容量为2的边,相邻点连容量为1的边,费用为0</p>
<p>而关键点,连容量为2的边,拆成两个点,分辨连横连边和竖连边,然后对每个拆出的点连两个边,一个费用为0一个费用为1</p>
<p>表示如果我们流一个方向两次就要花钱</p>
<p>拆出的点按照自己的方向向上下/左右连边</p>
<p>T7</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1597144653207.png" alt="" loading="lazy"></figure>
<p>要想把参与人数搞成第一关键字就可以对于每个人,先用一个1,-inf的边,让权值强行拉大,这样每个人都能流上流量</p>
<p>剩下的连个(k-1,0)</p>
<p>对应的向喜欢的组别连边</p>
<p>然后我们最小费用流一定会流经它</p>
<p>而我们学习小组可以通过拆边形成a^2向T连边,就是考虑与上次的差值...</p>
<p>T8</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1597145737155.png" alt="" loading="lazy"></figure>
<p>考虑可以用大权值控制第一关键字</p>
<p>也就是说减肥药的价值为减肥量+inf,而药材的价值为-inf,选一个减肥药必须选对应药材,求最大权闭合子图</p>
<p>然后会发现药材数量一定不会超过减肥药数量就卡上上界了</p>
<p>T9</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1597145828002.png" alt="" loading="lazy"></figure>
<p>黑白染色,然后让左边和右边的对接起来,</p>
<p>然后有一个费用啊,接不同的费用不同</p>
<p>首先只有一个接头时就只考虑0,1,2,1</p>
<p>连原先为0,</p>
<p>两个接口,则我们会发现横纵只能连一个,我们可以分叉表示每个方向</p>
<p>我们可以用一个五边形来拆点,就是</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1597146013923.png" alt="" loading="lazy"></figure>
<p>然后会发现我们有T型水管,比较复杂,直接拆为4边然后列方程</p>
<p>a+b+c=0</p>
<p>b+c+d=1</p>
<p>c+d+a=2</p>
<p>d+a+b=1</p>
<p>然后我们能解出a,b,c,d,然后这个费用是浮点数*3即可避免误差</p>
<p>T10</p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1597146063104.png" alt="" loading="lazy"></figure>
<p>枚举一个必须要包含的点作为树根</p>
<p>然后若选择了一个点,那么他到树根所有点都必须选,</p>
<p>最大权闭合子图</p>
<p>T11</p>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1597146128038.png" alt="" loading="lazy"></figure>
<p>我们先枚举一个边断掉</p>
<p>然后设dp状态f[i][j]表示点i的子树和j子树匹配的最大连通答案</p>
<p>然后就可以用网络流来儿子做到最优匹配转移</p>
<p>但这样会T,问题在于同一个可能的状态算了多次</p>
<p>然后考虑树形dp,dp_{i,j,k,l}表示i的父亲是j,k的父亲是l的时候子树的最大匹配程度是多少</p>
<p>然后转移的时候我们可以考虑网络流,最大权的去匹配儿子</p>
<p>这样我们的复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>6</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>T12</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1597146264047.png" alt="" loading="lazy"></figure>
<p>一个棋子要么被占领要么四周的都被占领</p>
<p>那么这个就很像直线了</p>
<p>S-&gt;(代价)-&gt;A1-&gt;(收益)-&gt;A2</p>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1597146339479.png" alt="" loading="lazy"></figure>
<p>A2是四个点</p>
<p>然后就一条线,要保证收益要么全部割掉右边的四个</p>
<p>要么割掉自己的</p>
<p>T13</p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1597146768714.png" alt="" loading="lazy"></figure>
<p>Ans=需要涂色的格子数-连续涂格子的次数</p>
<p>首先可以发现一个格子要么是横着要么是竖着涂的</p>
<p>然后相邻两个格子是横着还是竖着涂得选择了其中一种方式那么公共格子的另一种方式就不能选</p>
<p>从中选择最多连续染色方式?最小割</p>
<p>S-(1)-横-(inf)-纵-(1)-T</p>
<p>....</p>
<p>T14</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1597146816836.png" alt="" loading="lazy"></figure>
<p>如果在原图中两点之间有一条无向边，那么这两点到1的距离之差不大于1。<br>
这个命题的正确性是显然的，我们考虑它的逆命题：<br>
给定每个点到1的距离（不大于n），并给定一些已有的边，满足已有的边的两端到1的距离之差不大于1，那么一定存在一种方案满足该种情况。</p>
<p>那么就做完了,问题变为我们去钦定这个a,然后知道一个a能算出的b,然后已有连边的限制差为1,可以直接做</p>
<p>T15</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1597146900961.png" alt="" loading="lazy"></figure>
<p>首先发现横竖会冲突,然后列越长会限制横越短</p>
<p>另一个激光不能超过交点位置</p>
<p>二分图的切糕,我们可以把其中一条链给颠倒过来</p>
<p>然后就会...标准切糕模型</p>
<p>T16</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1597147228075.png" alt="" loading="lazy"></figure>
<p>合法的有</p>
<p>所有有三个的</p>
<p>以及一侧有两个的</p>
<p>然后您会发现满足任意2*2子矩阵有且仅有两对颜色不同必然对应一组合法解</p>
<p>然后问题转化之后考虑网络流,那么所有2*2子矩阵建成一个点,相邻点对相等情况可以看成一条边</p>
<p>因为同一个2*2的方阵中,如果我有两个不同的,就是类似于一个水管插头连接</p>
<p>就相当于铁轨铺设问题了,保证有闭合回路</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SDSCDay2]]></title>
        <id>https://xiaxiaoguang.github.io/post/sdscd1/</id>
        <link href="https://xiaxiaoguang.github.io/post/sdscd1/">
        </link>
        <updated>2020-08-09T06:39:23.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>最大值就是每一条横线每一条竖线都达到两边点数较小值*2</p>
<p>对于n是偶数的时候</p>
<p>我们跳不到最大值</p>
<p>尝试达到最大值减2</p>
<p>对于n是奇数的时候</p>
<p>发现我们可以分类讨论</p>
<p>B</p>
<p>ans=点-边+环</p>
<p>然后对于平方和可以用线段树</p>
<p>C</p>
<p>对于一个数字x,R(x)他们在膜B-1意义下是一样的</p>
<p>所以我们可以想办法处理出一个数组f,就是表示有一个区间在%B-1意义下是x</p>
<p>枚举右端点,看左端点有哪个位置,这样有O(nB)的复杂度</p>
<p>处理出f后可以再处理一个g</p>
<p>B-1和0在%B-1意义下都是0</p>
<p>如果一个序列的只有一个位置不是0位B-1可能会有问题,然后我们特判掉就好了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub></msub><mo>∗</mo><msup><mi>B</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">R(x)=\sum_{x_i}*B^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2244739999999998em;vertical-align:-0.39981em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.39981em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></p>
<p>而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mi>x</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">B^x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>可以因式分解出一个B-1....</p>
<p>就是说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>B</mi><mi>i</mi></msup><mo>−</mo><mn>1</mn><mo>=</mo><mo>(</mo><mi>B</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mo>(</mo><msup><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><msup><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>−</mo><msup><mi>B</mi><mrow><mi>i</mi><mo>−</mo><mn>3</mn></mrow></msup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>≡</mo><mn>0</mn><mi>m</mi><mi>o</mi><mi>d</mi><mo>(</mo><mi>B</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">B^i-1=(B-1)*(B^{i-1}-B^{i-2}-B^{i-3}.....-1) \equiv 0 mod (B-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>原来是y,在mod 意义加+x-y</p>
<p>那么考虑能否在S中找到一个数组差值为x-y</p>
<p>可以几个f(S,x)满足包含的为S,他们的和为x,区间个数</p>
<p>对于一个固定的右端点他的取值至多会有B种,所以我们预处理也是O(nB)的</p>
<p>然后再搞一搞0的情况</p>
<p>并且从y和输入的S转换出一个T来回答询问</p>
<h1 id="字符跳动acm赛题目串讲">字符跳动ACM赛题目串讲!</h1>
<p><s>没有集训队作业是有个150的老哥....</s></p>
<p>C1A</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1597103541070.png" alt="" loading="lazy"></figure>
<p>建一个图,然后能交换就连边</p>
<p>考虑如果一个pos和val不在连通块就不行</p>
<p>否则拉棵生成树出来交换叶子,暴力搞搞n^2就好了</p>
<p>就是类似于冒泡排序的那种方式,我们显然一个数到他该到的位置不会花太多代价,而他给了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>次</p>
<p>C1B</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1597103777432.png" alt="" loading="lazy"></figure>
<p>建AC自动机,然后把所有不合法的位置标志出来,一个点的fail不合法那么他也不合法</p>
<p>然后不经过不合法位置方案数??矩阵快速幂就好了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><msup><mi mathvariant="normal">∣</mi><mn>3</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>L</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|S|^3logL)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">L</span><span class="mclose">)</span></span></span></span></p>
<p>C1C</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1597103788275.png" alt="" loading="lazy"></figure>
<p>点权排序依次加入,维护size最大连通块</p>
<p>C1D</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1597103854305.png" alt="" loading="lazy"></figure>
<p>次数对于2取模说明我们可以用longlong来表示多项式</p>
<p>多项式带余除法....</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><msup><mi>x</mi><mn>32</mn></msup><mo>+</mo><msup><mi>x</mi><mn>26</mn></msup><mo>+</mo><msup><mi>x</mi><mn>15</mn></msup><mo>+</mo><msup><mi>x</mi><mn>7</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">P(x)=x^{32}+x^{26}+x^{15}+x^{7}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>再看看样例</p>
<p>发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn><mo>−</mo><mn>1</mn></mrow></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>P</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^{2^32-1}mod P =1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">x^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>的逆元就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn><mo>−</mo><mn>1</mn><mo>−</mo><mi>i</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{2^32-1-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>能够求逆发现就能够BSGS</p>
<p>预处理出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>K</mi><mi>S</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{KS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">x^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span></span></span></span>,以及他们的逆元,BSGS</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msqrt><mrow><mi>T</mi><mi>N</mi></mrow></msqrt><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sqrt{TN}logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.176665em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>C1E</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1597103957113.png" alt="" loading="lazy"></figure>
<p>回文树</p>
<p>一个串本质不同的回文子串是O(n)级别的</p>
<p>可以尝试DP</p>
<p>dp_i表示以i开头的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">p_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示以S去掉开头结尾各一个字符后得到字符串,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">b_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为s最长回文前缀,均用回文树节点表示</p>
<p>已经得到了第i个串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">S_i=t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>考虑按照下面步骤得到剩余串</p>
<p>1.结束套娃或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">t=p_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并来到第二歩</p>
<p>2.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>p</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">t=p_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>重复第二歩或者到第三步</p>
<p>3.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>t</mi><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_{i+1}=t,i=i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>并回到第1步或者令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">t=b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到第四步</p>
<p>4.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>b</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">t=b_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>重复本步或者令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s_{i+1}=t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>并回到第一步</p>
<p>一共这样四步,放在回文数上从小到大DP</p>
<p>C1F</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1597148358904.png" alt="" loading="lazy"></figure>
<p>有用的状态不会很多,首先集合内部没法拆分,可以考虑整数拆分</p>
<p>然后f(S)表示当整数拆分为S时他的期望是多少</p>
<p>P(AB)表示从局面A转移到局面B的概率</p>
<p>然后发现这个只有自环和DAG</p>
<p>怎么算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1597148452036.png" alt="" loading="lazy"></figure>
<p>先枚举一个B尝试所有能得到B的集合A</p>
<p>所以可以考虑枚举一个大小为k的B子集C,C要枚举不重复的子集,然后用C和B-C里面的配对</p>
<p>就可以得到这个情况下合法的A,顺便算出概率</p>
<p>C1G</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1597148667283.png" alt="" loading="lazy"></figure>
<p>随机240个排列,然后对于交互库里面那个排列退火</p>
<p>然后首先找一个排列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,随机更改m个位置的到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">P_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>然后交互库返回的几位D1D2</p>
<p>因为对于一个位置要么x-v1在a中出现,要么x-v2在B中出现</p>
<p>如果我们变的小于m次就重新随机,那么我们会发现对于每个位置就可以把可能的位置降为O(2m)排除了可行的n-2m个</p>
<p>m取到根号n就可以期望O(1)就可以让这些位置只剩下唯一解</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msqrt><mo>(</mo></msqrt><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">m=\sqrt(n)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.30499999999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mopen" style="padding-left:1em;">(</span></span><span style="top:-2.8950000000000005em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30499999999999994em;"><span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>最好</p>
<p>C1H</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1597148811702.png" alt="" loading="lazy"></figure>
<p>官方题解,建一个线段树在上面跑斜率优化,sb</p>
<p>上边界一定贴着一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>先枚举一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>找左右第一个比他大的数,记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">l_i,r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">[i,r_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>中任意一个位置j用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>j</mi><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub><mo>)</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(j-l_i)a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[r_i,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>任意一个位置用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(r_i-l_i-1)a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>更新答案</p>
<p>只需要支持区间插入单点求max可以用李超树qwq</p>
<p>C1I</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1597148861219.png" alt="" loading="lazy"></figure>
<p>模拟题</p>
<p>C1J</p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1597148895973.png" alt="" loading="lazy"></figure>
<p>不考虑旋转就是nim游戏</p>
<p>矩形的mex就是sg_i表示i的,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">sg_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><msub><mi>g</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">sg_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>s</mi><msub><mi>g</mi><mi>j</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">sg_i=maxsg_j+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,直接二维数点</p>
<p>那么相当于每个矩形都有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,异或起来等于0</p>
<p>假设都不选a_i都异或下,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就成了<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 6: a_i^b_̲i'>a_i^b_i</span>,但是线性基要输出方案</p>
<p>考虑线性基中每一个数怎么输出方案,其实就是每个数记录一下异或的是哪些基...</p>
<p>反正又西伯利亚题了</p>
<p>C1K</p>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1597148954609.png" alt="" loading="lazy"></figure>
<p>我们强制1和2不相同3和4不相同....这样我们会发现如果再把那个n组的限制连上去,你会发现我们一定是偶数环...是二分图</p>
<p>而且度数为2好像可以很快的解决匹配</p>
<p>所以一定有解O(n)</p>
<p>C1L</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1597149013894.png" alt="" loading="lazy"></figure>
<p>V-E+F=1</p>
<p>那么其实就可以考虑求面数=求点数和边数</p>
<p>k重交点会让点数+1</p>
<p>面数+2k,而一条线段会被两端点算两次</p>
<p>相当于边数+k,一条直线两端形成的射线会被少算一次再加回来</p>
<p>最后特判下椭圆的情况</p>
<p>C2A</p>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1597149280040.png" alt="" loading="lazy"></figure>
<p>因为m&lt;=100</p>
<p>连续段数量不超过1000...</p>
<p>维护连续段即可</p>
<p>C2B</p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1597149299819.png" alt="" loading="lazy"></figure>
<p>离线然后分块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>q</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(q\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>中序遍历是否单调</p>
<p>然后可以考虑什么数据结构支持修改和查询,线段树吧</p>
<p>改x的点权只会影响其到根的路径上一些子树是否为二叉搜索树,</p>
<p>然后判断是log的所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>C2C</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1597149399474.png" alt="" loading="lazy"></figure>
<p>可以考虑五维</p>
<p>f_{i,j,k,l,m}表示前i个数j,k,l,m4个1的位置</p>
<p>前面L个不足4就把剩下的填-1</p>
<p>容易发现状态数是2^L左右的</p>
<p>然后DP即可,发现不会很大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>L</mi><mi>P</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{L}{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.272341em;vertical-align:-0.35001em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9223309999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>C2D</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1597149488435.png" alt="" loading="lazy"></figure>
<p>一个可行区间为l,r的相加得到的为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mn>1</mn><mo>+</mo><mi>l</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mn>1</mn><mo>+</mo><mi>r</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[l1+l2-1,r1+r2+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>相乘也一样啊,就是区间范围相乘了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">f_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示得到的数左端点为l时右端点最小是多少,转移用定义...</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub><mo>=</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>f</mi><mi>y</mi></msub><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f_x=x,f_y=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>C2E</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1597149593529.png" alt="" loading="lazy"></figure>
<p>直接求虚树</p>
<p>C2F</p>
<figure data-type="image" tabindex="19"><img src="https://xiaxiaoguang.github.io/post-images/1597149619384.png" alt="" loading="lazy"></figure>
<p>分治...</p>
<p>solve(n,k)表示进行到2^n那个矩阵的答案</p>
<p>会发现我们和某个直线一定会两个重合,就是转化成本质相同的</p>
<p>然后始终我们剩下的都只会有一个直线(或者两个也行)</p>
<p>一个就是下面这个</p>
<figure data-type="image" tabindex="20"><img src="https://xiaxiaoguang.github.io/post-images/1597149814470.png" alt="" loading="lazy"></figure>
<p>C2G</p>
<figure data-type="image" tabindex="21"><img src="https://xiaxiaoguang.github.io/post-images/1597150131491.png" alt="" loading="lazy"></figure>
<p>通信题</p>
<p>阴间题</p>
<p>构造自动机,然后每个点只会有AB两个出边,然后转码数字串就直接把路径上的所有数字输出出来。</p>
<p>C2H</p>
<figure data-type="image" tabindex="22"><img src="https://xiaxiaoguang.github.io/post-images/1597150150222.png" alt="" loading="lazy"></figure>
<p>权值线段树</p>
<p>C2I</p>
<figure data-type="image" tabindex="23"><img src="https://xiaxiaoguang.github.io/post-images/1597150174380.png" alt="" loading="lazy"></figure>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \b at position 16: \sum_{i=0}^n{ia\̲b̲}'>\sum_{i=0}^n{ia\b}</span>可以用类欧</p>
<p>然后对于带根号的那个东西就可以用SBT在1e9范围内找一个最相近的分数逼近他,每走一步精度增加指数级</p>
<p>复杂度O(Tlogn)</p>
<p>就解决了,然而我还是不会类欧</p>
<p>感觉没有那个T可以直接凸包拟合</p>
<p>C2J</p>
<figure data-type="image" tabindex="24"><img src="https://xiaxiaoguang.github.io/post-images/1597150327439.png" alt="" loading="lazy"></figure>
<p>裁判可以划分为两个阵营,冲突的连边</p>
<p>然后对于裁判求最大独立集</p>
<p>C2K</p>
<figure data-type="image" tabindex="25"><img src="https://xiaxiaoguang.github.io/post-images/1597150358682.png" alt="" loading="lazy"></figure>
<p>按照他的方法随机生成几千张图,那个序列在这个图上退火</p>
<p>找个优秀的输出</p>
<p>C2L</p>
<figure data-type="image" tabindex="26"><img src="https://xiaxiaoguang.github.io/post-images/1597150378254.png" alt="" loading="lazy"></figure>
<p>把所有的公切点拿出来求一个凸包,然后得到这个n个圆形成的凸包,然后圆弧都变成了直线</p>
<p>再沿着这个凸包边界枚举找最长的一个圆弧即可</p>
<p>C2M</p>
<figure data-type="image" tabindex="27"><img src="https://xiaxiaoguang.github.io/post-images/1597150412859.png" alt="" loading="lazy"></figure>
<p>考虑建出一个trie树,然后LCP为树上LCA深度</p>
<p>然LCP(s,t)=1/2(|S|+|T|+LCA(S,T))然后d就有了</p>
<p>问题就是最小化</p>
<p>2(\sum_{i=1}<sup>n|t_i|)-\sum_{i=1}</sup>{n-1}d(t_i,t_{i+1})-|t_1|-|t_n|</p>
<p>把树根当做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">t_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是最小化</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>d</mi><mo>(</mo><msub><mi>t</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n d(t_i,t_i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>最后就是一个所有点到重心的距离之和</p>
<p>带权重心!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SDSCDay1]]></title>
        <id>https://xiaxiaoguang.github.io/post/sdcaday1/</id>
        <link href="https://xiaxiaoguang.github.io/post/sdcaday1/">
        </link>
        <updated>2020-08-08T05:55:33.000Z</updated>
        <content type="html"><![CDATA[<p>B</p>
<p>对于一个串长的位置是需要二分答案的,否则串数的复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的...</p>
<p>然后选的两个串靠后的串至少起始位置靠左啊...</p>
<p>然后就是一个lcp&gt;=l</p>
<p>能否在一个区间中选两个前缀lcs&gt;=一个长度</p>
<p>考虑建一个SAM,然后考虑一个点C,对于C来说他本质相同的字符串在其子树a,b中</p>
<p>如果我们把两个前缀,第一个前缀的位置作为x坐标,第二个前缀的位置作为y坐标</p>
<p>那么对于两个前缀他的lcs作为这个点他的值,此时我们有n^2个点</p>
<p>而且这两个子串a,b他们在向父亲合并时就构成了一个新的</p>
<p>显然对于一个SAM上节点,所有的endpos中只有相邻的有用处(贴的最近)</p>
<p>那么就是对于一个点y来说在c中查询一个前驱后继只有两个点能作为答案(点)</p>
<p>那么和并两个子树就相当于一个启发式合并的复杂度了.....</p>
<p>也就是说实际上我们这样的点只有nlogn个</p>
<p>然后再回到mlogn个询问上来,如果把他们拍到平面上,每个询问就都是一个区间是否有个正方形内某个数的值大于len,其中我们左端点是L+len-1</p>
<p>这个就是二维数点了,主席树,当然也可以用扫描线+线段树轻松离线解决!</p>
<p>C</p>
<p>当i增大到一定程度时答案会变成一个等差数列的形式...</p>
<p>然后我们就可以强行在某个位置开始用等差数列解决.....</p>
<p>艹这显然是错的但是很能拿分</p>
<p>其实我们对于边权很小的情况我们可以考虑把每条边的权值拆开变成贡献来算...</p>
<p>然后我们有个问题就是对于前i层点可以搞出一些东西,然后第i+1层点可以基于前i层点去操作</p>
<p>那么显然是前i层有一些点已经连通了,第i+1层点再连会导致一些边使得成环,就要断掉</p>
<p>然后对于贡献就很显然了,考虑对于权值为w的,我们把0~w-1的加入后每个都算他一遍,那么他就会被算w遍,正好和他的权值是w对应qwq</p>
<p>A</p>
<p>dp + 多项式</p>
<p>没了</p>
<p>讲课:...</p>
<p>T7</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596890708495.png" alt="" loading="lazy"></figure>
<p>(n+m)/k会进位,而且进一位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mo>[</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo>+</mo><mi>m</mi><mi mathvariant="normal">/</mi><mi>k</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">=[n/k+m/k+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>那么这个性质其实就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">[n%k+m%k&gt;=k]=[(n+m)/k-n/k-m/k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span></span></span></span>分为三项</p>
<p>把其中一项单独提出来!</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow></munder><mfrac><mi>n</mi><mi>k</mi></mfrac><mi>ϕ</mi><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{k&gt;1}\frac n k \phi(k)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.437043em;vertical-align:-1.329483em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&gt;</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.329483em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">n</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></munder><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{k=1}^n \sum_{d|k} \phi(d)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mi>i</mi><mi>n</mi></munderover><mi>i</mi></mrow><annotation encoding="application/x-tex">\sum_{i}^n i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">=\frac {n*(n+1)} {2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>所以把每个&quot;n&quot;带进去化简一下就是n*m....</p>
<p>T16</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596892235315.png" alt="" loading="lazy"></figure>
<p>首先对于一个C就能得到一个特定答案..</p>
<p>然后所有可能的C好像只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mrow><mi>P</mi><mo>−</mo><msub><mi>w</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>∈</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><mo>+</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">={P-w_i-1,i \in (1,n)}+T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></p>
<p>那么我们完全可以先二分一下(我们选一个边额外的收益)然后O(n^2)check一下,就是钦定C然后dp</p>
<p>考虑设F[C]表示 确定C的答案那么相当于找这个F数组的最大值</p>
<p>确定这个数组一个位置需要花费O(nlogV)直接做是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2logV)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span></p>
<p>我们可以先考虑计算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><msub><mi>C</mi><mn>1</mn></msub></msub></mrow><annotation encoding="application/x-tex">F_{C_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span>然后对于下一个就是如果比他小我们根本不用考虑计算,如果比他大则需要计算出新的值</p>
<p>然后就可以发现对于一个随机的排列最多有logV次会比前面大,</p>
<p>那么就可以随机一个C的排列然后就能做了...我们至多计算logV次某个数组精确最大值</p>
<p>T21</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596892277925.png" alt="" loading="lazy"></figure>
<p>dp,然后转移是一个区间....</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mi>r</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>−</mo><mi>l</mi></mrow></msub><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>s</mi><mi>g</mi><mi>n</mi><mo>(</mo><msub><mi>S</mi><mi>i</mi></msub><mo>−</mo><msub><mi>S</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=max_{i-r&lt;=j&lt;=i-l}f_j+sgn(S_i-S_j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>然后这个显然是可以维护一个以S为下标的线段树,然后以j为下标的单调队列去记录<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>这样可以做到O(nlogn)</p>
<p>显然值域是O(n)级别的</p>
<p>因为有用的只有f_j,f_j-1所以显然对于他们来说前缀和越小越好qwq</p>
<p>对于每个f值可以维护一个S的单调队列</p>
<p>然后全局所有的f值(还有一个区间的限制)可以维护一个总的下标的单调值就行了</p>
<p>T20</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596893133649.png" alt="" loading="lazy"></figure>
<p>首先对于每个k可以做到O(nlogn)就是都放进去然后拿深度最大的没被标记的点再,把k级祖先拿出来标记,重复这个过程</p>
<p>而对于k比较大可能删的比较快...</p>
<p>然后就发现答案差不多为$ O(x+(n-x)/k) $然后这个东西主要在于x,其他的部分是调和级数</p>
<p>所以只需要把他叶子距离为k的点初始化进堆做那个贪心就好了...剩下的就是一个调和级数了....</p>
<p>复杂度可能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>g</mi><mi>n</mi><mi>ln</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlgn\ln n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>T15</p>
<p>两个人,一开始有x,y颗石子,对着拿,每轮拿a_i个,不足全拿,带修a_i,x,y问每次n轮之后最后第一个人手上剩余多少石子.....</p>
<p>维护一个折线图,和x+y取min,和0取max</p>
<p>如果这个折线图的极差要大于上下边界差那么碰一次壁就和之前的无关了</p>
<p>如果极差太小那么我们既不碰上边界也不碰下边界</p>
<p>那么就可以统计一个区间的前缀和,对于初始在哪里计算个答案....</p>
<p>在一个范围内我们会碰上边界,初始值无关,我们只需要算区间中某个值的答案即可</p>
<p>那么只有一个小区间我们是需要维护的,所以就可以考虑线段树和分治...维护维护修改和查询</p>
<p>T13*</p>
<p>结论1,次数不重要</p>
<p>结论2,二分答案</p>
<p>结论3,这个有博弈论结论.如果有一张二分图g,一开始在S集合中,每个人可以移动一步不能动就输</p>
<p>那么一个点先手必胜当且仅当所有最大匹配都经过他</p>
<p>所以本质上我们把a,b排序</p>
<p>第x行第y列看成a_x+b_y,列出一个网格</p>
<p>如果a_x+b_y&lt;=二分的值,</p>
<p>那么网格会成为一个折线满足...</p>
<p>那么每次我们回跳到同一行同一列的白点或黑点</p>
<p>那么问题就变成了每个点每个点向他同行同列连边....是否有最大匹配</p>
<p>转化成最大独立集</p>
<p>所以可以发现白点一定是在某个分界点左上角...黑点在右下角</p>
<p>然后就可以考虑二分一个增量,对于增量从上到下从左到右</p>
<p>是单调变化的,所以可求出那个最优划分点.......</p>
<p>T11*</p>
<p>多项式可以发现我们在不知道R的时候能算出一个东西</p>
<p>所以就可以先和C点乘一下,再和R做点乘</p>
<p>考虑分治,显然C有用长度小于等于区间长度</p>
<p>那么我们每次都是从C中除以一个L的操作,???</p>
<p>总区间的C/右边的L就可知左边的R了....</p>
<p>所以我们就可以先递归左半部分再递归右边部分最后能得到底层的R是那个单项式</p>
<p>T6</p>
<p>通信题md</p>
<p>随机一个长数列,然后这个长数列大概率一些东西异或起来可以表示出一个线性基</p>
<p>那么我们猜任意110个数字能构成一个线性基,然后我们只用这些数字就可以搞搞</p>
<p>B然后是1就异或是0就不关</p>
<p>三个一组,如果有一个位置被ban掉了就考虑</p>
<p>000 001 010 011 100 101 110 111</p>
<p>1  : 001/110 即考虑那个被ban掉了</p>
<p>0 :  100</p>
<p>第一个位置被ban掉了</p>
<p>010 -&gt; 00<br>
011 -&gt; 11</p>
<p>然后反正就是这样设置下去,用三分组的方式构造....</p>
<p>T5</p>
<p>dp_{i,j}表示我走到i,然后目前收益为j的最小代价</p>
<p>那么这个剩余可以的代价要小于等于m/j...就调和级数了</p>
<p>T1错题</p>
<p>m&lt;=n+300</p>
<p>最多300个环</p>
<p>度数之和=2m,那么也就是说$ \sum_{d-2}=2(m-n)$</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mo>[</mo></msub><mrow><mi>d</mi><mo>−</mo><mn>2</mn></mrow><mo>]</mo><mo>&lt;</mo><mo>=</mo><mn>2</mn><mo>(</mo><mi>m</mi><mo>−</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_[{d-2}]&lt;=2(m-n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">[</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>度数大于等于3的不超过600个...</p>
<p>那么我们就可以考虑就是一堆链...链数是O(m-n)的</p>
<p>然后对于链外的关键点可以暴力</p>
<p>而链上的点我们还要求最短路可以考虑枚举一个分界点....</p>
<p>啊,然后他萎了</p>
<p>T9</p>
<p>Hall定理,一个二分图存在完备匹配,左边选出一些点来,然后右边的点存在完美匹配的充要条件是左边任意一个点集都有完备匹配</p>
<p>对于一个确定的A,B就可以连边然后考虑左边连a_i右边连b_j然后就是一个中间连边了...</p>
<p>最大流怎么转换成最小割...显然存在一个最小割我们可以把他们都割掉</p>
<p>最小割至少能做到\sum_{b_i}</p>
<p>然后我们想能不能dp一下这个右边的方案</p>
<p>然后要什么统计割一定要大于最小割....就是前缀和&gt;=某个数...</p>
<p>T17</p>
<p>靠...</p>
<p>g是f的k次卷积,求g的前缀和</p>
<p>首先把x拆成k个部分,每个x_i都用m的次幂表示出来</p>
<p>然后下课了....</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day10]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day10/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day10/">
        </link>
        <updated>2020-08-06T07:10:29.000Z</updated>
        <content type="html"><![CDATA[<p>自闭了,没有不会被卡的我</p>
<p>C</p>
<p>直接在线吧...</p>
<p>一个区间当所有数都不会被修改时我们就不做gcd了,就是意味着区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|x</p>
<p>等价于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><msub><mi>m</mi><msub><mi>a</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">lcm_{a_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span>|x就不会被修改...</p>
<p>线段树维护每个区间的LCM,如果不是x的约数就不递归,否则就递归下去</p>
<p>显然一个数最多被修改log次</p>
<p>每次看一个区间是不是x的因子,是的话一定有lcm不整除那个x</p>
<p>code:</p>
<pre><code class="language-cpp">

//From Dawn light
//Ultimate Destroy
//狛枝就是菜!
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
#define uint unsigned int
const int MAXN = 2e5 + 7;
const int MAXM = 5e5 + 7;
const int MAXT = 6e5 + 7;//3倍空间
using namespace std;

int n, m;
ll a[MAXN];

inline ll gcd(ll x, ll y) {
	return (y == 0) ? x : gcd(y, x % y);
}

//均摊复杂度正确
//一类区间:16,16,16,16,16 修改为16
//满足性质:min==max==gcdmax,change
//二类区间:4,8,4,8,4,8 修改为8
//满足性质:只修改一次,即我们只记住一下的即可
//三类区间:1111111111 修改为123,234,345....
//满足性质:只修改0次
//还有个性质:区间LCM&gt;1e18...感觉意义不大
//三被1包含了...但是问题不大qwq
struct rec {
	ll tag, maxx, minx, ccnt, sum, LCM;
} tr[MAXT];

inline ll lcm(ll x, ll y) {
	if((__int128)x / gcd(x, y) * y &gt; 1e18)return 1e18 + 1;
	return x / gcd(x, y) * y;
}

namespace seg {
	int T, root;
	int ls[MAXT], rs[MAXT];
#define lson ls[k]
#define rson rs[k]
#define mid ((l+r)&gt;&gt;1)
	inline void pushup(int k) {
		tr[k].maxx = max(tr[lson].maxx, tr[rson].maxx);
		tr[k].minx = min(tr[lson].minx, tr[rson].minx);
		tr[k].sum = tr[lson].sum + tr[rson].sum;
		tr[k].LCM = lcm(tr[lson].LCM, tr[rson].LCM);
	}
	inline void built(int &amp;k, int l, int r) {
		if(!k)k = ++T;
		if(l == r) {
			tr[k].maxx = tr[k].minx = tr[k].sum = tr[k].LCM = a[l];
			return;
		}
		built(lson, l, mid);
		built(rson, mid + 1, r);
		pushup(k);
	}
	inline void modify(int k, int l, int r, int L, int R, ll V) {
		if(l == r) {
			tr[k].sum = gcd(tr[k].sum, V);
			tr[k].maxx = tr[k].sum;
			tr[k].minx = tr[k].sum;
			tr[k].LCM = tr[k].sum;
			return ;
		}
		if(l &gt;= L &amp;&amp; r &lt;= R) {
			if(V % tr[k].LCM != 0) {
				tr[k].LCM = gcd(tr[k].LCM, V);
			} else {//没了
				return ;
			}
		}
		if(L &lt;= mid)modify(lson, l, mid, L, R, V);
		if(R &gt; mid)modify(rson, mid + 1, r, L, R, V);
		pushup(k);
	}
	inline uint query(int k, int l, int r, int L, int R) {
		if(L &lt;= l &amp;&amp; R &gt;= r) {
			return tr[k].sum;//自动取模?
		}
		if(R &lt;= mid)return query(lson, l, mid, L, R);
		else if(L &gt; mid)return query(rson, mid + 1, r, L, R);
		else return query(lson, l, mid, L, R) + query(rson, mid + 1, r, L, R);
	}
}
using namespace seg;

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	built(root, 1, n);
	for(ll i = 1, typ, x, y, z; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;typ);
		if(typ == 1) {
			scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;z);
			modify(root, 1, n, x, y, z);
		} else {
			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
			printf(&quot;%lld\n&quot;, query(root, 1, n, x, y));
		}
	}
	return 0;
}

</code></pre>
<p>A</p>
<p>怎么做到40pts啊?</p>
<p>显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>(</mo><mi>p</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2+2^2...+(p-1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>x^2=a(mod P)</p>
<p>一定会有一个值小于等于(P-1)/2,一个解是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,另一个就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>−</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P-x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>所以我们可以直接算一下这个值然后加起来...</p>
<p>但是要卡常就要优化取模...</p>
<p>x+=2*i-1</p>
<p>if(x&gt;mod) x-=mod;</p>
<p>这样我们x就可以从S<sup>2跳到(S+1)</sup>2</p>
<p>P%4==1</p>
<p>-1是二次剩余</p>
<p>a是二次剩余的话P-a也是二次剩余...</p>
<p>发现我们可以打表...</p>
<p>那么我们就可以输出(p-1)/4*p即可...</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><munder><mo>∑</mo><msup><mi>i</mi><mn>2</mn></msup></munder><mo>−</mo><mo>∑</mo><mfrac><msup><mi>i</mi><mn>2</mn></msup><mi>p</mi></mfrac><mo>∗</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">ans=\sum_{i^2}-\sum{\frac {i^2} {p}}*p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.829533em;vertical-align:-1.338425em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.811575em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.338425em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p>
<p>怎么算<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;\frac&#039; at position 13: \sum{\frac i^̲2 p}'>\sum{\frac i^2 p}</span></p>
<p>就可以考虑拿凸包去逼近这个曲线...如果可以就能得到一个n^{2/3}的做法了</p>
<p>额...感觉好抽象啊....</p>
<p>我们可以边在树上bfs边把凸包画出来...</p>
<p>然后考虑我们有一条严格在凸包上的线,这条线下面所有点都在曲线内部!</p>
<p>这个严格是指满足下面式子的斜率最大的整点构成的曲线</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mo>&lt;</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>x</mi><mo>+</mo><mi>d</mi><mi>x</mi><msup><mo>)</mo><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">\frac {dy} {dx} &lt;= F(x+dx)&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>就是考虑我们不停的沿着边界走,一直走上取整,就不会露过任何点</p>
<p>而用整数去逼近防止走到曲线内部可以用SBT...</p>
<p>首先如果走到了曲线内部就考虑弹栈, 如果在外面就考虑sbt向右子树走一步看在不在里面</p>
<p>如果我们这个样走一步,能够贴住这个曲线(刚好满足上面的式子),我们就走这一步,否则就知道上一步一定是最优的就更加贴合....</p>
<p>额..其实代码里面有详解,主要分三步,求值,暂定可以,拟合曲线</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
#define ull unsigned long long
#define U128 __uint128_t
#define uint unsigned int
using namespace std;
const int MAXN = 1e5 + 7;
ll n;


namespace fastIO {
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(U128 x, char C) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
		_sr[++_C] = C;
	}
}
using namespace fastIO;

struct ST {
	int que[MAXN][2];
	int tail;
	void pop() {
		tail--;
	}
	void push(int x, int y) {
		tail++;
		que[tail][0] = x;
		que[tail][1] = y;
	}
	void top(int &amp;x, int &amp;y) {
		x = que[tail][0];
		y = que[tail][1];
	}
} st;
//\sum_{i^2/p} 和 (x,y)
//凸包上方
inline int outside(ull x, ull y) {
	return (U128)y * n &gt; (U128)x * x;
	//y&gt;x^2/p
	//y*p&gt;x^2
}
//f(x)=i^2/p
//f(x)'=2*i/p
//切线斜率
inline int cut_off(ull x, uint dx, uint dy) {
	//2*x/p &gt;= dy/dx
	//x*dx &gt;= 2 * dy * p
	return (U128)n * dy &lt;= 2 * (U128)x * dx;
}

int main() {
	scanf(&quot;%lld&quot;, &amp;n);
	// puts(&quot;qwq&quot;);
	// printf(&quot;%lld\n&quot;, n);
	U128 ret = 0;
	int dx = 0, dy = 0, ux = 0, uy = 0, mx = 0, my = 0;
	int cnt = 0;
	ull x = 0, y = 1;
	st.push(0, 1);
	st.push(1, 0);
	ull w = n / 2;
	while(st.tail) {
		st.top(dx, dy);
		//如果我们已在上方
		while(outside(x + dx, y + dy) &amp;&amp; x + dx &lt;= w) {//不到一半...
			//dx是横着的一段距离
			//dy是竖着的
			ret += y * dx + ((ll)dy - 1) * (dx + 1) / 2;//三角形面积?/jk
			x += dx;
			y += dy;
			//再走一步qwq
			// printf(&quot;%lld %lld\n&quot;, x, y);
			cnt++;
		}
		if(x + dx &gt; w)break;
		//走过了一半,再数就重复了
		if(x &gt;= n)break;
		while(1) {
			st.pop();
			ux = dx;
			uy = dy;
			st.top(dx, dy);
			//如果当前怎么走都是阴间的
			// printf(&quot;%lld?%lld\n&quot;, dx, dy);
			if(outside(x + dx, y + dy))break;
			//上方了
		}
		while(1) {
			mx = ux + dx;
			my = uy + dy;
			// printf(&quot;%lld!%lld\n&quot;, mx, my);
			if(!outside(x + mx, y + my)) {//在下面了...
				if(cut_off(x + mx, dx, dy))break;
				//如果这一步斜率小了
				ux = mx;
				uy = my;
			} else st.push(dx = mx, dy = my);//还在上面就再来一次
		}
	}
	//没走完啊
	for(ull i = x + 1; i &lt;= w; ++i)
		ret = ret + (U128)i * i / n;
	U128 z = (U128)(w) * (w + 1) * (2 * w + 1) / 6 - ret * n;
	//\sum{i^2}-\sum_{i^2\p}*p
	//这里转化回来了!!!
	print(z, '\n');
	Ot();
	return 0;
}


</code></pre>
<p>B</p>
<p>啊,5pts挂了...好心疼</p>
<p>对于30我们暴力就好了,用bitset记下这个点能去那些点就好了然后边就不重要了...</p>
<p>如果碰到想找到的就break</p>
<p>然后dag就是转化用容斥求个方案数qwq,这个数据好像很强...</p>
<p>f_i表示0~p_i就是一开始不经过的关键点的路径条数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>g</mi><mi>S</mi></msub><msub><mi>P</mi><mi>i</mi></msub><mo>−</mo><munder><mo>∑</mo><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></munder><mi>g</mi><mo>[</mo><mi>j</mi><mo>]</mo><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i=g_SP_i-\sum_{f[j]}g[j]p_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其实就考虑第一个经过哪个...然后容斥掉</p>
<p>正解</p>
<p>对于一个可逆的矩阵可以在O(n^2k)加上一个秩为k的矩阵并求出可逆矩阵</p>
<p>修改一个点的入边出边就相当于矩阵上某一行均变为0,是一个秩为1的修改,这个可以在支持单点查询的时候很快</p>
<p>然后你妈的上定理了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596701135875.png" alt="" loading="lazy"></figure>
<p>那么好像我们把整个图求个逆矩阵然后两两之间的逆矩阵可以拿出来,然后对于一组询问我们把中间的一个矩阵搞出来点乘一下,就能做到是否相互到达,复杂度是O(k1<sup>3+k2</sup>k^2)</p>
<p>下面摘抄zhq的</p>
<p>DAG</p>
<p>考场最后40min想到的并不完全的做法。。会TTT。。然也没写完</p>
<p>以容斥计算方案数从而判断是否合法</p>
<p>然后应该就清楚了：容易 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 处理出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 从i到j的方案数。</p>
<p>然后我就想：用总方案数-经过一个禁止点的+经过两个的-经过三个的+。。。</p>
<p>经过若干禁止点S的方案数是可求的：一定按拓扑序经过，假设为S1，S2，S3，。。。Sx，那方案数就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>s</mi><mo>]</mo><mo>[</mo><mi>S</mi><mn>1</mn><mo>]</mo><mo>∗</mo><mi>f</mi><mo>[</mo><mi>S</mi><mn>1</mn><mo>]</mo><mo>[</mo><mi>S</mi><mn>2</mn><mo>]</mo><mo>∗</mo><mi>f</mi><mo>[</mo><mi>S</mi><mn>2</mn><mo>]</mo><mo>[</mo><mi>S</mi><mn>3</mn><mo>]</mo><mo>∗</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∗</mo><mi>f</mi><mo>[</mo><mi>S</mi><mi>x</mi><mo>]</mo><mo>[</mo><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[s][S1]* f[S1][S2]*f[S2][S3]*...*f[Sx][t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span> 。</p>
<p>对每个点的询问都要这么求，复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mi>k</mi><mn>1</mn></msub></msup><mo>∑</mo><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">2^{k_1}\sum k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099118em;vertical-align:-0.25001em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​ ，刚刚好TTT。。、</p>
<p>事实上！容斥可以做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>k</mi><mn>1</mn><mn>2</mn></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k_1^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ！（64-&gt;36，但常数也小了不少）</p>
<p>换种思考方法：用总方案数减（从s不经过禁止点走到S1，再从S1随便走到t）减（从s不经过禁止点走到S2，再从S2随便走到t）减（从s不经过禁止点走到S3，再从S3随便走到t）...</p>
<p>然后“从s不经过禁止点走到Si”的方案数就是从s走到Si的总方案数减减（从s不经过禁止点走到S1，再从S1随便走到Si）减（从s不经过禁止点走到S2，再从S2随便走到Si）-...（从s不经过禁止点走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>​ ，再从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 随便走到Si）的方案数。</p>
<p>所以我们可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>k</mi><mn>1</mn><mn>2</mn></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k_1^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 地处理出“从s不经过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>S</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">S_1...S_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>​ 这些关键点走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​ 关键点的方案数”。。</p>
<p>事实上，你把柿子写一下，发现这拆开后和上面 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mi>k</mi><mn>1</mn></msub></msup></mrow><annotation encoding="application/x-tex">2^{k_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>​ 的柿子一样。</p>
<p>是不是也有点容斥DP那味啊？？？就考虑所有集合中最大元素为i对最终答案产生的贡献——。。。</p>
<p>注意这一切都是建立在如果经过关键点那一定是按拓扑序经过的这一前提上。所以只能DAG用。。</p>
<p>通过考虑“第一个不合法的是谁”把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> 的容斥优化成Poly(k)</p>
<p>[HAOI2017]方案数仿佛和这个题一样</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">q&lt;=1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span></p>
<p>是bitset乱搞。。可我乱搞技术太菜了。。</p>
<p>只想到“诶我会 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>n</mi><mn>2</mn></msup><mi>w</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{n^2}{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​ ”预处理两个点间的可达性，别的不会了！！。</p>
<p>额。。你发现，点数很少，如果我们能快速地判断一条边通往的是不是一个已经走过的点，那判断一次的复杂度就从和m相关，变成和n相关。</p>
<p>那，如果用一个bitset记录哪些点还没走过，然后再和表示邻接矩阵的bitset and一下不就能快速找到了嘛！！</p>
<p>bitset里有俩函数可以帮助我萌找到所有为1的位置！见代码。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day9]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day9/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day9/">
        </link>
        <updated>2020-08-05T07:02:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm0SOkVW2obInHocXot*aVjuHsZ4*isoWzDeZ2xEnbp4kt4c2.mlEj*WHKJ79Hmlrdc!/r" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1I2UcDYqmlQb0.SVBuJnWFJUtVNhaMuUAHZISyj70ItxcinVPqFNQZjoimuOzNwHk!/r" alt="" loading="lazy"></figure>
<p>A</p>
<p>zhq切掉了</p>
<p>u和v xor起来最大那么如果不他在两条链上答案就就是u和vxor起来的答案</p>
<p>那么相当于只有两条链啊,对于包括u和v的两条链,那么我们就可以考虑这两个链不加入,然后其他的点都加进去,然后随着链下降我们会加入一些新点,这都问题不大</p>
<p>O(nw)极其好写</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#define ll long long
using namespace std;
const int MAXM = 1e6 + 7;
const int MAXN = 5e5 + 7;
map&lt;ll, int&gt;  mp;
int n, fa[MAXN], ccnt, ansu, ansv;
int home[MAXN], nxt[MAXM], to[MAXM];
ll a[MAXN], ans[MAXN], Nans, tmpans;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

const int MAXT = 1e7 + 7;
struct rec {
	int ch[MAXT][2];
	int siz[MAXT];
	int T, root;
	inline void ins(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			if(!ch[u][t])ch[u][t] = ++T;
			siz[u]++;
			u = ch[u][t];
		}
		siz[u]++;
		return ;
	}
	inline void del(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			siz[u]--;
			u = ch[u][t];
		}
		siz[u]--;
		return;
	}
	inline ll query(ll V) {
		ll qwq = 0;
		int u = root;
		for(ll i = 60; i &gt;= 0; --i) {
			int t = V &gt;&gt; i &amp; 1;
			if(!ch[u][t ^ 1])u = ch[u][t];
			else if(siz[ch[u][t ^ 1]] &gt;= 1)
				u = ch[u][t ^ 1], qwq |= (1ll &lt;&lt; i);
			else u = ch[u][t];
		}
		return qwq;
	}
} T2;

inline void init() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ll tmp = T2.query(a[i]);
		T2.ins(a[i]);
		if(tmp &gt; Nans) {
			ansu = i;
			ansv = mp[tmp ^ a[i]];
			Nans = tmp;
		}
	}
	// printf(&quot;%d %d %d?\n&quot;, Nans, ansu, ansv);
	return ;
}

inline void add(int u, int F) {
	tmpans = max(T2.query(a[u]), tmpans);
	T2.ins(a[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		add(v, u);
	}
}

int tp, tk[MAXN];
inline void solve(int x) {
	memset(T2.ch, 0, sizeof(T2.ch));
	T2.T = 1;
	T2.root = 1;
	memset(T2.siz, 0, sizeof(T2.siz));
	tp = 0;
	while(x != 0) {
		tk[++tp] = x;
		x = fa[x];
	}
	tmpans = 0;
	for(int i = tp; i &gt;= 1; --i) {
		int u = tk[i];
		// printf(&quot;!%d \n&quot;, u);
		ans[u] = tmpans;
		for(int k = home[u]; k; k = nxt[k]) {
			int v = to[k];
			if(v == tk[i - 1] || v == fa[u])continue;
			// printf(&quot;%d?\n&quot;, v);
			add(v, u);
			//插入顺便更新答案qwq
		}
		tmpans = max(tmpans, T2.query(a[u]));
		T2.ins(a[u]);
	}
	return ;
}

inline void solve2() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ans[i] = Nans;
		T2.ins(a[i]);
		Nans = max(Nans, T2.query(a[i]));
	}
	for(int i = 1; i &lt;= n; ++i)
		printf(&quot;%lld\n&quot;, ans[i]);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;fa[i]);
		if(fa[i] != i - 1)flg = 0;
		ct(i, fa[i]);
		ct(fa[i], i);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		mp[a[i]] = i;
	}
	if(flg) {
		solve2();
		return 0;
	}
	memset(ans, -1, sizeof(ans));
	init();//get u,v
	solve(ansu);
	// puts(&quot;--------&quot;);
	solve(ansv);
	for(int i = 1; i &lt;= n; ++i)
		if(ans[i] != -1)printf(&quot;%lld\n&quot;, ans[i]);
		else printf(&quot;%lld\n&quot;, Nans);
	return 0;
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1nlwmcC*RLBJETPoIOfL2XIWbfFg2sJ90eAUvTHvz1LHwQiDUpVNklFj5D6c3f6Uc!/r" alt="" loading="lazy"></figure>
<p>B</p>
<p>构造</p>
<p>角上X&lt;=4</p>
<p>边上加角上我们可以最多的能放就放放出答案</p>
<p>X+Y&lt;=4+R-y/2</p>
<p>就是小于等于2* R/2 +2* C/2 +4</p>
<p>点数小于等于边数-1</p>
<p>总边数减去黑格删去的边数角落边界和内部黑格删去的不同</p>
<p>x+2Y+3Z&lt;=(R-1)(C-1)</p>
<p>3(X+Y+Z)&lt;=2R/2+2C/2+4</p>
<p>当然这个上界可能取不到</p>
<p>n=3k 上界是n^2/3</p>
<p>n=6k+1,6k+5 n^2+2/3</p>
<p>n=6k+2,6k+4 n^2+1/3</p>
<p>如果9要取到等号边界要放满5个格子...</p>
<p>然后根据连通性我们边界上都要是</p>
<p>然后偶数就可以...由题解构造...</p>
<p>先定下中间的部分,再一步步扩张,是构造的基本思路</p>
<p>间行种植可以帮助我们解决扩张</p>
<p>而中间的部分...只能自己慢慢试了....</p>
<p>n=6k</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596635791017.png" alt="" loading="lazy"></figure>
<p>n=6k+1</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1596635812577.png" alt="" loading="lazy"></figure>
<p>n=6k+2</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1596635825763.png" alt="" loading="lazy"></figure>
<p>n=6k+3</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1596635841225.png" alt="" loading="lazy"></figure>
<p>n=6k+4</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1596635856427.png" alt="" loading="lazy"></figure>
<p>n=6k+5</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1596635865367.png" alt="" loading="lazy"></figure>
<p>当然最简单的6k也可以使用</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1596635881086.jpg" alt="" loading="lazy"></figure>
<p>其实这个启发我们网格构造题可以考虑从中间起手扩展</p>
<p>但是中间的起手一定要花大点的...两倍差不多</p>
<p>C</p>
<p>考虑把所有d压成一个d维向量S记在每个点上....</p>
<p>然后对于一个向量,他的出边就是随机一个权值然后*该点向量然后再</p>
<p>对于一个点,他的最小割就是所有入边形成的线性空间的秩...就是基底</p>
<p>那会发现最小割大小不超过3,则构成这个点向量的秩数就不超过3...</p>
<p>求秩就是求线性基的大小,所有的入边构成一个线性基,然后考虑用这个线性基去求这个向量的秩数...</p>
<p>然后我们不要每次拿所有的入边去做,每次削成一个线性基,然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=\sum{w_{i,j}*e_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>就解决了</p>
<p>首先秩小于等于最小割啊....另外我们由于随机所以大概率对吗</p>
<p>其实就是入边是一些不同的线性组合构成的就大概率能保证这个点也是对的...</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
const int MAXN = 2e5 + 7;
const int MAXM = 1e6 + 7;
const int P = 998244353;
int n, K, m;
int vis[MAXN], home[MAXN], nxt[MAXM], to[MAXM], first[MAXN], ccnt;
int c[MAXN], que[MAXM], d[MAXN], ans[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void ct2(int x, int y) {
	ccnt++;
	nxt[ccnt] = first[x];
	first[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	vis[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		dfs(v);
	}
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

struct rec {
	int a[12];
	inline rec &amp;operator+=(const rec &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (a[i] + x.a[i]) % P;
		}
		return *this;
	}
	inline rec operator+(const rec &amp;x) const {
		rec c = *this;
		c += x;
		return c;
	}
	inline rec &amp;operator*=(const ll &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (1ll * x * a[i]) % P;
		}
		return *this;
	}
	inline rec operator *(const int &amp;x) const {
		rec c = *this;
		c *= x;
		return c;
	}
} b[MAXN];

struct _list {
	int n;
	vector&lt;rec&gt; V;
	inline int gs() {
		int n = V.size();
		for(int i = 0; i &lt; n; ++i)b[i] = V[i];
		//拿b消元才行
		for(int i = n; i &lt; max(n, K); ++i) {
			for(int j = 0; j &lt; K; ++j) {
				b[i].a[j] = 0;//init
			}
		}
		n = max(n, K);
		//个数和列数取最大
		V.clear();
		for(int i = 0; i &lt; K; ++i) {
			c[i] = 0;
		}
		for(int i = 0; i &lt; K; ++i) {
			if(!b[i].a[i]) {
				//如果这个对角线是空的...
				for(int j = 0; j &lt; n; ++j) {
					if(!c[j] &amp;&amp; b[j].a[i]) {
						swap(b[i], b[j]);
						//交换两行
						//就是我们之后的的有一个没有被动过的这个位置有数
						break;
					}
				}
			}
			if(!b[i].a[i])continue;
			c[i] = 1;
			V.push_back(b[i]);
			//加入这一行
			//说明这一行有东西啊
			int t = P - ksm(b[i].a[i], P - 2);
			//求下逆
			for(int j = 0; j &lt; n; ++j) {
				if(j != i &amp;&amp; b[j].a[i]) {
					//高斯消元
					int c = 1ll * t * b[j].a[i] % P;
					//乘上这个再加就可以使他变为0
					b[j] = b[j] + b[i] * c;
					//一行加一列
				}
			}
		}
		return V.size();
	}
} a[MAXN];

inline int mrand() {
	return (rand() &lt;&lt; 16)^rand() + rand();
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1, u, v; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct2(v, u);
	}
	dfs(1);
	// puts(&quot;qwq&quot;);
	for(int u = 1; u &lt;= n; ++u) {
		for(int i = first[u]; i; i = nxt[i]) {
			int v = to[i];
			if(vis[v])
				d[u]++;
		}
	}


	// for(int i = 1; i &lt;= n; ++i)
	// 	printf(&quot;%d\n&quot;, d[i]);
	srand(114514);
	for(int i = home[1]; i; i = nxt[i])++K;
	// b[1].a[1] = 1;
	// b[1] *= 2;
	// b[1] += b[1];
	// printf(&quot;%d\n&quot;, b[1].a[1]);
	// printf(&quot;%d\n&quot;, K);
	int N = 0, head = 1, tail = 1;
	que[tail] = 1;
	while(head &lt;= tail) {
		int u = que[head];
		// printf(&quot;%d*&amp;\n&quot;, u);
		++head;
		if(u != 1)
			ans[u] = a[u].gs();
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			rec t;
			for(int k = 0; k &lt; K; ++k)
				t.a[k] = 0;
			if(u == 1)
				t.a[N++] = 1;//初始基底
			else {
				for(int i = 0; i &lt; a[u].V.size(); ++i) {
					t = t + a[u].V[i] * (mrand() % P);
				}
			}
			a[v].V.push_back(t);
			d[v]--;
			if(!d[v])que[++tail] = v;
			//拓扑
		}
	}
	for(int i = 2; i &lt;= n; ++i)
		printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}

</code></pre>
<p>强烈推荐弹丸论破</p>
<p>尤其是狛枝凪斗的希望教...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day8]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day8/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day8/">
        </link>
        <updated>2020-08-04T08:10:33.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>传统的博弈论,k-nim模型,对于k-nim模型他的SG值显然还是石子个数</p>
<p>而是否决胜是对于每一个二进制位求和能不能被k+1整除</p>
<p>然后就是统计有多少种方案使他们最后是0</p>
<p>这样我们就可以DP啦QwQ</p>
<p>三进制xor就是每一位加起来%3</p>
<p>那么我们是数位DP,从高向低去确定每一位,所以我们要记下是否卡到上/下界</p>
<p>然后这是三种状态,压一压就是3^n种状态,一共有log位,每一位记为w</p>
<p>每次转移时可以枚举a1~n第w位值是什么</p>
<p>就可以做到O(6^nlog)</p>
<p>显然可以优化转移变为一个个枚举</p>
<p>那么我们就再记两维表示我们已经转移了前i个数的他们的w一位的和</p>
<p>f[S][w][i][sum]表示所有a的w上面的位,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1...</mn><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1...i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的第w已经定好了</p>
<p>sum表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1...</mn><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1...w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在第w为的值</p>
<p>然后这样子就能做到像插头dp一样转移</p>
<p>三进制处理?</p>
<p>预处理每个3的i次是什么,然后(x/3^i)%3就是某个数x三进制下第i位是几</p>
<p>然后code:</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define pii pair&lt;int,int&gt;
#define fi first
#define se second
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int P = 998244353;
const int MAXN = 14;
const int MAXM = 6e5 + 7;
int n, l[MAXN], r[MAXN];
int f[2][MAXM][3];
int p3[MAXN];
#define BIT(x,i) ((x)/p3[(i)]%3)//qwq

int trans(int w, int L, int R, int o, int e) {
	//w就是那一位
	//L是我们这个数的下界
	//R是上界
	//O是S的第i-1位
	//e是当前的我们想要加上的数
	int tmp = (L / (1 &lt;&lt; (w + 1))) == (R / (1 &lt;&lt; (w + 1)));
	//L是否在这一位是等于R的
	int eqL = (o == 0);
	//如果为0表示我们卡下界
	int eqR = (o == 1) | (o == 0 &amp;&amp; tmp);
	//为1我们卡上界
	//或者卡下界,下界==上界
	int wL = (L &gt;&gt; w) &amp; 1;
	//wL是表示L第w是否为1
	int wR = (R &gt;&gt; w) &amp; 1;
	//...
	if(eqL &amp;&amp; e &lt; wL)return -1;
	//eqL表示卡了下界,我们没法凑出
	if(eqR &amp;&amp; e &gt; wR)return -1;
	//这个是卡了上界
	eqL &amp;= (e == wL);
	eqR &amp;= (e == wR);
	//如果我们完全卡下界就没了
	//只能返回0
	if(eqL)return 0;
	//否则我们返回3^下的那个,相当于异或成功了
	return 2 - eqR;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	p3[0] = 1;
	for(int i = 1; i &lt;= n; ++i)
		p3[i] = p3[i - 1] * 3;
	for(int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);
	memset(f, 0, sizeof(f));
	int nw = 0;
	f[nw][0][0] = 1;
	for(int bit = 29; bit &gt;= 0; --bit) {
		//枚举每个数位
		//显然这货被我们滚掉了
		//因为他只是可行性判断的一部分
		for(int i = 1; i &lt;= n; ++i) {
			//枚举我们去确定的前i位
			memset(f[nw ^ 1], 0, sizeof(f[nw ^ 1]));
			for(int S = 0; S &lt;= p3[n] - 1; ++S) {
				//枚举所有已经定好的w上面的位
				for(int v3 = 0; v3 &lt;= 2; ++v3) {
					//枚举所有可能的w和
					if(f[nw][S][v3]) {
						int w = f[nw][S][v3];
						for(int v = 0; v &lt;= 1; ++v) {
							//枚举我这位是0还是1
							if(i == n &amp;&amp; ((v3 + v) % 3 != 0))continue;
							int nv = trans(bit, l[i], r[i], BIT(S, i - 1), v);
							//trans出新nv
							if(nv == -1)continue;
							int nS = S - p3[i - 1] * BIT(S, i - 1) + p3[i - 1] * nv;
							//计算S的变化
							//就是减去原来的i-1位然后加上新的i-1位
							//是三进制下的
							f[nw ^ 1][nS][(v3 + v) % 3] = (f[nw ^ 1][nS][(v3 + v) % 3] + w) % P;
						}
					}
				}
			}
			nw ^= 1;
		}
	}
	long long ans = 0;
	for(int i = 0; i &lt; p3[n]; ++i)
		ans = (ans + f[nw][i][0]) % P;
	//当最后为0时,也是一切尘埃落定之时
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
<p>B</p>
<p>首先我们发现去重是个有毒的东西,所以我们可以考虑转为数组下标的数组</p>
<p>然后钦定对于一个b,对应其字典序最小的S这样就不会算重</p>
<p>然后怎么算Si+1是字典序最小的那个呢?</p>
<p>首先对于s_i+1要满足x<sub>y中没有y,y</sub>z中没有z.....</p>
<p>然后如果没有任何一个存在的情况就是字典序最小的qwq</p>
<p>h_i是最大的D,满足i \in S_D</p>
<p>求几个合法的h就是求几个合法的树状图...</p>
<p>显然我们对于i&lt;j,a_i==a_j,弱h_j&gt;h_i,则就由于被挡住而存在k在i,j之间h_k&gt;h_i</p>
<p>不然考虑S_k+1可以把j替换为i</p>
<p>然后考虑这个限制,g[L][R][K]表示对于L~R所有i,若a_i=a_R+1</p>
<p>那么L~R一定有一个比h_i大的</p>
<p>首先我们可以枚举有哪些h_i=k</p>
<p>首先不能等于a_R+1否则我们会发生平移操作</p>
<p>枚举完之后又会分成若干个子区间啦</p>
<p>第一个转移时被保护的</p>
<p>f是没有R+1的限制下的方案数</p>
<p>R+1的限制就是对于一个a_i=a_R+1,中间一定要有一个h_i帮他挡着</p>
<p>因为我们区间是在一点点定值下去的...</p>
<p>如果随便定会使得不满足i~R+1的限制,所以只能在某个地方才能定值</p>
<p>我们定值的过程相当于定K的位置,就是说从大到小去定每个h的值</p>
<p>然后我们g有限制的就要转移时不能给a_i=a_r+1先定值</p>
<p>而f则可以通过g数组在我们定好值的位置上加上限制来转移</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596530560212.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596530578596.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596530572566.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596530584634.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1596530589866.png" alt="" loading="lazy"></figure>
<p>K=3</p>
<p>枚举i=1~n,记一下S2和S3上一步是什么....</p>
<p>最后说实话讲的有点乱</p>
<p>其实就是a_i==a_j,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>,那么i一定出现在j前面的S里,也就是说只有两个都选上时的序列才行</p>
<p>然后这个是限制,求一下本质不同的h序列个数</p>
<p>code:</p>
<pre><code class="language-cpp">
//From Ultimate Destroy
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXN = 111;
const int P = 998244353;

int n, a[MAXN], K, g[MAXN][MAXN][MAXN], f[MAXN][MAXN][MAXN];
//妈的讲的和实际上是反的
inline void init() {
	int flg = 0;
	//初始化部分
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = i; j &lt;= n; ++j) {
			f[1][i][j] = 1;
			//这显然只有一种方案
			if(j &lt; n) {
				//对于小于n的情况
				//如果定他大于n会与这个dp状态不太符合
				flg = 0;
				for(int k = i; k &lt;= j; ++k) {
					//枚举
					if(a[k] == a[j + 1])flg = 1;
					//如果满足这两个相等,那么就是说这之前的才行!
					//也就是这个区间会被卡r+1啊
				}
				if(!flg)g[1][i][j] = 1;
			}
		}
	}
}

inline void dp() {

	for(int k = 2; k &lt;= K; ++k) {
		for(int L = 1; L &lt;= n; ++L) {
			for(int l = 1; l &lt;= n - L + 1; ++l) {
				int r = l + L - 1;
				int w = f[k - 1][l][r] * (L != n);
				//如果L是n长度就太长了
				//显然就成了个初始态
				for(int p = l; p &lt;= r; ++p) {
					int t = 1;
					//枚举转折点
					if(p &lt; r)t = t * 1ll * f[k][p + 1][r] % P;
					//如果不是右端点,我们可以乘上之后那段区间随意的方案数
					if(p &gt; l)t = t * 1ll * g[k - 1][l][p - 1] % P;
					//但是前面那段区间是受到限制的
					//不能放k-1
					w = (w + t) % P;
				}
				f[k][l][r] = w;

				if(r &lt; n) {
					//r+1&lt;=n
					w = g[k - 1][l][r] * (L != n);
					for(int p = l; p &lt;= r; ++p)
						if(a[p] != a[r + 1]) {
							//我彪掉了...
							//这个a_p显然只能先定值k啊!!!
							int t = 1;
							if(p &lt; r)t = t * 1ll * g[k][p + 1][r] % P;
							//显然由于本身我们更新的缘故,这个东西就要受到限制
							if(p &gt; l)t = t * 1ll * g[k - 1][l][p - 1] % P;
							//然后又要受到新限制啦qwq
							w = (w + t) % P;
							//这是那个西格玛
						}
					g[k][l][r] = w;
				}
			}
		}
	}
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	init();
	dp();
	printf(&quot;%d\n&quot;, f[K][1][n]);//QAQ
	return 0;
}

</code></pre>
<p>C</p>
<p>Q=1的暴力</p>
<p>首先二分答案S</p>
<p>统计一下最多选多少个数</p>
<p>首先小于S/2一定被选</p>
<p>而&gt;S/2的两个区间内肯定只能选一个数,所以可以枚举每个区间看最小值能不能选,能选答案+1</p>
<p>多次询问就用个数据结构维护一下,对于小于S/2的个数可以主席树</p>
<p>但是第二个统计有点毒啊...</p>
<p>于是我们思考有多少个三元组(x,y,z)满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>z</mi><mo>&lt;</mo><mi>y</mi><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L&lt;x&lt;z&lt;y&lt;R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>&lt;</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a[x],a[y]&lt;S/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[x+1,y-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>最小值</p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>&gt;</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a[k]&gt;S/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span></span></span></span>否则会跨两个区间</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">a[k]+max(a[x],a[y])&lt;=S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></p>
<p>观察第2,3,4,三个条件我们可以发现对于一个k有唯一的一组x,y能与之对应</p>
<p>那么对于一个三元组k,有两个限制,值域限制和位置限制</p>
<p>首先我们可以算出s的范围</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>∈</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mn>2</mn><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">S \in  [a[k]+max(a[x],a[y]),2a[k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么显然我们一个k就是一个区间加,然后S是单点查</p>
<p>当然也可以k单点加(差分)S区间查,可主席树</p>
<p>然后这是三维数点</p>
<p>显然我们可以找到对于L,R中左边第一个dL,右边第一个dR满足小于等于S/2的</p>
<p>那么满足条件的三元组都在这个区间里面而且也一定都在这个区间里面</p>
<p>所以就变成了k在dL,dR之间,就变成了了二维数点</p>
<p>实际上我们要找小于的,否则可能会因为相等的值而找重复了,实测这也是对的</p>
<p>这样就可以二分+树状数组两个log解决了</p>
<p>minmax卷积 : a_i+j=min(max(b_i,c_j))</p>
<p>首先我们考场上有一个类似笛卡尔树的堆的做法</p>
<p>就是考虑一开始都选上,然后我们删去相邻最大和的,就一直删下去知道满足了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#define se second
#define fi first
#define mkp(x,y) (make_pair(x,y))
#define ins insert
using namespace std;
const int MAXN = 1e5 + 7;
multiset&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; st;
int nxt[MAXN], pre[MAXN], a[MAXN], n, Q, vis[MAXN];

inline void del(int x) {
	nxt[pre[x]] = nxt[x];
	pre[nxt[x]] = pre[x];
}

inline void solve(int l, int r, int z) {
	for(int i = l; i &lt; r; ++i) {
		st.ins(mkp(a[i] + a[i + 1], mkp(i, i + 1)));
		// printf(&quot;%d\n&quot;, a[i] + a[i + 1]);
		// printf(&quot;%d?\n&quot;, st.size());
		nxt[i] = i + 1;
		pre[i] = i - 1;
	}
	pre[l] = r;
	st.ins(mkp(a[r] + a[l], mkp(r, l)));
	nxt[r] = l;
	pre[r] = r - 1;
	int k1, k2;
	// printf(&quot;%d?\n&quot;, st.size());
	while(st.size() &gt; z) {
		auto it = st.end();
		--it;
		int u = (*it).se.fi;
		int v = (*it).se.se;
		// printf(&quot;%d?%d %d\n&quot;, u, v, (*it).fi);
		if(vis[u] &amp;&amp; vis[v]) {
			st.erase(it);
			continue;
		}
		if(vis[u] || (a[u] &lt; a[v] &amp;&amp; !vis[v]))u = v;
		// printf(&quot;%d?\n&quot;, u);
		//我们只删除u
		k1 = a[u] + a[nxt[u]];
		k2 = a[u] + a[pre[u]];
		vis[u] = 1;
		st.erase(it);
		if(u != v)st.erase(st.find(mkp(k2, mkp(pre[u], u))));
		else st.erase(st.find(mkp(k1, mkp(u, nxt[u]))));
		del(u);
		st.ins(mkp(a[pre[u]] + a[nxt[u]], mkp(pre[u], nxt[u])));
	}
	auto it = st.end();
	--it;
	printf(&quot;%d\n&quot;, (*it).fi);
	st.clear();
	return;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;Q);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	if(n &lt;= 10000 || Q &lt;= 10000) {
		for(int i = 1, x, y, z; i &lt;= Q; ++i) {
			scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
			for(int i = x; i &lt;= y; ++i)vis[i] = 0;
			solve(x, y, z);
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day7]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day7/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day7/">
        </link>
        <updated>2020-08-03T07:03:09.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>每个点求第k小的路径长,保证树随机</p>
<p>二分+线段树+树上爬</p>
<p>我们考虑对于一个LCA是不是存在大于二分值的路径K条</p>
<p>发现这个可以对于一个唯一的u建立线段树存子树</p>
<p>然后就可以用点分树的思想<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>3</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">Olog^3n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
<p>然后发现我们可以换种思路,就是使得点x所有的距离都记录到线段树里</p>
<p>但你发现直接做不太好</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dep[u]+dep[i]-2dep[LCA]&lt;=ans
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>也就意味着我们可以用一个线段树维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dep[i]-2dep[LCA]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mclose">]</span></span></span></span></p>
<p>然后我们depi显然不变,但2deplca随着x走可能会发生改变,因为lca可能会发生改变</p>
<p>x子树外的i他们的lca显然不会变,然后你会发现只有对于x子树里那些i他们的lca会变为x下面的点...所以只需要每走一步做一个简单的子树全部修改操作即可</p>
<p>然后查询就是一个树状数组二分,您会发现树状数组在开2的次幂时正好是和二分时的mid一样的</p>
<p>看code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define R register
const int MAXN = 5e5 + 7;
using std::max;
int n, K;
int dfn[MAXN], dep, dp[MAXN], dfm[MAXN], topE[MAXN], ans[MAXN];
int ccnt, len[MAXN], home[MAXN], nxt[MAXN], to[MAXN];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	len[ccnt] = z;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = 0;
		int x = 0;
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(int x, char s) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
		_sr[++_C] = s;
	}
}
using namespace fastIO;

const int MAXM = (1 &lt;&lt; 20) + 1;
namespace  BIT {
	int sum[MAXM];
#define lowbit(x) (x&amp;-x)
	inline void add(int x, int y) {
		for(; x &lt; MAXM; x += lowbit(x))sum[x] += y;
	}
	inline int query() {
		R int l = 0, r = MAXM - 1, s = K;
		while(l + 1 != r) {
			int mid = (l + r) / 2;
			if(sum[mid] &gt;= s)r = mid;
			else s -= sum[mid], l = mid;
		}
		return l + 1;
	}
}
using namespace BIT;

int nwdp[MAXN], mdp;

inline void dfs(int u, int F) {
	dfn[u] = ++dep;
	mdp = max(mdp, dp[u]);
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		topE[v] = len[i];
		dp[v] = dp[u] + len[i];
		dfs(v, u);
	}
	dfm[u] = dep;
}

inline void dfs1(int u, int F) {
	if(u != 1)
		for(R int i = dfn[u]; i &lt;= dfm[u]; ++i) {
			add(nwdp[i], -1);
			nwdp[i] -= 2 * topE[u];
			add(nwdp[i], 1);
		}
	ans[u] = dp[u] + query() - mdp;
	//-mdp是为了防止负数
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		dfs1(v, u);
	}
	if(u != 1) {
		for(R int i = dfn[u]; i &lt;= dfm[u]; ++i) {
			add(nwdp[i], -1);
			nwdp[i] += 2 * topE[u];
			add(nwdp[i], 1);
		}
	}
}

int main() {
	n = read();
	K = read();
	for(R int i = 1, x, y, z; i &lt; n; ++i) {
		x = read();
		y = read();
		z = read();
		ct(x, y, z);
		ct(y, x, z);
	}
	dfs(1, 0);
	++mdp;
	for(R int i = 1; i &lt;= n; ++i) {
		nwdp[dfn[i]] = dp[i] + mdp;
		add(nwdp[dfn[i]], 1);
	}
	dfs1(1, 0);
	for(R int i = 1; i &lt;= n; ++i)print(ans[i], '\n');
	Ot();
	return 0;
}


</code></pre>
<p>B</p>
<p>dp[x][k][0/1]表示x的子树access了k次后不同的子树形态,x到他儿子的边中有没有实边</p>
<p>然后考虑合并</p>
<p>但是你会发现子树之间的access顺序会决定不同的树的形态</p>
<p>所以我们可以钦定那条边是实边,然后考虑其他的就顺序任意即可,而钦定的放在最后access</p>
<p>您发现我们不需要考虑access具体操作顺序,只需要知道这个是最后的</p>
<p>无效操作?意义不大,我们统计答案的时候搞一下就行了</p>
<p>代码中g就是对应了0那一维,f对应了1</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define R register
using namespace std;
const int P = 998244353;
const int MAXN = 1e4 + 7;
const int MAXM = 5e4 + 7;
int siz[MAXN], n, m, k, a[MAXN], f[MAXN][520], g[MAXN][520];
int to[MAXM], nxt[MAXM], home[MAXM], ccnt;

inline void ct(const int &amp;x, const int &amp;y) {
	ccnt++;
	nxt[ccnt] = home[x];
	to[ccnt] = y;
	home[x] = ccnt;
}

inline void dfs(const int &amp;u, const int &amp;F) {
	f[u][0] = 1;
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		dfs(v, u);
		for(R int j = siz[u]; j &gt;= 0; --j) {
			g[u][j + 1] = (g[u][j + 1] + f[u][j]) % P;
			//g,f相互转移
			for(R int k = 0; k + j &lt;= m &amp;&amp; k &lt;= siz[v]; ++k) {//限制次数上限,sizv,m
				if(g[v][k]) { //如果不是空
					g[u][j + k] = (g[u][j + k] + 1ll * f[u][j] * g[v][k]) % P;
					//f是考虑access的,所以可以从f向之后g更新
					g[u][j + k] = (g[u][j + k] + 1ll * g[u][j] * g[v][k]) % P;
					//直接乘即可,g是任意的?
					f[u][j + k] = (f[u][j + k] + 1ll * f[u][j] * g[v][k]) % P;
					//都可以这样更新
				}
			}
		}
		siz[u] += siz[v];
		siz[u] = min(siz[u], m);
	}
	for(R int i = 1; i &lt;= siz[u]; ++i) {
		g[u][i + 1] = (g[u][i + 1] + f[u][i]) % P;
		//可以认为我们能多access一次然后不access的都不考虑了
	}
	siz[u] = siz[u] + 1;
	siz[u] = min(siz[u], m);
	//大于就价值不大
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(R int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	dfs(1, 0);
	int ans = 1;
	for(R int i = 1; i &lt;= m; ++i)ans = (ans + g[1][i]) % P;
	//g是DP数组,表示我们access几次
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>考虑对于每一位1算出他的方案数</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示有几对数满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>+</mo><mi>i</mi></mrow></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">|a_{i}-a_{3+i}|=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>x</mi><mi>o</mi><mi>r</mi><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a_i xor a_i+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<p>而且我们可以枚举绝对值符号的正负性</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596440062532.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596440067548.png" alt="" loading="lazy"></figure>
<p>然后会发现是一个卷积,优化一下就是blog^2b的</p>
<p>i^(i+x)第w位的值是有i在第w位的值和i+x在第w位的值</p>
<p>(i+x)在o~w-1时是否进位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i%2^w+x%2^w&gt;2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></p>
<p>然后就可以枚举一下</p>
<p>bit(i,w)=0,bit(x,w)=0,那么i+x必须要进位所以i%2<sup>w&gt;=2</sup>w-x%2^w</p>
<p>从而计算出x在哪个范围里...就可以发现我们的i和i+w了</p>
<p>本质上是一个数位dp,但是我们可以通过钦定一个然后直接计数</p>
<p>虞皓翔大佬的解法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day6]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day6/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day6/">
        </link>
        <updated>2020-08-02T07:04:27.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>|S|=n</p>
<p>显然下面那个dp的答案是m*(m-1)^(n-1)</p>
<p>然后我们需要用二项式反演来容斥</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mi>j</mi></munder><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>j</mi></msup><mi>C</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">ans_i=C(m,i)*(\sum_{j} (-1)^j C(i,j) g(i))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>zhq:显然可以NTT优化mlogm</p>
<p>自闭了....</p>
<p>K=1</p>
<p>答案相当于对于一个颜色i,有多少染色方案满足包括这个颜色</p>
<p>首先显然颜色之间没有本质区别,所以他们的方案数是一样的</p>
<p>然后问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">g_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>这...显然是树形DP啊</p>
<p>你会发现这个DP是没法快速合并的qwq要自上而下去DP</p>
<p>首先对于每个子树规定一个点y</p>
<p>然后递归到y这个子树</p>
<p>所以各个儿子之间就互不影响了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{x,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示x的颜色已经定好,是否为1的情况下子树染色方案数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo>∏</mo><mrow><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>(</mo><mi>m</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">f_{x,0}=\prod {f_{y,0}(m-2)+f_{y,1}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>∏</mo><mrow><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mrow></mrow><annotation encoding="application/x-tex">f_{x,1}=\prod {f_{y,0}{m-1}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span></span></span></p>
<p>x如果为S,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[x][1]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>只能自上而下去搞是特别</p>
<p>k&gt;1显然对于x^k我们有斯特林展开公式!</p>
<pre><code>证明:

$$x^n=x^{n-1}*x$$

$$x^n=x \sum_{i=k}^{n-1} S(n-1,k) x^{k!} $$

$$x^n=\sum_{i=k}^{n-1} S(n-1,k) x^{k+1!} + \sum_{i=k}^{n-1} S(n-1,k) kx^{k}$$

把x^k下降幂提出来,里面就是斯特林数递推式

然后就能等于x^k的那个式子了

k!表示k次下降幂

</code></pre>
<p>变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>c</mi></msub><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><mrow><mi>S</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_c\sum_{i=0}^k {S(k,i)C(|S(C)|,i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><mrow><mi>S</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mi>i</mi><mo>!</mo></mrow><munder><mo>∑</mo><mi>c</mi></munder><mrow><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>c</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=0}^k {S(k,i)*i!} \sum_c{C(|S(c)|,i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">!</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>=</mo><munder><mo>∑</mo><mi>c</mi></munder><mrow><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">g=\sum_c{C(|S(C)|,i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>如果后面的g能算出来就好了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mi>c</mi></munder><munder><mo>∑</mo><mrow><mi>T</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi></mrow></munder><mo>[</mo><mi>T</mi><mo>∈</mo><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{c} \sum_{T,|T|=i} [T \in S(C)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mpunct mtight">,</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>T</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi></mrow></munder><munder><mo>∑</mo><mi>c</mi></munder><mo>[</mo><mi>T</mi><mo>∈</mo><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{T,|T|=i} \sum_{c} [T \in S(C)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mpunct mtight">,</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p>就是i个颜色在关键点上都出现的方案数</p>
<p>令上面那个东西为h,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mi>h</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(i)=C(m,i)h(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p>
<p>dp可以考虑容斥</p>
<p>我们可以考虑枚举有多少个颜色不在这里面,然后用一个容斥算出答案</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>j</mi></msup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>j</mi><mi>i</mi></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">h(i)=\sum_{j=0}^i(-1)^j\binom {j} {i} dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>dp[j]表示至少有j个不在S(c)中的方案数,即某个大小为j的集合ban满足与上S(c)为空集</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[x][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>是C_x不在ban里面的,1C_x表示在ban里面的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的颜色是父亲定好的</p>
<p>转移式子</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596352951787.png" alt="" loading="lazy"></figure>
<p>这个是父亲决定了儿子的颜色</p>
<p>统计答案</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596352959365.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mo>+</mo><msup><mi>k</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk+k^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>B</p>
<p>切开两个边会使得整个树变成三个连通块ABC</p>
<p>然后要求AB不连通,BC也不连通,就是把A+C和B之间的边割掉</p>
<p>d[x]表示子树x内连出去的边有几条因为LCA==1</p>
<p>然后您会发现dA+dC包含了子树A-&gt;C会较多,要减去cnt(A,C)</p>
<p>然后子树搞一个dfs序就变成了区间,放到平面上就可以二维前缀和优化!</p>
<p>然后发现会有一个割子节点和祖先的关系,这样挨着一定最优</p>
<p>这就意味着我们可以用一颗模板树维护一下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>c</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d[y]-2cnt(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,然后用dfs去枚举x</p>
<p>然后可以发现对于x的一条非树边我们要把y到根节点的路径上所有点的权值都减去2</p>
<p>然后对于点x优先dfs他的重儿子再从重儿子那里继承线段树</p>
<p>也就是说我们对于一条重链只开了1个线段树,而只有log线段树</p>
<p>然后轻儿子的线段树可以开垃圾桶回收靠</p>
<p>空间复杂度就不是两个log了!</p>
<p>但是能写出来是不可能的了</p>
<p>所以我们可以dsuontree</p>
<p>喜提3个log解决了,但是您认为3个log难看?全局平衡二叉树解决了</p>
<p>C</p>
<p>回文浓度小于$$\sum_{C(cnt_i+1,2)}$$</p>
<p>所以直接排序就是最优的!</p>
<p>cnt_i表示由几种数他的总数为i</p>
<p>cnt_a==cnt_b-&gt;abababab,babababababa</p>
<p>cnt_a==cnt_b+1-&gt;ababa</p>
<p>cnt_a==2可以作为左右括号抱起来!</p>
<p>除此之外没有任何回文方法了!可以打表验证一下,对于所有满足条件的方案有多少混合方式!</p>
<p>出现次数为2的数可以作为左右括号把别人抱起来的</p>
<p>对于2最后我们再去合并</p>
<p>对于ababab,这个外面不能被抱</p>
<p>而本身是回文的就是aaa,ababa可以抱</p>
<p>f[A][B]表示由A个不可套段,B个可套段方案数</p>
<p>然后还是要记录一下这类长度剩下几个,cnt_a的数剩下几个</p>
<p>对于cnt_a==2的数,可以作为左右括号去套可套段,也可以去套空气</p>
<p>ccbb</p>
<p>所以肯定可以枚举这两种选择分别有几种数,然后再去枚举一共套了几段空气</p>
<p>最后我们用一些组合计数去算答案</p>
<p>就解决了!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day5]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day5/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day5/">
        </link>
        <updated>2020-08-01T07:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dp_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从点i开始的答案然后求和+最大值</p>
<p>直接写的话有30pts,用一个longlong可以记一下答案,但是这里是不能直接做的</p>
<p>显然DP不能优化,考虑优化转移</p>
<p>两个set比较的复杂度是O(min(S1,S2),logn)的,然后对于合并可以启发式合并,这个是均摊O<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的</p>
<p>为啥写挂了?因为没有启发式合并啊</p>
<p>注意最大的那个数我们找出来后要打个*2标记然后加的时候就直接不考虑他就能保证复杂度不会被卡成O(n^2)了!!</p>
<p>而且我们父亲要继承最大的儿子才行/kk.</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
#define int long long
#define ll long long
const int P = 998244353;
const int MAXN = 1e5 + 7;
const int MAXM = 3e5 + 7;
int n, ccnt;
int home[MAXM], to[MAXM], nxt[MAXM], len[MAXM];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	len[ccnt] = z;
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
	return ans;
}

ll dp[MAXN];
inline void dfs(int u, int F) {
	ll maxson = 0;
	for(int i = home[u]; i ; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		ll val = ksm(2, len[i]);
		dp[u] += dp[v] + val;
		maxson = max(dp[v] + val, maxson);
	}
	dp[u] += maxson;
	return ;
}
//queue?vector?set ba....
inline ll ksm2(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
set&lt;int&gt; st[MAXM]; //I am not afraid of TLE
int id[MAXM], tag[MAXM];
#define ins insert

inline int getf(int x) {
	return id[x] == x ? x : id[x] = getf(id[x]);
}

inline void add(int u, int x) {
	x -= tag[u];
	// printf(&quot;%d?%d\n&quot;, u, x);
	while(st[u].find(x) != st[u].end()) {
		st[u].erase(x);
		++x;
	}
	st[u].ins(x);//qwq?
	// printf(&quot;%d?%d?%d?\n&quot;, u, x, st[u].size());
}

inline int merge(int x, int y) {
	int qaq = min(st[x].size(), st[y].size());
	if(qaq == st[x].size()) {
		swap(st[x], st[y]);
		swap(tag[x], tag[y]);
	}
	// printf(&quot;merge : %d %d %d\n&quot;, x, y, qaq);
	for(auto it : st[y]) {
		add(x, it + tag[y]);
	}//fake启发式合并
	return x;
}

inline int pd(int x, int y) {
	auto itx = st[x].end();
	auto ity = st[y].end();
	if(st[y].size() == 0 &amp;&amp; st[x].size() != 0)return 1;
	else if(st[y].size() == 0 &amp;&amp; st[x].size() == 0)return 0;
	else if(st[x].size() == 0)return 0;
	itx--;
	ity--;
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	while((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; (itx != st[x].begin()) &amp;&amp; (ity != st[y].begin())) {
		// printf(&quot;%d %d\n&quot;, *itx, *ity);
		itx--;
		ity--;
	}
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	if((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; st[x].size() &lt;= st[y].size())//leny&gt;lenx
		return 0;
	else if( (*ity) + tag[y] == (*itx) + tag[x] &amp;&amp; st[y].size() &lt; st[x].size())
		return 1;
	else return ((*itx) + tag[x]) &gt; ((*ity) + tag[y]);
}

inline void dfs2(int u, int F) {
	// printf(&quot;%d %d %d!@#\n&quot;, u, F, id[u]);
	int maxid = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		// printf(&quot;%d???\n&quot;, v);
		dfs2(v, u);
		add(getf(v), len[i]);
		// printf(&quot;%d&amp; %d?\n&quot;, getf(v), len[i]);
		if(getf(v) != getf(maxid) &amp;&amp; pd(getf(v), getf(maxid))) {
			maxid = v;
		}
	}
	// printf(&quot;%d %d??\n&quot;, u, maxid);
	if(maxid)id[u] = getf(maxid);
	tag[getf(u)]++;
	// printf(&quot;%d?\n&quot;,)
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		if(maxid != v) {
			merge(getf(u), getf(v));
			// printf(&quot;%d %d!!\n&quot;, u, v);
		}
	}
	// ll ans = 0;
	// for(auto it : st[getf(u)]) {
	// 	// printf(&quot;%lld\n&quot;, it);
	// 	ans = (ans + ksm2(2, (it + tag[getf(u)])) % (P - 1)) % P;
	// }
	// printf(&quot;%lld\n&quot;, ans);
	return ;
}

inline void solve() {
	for(int i = 1; i &lt;= n; ++i)id[i] = i;
	dfs2(1, 0);
	// puts(&quot;QAQ&quot;);
	ll ans = 0;
	for(auto it : st[getf(1)]) {
		// printf(&quot;%lld\n&quot;, it);
		ans = (ans + ksm2(2, (it + tag[getf(1)])) % (P - 1)) % P;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}


signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2, x, y; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		if(y &gt; 30)flg = 0;
		ct(x, i, y);
		ct(i, x, y);
	}
	// if(flg) {
	// 	dfs(1, 0);
	// 	printf(&quot;%lld\n&quot;, dp[1] % P);
	// } else {
	solve();
	// }
	return 0;
}

我都好调死了
</code></pre>
<p>C</p>
<p>考虑left表示前面加一个字符,right表示后面加一个</p>
<p>然后转移的时候就是在前缀树和后缀树上重新定位一下就能决定我们是在哪个方向加入字符了</p>
<p>就是ch和fa上</p>
<p>所以我们可以强制每个节点在左边加字符(向下走)走到最长的串,算出第一部分的答案,然后再考虑向后面加字符,这个就是一个后缀自动机上拓扑序DP一下</p>
<p>然后如果我们边有长度其实决定了我们可以等等再走,所以转移又会不太一样</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define R register
const int MAXN = 1e6 + 7;
const int MAXM = 5e5 + 7;
using std::max;
char s[MAXM];
int  c[MAXN], a[MAXN];
long long dp[MAXN];
int ch[MAXN][26], fa[MAXN], siz[MAXN], len[MAXN], T, lst;
inline void init() {
	T = lst = 1;
}
inline void ins(char c) {
	R int p = lst, np = lst = ++T;
	len[np] = len[p] + 1;
	siz[np] = 1;
	for(; !ch[p][c] &amp;&amp; p; p = fa[p])ch[p][c] = np;
	if(!p) {
		fa[np] = 1;
	} else {
		R int q = ch[p][c];
		if(len[q] == len[p] + 1) {
			fa[np] = q;
		} else {
			R int nq = ++T;
			len[nq] = len[p] + 1;
			memcpy(ch[nq], ch[q], sizeof(ch[nq]));
			fa[nq] = fa[q];
			fa[q] = fa[np] = nq;
			for(; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
		}
	}

}


int main() {
	scanf(&quot;%s&quot;, s + 1);
	int n = strlen(s + 1);
	init();
	R int i;
	for(i = 1; i &lt;= n; ++i) {
		ins(s[i] - 'a');
	}
	for(i = 1; i &lt;= T; ++i) {
		c[len[i]]++;
	}
	for(i = 1; i &lt;= n; ++i) {
		c[i] += c[i - 1];
	}
	for(i = T; i &gt;= 1; --i) {
		a[c[len[i]]--] = i;
	}
	for(i = T; i &gt;= 2; --i) {
		siz[fa[a[i]]] += siz[a[i]];
	}
	dp[1] = 0;
	R int u, F, v;
	for(i = 1; i &lt;= T; ++i) {
		u = a[i];
		F = fa[u];
		dp[u] = max(dp[u], dp[F] + (long long)siz[u] * (len[u] - len[F]));
		for(F = 0; F &lt; 26; ++F) {
			if((v = ch[u][F]) != 0) {
				dp[v] = max(dp[v], dp[u] + (long long)siz[v] * (len[v] - len[u]));
			}
		}
	}
	printf(&quot;%lld\n&quot;, dp[lst]);
	return 0;
}

</code></pre>
<p>B</p>
<p>是个多项式算法都给您放过去</p>
<p>考场上我神仙的遇上了土豆电池T掉了</p>
<p>一个序列有多种划分方式,但是我们只需满足一种,所以就可以考虑容斥了!</p>
<p>然后对于前中后三段其实是可以考虑各种情况然后状压DP的....</p>
<p>然后考虑dp,dp_{i,j}表示前i个数经过了j个互不相等的数</p>
<p>1/231/321/32</p>
<p>则要经过dp(1,1)-&gt;dp(4,3)-&gt;dp(3,3)-&gt;dp(9,2)</p>
<p>这样子就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mo>&gt;</mo><mo>=</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp(a,a)-&gt;dp(b,k)-&gt;dp(n,&gt;=b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>如果n比较大,中间会有很长一段令人相同的限制,这些都一样就可以快速幂把它优化掉</p>
<p>就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>k</mi><msup><mo>)</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>f</mi><mi>i</mi><mo>−</mo><mi>e</mi><mi>d</mi></mrow><mi>k</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">P(k,k)^{\frac {n-fi-ed} {k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.28389em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.03389em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9584142857142857em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4623857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>枚举fi,ed暴力用之前的dp计算fi和ed的方案数,中间再乘上这个即可qwq,然后记得要容斥就要乘上方案数</p>
<p>因为我们有一个fi就能算出ed了,所以只有本质不同的k个fi作为限制,然后用于容斥qwq</p>
<p>然后我们就可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>∗</mo><mo>(</mo><msup><mi>k</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">2^k*(k^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然后又会发现我们有个第一段a,他要最大,就能转移到的最小的c最优</p>
<p>而且maxa能转移到minb,maxb能转移到minc,b是k<sub>2k或n-k</sub>n</p>
<p>这样每个状态都是O(k)种</p>
<p>然后我们发现他们可以通过一些长度小于k的方案数</p>
<p>从1-&gt;3,3-&gt;k-2再从k-2-&gt;1一直循环就是可以加速的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>k</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>实际状态数很少,压一压状态还可以更少??</p>
<p>对于n&lt;=k的情况我们只需要枚举最大值和最小值然后前i个要求互补相同,后n-i个要求互不相同,i&lt;n时有这样的而i&gt;n的时候我们有(n,k)n!?</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596268289265.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596268283405.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596268271417.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/">
        </link>
        <updated>2020-07-31T13:26:02.000Z</updated>
        <content type="html"><![CDATA[<p><s>自己抄自己</s></p>
<p>C</p>
<p>50pts直接for就for过去了吧</p>
<p>100pts考虑选取一个素数p，然后mod p意义下只会有n^2/p个</p>
<p>然后先for第一个点，再for第二个点的第一维，然后就能算出y坐标是多少了，再去查表，看那个点是哪个点</p>
<p>你可以发现我们能够exgcd去解决，对于一个点，首先解出一个最小解，然后我们从这个解上去+a'找看有没有对应的，花费总解数solve，如果解很多的放入一个vector中就暴力一下</p>
<p>你会发现由于只有1e9所以很快的，大部分解都很少</p>
<p>B</p>
<p>很套路？分段权值为逆序对数+W</p>
<p>猜一下有决策单调性</p>
<p>结果我们没法在O(1)时间算出逆序对，其实可以莫队？的思路</p>
<p>决策单调性：单调栈/队列上二分</p>
<p>CDQ分治+决策单调性二分</p>
<p>决策单调性二分里面的操作可以参考CF868F Yet Another Minimization Problem</p>
<p>就能做到O(nlog^3n)</p>
<p>如果可以离线可以O(\sqrt n)修改O(1)分块</p>
<p>值域分块就是首先我们处理出每个块内部的前缀和，那么查询时块块之间前缀和+块内前缀和</p>
<p>然后强制在线可以可持久化分块，空间复杂度是带根号的，绝对完蛋啊</p>
<p>A</p>
<p>带  花  树</p>
<p>路径简单，而且颜色交替，而且端点不同，两两不交，端点标记，权值和最大</p>
<p>要么带权匹配，要么带权拟阵交</p>
<p>相当于拆下点然后路径要从黑到白从白到黑，而且两个点之间有一个被选用</p>
<p>并且我们对于两个拆出的点之间连一条边权为0的边</p>
<p>然后对于两个颜色不同的拆点，是一个端点，我们可以再拆出一个新建点来把<br>
点权变成边权</p>
<p>然后对于那个新点连向的那两个拆点的边的边权就是那个点的点权</p>
<p>新建的点两两连边连成完全图，防止我们没有用上而没有完备匹配</p>
<p>然后如果有奇数个标记点我们就再额外开一个新建点，使得这个图有完美匹配</p>
<p>为什么要完备匹配？因为最大权只有完备匹配</p>
]]></content>
    </entry>
</feed>