<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-06-15T15:07:00.285Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[网络流相关复习]]></title>
        <id>https://xiaxiaoguang.github.io/post/wang-luo-liu-xiang-guan-fu-xi/</id>
        <link href="https://xiaxiaoguang.github.io/post/wang-luo-liu-xiang-guan-fu-xi/">
        </link>
        <updated>2020-06-15T14:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>From 2020省选复习</p>
<p>这个....是一个很大很大的东西,在没有完成一轮复习前我们还是不要考虑花式建图的复习了...</p>
<p>先把算法肝透吧</p>
<p>核心:最大流dinic</p>
<p>其实,这个没有什么好讲的(因为讲就太长了),注意我们反向边以及ccnt=1?</p>
<p>还有bfs的时候要flow[i]&gt;0.....</p>
<p>还有当前弧优化,以及memcpy是前面为接受复制后面是复制体....</p>
<pre><code class="language-cpp">queue&lt;int&gt; que;
inline int bfs()
{
	while(!que.empty())que.pop();
	memset(h,0,sizeof(h));
	que.push(s);
	h[s]=1;
	while(!que.empty()) {
		int u=que.front();
		que.pop();
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			if(!h[v]&amp;&amp;flow[i]&gt;0) {
				h[v]=h[u]+1;
				que.push(v);
			}

		}
		if(h[t])return 1;
	}
	return h[t];
}

inline int dfs(int u,int nflow)
{
	if(nflow==0||u==t)return nflow;
	int ret=nflow,a=0;
	for(int &amp;i=cur[u]; i; i=nxt[i]) {
		int v=to[i];
		if(h[v]==h[u]+1&amp;&amp;(a=dfs(v,std::min(nflow,flow[i])))) {
			flow[i]-=a;
			flow[i^1]+=a;
			ret-=a;
			if(!ret)break;
		}
	}
	if(ret==nflow)h[u]=-1;
	return (nflow-ret);
}

</code></pre>
<p>算法2:最小费用最大流</p>
<p>如果没有负权??边,我们可以直接拍dijkstra费用流</p>
<p>而如果有的话我们要先跑spfa求出最短路加势再去dijkstra,每个边边权变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>−</mo><mi>h</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>+</mo><mi>w</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">h[u]-h[v]+w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>并且每跑完一次update一次势能函数...</p>
<p>然后这都很菜菜菜菜,zkw费用流吊打他们</p>
<p>具体就是先spfa把每个点的dis(最短路)值求出来,然后跑一个和dinic的dfs很像的东西,但是加上了<code>如果下个点最短路是这个点延伸而来才扩展</code>的限制,并且每个点只允许访问一次(vis数组)</p>
<p>也不难看出其实就是spfa费用流一次扩展多条路径.....</p>
<p><s>但是吊锤dijkstra</s></p>
<pre><code class="language-cpp">
inline int spfa() {
	while(!que.empty())que.pop();
	for(int i=1; i&lt;=t; ++i)
		dis[i]=-1e18;
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	vis[s]=1;
	que.push(s);
	//spfa势能预处理
    //这个是zkw没有势能....
	while(!que.empty()) {
		int u=que.front();
		que.pop();
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			if(dis[v] &lt; dis[u] + w[i] &amp;&amp; flow[i] &gt; 0) {
				dis[v]=dis[u]+w[i];
				if(!vis[v]) {
					vis[v]=1;
					que.push(v);
				}
			}
		}
		vis[u]=0;
	}
	return dis[t]&gt;=-1e17;
}
int mrk[MAXN];
inline int dfs(int u,int nflow) {
	if(u==t) {
		maxcost+=dis[u]*nflow;
		return nflow;
	}
	mrk[u]=1;
	int ret=0;
	for(int &amp;i=cur[u]; i; i=nxt[i]) {
		int v=to[i];
		if(!mrk[v]&amp;&amp;abs(dis[v]-dis[u]-w[i])&lt;=eps&amp;&amp;flow[i]) {
			int a=dfs(v,min(nflow-ret,flow[i]));
			if(a) {
				flow[i]-=a;
				flow[i^1]+=a;
				ret+=a;
				if(ret==nflow)break;
			}
		}
	}
	return (ret);
}

inline void zkwcost() {
	maxcost=0;
	while(spfa()) {
		memcpy(cur,home,sizeof(home));
		memset(mrk,0,sizeof(mrk));
		dfs(s,1e9);
	}
}
</code></pre>
<p>最后一定要注意建边不能宏定义!!!!!!</p>
<p>一定要写两个函数.....TAT</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[tarjan图论算法复习]]></title>
        <id>https://xiaxiaoguang.github.io/post/tarjan-tu-lun-suan-fa-fu-xi/</id>
        <link href="https://xiaxiaoguang.github.io/post/tarjan-tu-lun-suan-fa-fu-xi/">
        </link>
        <updated>2020-06-14T14:38:48.000Z</updated>
        <content type="html"><![CDATA[<p>From 2020省选复习</p>
<p>首先我们小手一挥分出类</p>
<ol>
<li>强联通分量</li>
<li>割点</li>
<li>割边</li>
<li>点双连通分量</li>
<li>边双连通分量</li>
</ol>
<p>目前完成了123,如果考45我也大概率不会....</p>
<p>算法一</p>
<p>我们用low数组表示最多经过一条返祖边到达的最小编号是什么,dfn表示这个点的编号是什么</p>
<p>然后dfs经过的入栈,当low==dfn的时候,说明一些点能构成一个强联通分量了,因为我们已经不能再回去了</p>
<p>否则就还可以再缩扩大连通块大小</p>
<p>算法二</p>
<p>首先我们要知道的是我们访问的点能作为割点,说明存在一个儿子,low值大于等于这个点dfn值</p>
<p>但是这个东西在根的时候是伪的,因为根的值一定是最小的....所以根要单独看,是当存在多于一个儿子时就是割点啦</p>
<p>算法三</p>
<p>把算法二的low&gt;=dfn改改,改为low&gt;dfn</p>
<p>相当于去掉这个边,子树就再不能走回u了</p>
<p>code1:</p>
<pre><code class="language-cpp">int dfn[MAXN],low[MAXN],fl[MAXN],st[MAXN],tp,bel[MAXN],T,dep;
inline void tarjan(int u) {
	low[u]=dfn[u]=++dep;
	fl[u]=1;
	st[++tp]=u;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u]=std::min(low[u],low[v]);
		} else if(!fl[v])continue;
		low[u]=std::min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]) {
		++T;
		while(1) {
			int v=st[tp];
			bel[v]=T;
            fl[v]=0;
			tp--;
			if(v==u)break;
		}

	}
	return ;
}

</code></pre>
<p>至于fl去掉横跨边有没有用....不知道</p>
<p>code2:</p>
<pre><code class="language-cpp">inline void tarjan(int u)
{
	dfn[u]=low[u]=++dep;
	int tmp=0;
	for(int i=home[u]; i ; i=nxt[i]) {
		int v=to[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[v],low[u]);
			if(u==rt) {
				++tmp;
			}
			if(low[v]&gt;=dfn[u] &amp;&amp; u!=rt) {
				ap[++tot]=u;
			}
		}
		low[u]=min(low[u],dfn[v]);
	}
	if(u==rt&amp;&amp;tmp&gt;1) {
		ap[++tot]=u;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kruskal重构树复习]]></title>
        <id>https://xiaxiaoguang.github.io/post/kruskal-chong-gou-shu-fu-xi/</id>
        <link href="https://xiaxiaoguang.github.io/post/kruskal-chong-gou-shu-fu-xi/">
        </link>
        <updated>2020-06-11T15:02:22.000Z</updated>
        <content type="html"><![CDATA[<p>From 2020省选前复习</p>
<p>首先这个算法的核心是kruskal算法,就是在其上加入了一些新元素使之更优秀了</p>
<p>我们还是边权排序去做最小生成树,但是这次我们在连树边的时候,先建立一个新点</p>
<p>新点的权值是边权值,然后新点成为原来的边的起点终点的父亲,一直做下去就好了qwq</p>
<p>这个树有什么性质呢?</p>
<ol>
<li>二叉树</li>
<li>x,y的LCA代表的点权一定是他们路径上的极值</li>
<li>如果</li>
</ol>
<p>然后上例题</p>
<p>T1货车运输</p>
<p>两点间路径最大的最小值</p>
<p>直接重构树,然后是从大到小排序即可</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using std::swap;
using std::sort;
const int MAXN = 2e5 + 7;
int n, m;
struct rec {
	int x, y, w;
	bool operator&lt;(const rec &amp;x)const {
		return w &gt; x.w;
	}
} e[MAXN];
int f[MAXN], a[MAXN], fa[MAXN];
int ccnt;
int home[MAXN], nxt[MAXN], to[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline int getf(int x) {
	return f[x] == x ? x : f[x] = getf(f[x]);
}

inline void builtT() {
	sort(e + 1, e + m + 1);
	for(int i = 1; i &lt;= m; ++i) {
		int u = e[i].x;
		int v = e[i].y;
		if(getf(u) == getf(v))continue;
		u = getf(u);
		v = getf(v);
		++n;
		f[n] = n;
		ct(n, u);
		ct(n, v);
		a[n] = e[i].w;
		f[u] = n;
		f[v] = n;
	}
	return;
}

int siz[MAXN], dep[MAXN], son[MAXN];
inline void dfs1(int u, int F) {
	fa[u] = F;
	siz[u] = 1;
	int maxson = -1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dep[v] = dep[u] + 1;
		dfs1(v, u);
		siz[u] += siz[v];
		if(siz[v] &gt; maxson) {
			maxson = siz[v];
			son[u] = v;
		}
	}
	return ;
}

int top[MAXN];
inline void dfs2(int u, int topf) {
	top[u] = topf;
	if(!son[u])return;
	dfs2(son[u], topf);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == son[u] || v == fa[u])continue;
		dfs2(v, v);
	}
	return ;
}

inline int LCA(int x, int y) {
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])swap(x, y);
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])swap(x, y);
	return x;
}

inline void init() {
	dfs1(n, 0);
	dfs2(n, n); //n is root
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;e[i].x, &amp;e[i].y, &amp;e[i].w);
	}
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	builtT();
	init();
	int q;
	scanf(&quot;%d&quot;, &amp;q);
	for(int i = 1, x, y; i &lt;= q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		if(getf(x) != getf(y)) {
			puts(&quot;-1&quot;);
			continue;
		}
		int anc = LCA(x, y);
		printf(&quot;%d\n&quot;, a[anc]);
	}
	return 0;
}

</code></pre>
<p>T2NOI2018归程</p>
<p>考虑从点1跑一个最短路,得到每个点到n的最短路信息</p>
<p>问题变成只走海拔大于x的边能走到的点中到1的最短路最小是什么</p>
<p>考虑按照海拔重构树,然后海拔是从大到小排序的,那么对于一个点,他一定有某个祖先的父亲是权值小于等于x的,倍增找到这个满足的点</p>
<p>然后这个点的子树中最短路最小的就是答案qwq</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#define mkp(x,y) (make_pair(x,y))
#define se second
const int MAXN=1e6+7;
const int inf=2e9+7;
using namespace std;
int n,m,q,k,s;
struct rec {
	int u,v,l,h;
	bool operator&lt;(const rec &amp;x)const {
		return h&gt;x.h;
	}
} e[MAXN];
struct edge {
	int to,nxt,h;
} E[MAXN];

int f[MAXN];
inline int getf(int u) {
	return f[u]==u?u:f[u]=getf(f[u]);
}

int home[MAXN],nxt[MAXN],to[MAXN],ccnt,len[MAXN],first[MAXN],cnt;
inline void ct(int x,int y,int w) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
	len[ccnt]=w;
}
inline void ct2(int x,int y) {
	cnt++;
	E[cnt].nxt=first[x];
	first[x]=cnt;
	E[cnt].to=y;
}

priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int,int&gt; &gt; &gt; que;
int dis[MAXN],vis[MAXN];

inline void dijkstra() {
	int s=1;
	while(!que.empty())que.pop();
	memset(dis,0x3f3f3f3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[s]=0;
	que.push(mkp(0,s));
	while(!que.empty()) {
		int u=que.top().se;
		que.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			if(dis[u]+len[i]&lt;dis[v]) {
				dis[v]=dis[u]+len[i];
				que.push(mkp(dis[v],v));
			}
		}
	}
	return ;
}

int fa[MAXN][20];
int ans[MAXN],a[MAXN];
inline void dfs(int u,int F) {
	ans[u]=dis[u];
//	a[u]=h;
	fa[u][0]=F;
	for(int i=first[u]; i; i=E[i].nxt) {
		int v=E[i].to;
		if(v==F)continue;
		dfs(v,u);//qwq
		ans[u]=min(ans[u],ans[v]);
	}
//	printf(&quot;%d %d %d\n&quot;,u,ans[u],a[u]);

	return ;
}

inline void solve() {
	dijkstra();
//	for(int i=1; i&lt;=n; ++i)printf(&quot;%d &quot;,dis[i]);
//	puts(&quot;&quot;);
	sort(e+1,e+m+1);
	for(int i=1; i&lt;=n; ++i)f[i]=i,a[i]=inf;
	for(int i=1; i&lt;=m; ++i) {
		int u=e[i].u;
		int v=e[i].v;
		int h=e[i].h;
		int l=e[i].l;//qwq
//		printf(&quot;%d %d\n&quot;,u,v);

		if(getf(u)==getf(v))continue;

		u=getf(u);
		v=getf(v);
		++n;
		a[n]=h;
		f[n]=n;
		f[u]=n;
		f[v]=n;
		ct2(n,u);
		ct2(n,v);
	}
	dfs(n,0);//init 子树最大值,以及倍增
	for(int i=1; i&lt;=18; ++i) {
		for(int j=1; j&lt;=n; ++j) {
			fa[j][i]=fa[fa[j][i-1]][i-1];//qwq
		}
	}
	return ;
}

inline void init() {
	memset(home,0,sizeof(home));
	ccnt=0;
	cnt=0;
	memset(first,0,sizeof(first));
	memset(a,0,sizeof(a));
	a[0]=inf;
}

int main() {
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--&gt;0) {
		init();
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int tmp=n;
		for(int i=1; i&lt;=m; ++i) {
			scanf(&quot;%d%d%d%d&quot;,&amp;e[i].u,&amp;e[i].v,&amp;e[i].l,&amp;e[i].h);
			ct(e[i].u,e[i].v,e[i].l);
			ct(e[i].v,e[i].u,e[i].l);
		}
		solve();//build Tree and dijkstra
		scanf(&quot;%d%d%d&quot;,&amp;q,&amp;k,&amp;s);
		int lst=0;
		for(int i=1,u,p; i&lt;=q; ++i) {
			scanf(&quot;%d%d&quot;,&amp;u,&amp;p);
			u=(u+k*lst-1)%tmp+1;
			p=(p+k*lst)%(s+1);
//			printf(&quot;%d %d??\n&quot;,u,p);
			for(int i=17; i&gt;=0; --i) {
				if(fa[u][i]==0)continue;
				if(a[fa[u][i]]&gt;p) {
					u=fa[u][i];
				}
			}
//			printf(&quot;%d\n&quot;,u);
			lst=ans[u];
			printf(&quot;%d\n&quot;,lst);
		}
	}
	return 0;
}


</code></pre>
<p>完结撒花</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[省选前复习专栏]]></title>
        <id>https://xiaxiaoguang.github.io/post/sheng-xuan-qian-fu-xi-zhuan-lan/</id>
        <link href="https://xiaxiaoguang.github.io/post/sheng-xuan-qian-fu-xi-zhuan-lan/">
        </link>
        <updated>2020-06-11T14:55:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code>“或许用尽全力就是为了证明自己真的不行”---Elegia  
</code></pre>
<p>鄙人复习路径:</p>
<p>1.图论<br>
2.动态规划<br>
3.字符串<br>
4.数据结构<br>
5.数论<br>
6.待添加</p>
<p>目前进行章节</p>
<p>强连通,缩点 √<br>
树上差分 √<br>
最小生成树 √<br>
Kruscal重构树 x</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5666 树的重心]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5666-shu-de-chong-xin/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5666-shu-de-chong-xin/">
        </link>
        <updated>2020-06-10T14:32:02.000Z</updated>
        <content type="html"><![CDATA[<p>简要题意：</p>
<p>删去每个边之后树分裂成两个小树，然后对两棵树所有重心的编号求和，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span></p>
<p>首先我们考虑怎么快速求出某颗树的重心，可以调整法，就是沿着重儿子跳，保持满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum-siz[u]&lt;=n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，而且u的重儿子大小小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>那么我们发现这个东西可以倍增跳啊，如果此时除去重儿子子树其他点加起来数太小了，那么可以向重儿子跳，只要满足这个条件我们那就倍增向下跳，最后一定能落在重心上！</p>
<p>注意这个是因为我们断开了一条边，所以我们还要观察断开后siz和son的变化。。。</p>
<h3 id="case1-处于断开边的下方">case1 处于断开边的下方</h3>
<p>siz，son都不变，sum变了</p>
<h3 id="case2-处于被断开边的上方">case2 处于被断开边的上方</h3>
<p>我们发现除了被断开边的上面那个点所在的重链要改改外其他的好像不太变？</p>
<p>而那个重链我们可以在换根的时候一并都改了，因为我们不存在一条过原来根到另个子树的重链</p>
<p>别的没什么了，就是注意处理倍增</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
using namespace std;
const int MAXN=1e6+7;
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf,*pend=buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;
int n;
int ccnt,home[MAXN],nxt[MAXN],to[MAXN];
#define ad2(x,y) (ct(x,y),ct(y,x))
inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}
int siz[MAXN],son[MAXN],p[MAXN][20],fa[MAXN],siz2[MAXN],son2[MAXN],son3[MAXN],pr[MAXN];
inline void dfs(int u,int F) {
	siz[u]=1;
	fa[u]=F;
	pr[u]=F;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dfs(v,u);
		siz[u]+=siz[v];
		if(siz[v]&gt;siz[son[u]])son2[u]=son[u],son[u]=v;
		else if(siz[v]&gt;siz[son2[u]])son2[u]=v;
		//son是最大子，son2是次大子
	}

	p[u][0]=son[u];
	for(int i=1; i&lt;=17; ++i)p[u][i]=p[p[u][i-1]][i-1];//跳重儿子的倍增
}

ll ans;
inline int pd(int x,int sum) {
	return x*(max(siz2[son3[x]],sum-siz2[x])&lt;=sum/2);
}

inline void dfs2(int u,int F) {
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;

		siz2[u]=siz[1]-siz[v];//断开这条边并且u是根
		fa[v]=0;
		fa[u]=0;
		//两个都是根啊
		if(son[u]==v)son3[u]=son2[u];//如果是重儿子我们选择次儿子
		else son3[u]=son[u]; //如果是不重儿子，那么这个点重儿子就可以继承
		if(siz2[F]&gt;siz2[son3[u]])son3[u]=F;//换成另一个方向

		p[u][0]=son3[u];
		for(int j=1; j&lt;=17; ++j)
			p[u][j]=p[p[u][j-1]][j-1];
		//向上跳
		int b=u;
		for(int j=17; j&gt;=0; --j)
			if(siz2[u]-siz2[p[b][j]]&lt;=siz2[u]/2)b=p[b][j];
		ans+=pd(son3[b],siz2[u])+pd(b,siz2[u])+pd(fa[b],siz2[u]);
		//siz2[u]是最大,而且可能他或他的重儿子或者他的父亲都能做成重心
		//向下跳qwq
		b=v;
		for(int j=17; j&gt;=0; --j)
			if(siz2[v]-siz2[p[b][j]]&lt;=siz2[v]/2)b=p[b][j];
		ans+=pd(son3[b],siz2[v])+pd(b,siz2[v])+pd(fa[b],siz2[v]);

		fa[u]=v;
		dfs2(v,u);
	}
	son3[u]=p[u][0]=son[u];
	fa[u]=pr[u];
	for(int j=1; j&lt;=17; ++j)
		p[u][j]=p[p[u][j-1]][j-1];
	siz2[u]=siz[u];
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	int T;
	T=read();
	while(T--) {
		memset(home,0,sizeof(home));
		memset(son,0,sizeof(son));
		memset(fa,0,sizeof(fa));
		memset(pr,0,sizeof(pr));
		ccnt=0;
		ans=0;
		n=read();
		for(int i=1,x,y; i&lt;n; ++i) {
			x=read();
			y=read();
			ad2(x,y);
//			ad2(y,x);
		}
		dfs(1,0);
		memcpy(siz2,siz,sizeof(siz2));
		memcpy(son3,son,sizeof(son3));
		memcpy(fa,pr,sizeof(fa));
		dfs2(1,0);
		printf(&quot;%lld\n&quot;,ans);
	}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6602 「EZEC-2」数轴]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6602-ezec-2-shu-zhou/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6602-ezec-2-shu-zhou/">
        </link>
        <updated>2020-06-10T14:28:23.000Z</updated>
        <content type="html"><![CDATA[<p>扶苏大神推荐</p>
<p>简要题意</p>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的序列，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次操作，对序列单点加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 。每次操作后都要求出序列中最长的区间，满足区间和不大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p>
<p>From 一扶苏一 <s>/se/se/se</s></p>
<p>需要注意的是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>6</mn><mo separator="true">,</mo><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e6,m&lt;=1e9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span></span></span></span>但是<strong>k&lt;=100</strong></p>
<p>首先，我们会发现在直接数轴上DP是不行的，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">m&lt;=1e9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span></span></span></span>，直接去考虑是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">m^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>的？</p>
<p>而数轴上坐标点如此离散的情况下，我们如果想要直接知道一个点之前那个点是什么,可以使用<strong>离散化或者链表</strong>的方法</p>
<p>而离散化显得很不能扩展，因为只是变成了差不多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的做法</p>
<p>而链表可以再有动态变化的情况下维护</p>
<p>所以我们只需要去考虑删除一个数之后用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>w</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">twopointers</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span>O(k)维护新答案</p>
<p>但是要把整个过程反过来，这样答案单调上升，ans可以直接取max</p>
<p>写的时候注意我们答案是要pre和nxt之间找的,而且设置的头尾还不能减去.....毒毒毒</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cassert&gt;
using std::lower_bound;
using std::max;
using std::sort;
const int MAXN = 1e6 + 7;
const int inf = 1e9 + 7;
int n, m, k, tot, ans = -1;
int x[MAXN], a[MAXN], A[MAXN];
struct rec {
	int x, a;
	bool operator&lt;(const rec &amp;l)const {
		return x &lt; l.x;
	}
	bool operator&lt;(const int &amp;l)const {
		return x &lt; l;
	}
} pt[MAXN], rt[MAXN];
int pre[MAXN], nxt[MAXN];

inline void solve(int x) {
//	printf(&quot;%d %d\n&quot;,x,nxt[x]);
	int nw = x;
	int y = nw;
	int S = rt[x].a;
	if(S &gt; k) {
		if(pre[x] != 0)
			ans = max(rt[x].x - rt[pre[x]].x - 2, ans);
		else ans = max(ans, rt[x].x - 1);
		if(nxt[x] != tot + 1)
			ans = max(rt[nxt[x]].x - rt[x].x - 2, ans);
		else ans = max(ans, m - rt[x].x - 1);
//		printf(&quot;%d %d\n&quot;,x,nxt[x]);
//		if(x==0 &amp;&amp; nxt[x]==tot+1) ans=max(ans,m);

		return ;
	}
	while(S &lt;= k) {
		x = pre[x];
		if(S + rt[x].a &gt; k) {
//			printf(&quot;%d %d %d %d %d %d %d\n&quot;, nw, x, nxt[nw], tot, rt[nxt[nw]].x, rt[nw].x, rt[x].x);
			if(nxt[nw] != tot + 1)
				ans = max(rt[nxt[nw]].x - rt[x].x - 2, ans);
			else ans = max(rt[nxt[nw]].x - rt[x].x - 1, ans);
//			printf(&quot;%d\n&quot;, ans);
			x = nxt[x];
			break;
		}
		S += rt[x].a;
	}

	while(S  &lt;= k) {
		y = nxt[y];
		if(S + rt[y].a &gt; k ) {
			if(pre[x] != 0)
				ans = max(rt[y].x - 2 - rt[pre[x]].x, ans);
			else ans = max(rt[y].x - 1 - rt[pre[x]].x, ans);
			y = pre[y];
			break;
		}
		S += rt[y].a;
	}
//	printf(&quot;%d %d %d\n&quot;, nw, x, y);
	if(nxt[y]==tot+1 &amp;&amp; pre[x]==0)
		ans=max(rt[nxt[y]].x-rt[pre[x]].x,ans);
	else if(nxt[y]==tot+1||pre[x]==0)
		ans=max(rt[nxt[y]].x-rt[pre[x]].x-1,ans);
	else {
		ans=max(ans,rt[nxt[y]].x-rt[pre[x]].x-2);
	}
//	puts(&quot;qwq&quot;);
//	assert(x&lt;=nw);
	while(x != nw) {
//		printf(&quot;%d %d!!\n&quot;,x,nw);
		S -= rt[x].a;
		x = nxt[x];
		while(S &lt;= k) {
			y = nxt[y];
			if(S + rt[y].a &gt; k) {
				if(y==tot+1 &amp;&amp; pre[x]==0)
					ans=max(rt[y].x-rt[pre[x]].x,ans);
				else if(y==tot+1||pre[x]==0)
					ans=max(rt[y].x-rt[pre[x]].x-1,ans);
				else {
					ans=max(ans,rt[y].x-rt[pre[x]].x-2);
				}
				y = pre[y];
				break;
			}
			S += rt[y].a;
		}
		if(nxt[y]==tot+1 &amp;&amp; pre[x]==0)
			ans=max(rt[nxt[y]].x-rt[pre[x]].x,ans);
		else if(nxt[y]==tot+1||pre[x]==0)
			ans=max(rt[nxt[y]].x-rt[pre[x]].x-1,ans);
		else {
			ans=max(ans,rt[nxt[y]].x-rt[pre[x]].x-2);
		}
	}

	return ;
}

inline void init() {
	rt[0].a = inf;
	rt[0].x = 0;
	nxt[0] = 1;
	pre[0]=0;
	rt[tot + 1].a = inf;
	rt[tot + 1].x = m;
	pre[tot + 1] = tot;
	nxt[tot + 1]=tot + 1;
//	printf(&quot;!!%d\n&quot;,tot);
	for(int i = 1; i &lt;= tot; ++i) {
		pre[i] = i - 1;
		nxt[i] = i + 1;
	}
	for(int i = 1; i &lt;= tot; ++i) {
		solve(i);
	}
	return;
}

inline void del(int x) {
	nxt[pre[x]] = nxt[x];
	pre[nxt[x]] = pre[x];
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);

	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;pt[i].x, &amp;pt[i].a);
		x[i] = pt[i].x;
		a[i] = pt[i].a;
	}
//	puts(&quot;qwq&quot;);
	sort(pt + 1, pt + n + 1);
	for(int i = 1; i &lt;= n; ++i) {
//		printf(&quot;%d %d\n&quot;,pt[i].x,pt[i-1].x);
		if(pt[i].x == pt[i + 1].x &amp;&amp; i != n + 1) {
			pt[i + 1].a += pt[i].a;
		} else {
//			printf(&quot;%d %d\n&quot;,pt[i].x,pt[i].)
			rt[++tot] = pt[i];
		}
	}
//	puts(&quot;!!!&quot;);
	init();
//	puts(&quot;QWQ&quot;);
//	for(int i = 1; i &lt;= tot; ++i) {
//		printf(&quot;%d %d\n&quot;, rt[i].x, rt[i].a);
//	}
	// printf(&quot;%d %d\n&quot;, lower_bound(rt + 1, rt + tot + 1, 1) - rt, lower_bound(rt + 1, rt + tot + 1, 0) - rt);
	for(int i = n; i &gt;= 1; --i) {
		A[i] = ans;
		int id = lower_bound(rt + 1, rt + tot + 1, x[i]) - rt;
//		printf(&quot;%d %d %d??\n&quot;, i, id, ans);
//		for(int i=0; i!=tot+1; i=nxt[i]) {
//			printf(&quot;%d! &quot;,i);
//		}
//		puts(&quot;&quot;);
		rt[id].a -= a[i];
//		printf(&quot;%d\n&quot;,id);
		if(rt[id].a == 0) {
			del(id);
//			printf(&quot;%d %dqwq\n&quot;,pre[id],nxt[id]);
			solve(pre[id]);
			solve(nxt[id]);
		} else {
			solve(id);
		}
	}
	for(int i = 1; i &lt;= n; ++i)
		printf(&quot;%d\n&quot;, A[i]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6592 [YsOI2020]幼儿园]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6592-ysoi2020you-er-yuan/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6592-ysoi2020you-er-yuan/">
        </link>
        <updated>2020-06-07T15:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>佳衡&amp;华清推荐</p>
<p>orzhq</p>
<p>首先拿到题看到强制在线有点虚...</p>
<p>不过仔细读题发现可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mq)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>,30pts好成绩</p>
<p>然后就是怎么离线....不太会啊</p>
<p>直接想正解...(ljh教育)</p>
<p>首先反向边,问题变成从1到每个点的<strong>单调递增</strong></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示点i只走大于j的边走到i的最小最大边权是什么</p>
<p>然后求这个数组...我们盲猜有大部分值是相同的,所以可以用某些鬼畜手段使他不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的</p>
<p>然后你敏锐的发现,对于任何一条边,如果我们是从小到大去插入的,那么我们插入边i一定只会影响v</p>
<p>因为首先我们更新了v的答案,也就是f[v],而我们从v出走又要走比i更大的,所以一定不会再更新下去</p>
<p>那么我们就可以用一个动态开点线段树来搞这个东西,在左端点权值处记下右端点权值,然后相当于查询l,m中最小值是否小于r</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using std::min;
using std::max;
const int MAXN = 3e5 + 7;

int f[MAXN];

namespace seg {
#define mid ((l+r)&gt;&gt;1)
	int root[MAXN], T, ls[MAXN * 30], rs[MAXN * 30], tr[MAXN * 30];
	inline void modify(int &amp;k, int l, int r, int pos, int vl) {
		if(!k) {
			k = ++T;
			tr[k] = MAXN;
		}

		if(l == r) {
			tr[k] = min(tr[k], vl);
			return ;
		}

		if(pos &lt;= mid)modify(ls[k], l, mid, pos, vl);
		else modify(rs[k], mid + 1, r, pos, vl);

		tr[k] = min(tr[ls[k]], tr[rs[k]]);
	}
	inline int query(int k, int l, int r, int L, int R) {
		if(!k)return MAXN;
		if(L &lt;= l &amp;&amp; R &gt;= r)return tr[k];

		if(L &gt; mid)return query(rs[k], mid + 1, r, L, R);
		else if(R &lt;= mid)return query(ls[k], l, mid, L, R);
		else return min(query(ls[k], l, mid, L, R), query(rs[k], mid + 1, r, L, R));

	}
}
int n, m, k, w;
int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;w);
	memset(f, -1, sizeof(f));
	f[1] = 0;
	seg::tr[0] = MAXN;
	for(int i = 1, u, v; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;v, &amp;u);
		if(~f[u]) {//这个u可别离线啊
			// printf(&quot;%d %d %d %d %d\n&quot;, u, v, f[u], f[v], i);
			f[v] = max(f[v], u == 1 ? i : f[u]);
			//二者值最大
			seg::modify(seg::root[v], 1, m, f[v], i);
			//最大的r
		}
	}
	int pre = 0;
	for(int qwq = 1, x, l, r; qwq &lt;= k; ++qwq) {
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;l, &amp;r);
		if(w)x ^= pre, l ^= pre, r ^= pre;
		if(x == 1) {
			puts(&quot;1&quot;);
			++pre;
			continue;
		}
		int ans = seg::query(seg::root[x], 1, m, l, m);
		// printf(&quot;%d!\n&quot;, ans);
		if(ans &lt;= r) {
			puts(&quot;1&quot;);
			++pre;
			continue;
		} else {
			puts(&quot;0&quot;);
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[省选模拟赛6]]></title>
        <id>https://xiaxiaoguang.github.io/post/sheng-xuan-mo-ni-sai-6/</id>
        <link href="https://xiaxiaoguang.github.io/post/sheng-xuan-mo-ni-sai-6/">
        </link>
        <updated>2020-06-06T11:37:01.000Z</updated>
        <content type="html"><![CDATA[<p>http://noi.ac/contest/341</p>
<p>qaq作业好多</p>
<p>qwq你p站也太强了吧绘画巅峰?</p>
<figure data-type="image" tabindex="1"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/4pNOqgOvBLvj4yTC9qc55QUCcGFV0.dI0fDlkezxF9FZOJ3ZW2v2AeDp1O9FaeGC0oGqhJoqwmoAYc5NjpkueE3p.IJt2Utw*7yUNqTm4F0!/r" alt="" loading="lazy"></figure>
<p>T1</p>
<p>每个点带代价的半径为K的园覆盖</p>
<p>首先我们联想到消防局的设立那道题,然后就有了20分贪心qwq</p>
<p>之后我们再去想优化这个贪心?不太行了,所以我们可以使用那道题另一个解法,动态规划</p>
<p>状态是显然的dp[i][j]表示点i向下j层已经被覆盖了的最小代价,然后你会发现这样没法转移,所以还要改一下</p>
<p>dp[i][j]表示点i向上j-K层已经被覆盖的最小代价,如果是负的就是向下</p>
<p>然后转移可以分成三类qwq</p>
<h2 id="case-0硬点">case 0:硬点</h2>
<p>首先我们要保证一个基本事实,就是越优的越大,也就是说我向上能覆盖i就一定能向上覆盖i-1</p>
<p>所以在最后我们要集体向他前一个取min</p>
<p><s>这个状态的设计也是为了这个转移方便</s></p>
<h2 id="case1-dpik1~2k">case1: dp[i][K+1~2K]</h2>
<p>钦定第二维是x</p>
<p>你会发现这样我们一定是在儿子的地方能覆盖到向下x-1的,这样我才能覆盖x</p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow></msub><mi>d</mi><mi>p</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>[</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[u][x]=\sum_{v \in son[u]}dp[v][x-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<h2 id="case2dpi0">case2:dp[i][0]</h2>
<p>憨憨皮,这不是在点i放一个吗</p>
<p>那他的转移不就是下面点的dp[v][2K]之和吗</p>
<h2 id="case3dpi1~k">case3:dp[i][1~K]</h2>
<p>烦死了,这个最麻烦....</p>
<p>首先你要认识到我们是在儿子处放上了某个东东然后那个儿子手伸的老长把我上面的位置也覆盖了</p>
<p>所以至少要加上某个儿子的dp[v][x-1]</p>
<p>你以为这就完了?你其他子树弃疗了?</p>
<p>所以我们考虑子树v是被硬点伸手的那个,那么他向上伸手长度是x-1,把向上伸改成向旁边伸,这样他只能伸出x-2</p>
<p>那么其他儿子的要求就是向下x-2层</p>
<p>相当于其他儿子的dp[p][K+x-2]求个和</p>
<p>当然,你需要有个基础认知就是x=K-x所以是dp[p][K+K-x-2]求个和</p>
<p>这个题就做完了qwq</p>
<p>T2</p>
<p>20pts:我们考虑线性均摊,就是可以做到查询O(n)插入O(1)的那种,这样插入1e7个也随便跑</p>
<p>70pts:树套树,线段树套平衡树,菜鸡题目没有区间第k大所以直接用set就好,而且手写您也过不了更多</p>
<p>100pts:谢谢来自uoj群jiangly</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1591449977678.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1591449982909.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1591449988219.png" alt="" loading="lazy"></figure>
<p>上面是更优做法,下面是官方标称</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<h3 id="t2-逊">T2 逊!</h3>
<p>倒着考虑：先插好所有元素，每次要不询问、要不删除一个元素。这种处理方式可以让我们事先在下标线段树里有序地预处理好每个节点范围内的数字（从底层一路归并上来，预处理复杂度只有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>）。</p>
<p>如何处理删除？因为我们使用线性存储，一个很自然的想法是并查集：设正反两个并查集，一开始都是指向自己的；每当一个元素被删掉后分别将它们指向前、后两个元素。 目前查询的效率是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mi>n</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mi>α</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log ^2 n + \log n \alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的，因为我们要根据区间在线段树上找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 个节 点，每个节点二分出最接近的位置，再用并查集查询前后有效的元素。</p>
<p>有一个黑科技可以优化复杂度。对于线段树每个节点额外做一步预处理：对当前有序数组的每一个位置，维护它往左子树和右子树走下去对应的有序数组的下标（可以在归并的时候一并得到这些信息）。 这样每次询问时我们不必对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 个节点一并二分，只需二分根节点的有序数组，其余的二分结果可以在遍历线段树时根据这些指针得到。</p>
<p>效率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mi>α</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m \log n \alpha (n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>然后对于第三部分的解释:</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1591452563552.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1591452574661.png" alt="" loading="lazy"></figure>
<p>T3</p>
<p>40pts:您开开心心的设计出dp[i]表示前i张牌都打出去的最优收益,然后转移的区间众数可以预处理,然后O(n^2)的dp,并且看了一眼1.5次方使用了pow,然后您T了,连羽毛都腐烂在土地里面</p>
<p>52pts:预处理1.5次方</p>
<p>再往上?问zhq,orzhq</p>
<p><s>难看的</s>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using std::min;
#define ll long long
const int MAXN=5e5+7;
const int INF=1e9+7;
int ccnt,K,n;
int home[MAXN],nxt[MAXN],to[MAXN],fa[MAXN];
#define ad2(x,y) (ct(x,y),ct(y,x))
inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

ll dp[MAXN][207],c[MAXN],siz[MAXN];
//从K+1到K+K是向下覆盖
//从K-1到0是向上覆盖
//K是刚好覆盖
inline void dfs(int u,int F) {
	dp[u][0]=c[u];//向上k层
	siz[u]=1;
	for(int i=K+1; i&lt;=K+K; ++i)dp[u][i]=0;

	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dfs(v,u);

		siz[u]+=siz[v];
		dp[u][0]+=dp[v][K+K];

		for(int j=K+1; j&lt;=K+K; ++j) {
			dp[u][j]+=dp[v][j-1];
		}
	}
	if(siz[u]==1) { //叶子结点
		for(int i=1; i&lt;=K; ++i) {
			dp[u][i]=c[u];//如果要想向上只能自己
		}
	} else {
		for(int i=1; i&lt;=K; ++i) {
			dp[u][i]=INF;
		}
		ll rc[107];
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			if(v==F)continue;
			for(int i=0; i&lt;K; ++i)rc[i]=dp[v][i];
			for(int j=home[u]; j; j=nxt[j]) {
				if(i==j)continue;
				int p=to[j];
				if(p==F)continue;
//				printf(&quot;!%d\n&quot;,p);
				for(int i=0; i&lt;K; ++i)rc[i]+=dp[p][K+K-i-1];
			}
			for(int j=1; j&lt;=K; ++j) {
				dp[u][j]=min(rc[j-1],dp[u][j]);
			}
		}
	}
	for(int i=1; i&lt;=K+K; ++i) {
		dp[u][i]=min(dp[u][i],dp[u][i-1]);
	}
	return ;
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;T1_2.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;K);

	for(int i=1; i&lt;=n; ++i)scanf(&quot;%lld&quot;,&amp;c[i]);

	for(int i=1,x,y; i&lt;n; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ad2(x,y);
	}
	dfs(1,0);
//	for(int i=1; i&lt;=n; ++i) {
//		printf(&quot;%d &quot;,i);
//		for(int k=0; k&lt;=K+K; ++k) {
//			printf(&quot;%d &quot;,dp[i][k]);
//		}
//		puts(&quot;qwq&quot;);
//	}
	printf(&quot;%lld\n&quot;,dp[1][K]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3810 【模板】三维偏序（陌上花开）重糊]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3810-mo-ban-san-wei-pian-xu-mo-shang-hua-kai-chong-hu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3810-mo-ban-san-wei-pian-xu-mo-shang-hua-kai-chong-hu/">
        </link>
        <updated>2020-06-05T15:10:45.000Z</updated>
        <content type="html"><![CDATA[<p>重糊带师</p>
<p>我们之前的做法是cdq套cdq,但是这个做法复杂度虽然正确常数爆炸爆炸qwq</p>
<p>所以我们这里用树状数组写了一遍</p>
<p>首先我们要保证用a第一维排序,然后b和c是第二第三关键字去排序</p>
<p>然后cdq归并排序去保证b哪一位左边小于右边</p>
<p>再用树状数组保证左边小于右边</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define mid ((l+r)&gt;&gt;1)
using std::sort;
const int MAXN=2e5+7;
int n,qwq,tag[MAXN];
struct NODE {
	int a,b,c,ans,cnt;
	bool operator&lt;(const NODE &amp;x)const {
//		return a&lt;x.a;
		if(a==x.a) {
			if(b==x.b)return c&lt;x.c;
			else return b&lt;x.b;
		} else return a&lt;x.a;
	}
} node[MAXN],b[MAXN],que[MAXN],a[MAXN];

namespace seg {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN];
	inline void add(int x,int val) {
		for(; x&lt;MAXN; x+=lowbit(x)) {
			tr[x]+=val;
		}
	}
	inline int qry(int x) {
		int ret=0;
		for(; x; x-=lowbit(x)) {
			ret+=tr[x];
		}
		return ret;
	}
}
using namespace seg;

inline void solve(int l,int r) {
	if(l==r)return ;
	solve(l,mid);
	solve(mid+1,r);
//	sort(node+l,node+mid+1,cmp);
//	sort(node+mid+1,node+r,cmp);
//	printf(&quot;%d %d %d\n&quot;,l,mid,r);
	int cnt=0;
	for(int i=l,j=l,k=mid+1; i&lt;=r; ++i) {
		if((k&gt;r||node[j].b&lt;=node[k].b)&amp;&amp;(j&lt;=mid)) {
//			printf(&quot;?%d %d %d %d\n&quot;,node[j].id,node[j].a,node[j].b,node[j].c);
			add(node[j].c,node[j].cnt);
			que[++cnt]=node[j];
			b[i]=node[j];
			++j;

		} else {
//			printf(&quot;!%d %d %d %d-&gt;&quot;,node[k].id,node[k].a,node[k].b,node[k].c);
			int tmp=qry(node[k].c);
			node[k].ans+=tmp;
//			printf(&quot;%d\n&quot;,tmp);
			b[i]=node[k];
			++k;
		}
	}
//	puts(&quot;QWQ&quot;);
	for(int i=1; i&lt;=cnt; ++i) {
//		printf(&quot;%dQWQ %d &quot;,que[i].c,que[i].cnt);
		add(que[i].c,-que[i].cnt);
	}
//	printf(&quot;\n\n&quot;);
	for(int i=l; i&lt;=r; ++i) {
//		if(i&lt;=tmp) {
//		printf(&quot;)%d %d %d %d\n&quot;,node[i].id,node[i].a,node[i].b,node[i].c);
//			add(node[i].c,-1);
//		}
		node[i]=b[i];
	}
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;qwq);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%d%d%d&quot;,&amp;a[i].a,&amp;a[i].b,&amp;a[i].c);
//		a[i].id=i;
	}
	sort(a+1,a+n+1);
	int top=0;
	int rc=0;
	for(int i=1; i&lt;=n; ++i) {
		top++;
		if(a[i+1].a!=a[i].a||a[i+1].b!=a[i].b||a[i+1].c!=a[i].c) {
			node[++rc]=a[i];
			node[rc].cnt=top;
			top=0;
		}
	}
	solve(1,rc);
	for(int i=1; i&lt;=rc; ++i) {
		tag[node[i].ans+node[i].cnt-1]+=node[i].cnt;
//		printf(&quot;%d\n&quot;,ans[i]);
	}
	for(int i=0; i&lt;n; ++i) {
		printf(&quot;%d\n&quot;,tag[i]);
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5495 Dirichlet 前缀和]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5495-dirichlet-qian-zhui-he/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5495-dirichlet-qian-zhui-he/">
        </link>
        <updated>2020-06-05T15:08:27.000Z</updated>
        <content type="html"><![CDATA[<p>转载自洛谷博客</p>
<p>orzhq真的强大啊</p>
<p>模板题，没啥好说的</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>i</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></munder><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_k=\sum_{i|k}a_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后给出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>做法就是考虑一个数是另一个数的约数当且仅当满足所有质因子的指数都小于等于另一个数。</p>
<p>然后你会发现这个就是高维前缀和啊</p>
<p>然后就可以质因数分解后指数的高维前缀和</p>
<pre><code class="language-cpp">for(int i = 1;i &lt;= tot;i ++)
	for(int j = 1;pri[i] * j &lt;= n;j ++)
		a[pri[i] * j] += a[j];
</code></pre>
<p>然后最后还有一个后缀和，就是考虑把这个循环改改，+变成-</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>k</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>i</mi></mrow></munder><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_k=\sum_{k|i}c_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-cpp">
for(int i=tot;i&gt;=1;--i)
	for(int j=1;pri[i]*j&lt;=n;++j)
    	a[j]-=a[pri[i]*j]

</code></pre>
<p>没有了</p>
]]></content>
    </entry>
</feed>