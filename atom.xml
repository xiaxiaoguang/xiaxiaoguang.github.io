<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-10-01T07:18:48.969Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第一场)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/">
        </link>
        <updated>2020-10-01T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>屑</p>
<p>A</p>
<p>考虑必胜策略的构造</p>
<p>假设我有最后一张牌</p>
<p>如果对方选取i,我就选择i+1</p>
<p>然后考虑我们这样做一定能有一个牌权</p>
<p>如果对方先手而且我的牌不比他多就能靠这个牌权取胜</p>
<p>所以:</p>
<p>奇数+奇先手必胜</p>
<p>奇数+偶先手必胜</p>
<p>偶数 偶必胜</p>
<p>n=2先手必胜</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
int T;
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--&gt;0) {
		int op;
		cin&gt;&gt;s;
		scanf(&quot;%d&quot;,&amp;op);
		if(s.size()==1 &amp;&amp; s[s.size()-1]=='2') {
			printf(&quot;%d\n&quot;,op);
		} else if((s[s.size()-1]-'0')%2==0)puts(&quot;1&quot;);
		else {
			if(op==0)puts(&quot;0&quot;);
			else puts(&quot;1&quot;);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>发现我们可以在线/se</p>
<p>举个例子:</p>
<p>染色一行,那么我们如果染蓝色,看看这一行最近一次染得是蓝色还是红色</p>
<p>如果染的蓝色,那么我们查询这个上次到这次时间区域染列红色的个数,那些会变蓝,对应加上</p>
<p>如果染的是红色,那么我们查询这次到上次时域染的行蓝色的个数,那些会不变,加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">m-cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>直接暴力分类讨论要8中,所以我在代码中压缩了行列的区别</p>
<p>考场心态炸裂QAQ</p>
<p>不该打grakn forces2020</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int MAXN=1e6+7;
using namespace std;
int n,m,k;
ll ans;
int col[2][MAXN],tim[2][MAXN];
//color time
const int MAXT=2e6+7;
struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXT];
	inline void mdf(int x,int v) {
		for(; x&lt;=k; x+=lowbit(x))tr[x]+=v;
	}
	inline ll qry(int x) {
		ll ret=0;
		for(; x; x-=lowbit(x))ret+=tr[x];
		return ret;
	}
} tr[2][2];//first h,l second r,b

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int main() {
	n=read();
	m=read();
	k=read();
	ans=1ll*n*m;
	for(int i=1,x,y,z; i&lt;=k; ++i) {
		x=read();
		z=read();
		y=read();
		if(y==0) {//红色
			if(col[x][z]==0) {//base red paint red
				ans += tr[x^1][1].qry(i)-tr[x^1][1].qry(tim[x][z]);
			} else {//base blue paint ret
				if(x==1) {
					ans += (n-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
				} else ans += (m-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
			}
            		} else {//蓝色
			if(col[x][z]==1) {
				ans -= tr[x^1][0].qry(i)-tr[x^1][0].qry(tim[x][z]);
			} else {//红色？？
				if(x==0)
					ans -= (m-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
				else ans -= (n-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
			}
		}
		if(tim[x][z]!=0) {
			tr[x][col[x][z]].mdf(tim[x][z],-1);
		}
		tr[x][y].mdf(i,1);
		col[x][z]=y;
		tim[x][z]=i;
	}
	ans=1ll*n*m-ans;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>nth_element</p>
<p>QAQ降智了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=12345;
int n,Q,a[MAXN],v[MAXN];

struct rec {
	ll W;
	int id;
	bool operator&lt;(const rec &amp;x)const {
		return W==x.W?id&lt;x.id:W&gt;x.W;
	}
} p[MAXN];

int t,k;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; ++i)scanf(&quot;%d%d&quot;,&amp;v[i],&amp;a[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for(int i=1; i&lt;=Q; ++i) {
		scanf(&quot;%d%d&quot;,&amp;t,&amp;k);
		for(int i=0; i&lt;n; ++i) {
			p[i].W=1ll*a[i]+1ll*v[i]*t;
			p[i].id=i+1;
		}
		nth_element(p,p+k-1,p+n);
		printf(&quot;%d\n&quot;,p[k-1].id);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>考虑DP,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示看了前i个A数前j个B数能够得到的最小划分代价</p>
<p>然后转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的,因为要枚举上一行上一列是什么</p>
<p>然后转移能优化吗QAQ?</p>
<p>你会发现:</p>
<blockquote>
<p>结论：存在一个最优解的每次删数，至少有一段长度是1</p>
</blockquote>
<p>因为我们有一段都大于1的</p>
<p>我们可以拆成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>a</mi><mo>+</mo><mi>y</mi><mi>b</mi><mo>&lt;</mo><mo>=</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">xa+yb&lt;=(x+y)*(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>所以整完了,转移式子变得可以优化</p>
<p>实现的时候有一维可以直接前缀最小值</p>
<p>另一维...好像按理说也是可以的,不过我的实现是使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>数组</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 2005;
int n, m;
int A[MAXN], B[MAXN];
ll f[MAXN][MAXN], suma[MAXN], sumb[MAXN];
ll minxa[MAXN][MAXN], minxb[MAXN];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		A[i]--;
		suma[i] = suma[i - 1] + A[i];
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;B[i]);
		B[i]--;
		sumb[i] = sumb[i - 1] + B[i];
	}
	if(n &lt; m) {
		swap(n, m);
		swap(A, B);
		swap(suma, sumb);
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	memset(minxa, 0x3f3f3f3f, sizeof(minxa));
	memset(minxb, 0x3f3f3f3f, sizeof(minxb));
	minxa[0][0] = 0;
	for(int i = 1; i &lt;= m; ++i)minxa[0][i] = 0;
	minxb[0] = 0;
	f[0][0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			f[i][j] = min(f[i][j], minxa[i - 1][j - 1] + A[i] * sumb[j]);
			f[i][j] = min(f[i][j], minxb[j - 1] + B[j] * suma[i]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			minxa[i][j] = min(minxa[i][j - 1], f[i][j] - A[i + 1] * sumb[j]);
			minxb[j] = min(minxb[j], f[i][j] - B[j + 1] * suma[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n][m]);
	return 0;
}
/*
3 4
2 4 3
2 6 6 4
*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1567. [2020提高组十连测day5]藤原千花]]></title>
        <id>https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/</id>
        <link href="https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/">
        </link>
        <updated>2020-09-27T15:01:31.000Z</updated>
        <content type="html"><![CDATA[<p>马耀华的比赛题A</p>
<p>太重要了所以这场比赛题我将拆成三篇博客讲述</p>
<p>http://www.zhengruioi.com/problem/1567</p>
<p>线图....QAQ他的点数是按照组合数级别上涨的...</p>
<p>真的来说是图中多少条长为k的路径...</p>
<p>详情请见zjoi 线图那道题</p>
<p>考场时没有判断一个点然后挂掉了QAQ</p>
<p>现在来看是什么我都没有判断就挂掉了....</p>
<h1 id="暴力">暴力</h1>
<p>k=0,判断是否连通&amp;&amp;是否是每个点度数都为偶数</p>
<p>k=1,你会发现新图中一个点是原图中两个点的度数和-2</p>
<p>那么我们就可以把所有新图中的点度数算出来然后和k=0一样了</p>
<p>然鹅...不严谨的我没有想到这样一个可爱的情况:</p>
<p>1孤零零的站在那里,第一次线图他消失了</p>
<p>所以要特殊判断一个点...</p>
<h1 id="正解">正解:</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>首先k=0的判据:所有点度数为偶数一定还成立</p>
<p>然后根据k=1我们可以发现:如果所有点度数奇偶性相同也可以</p>
<p>那....所有点度数都为奇数的图能否由线图导出?</p>
<p>你会发现可以,此时只需要所有边两侧的点度数奇偶性不同</p>
<p>那...这样好像可以递归下去,这样的图又能否由线图导出?</p>
<p>然后你又会发现这样的图好像一定是一个二分图...</p>
<p>也就是说我们不存在奇环,至少三元环</p>
<p>再一想,一旦一个图中某个点度数为3就会出现这样一个三元环!就暴毙了</p>
<p>不过好像左边一个点右边两个点的完全二分图也满足这个性质而且能够导出??.....QAQ</p>
<p><strong>但是至少这种情况是特殊的</strong></p>
<p>即,它属于那种能够越变越小的特殊线图:链</p>
<p>每进行一次,链的长度会缩短1</p>
<h2 id="判no判据">判No判据</h2>
<h3 id="存在长度大于k的链">存在长度大于k的链</h3>
<p>缩不完</p>
<h3 id="存在长度等于k的链而且有其他剩下的连通块">存在长度等于k的链,而且有其他剩下的连通块</h3>
<p>长度等于k的链会变成一个点</p>
<p>至少剩下两个连通块</p>
<h3 id="存在多个长度等于k的链">存在多个长度等于k的链</h3>
<p>QAQ这个其实和上面一样</p>
<p>但是判断起来可不一样啊</p>
<h3 id="不存在点">不存在点</h3>
<p>QAQ这个卡了我一会..</p>
<p>题目定义</p>
<h3 id="存在不止一个连通块">存在不止一个连通块</h3>
<p>QAQ这个又卡了我一会....</p>
<p>注意有些链可能缩没了</p>
<h3 id="上面都没触犯结果三个图性质都没满足">上面都没触犯,结果三个图性质都没满足</h3>
<p>这个最好判断qwq</p>
<h2 id="判yes判据">判Yes判据</h2>
<h3 id="最后只剩下存在长为k的链">最后只剩下存在长为k的链</h3>
<p>一个点也行</p>
<h3 id="满足一个图性质">满足一个图性质</h3>
<p>显然</p>
<p>于是我们大胆实践</p>
<p>就用2h完成了这道题!!!</p>
<p>附赠第一发AC的代码/se</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int n, m, k;
struct rec {
	int x, y;
} e[MAXN];
int f[MAXN], in[MAXN];
inline int getf(int x) {
	return f[x] == x ? x : f[x] = getf(f[x]);
}

inline void pd1() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(getf(i) != getf(1))return (void)puts(&quot;No&quot;);
	}
	for(int i = 1; i &lt;= n; ++i) {
		//		printf(&quot;%d %d?\n&quot;,i,in[i]);
		if(in[i] &amp; 1)return (void)puts(&quot;No&quot;);
	}
	return (void)puts(&quot;Yes&quot;);
}//k equal 0

//one node
inline void pd2() {
	static int siz[MAXN];
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		siz[getf(i)]++;
	}
	int cnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(siz[i] &gt; 1) {
			++cnt;
		}
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	if(cnt == 0)return (void)puts(&quot;No&quot;);
	for(int i = 1; i &lt;= m; ++i) {
		if((in[e[i].x] + in[e[i].y]) &amp; 1)return (void)puts(&quot;No&quot;);
	}
	puts(&quot;Yes&quot;);
	return ;
}

int home[MAXN], nxt[MAXN], to[MAXN], ccnt;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int flg, mx;
int dep[MAXN], vis[MAXN];
//du shu is 2
//with out circle
//lian tong kuai!
inline void dfs(int u, int F) {
	if(!flg)return ;
	vis[u] = 1;
	mx = max(mx, dep[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		//		printf(&quot;%d-&gt; %d %d in? %d\n&quot;,u,v,vis[v],in[v]);
		if(vis[v])flg = 0;
		else {
			if(in[v] != 1 &amp;&amp; in[v] != 2)flg = 0;
			dep[v] = dep[u] + 1;
			dfs(v, u);
		}
	}
}

int visp[MAXN];
inline void dfs2(int u, int F) {
	visp[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		if(to[i] == F)continue;
		dfs2(to[i], u);
	}
}

//if k &gt; maxlen lian ,can1
//if graph is jishu or graph is jioutu,can2
inline void pd3() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
		ct(e[i].x, e[i].y);
		ct(e[i].y, e[i].x);
	}
	int cnt = 0;
	int flg2 = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(in[i] == 0) {
			visp[i] = 1;
			continue;
		}
		if(!vis[getf(i)] &amp;&amp; in[i] == 1) { //is himself
			// printf(&quot;%d?%d\n&quot;, i, in[i]);
			flg = 1;
			mx = 0;
			dfs(i, 0);
			if(!flg) continue;
			if(mx &gt; k)return (void)puts(&quot;No&quot;);
			else if(mx == k) {
				if(!flg2)return (void)puts(&quot;No&quot;);
				flg2 = 0; //cunzai!
				dfs2(i, 0);
			} else dfs2(i, 0);
		}
	}
	// puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(!visp[i] &amp;&amp; i == getf(i)) {
			cnt++;
			//				printf(&quot;%d \n&quot;,i);
		}
	}
	// printf(&quot;%d %d\n&quot;, cnt, flg2);

	if(flg2 &amp;&amp; cnt == 0)return (void)puts(&quot;No&quot;);
	// printf(&quot;%d %d\n&quot;, flg2, cnt);
	if(!flg2 &amp;&amp; cnt == 0) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qwq&quot;);
		return (void)puts(&quot;Yes&quot;);
	} else if(!flg2) {//too....
		return (void)puts(&quot;No&quot;);
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if(!(in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg)return (void)puts(&quot;Yes&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if((in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;QAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	flg = 1;
	for(int i = 1; i &lt;= m; ++i) {
		if(visp[e[i].x] || visp[e[i].y])continue;
		if(!((in[e[i].x] &amp; 1) ^ (in[e[i].y] &amp; 1))) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	return (void)puts(&quot;No&quot;);
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].x, &amp;e[i].y);
	}
	if(k == 0) {
		return pd1(), 0;
	}//qaq
	if(k == 1) {
		return pd2(), 0;
	}//qwq
	pd3();//QAQAQAQ
	return 0;
}

/*

12 10 2
1 2
3 4

5 6
6 7
7 8
8 5

9 10
10 11
11 12
12 9

*/


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/">
        </link>
        <updated>2020-09-25T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>浪费生命的3h30min...</p>
<p>A</p>
<p>map</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>比较巧妙</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
//const int MAXN=1e5+7;
int n,m;
map&lt;int,int&gt; mp;
int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y,opt; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;opt);
		if(opt==1) {
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			mp[x]=y;
		} else {
			scanf(&quot;%d&quot;,&amp;x);
			if(mp.find(x)==mp.end()) {
				puts(&quot;0&quot;);
			} else printf(&quot;%d\n&quot;,mp[x]);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>每个点记录状压2^k的状态</p>
<p>然后发现边长为1</p>
<p>可以广度优先搜索</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int,int&gt;
#define se second
#define fi first
#define mkp(x,y) (make_pair(x,y))
const int MAXS=1100;
const int MAXN=5007;
const int MAXM=6007;
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

int n,ccnt,m,k,hd,tl;
int home[MAXN],nxt[MAXM],to[MAXM],w[MAXM],hve[MAXN];

int f[MAXN][MAXS],vis[MAXN][MAXS];//f_uS表示点u在已经有了S之后能不能走过去。。。
pii que[MAXS*MAXN];//不能炸吧。。。

inline void ct(int x,int y,int z) {
	++ccnt;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
	w[ccnt]=z;
}

inline void solve() {
	memset(f,0x3f3f3f3f,sizeof(f));
	f[1][hve[1]]=0;
	vis[1][hve[1]]=1;
	hd=tl=1;
	que[hd]=mkp(1,hve[1]);
	while(hd&lt;=tl) {
		int u=que[hd].fi,S=que[hd].se;
		hd++;
		if(u==n)break;
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i],q=w[i];
			int nS=S|hve[v];
			if(!vis[v][nS] &amp;&amp; ((q&amp;S)==q)) {
				vis[v][nS]=1;
				que[++tl]=mkp(v,nS);
				f[v][nS]=f[u][S]+1;
			}
		}
	}
	int ans=1e9;
	for(int i=0; i&lt;MAXS; ++i)ans=min(ans,f[n][i]);
	if(ans==1e9)printf(&quot;No Solution&quot;);
	else printf(&quot;%d\n&quot;,ans);
	return;
}

int main() {
//	freopen(&quot;test1.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);

	n=read();
	m=read();
	k=read();
	for(int i=1,x; i&lt;=n; ++i) {
		for(int j=0; j&lt;k; ++j) {
			x=read();
			hve[i]|=(x&lt;&lt;j);
		}
	}
	for(int i=1,x,y,z; i&lt;=m; ++i) {
		x=read();
		y=read();
		z=0;
		for(int j=0,p; j&lt;k; ++j) {
			p=read();
			z|=(p&lt;&lt;j);
		}
		ct(x,y,z);//qaq
	}
	solve();//bfs
	return 0;
}


</code></pre>
<p>C</p>
<p>一个质数能被分解成两个质数的乘积</p>
<p>当且仅当质因数指数和为2</p>
<p>问题变得显然,线性筛每个数最小质因子即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e7+7;
int q;
int sum[MAXN];
int pri[MAXN],isp[MAXN],mpr[MAXN];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void init() {
	int tot=0;
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			pri[++tot]=i;
			mpr[i]=i;
		}
		for(int j=1; j&lt;=tot &amp;&amp; i * pri[j] &lt; MAXN; ++j) {
			isp[i*pri[j]]=1;
			mpr[i*pri[j]]=min(pri[j],mpr[i]);
			if(i%pri[j]==0) {
				mpr[i*pri[j]]=pri[j];
				continue;
			}
		}
	}
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			sum[i]=sum[i-1]+1;
		} else {
			int x=i;
			x/=mpr[x];
			x/=mpr[x];
			if(x==1) {
				sum[i]=sum[i-1]+1;
			} else sum[i]=sum[i-1];
		}
	}
	return;
}

int main() {
//	freopen(&quot;test2.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	init();
	q=read();
	for(int i=1,l,r; i&lt;=q; ++i) {
		l=read();
		r=read();
		printf(&quot;%d\n&quot;,sum[r]-sum[l-1]);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>树上链交!</p>
<p>首先判断有没有空集,就是看两者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>的深度哪个更浅</p>
<p>然后把浅的那个LCA和另外两个端点再做LCA,如果有一个等于本身就说明LCA在另外的链上</p>
<p>然后链交大小?</p>
<p>设两条路径为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">LCA(x,u),LCA(x,v),LCA(u,y),LCA(v,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>四个点按照dfs序排下序,然后选取最后两个求dis即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=4e5+7;
int n,q,qwq,depp,ccnt;
int siz[MAXN],dfn[MAXN],dep[MAXN],fa[MAXN],son[MAXN],top[MAXN];
int home[MAXN],nxt[MAXN],to[MAXN];
int a[10];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void dfs1(int u,int F) {
	siz[u]=1;
	dfn[u]=++depp;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dep[v]=dep[u]+1;
		fa[v]=u;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]&gt;siz[son[u]])son[u]=v;
	}
	return ;
}

inline void dfs2(int u,int topf) {
	top[u]=topf;
	if(!son[u])return ;
	dfs2(son[u],topf);
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==fa[u] || v==son[u])continue;
		dfs2(v,v);
	}
}

inline int LCA(int x,int y) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]&lt;dep[top[y]])
			x^=y^=x^=y;
		x=fa[top[x]];
	}
	if(dep[x]&gt;dep[y])x^=y^=x^=y;
	return x;
}

inline bool cmp(const int &amp;x,const int &amp;y) {
	return dfn[x]&lt;dfn[y];
}

inline int DIS(int x,int y) {
	return dep[x]+dep[y]-2*dep[LCA(x,y)];
}

//this is a completely 链交大小
inline void solve(int u,int v,int x,int y) {
	a[1]=LCA(u,x);
	a[2]=LCA(u,y);
	a[3]=LCA(v,x);
	a[4]=LCA(v,y);
	sort(a+1,a+5,cmp);
	printf(&quot;%d\n&quot;,DIS(a[3],a[4])+1);
	return;
}

int main() {
//	freopen(&quot;test3.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	q=read();
	qwq=read();
	for(int i=1,x,y; i&lt;n; ++i) {
		x=read();
		y=read();
		ct(x,y);
		ct(y,x);
	}
	dep[1]=1;
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1,x,y,z; i&lt;=q; ++i) {
		x=read();
		y=read();
		z=read();
		solve(x,y,z,y);//直接链交走人了。。。
	}
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 【LGR-076】洛谷 ⑨ 月月赛 I & Cnoi2020 ]]></title>
        <id>https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/</id>
        <link href="https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/">
        </link>
        <updated>2020-09-24T14:55:05.000Z</updated>
        <content type="html"><![CDATA[<p>呃呃呃本来想打的然后因为数学物理考试咕咕咕了...</p>
<p>说实话都是纸老虎仔细想想就切掉了....</p>
<p>P6832 [Cnoi2020]子弦</p>
<p>可以冲sam吗?.....1e7不太能啊</p>
<p>答案显然就是每个最短的串的出现次数</p>
<p>即统计a~z出现次数</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e7 + 8;
char s[MAXN];
int cnt[50], ans;
int main() {
	scanf(&quot;%s&quot;, s);
	int n = strlen(s);
	for(int i = 0; i &lt; n; ++i) {
		cnt[s[i] - 'a']++;
	}
	for(int i = 0; i &lt; 26; ++i)ans = max(ans, cnt[i]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
<p>P6833 [Cnoi2020]雷雨</p>
<p>一开始就发现了正解然后心里暗示自己是错误的/cy</p>
<p>显然可以做三遍最短路:第一遍是从最上层任意一个点出发到剩下所有点的,第二遍是从红魔馆,第三遍是迷途竹林</p>
<p>然后枚举中间点三者求和即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nmlog(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>因为点数和边数同阶所以dijkstra可过</p>
<p>spfa???老哥这是<strong>网格图</strong>啊</p>
<p>code:</p>
<p>咕咕咕</p>
<p>P6834 [Cnoi2020]梦原</p>
<p>纸老虎1</p>
<p>先想想给出一个树的形态咋做吧....</p>
<p>显然一定每次选极大连通块??</p>
<p>然后如果是链上好像就是积木大赛???</p>
<p>差分数组所有正值加起来???</p>
<p>啊啊啊这好像树上是一样的....</p>
<p>然后树形态不固定好像也会了....</p>
<p>因为显然一个值会在1/k个区间出现啊,他的贡献就是value*1/k</p>
<p>用一个二维数点,求区间比一个数大的数的和/数的出现次数</p>
<p>离线+树状数组即可</p>
<p>注意特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>此时概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>讲述写代码的时候一个sb错误:树状数组的add和取模优化的add重了QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int n,k;
ll fac[MAXN],ifac[MAXN],inv[MAXN];
struct rec {
	int x,id;
	bool operator&lt;(const rec &amp;w) const {
		return x&lt;w.x;
	}
} a[MAXN];

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
const int MAXT=2e6+7;
struct BIT {
#define lowbit(x) (x&amp;-x)
	ll tr[MAXT];
	inline ll qry(int x) {
		ll ret=0;
		if(x==0)return 0;
		for(; x; x-=lowbit(x)) {
			add(ret,tr[x]);
		}
		return ret;
	}
	inline void mdf(int x,ll V) {
		for(; x&lt;=n; x+=lowbit(x))add(tr[x],V);
	}
} tr1,tr2;

inline ll ksm(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&amp;1)ans=ans*x%P;
		x=x*x%P;
		y&gt;&gt;=1;
	}
	return ans;
}

inline void init() {
	fac[0]=1;
	for(int i=1; i&lt;=k; ++i)fac[i]=1ll*fac[i-1]*i%P;
	ifac[k]=ksm(fac[k],P-2);
	ifac[0]=ifac[1]=1;
	for(int i=k-1; i&gt;=2; --i)ifac[i]=1ll*ifac[i+1]*(i+1)%P;
	for(int i=1; i&lt;=k; ++i) {
		inv[i]=1ll*fac[i-1]*ifac[i]%P;
	}
	return ;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf,*pend=buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

signed main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	k=read();
	for(int i=1; i&lt;=n; ++i) {
		a[i].x=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	init();
	ll ans=0;
	for(int i=1; i&lt;=n; ++i) {
		if(a[i].id==1) {
			add(ans,a[i].x);
			tr1.mdf(a[i].id,a[i].x);
			tr2.mdf(a[i].id,1);
			continue;
		}
		int L=max(1ll,a[i].id-k);
		int sum=tr1.qry(a[i].id-1)-tr1.qry(L-1);
		int num=tr2.qry(a[i].id-1)-tr2.qry(L-1);
		add(ans,1ll*(num*a[i].x%P-sum+P)%P*inv[a[i].id-L]%P);
		tr1.mdf(a[i].id,a[i].x);
		tr2.mdf(a[i].id,1);
		//一个统计个数一个统计sum
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}

/*

5 4
1 2 3 4 5

*/


</code></pre>
<p>P6835 [Cnoi2020]线形生物</p>
<p>哇偶!</p>
<p>我:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i走到n的期望值</p>
<p>ljh:太棒了你可以高斯消元!</p>
<p>我:QAQ!</p>
<p>ljh随手在黑板上写了几个式子,然后切掉了!</p>
<p>我:!!!!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>走到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的期望步数</p>
<p>由期望的线性性质我们可以得到答案就是求个和</p>
<p>怎么求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>sum表示f数组前缀和</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></mfrac><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=\frac 1 {in[i]}*(\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+f_i+1)+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>然后我们随便化简一下</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]!=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>做完了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int id,n,m;
ll f[MAXN],sum[MAXN];

int home[MAXN],nxt[MAXN],to[MAXN],ccnt,in[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}

int main() {
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;=m; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		in[x]++;
	}
	for(int i=1; i&lt;=n; ++i) {
		in[i]++;
	}
	//dp！
	ll ans=0;
	for(int u=1; u&lt;=n; ++u) {
		f[u]=1;
		sum[u]=sum[u-1];
		if(in[u]==1) { //只有一步QAQ
			add(ans,1);
			add(sum[u],f[u]);
			continue;
		}
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			add(f[u],(sum[u]-sum[v-1]+1+P)%P);
		}
		add(sum[u],f[u]);
		add(ans,f[u]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr提高组十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/">
        </link>
        <updated>2020-09-22T15:05:50.000Z</updated>
        <content type="html"><![CDATA[<p>阴间的dmy</p>
<p>http://www.zhengruioi.com/contest/703</p>
<p>A</p>
<p>提高组D2T1送分题</p>
<p>但是题面不够长所以qwq</p>
<p>做法:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第一个串匹配到i第二个串匹配到j的最小代价</p>
<p>然后转移:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>!</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i!=b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{i,j}=min(f_{i-1,j-1},min(f_{i-1,j},f_{i,j-1}))+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i==b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>优化:因为答案不会超过50,所以第二维有用的只有100个状态</p>
<p>直接用这些dp即可</p>
<p>其实本题造数据很难把</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+7;
int n;
int f[MAXN][105];
char s[MAXN],t[MAXN];
int main() {
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%s&quot;,t+1);
	int n1=strlen(s+1);
	int n2=strlen(t+1);
	if(n1&lt;n2) {
		swap(n1,n2);
		swap(s,t);
	}
	if(n1-n2&gt;50)return printf(&quot;-1&quot;),0;
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0][50]=0;
	for(int i=1; i&lt;=n1; ++i) {
		for(int j=50; j&gt;=-50; --j) {
			int p=i-j;
			if(p&lt;0 || p&gt;n2)continue;
			if(s[i]==t[p]) {
				f[i][j+50]=f[i-1][j+50];
			} else {
				f[i][j+50]=min(f[i][j+1+50],min(f[i-1][j-1+50],f[i-1][j+50]))+1;
			}
		}
	}
	if(f[n1][n1-n2+50]&gt;50)return printf(&quot;-1&quot;),0;
	printf(&quot;%d\n&quot;,f[n1][n1-n2+50]);
	return 0;
}


</code></pre>
<p>B</p>
<p>神仙数学题</p>
<p>你考虑维护两个L,R是2的幂次,同时满足形式:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111111</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111111(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111112</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111112(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>然后考虑合法成为答案的数x一定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之间</p>
<p>那么这个数字的幂次要尽可能的小于是想到再维护两个和这个差不多的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>Lx表示把前200位拿出来的前缀幂次最小值,<strong>如果不够两百位我们后面用0补齐两百位</strong></p>
<p>Rx表示把前两百位拿出来的前缀幂次最大值<strong>不够两百位也是用零补齐</strong></p>
<p>然后每次用x*Lx,如果正好大于L就是答案,否则我们如果小于Rx就留下更新然后不乘了</p>
<p>否则然后更新一次后我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo>∗</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx*Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>这个值去考虑更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>如果大于Rx更新Rx否则更新Lx</p>
<h2 id="因为我们lxrx的性质他一定满足大于或小于">因为我们Lx,Rx的性质他一定满足大于或小于!</h2>
<p>那你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">LxRx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>的形式都是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000000000</mn><mo>(</mo><mi>x</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1000000000(x个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9999999999</mn><mo>(</mo><mi>y</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9999999999(y个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>所以仔细思考一下我们一定能倍增出第一个合法的了</p>
<p>然后做完了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 100005 /*rem*/
#define mod 998244353
#define db double
#define vi vector&lt;int&gt;
#define pb push_back
#define mp make_pair
#define pi pair&lt;int, int&gt;
#define fi first
#define se second
using namespace std;
ll ksm(ll a, ll b) {
   if (!b) return 1;
   ll ns = ksm(a, b &gt;&gt; 1);
   ns = ns * ns % mod;
   if (b &amp; 1) ns = ns * a % mod;
   return ns;
}
const int mxs = 230; /*reme*/
void upd(vi &amp;a) {
	for (int i = 0; i &lt; a.size(); i++)
		if (a[i] &gt;= 10) {
			if (i == a.size() - 1)
				a.pb(a[i] / 10);
			else a[i + 1] += a[i] / 10;
			a[i] %= 10;
		}	
	if (a.size() &gt; mxs) {
		for (int j = 0; j &lt; mxs; j++)
			a[j] = a[a.size() - mxs + j];
		a.resize(mxs);
	} 
}
void otp(vi a) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		cout &lt;&lt; a[i];
	cout &lt;&lt; endl;
}
vi operator * (vi &amp;a, vi &amp;b) {
	vi c(a.size() + b.size() - 1);
	for (int i = 0; i &lt; c.size(); i++) c[i] = 0;
	for (int i = 0; i &lt; a.size(); i++)
		for (int j = 0; j &lt; b.size(); j++)
			c[i + j] += a[i] * b[j];
	upd(c);
//	cout &lt;&lt;&quot;NUL&quot; &lt;&lt; endl;
//	otp(a), otp(b), otp(c);
	return c;
}
bool operator &lt; (vi &amp;a, vi &amp;b) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		if (a[i] != b[i]) return a[i] &lt; b[i];
	return 0;
} 
vi operator + (vi &amp;a, vi &amp;b) {
	vi c(max(a.size(), b.size()));
	for (int i = 0; i &lt; c.size(); i++) {
		c[i] = 0;
		if (i &lt; a.size())
			c[i] += a[i];
		if (i &lt; b.size())
			c[i] += b[i];
	}
	upd(c);
	return c;
}
struct pw {
	vi a;
	vi b; // ��
	pw(){a.clear(), b.clear();}
	pw(vi x, vi y) {
		a = x, b = y;
	} 
	pw operator * (pw c) {
		
		return pw(a * c.a, b + c.b);
	}
};
pw L, R, cur;
vi lb, mx;
char inp[mxs];
void otp(pw a) {
	otp(a.a), otp(a.b);
}
int main() {
//	freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);
	int l;
	cin &gt;&gt; l;
	for (int i = 0; i &lt; l; i++)
		inp[i] = '1';
	vi u, v;
	for (int i = 0; i &lt; mxs - 1; i++)
		u.pb(0);
	u.pb(2), v.pb(1);	
	for (int i = 0; i &lt; mxs - l; i++)
		lb.pb(0), mx.pb(9);
	for (int i = l - 1; i &gt;= 0; i--)
		lb.pb(inp[i] - '0'), mx.pb(inp[i] - '0'); 
	L = pw(u, v);
	R = pw(u, v);		
	v[0] = 0, u[mxs - 1] = 1;
	cur = pw(u, v);
	while (1) {
	//	otp(L), otp(R);
		while (1) {
			pw ed = cur * L;
		//	otp(ed);
			if (cur.a &lt; ed.a &amp;&amp; ed.a &lt; mx) {
				cur = ed;
				if (!(cur.a &lt; lb)) {
					for (int i = cur.b.size() - 1; i &gt;= 0; i--)
						cout &lt;&lt; cur.b[i];
					cout &lt;&lt; endl;
					return 0;
				}
			}
			else break;
		}
		while (1) {
			pw nr = L * R;
			if (nr.a[mxs - 1] == 1) {
				L = nr;
				break;
			}
			else R = nr;
		}
	}
	return 0;
}



不是自己写的
</code></pre>
<p>C</p>
<p>倒序染色</p>
<p>然后你会发现我们每次还没有染色的相邻的不能染同一种颜色</p>
<p>其他的随便染上当前颜色即可</p>
<p>这个k的构造方式就是每次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">n-n/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">3</span></span></span></span>的迭代到0的次数....</p>
<p>可以证明最后这样染出颜色的方案一定不会存在一个区间的没有出现次数为1的</p>
<p>因为不管怎么样你都会被一个新颜色叉掉</p>
<p>倒序是因为前面的限制严,要用出现次数少的颜色</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
int n, k, a[MAXN];
//考虑用一种颜色染大于sum/3的灯然后我们递归剩下的解决
//我们要小心任何时刻都不能有相临相同的?
int b[MAXN], vis[MAXN], c[MAXN];
vector&lt;int&gt;  near[MAXN];
set&lt;int&gt; st;
inline void init() {
	st.clear();
	st.insert(n + 1);
	st.insert(0);
	for(int i = 1; i &lt;= n; ++i) {
		near[i].clear();
	}
	for(int i = 1; i &lt;= n; ++i)
		if(!vis[i]) {
			auto qwq1 = st.lower_bound(i);
			auto qwq2 = st.upper_bound(i);
			// printf(&quot;%d?%d\n&quot;, qwq1, qwq2);
			// near[a[i]].push_back(*qwq2);
			// near[*qwq2].push_back(a[i]);
			qwq1--;
			near[i].push_back(*qwq1);
			near[i].push_back(*qwq2);
			near[*qwq1].push_back(i);
			near[*qwq2].push_back(i);
			st.insert(i);
		}
	for(int i = 1; i &lt;= n; ++i) {
		if(!vis[i]) {
			sort(near[i].begin(), near[i].end());
			near[i].erase(unique(near[i].begin(), near[i].end()), near[i].end());
			// printf(&quot;%d\n&quot;, i);
			// for(auto v : near[i]) {
			// 	printf(&quot;%d &quot;, v);
			// }
			// puts(&quot;??&quot;);
		}
	}
	return ;
}

inline void solve(int l, int r, int dep) {
	if(l &gt; r)return;
	// printf(&quot;%d %d %d\n&quot;, l, r, dep);
	init();
	int limit = ceil((double)(r - l + 1) / 3);
	// if(limit == 0)limit = 1;
	for(int i = r; i &gt;= l; --i) {
		int p = a[i];
		if(!vis[p]) {
			bool flg = 1;
			// printf(&quot;in- &gt; %d\n&quot;, p);
			for(auto v : near[p]) {
				if(b[v] == dep) {
					// printf(&quot;%d %d???\n&quot;, v, dep);
					flg = 0;
				}
			}
			if(flg) {
				vis[p] = 1;
				b[p] = dep;
				limit--;
				// printf(&quot;%d %d\n&quot;, p, dep);
			}
		}
		if(!limit)break;
	}
	int tot = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(!vis[a[i]]) {
			// printf(&quot;%d?\n&quot;, i);
			c[++tot] = a[i];
		}
	}
	// printf(&quot;tot-&gt;%d\n&quot;, tot);
	for(int i = l; i &lt;= l + tot - 1; ++i) {
		// printf(&quot;%d\n&quot;, c[i - l + 1]);
		a[i] = c[i - l + 1];
	}
	// if(l = l + tot - 1)
	solve(l, l + tot - 1, dep + 1);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	init();
	solve(1, n, 1);
	for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, b[i]);
	puts(&quot;&quot;);
	return 0;
}

/*

3 3
1  2  3

4 3
4 3 2 1

*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020普转提七连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/">
        </link>
        <updated>2020-09-21T14:56:57.000Z</updated>
        <content type="html"><![CDATA[<p>http://www.zhengruioi.com/contest/704</p>
<p>没有上场毒瘤啊</p>
<p>A</p>
<p>打眼一看好像直接模拟就好了</p>
<p>但是可能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>情况</p>
<p>这种情况下根据kmp的错位相同原理,我们可能有很多字符是要一样的</p>
<p>那么我们用一个并查集把这样的字符形成的连通块找出来然后暴力看看每一块改成什么就好了</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>a</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nalogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>属于不精细的实现QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7;
int n, k, ans;
char a[MAXN];
int fa[MAXN], num[MAXN][26];
inline int getf(int x) {
	return fa[x] == x ? x : fa[x] = getf(fa[x]);
}

inline void merge(int x, int y) {
	for(int i = 0; i &lt; 26; ++i) {
		num[getf(x)][i] += num[getf(y)][i];
	}
	fa[getf(y)] = getf(x);

	return ;
}

inline void init() {
	for(int i = 1; i &lt;= n; ++i) {
		fa[i] = i;
		num[i][a[i] - 'a'] = 1;
	}
	return ;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s&quot;, a + 1);
	init();
	int l = n - k + 1, r, tmp;
	//错位相同,显然我们错位不能多了
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] != i)continue;
		r = l + i - 1;
		merge(i, r);
		tmp = r - 1 + l;
		while(tmp &lt;= n) {
			merge(i, tmp);
			if(tmp &gt; k) {
				break;
			}
			tmp = tmp - 1 + l;
		}
	}
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] == i) {
			int S = 0, Max = -1;
			for(int j = 0; j &lt; 26; ++j) {
				if(num[i][j] &gt; Max)Max = num[i][j];
				S += num[i][j];
			}
			ans += S - Max;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

10 7
aabaabaabc
5 4
abcde
5 3
abcba
6 4
abbbaa

*/


</code></pre>
<p>B</p>
<p>每一位只要出现011三个字符就一定可以判断出三种运算了</p>
<p>因为&amp;和其他可以用01去试,然后xor和|可以用11去试</p>
<p>显然不存在其他的不包括这个011的方案能验证出来....</p>
<p>答案每一位取max即可</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 505;

int n, m, T;
char a[MAXN][MAXN];
int cnt[MAXN], flg[MAXN];

inline void init() {
	for(int i = 1; i &lt;= m; ++i) {
		cnt[i] = flg[i] = 0;
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		init();
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, a[i] + 1);
		}
		for(int i = 1; i &lt;= n; ++i) {
			for(int j = 1; j &lt;= m; ++j) {
				if(a[i][j] == '0') {
					flg[j] = 1;
				}
				if(a[i][j] == '1') {
					cnt[j]++;
				}
			}
		}
		int ans = 0;
		for(int i = 1; i &lt;= m; ++i) {
			if(flg[i] &amp;&amp; cnt[i] &gt;= 2) {//110
				continue;
			} else if(!flg[i] &amp;&amp; cnt[i] &gt;= 2) {//111
				ans = max(ans, 1);
			} else if(flg[i] &amp;&amp; cnt[i] &lt; 2) {//0??
				ans = max(ans, 2 - cnt[i]);
			} else if(!flg[i] &amp;&amp; cnt[i] &lt; 2) {//???
				ans = max(ans, 3 - cnt[i]);
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>md....好像做过啊!</p>
<p>结论:大于53的质数没有用处,大于60的数没有用处</p>
<p>因为我们改成1一定更优秀</p>
<p>所以你会发现我们最后序列每个质因数一定只用了一次....</p>
<p>所以状压一下这16个质因数</p>
<p>然后考虑dp,f_{i,S}表示考虑了前i个数已经用了的质因数集合为S的最小代价</p>
<p>转移枚举下个数填什么,然后一定要是某个补集的子集才行</p>
<p>有很多种优化的方法</p>
<ol>
<li>60个数不用全部枚举,可以剪掉一些显然sb的</li>
<li>只枚举当前有用集合中的,而有用集合可以预处理</li>
</ol>
<p>code就没有了</p>
<p>D</p>
<p>重题</p>
<p>跟沈睿哥哥吐糟还被骂了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1600701080965.png" alt="" loading="lazy"></figure>
<p>参照某篇叫[国家集训队]等差子序列的题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5384 [Cnoi2019]雪松果树]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/">
        </link>
        <updated>2020-09-19T14:51:07.000Z</updated>
        <content type="html"><![CDATA[<p>单独腾一篇博客吧!</p>
<p>关于树上k级祖先和树上k级儿子的绝对快做法</p>
<p>首先枚举下各种做法吧!</p>
<h1 id="树上k级祖先">树上k级祖先</h1>
<h2 id="onlogn预处理"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>预处理</h2>
<ol>
<li>倍增求k级祖先</li>
</ol>
<p>显然,回答一组询问也是严格log的</p>
<p>访问空间太慢而且会被卡空间所以很屑</p>
<ol start="2">
<li>树剖求k级祖先</li>
</ol>
<p>当重链长度大于k,我们k级祖先就在这条链上,对于一个链都记录了直接访问即可...</p>
<p>这个显然不如:</p>
<ol start="3">
<li>长链剖分求k级祖先</li>
</ol>
<p>预处理每个长链数组还是要的</p>
<p>预处理倍增数组还是要的QAQ否则你可以尝试OnO1rmq!</p>
<p>然后你会发现我们如果一步跳到k最高二进制位的祖先后</p>
<p>由于k级祖先的长链长度一定大于这个数的</p>
<p>所以我们可以再从那个点向上或者向下沿着长链跳一步即可</p>
<p>时间复杂度回答起来是O1的</p>
<h2 id="on离线">O(n)离线</h2>
<p>开一个栈记录从根到x dfs经过的所有点</p>
<p>然后我们考虑dfs到x回答x的所有询问即可</p>
<h1 id="k级儿子个数和">k级儿子个数和</h1>
<p>hh</p>
<ol>
<li>线段树合并</li>
</ol>
<p>按照深度为下标建树然后每个位置记录有多少数</p>
<p>线段树合并</p>
<ol start="2">
<li>dsu on tree</li>
</ol>
<p><code>树上启发式合并</code></p>
<p>线段树合并另一种实现形式....</p>
<ol start="3">
<li>离线树状数组</li>
</ol>
<p>相当于数一个区间的某一个深度的个数</p>
<ol start="4">
<li>二分+vector</li>
</ol>
<p>每个深度的点开一个vector全部记录下来,然后在哪个vector处二分即可</p>
<p>当然可以压成所有的一个数组来优化空间</p>
<ol start="5">
<li>长链剖分</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">O(n)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
<p>出现了线性做法!</p>
<p>其实是利用了长链性质优化了dsu on tree</p>
<h1 id="finally">Finally</h1>
<p>my choice : (你谷最快)</p>
<p>可以离线求k级祖先</p>
<p>然后第二个数点我们可以树上差分</p>
<p>因为只求等于某个数的个数啊...</p>
<p>附上你谷rank 1代码</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e6+7;
const int MAXQ=3e6+7;
int n,m;
int ccnt,home[MAXN],id[MAXQ],nxt[MAXQ],to[MAXQ],fst[MAXN],sec[MAXN],dep[MAXN];
int ans[MAXN],st[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}

	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
	int _C=-1,_Z;
	char _sr[1&lt;&lt;21],_z[20];
	inline void Ot() {
		fwrite(_sr,1,_C+1,stdout),_C=-1;
	}
	inline void print(int x) {
		if(_C&gt;1&lt;&lt;20)Ot();
		while(_z[++_Z]=x%10+48,x/=10);
		while(_sr[++_C]=_z[_Z],--_Z);
		_sr[++_C]=' ';
	}
}
using namespace fastIO;

inline void ct(const int &amp;u,const int &amp;v) {
	ccnt++;
	nxt[ccnt]=home[u];
	home[u]=ccnt;
	to[ccnt]=v;
}

inline void ct2(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=fst[u];
	fst[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

inline void ct3(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=sec[u];
	sec[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

int tp,cnt[MAXN];
inline void dfs(int u) {
	st[++tp]=u;
	int v;
	for(int i=fst[u]; i; i=nxt[i]) {
		v=to[i];
		if(v&lt;tp) {
			ct3(st[tp-v],v,id[i]);
		}
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dep[v]=dep[u]+1;
		dfs(v);
	}
	--tp;
}

inline void dfs2(int u) {
	int v;
	cnt[dep[u]]++;
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]-=cnt[dep[u]+v];
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dfs2(v);
	}
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]+=cnt[dep[u]+v]-1;
	}
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	m=read();
	for(int i=2,x; i&lt;=n; ++i) {
		x=read();
		ct(x,i);
	}
	for(int i=1,x,y; i&lt;=m; ++i) {
		x=read();
		y=read();
		ct2(x,y,i);
	}
	dep[1]=1;
	dfs(1);
	dfs2(1);
	for(int i=1; i&lt;=m; ++i)print(ans[i]);
	Ot();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/">
        </link>
        <updated>2020-09-18T15:02:37.000Z</updated>
        <content type="html"><![CDATA[<p>哎...人总有写挂的一天吗?</p>
<p>A</p>
<p>傻逼题用map直接模拟即可</p>
<p>最后剩下的那个就是答案</p>
<p>卡双模hash</p>
<p>时间复杂度O(nlogn)</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int bas1 = 12344;
const int bas2 = 67891;
const int P1 = 1e9 + 9;
const int P2 = 1e9 + 3;
const int MAXS = 30;
const int MAXN = 1e5 + 7;
#define pii pair&lt;ll,ll&gt;
#define se second
#define fi first
#define mkp(x,y) make_pair(x,y)
int n;
string s;
map&lt;string, int&gt; mp;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 0; i &lt; n + n - 1; ++i) {
		cin &gt;&gt; s;
		mp[s]++;
	}
	for(auto v : mp) {
		if(v.se &amp; 1)
			cout &lt;&lt; v.fi &lt;&lt; endl;
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>就是base为2i的进制转换</p>
<p>直接模拟即可</p>
<p>这个可以看看代码</p>
<p>注意</p>
<ol>
<li>输出虚数部分的+时要小心,因为可能前面那个数是0啊</li>
<li>特判0</li>
</ol>
<p>而又没法对拍,只能手动....</p>
<p>code:</p>
<pre><code class="language-cpp">/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/
//orzEI!
#include&lt;bits/stdc++.h&gt;
#define ll __int128
using namespace std;
const int MAXN = 100;

ll t1, t2, p1, p2, q1, q2;
char s[MAXN];
int cnt;
ll qwq[MAXN];

namespace fastIO {
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(ll x) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
	}
	inline void print2(char s) {
		_sr[++_C] = s;
	}
}
using namespace fastIO;

inline void init() {
	qwq[0] = 1;
	for(int i = 1; i &lt; 80; ++i)qwq[i] = qwq[i - 1] * 2;
	return ;
}

inline ll ksm(int x) {
	return qwq[x];
}

inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

int main() {
	scanf(&quot;%s&quot;, s + 1);
	int a = strlen(s + 1);
	if(a == 1 &amp;&amp; s[1] == '0') {
		return puts(&quot;0&quot;), 0;
	}
	init();
	cnt = a + 1;
	for(int i = 1; i &lt;= a; ++i) {
		if(s[i] == '.') {
			cnt = i;
			break;
		}
	}
	//处理整数部分
	for(int i = 1; i &lt; cnt; ++i) {
		int t = (cnt - i) % 4;
		if(t == 1) { //正数
			t1 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if(t == 2) { //正数i
			t2 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if (t == 3) { //负数
			t1 -= ksm(cnt - i - 1) * (s[i] - '0');
		} else {//负数i
			t2 -= ksm(cnt - i - 1) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',t1,t2,i);
	}
	//处理小数部分
	//使用最大的那一部分，然后除除gcd吧QAQ
	for(int i = a; i &gt; cnt; --i) {
		if(s[i] == '0')continue;
		int t = (i - cnt) % 4;
		//		printf(&quot;%d?%d\n&quot;,t,i);
		if((t == 1 || t == 3) &amp;&amp; !q2) {
			q2 = ksm(i - cnt);
		}
		if((t == 2 || t == 0) &amp;&amp; !q1) {
			q1 = ksm(i - cnt);
		}
	}
	if(!q1)q1 = 1;
	if(!q2)q2 = 1;
	//	printf(&quot;%lld %lld\n&quot;,q1,q2);
	for(int i = cnt + 1; i &lt;= a; ++i) {
		int t = (i - cnt) % 4;
		if(t == 1) { //负数i
			p2 -= q2 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 2) { //负数
			p1 -= q1 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 3) { //正数i
			p2 += q2 / ksm(i - cnt) * (s[i] - '0');
		} else {//正数
			p1 += q1 / ksm(i - cnt) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',p1,p2,i);
	}
	//	printf(&quot;%lld %lld %lld %lld %lld %lld\n&quot;,p1,q1,t1,p2,q2,t2);
	p2 += q2 * t2;
	p1 += q1 * t1;
	ll qwq1 = gcd(p1, q1);
	ll qwq2 = gcd(p2, q2);
	p2 /= qwq2;
	q2 /= qwq2;
	p1 /= qwq1;
	q1 /= qwq1;
	if(q1 &lt; 0)p1 = -p1, q1 = -q1; //同时乘-1
	if(q2 &lt; 0)p2 = -p2, q2 = -q2;
	if(p1 != 0) {
		if(p1 &lt; 0) {
			print2('-');
			p1 = -p1;
		}
		if(q1 == 1) {
			print(p1);
		} else {
			print(p1);
			print2('/');
			print(q1);
		}
	}
	if(p2 != 0) {
		if(p2 &lt; 0) {
			print2('-');
			p2 = -p2;
		} else {
			if(p1 != 0)
				print2('+');//死因啊
		}
		if(q2 == 1) {
			if(p2 != 1)
				print(p2);
		} else {
			print(p2);
			print2('/');
			print(q2);
		}
		print2('i');
	}
	Ot();
	return 0;
}

/*

311111111.11111
11111111.11111
111111111111111111111111111111.11111111111111111111111111111111
11111111111111111111111111111111

*/



</code></pre>
<p>哎...这尼玛的都能卡</p>
<p>C</p>
<p>就差一步啊QAQTAT</p>
<p>首先把整个序列变成一个前1后-1的差分的形式后</p>
<p>我们可以发现相邻的1,-1可以用后面的一个1替代,然后相邻的-1,1 可以用后面的一个-1替代....</p>
<p>就做完了....最后数数序列中有数的位置有多少个即可</p>
<pre><code class="language-cpp">
/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int T;
char a[MAXN];
int b[MAXN];


// inline void solve() {
// 	int n = strlen(a + 1);
// 	int cnt = 0;
// 	ans = 0;
// 	bool flg = 1;
// 	memset(b, 0, sizeof(b));
// 	a[n + 1] = '0';
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(flg &amp;&amp; a[i] == '1') {
// 			//			ans++;
// 			b[i] = 1;
// 			continue;
// 		}
// 		if(flg &amp;&amp; a[i] == '0') {
// 			flg = 0;
// 		}
// 		cnt += a[i] - '0';
// 		if(cnt == 1 &amp;&amp; a[i + 1] == '0') {
// 			//			++ans;
// 			b[i] = 1;
// 			cnt = 0;
// 		} else if(a[i + 1] == '0' &amp;&amp; cnt &gt; 1) {
// 			b[i - cnt] = 1;
// 			b[i] = -1;
// 			cnt = 0;
// 			//			ans+=2;
// 		}
// 	}
// 	//	puts(&quot;qwq&quot;);
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
// 			b[i + 1] = -1;
// 			b[i] = 0;
// 		}
// 		ans += (b[i] != 0);
// 		//		printf(&quot;%d &quot;,b[i]);

// 	}
// 	//	puts(&quot;&quot;);
// 	//	printf(&quot;%d\n&quot;,ans);
// }

inline void solve2() {
	int n = strlen(a + 1);
	int cnt = 0;
	int ans = 0;
	bool flg = 1;
	memset(b, 0, sizeof(b));
	a[n + 1] = '0';
	for(int i = 1; i &lt;= n; ++i) {
		if(flg &amp;&amp; a[i] == '1') {
			//			ans++;
			b[i] = 1;
			continue;
		}
		if(flg &amp;&amp; a[i] == '0') {
			flg = 0;
		}
		cnt += a[i] - '0';
		if(a[i + 1] == '0' &amp;&amp; cnt &gt;= 1) {
			b[i - cnt] = 1;
			b[i] = -1;
			cnt = 0;
			//			ans+=2;
		}
	}
	//	puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(b[i] == 1 &amp;&amp; b[i + 1] == -1) {
			b[i + 1] = 1;
			b[i] = 0;
		}
		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
			b[i + 1] = -1;
			b[i] = 0;
		}
		ans += (b[i] != 0);
		//		printf(&quot;%d &quot;,b[i]);

	}
	//	puts(&quot;&quot;);
	printf(&quot;%d\n&quot;, ans);
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, a + 1);
		// solve();
		solve2();
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>OEIS</p>
<p>i*(i+1)爆int了</p>
<p>正确做法:</p>
<p>考虑组合数学</p>
<p>首先我们枚举k表示把第一类小球分成几组</p>
<p>然后方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>然后我们在此基础上把第二类小球加进去,就是考虑我们只能插在第一类小球之间,和第一类放在一起</p>
<p>假设有t种,方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>那么我们第一种是第一类小球两侧都是第二类小球,第二种是左侧或者右侧是第二类小球,第三种是第二类小球两侧都是第一类小球</p>
<p>对应t的k+1,k,k-1三种可能</p>
<p>方案数就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><mo>∗</mo><mo>(</mo><mn>1</mn><mo>+</mo><mo>[</mo><mi>t</mi><mo>=</mo><mo>=</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{k-1}\binom{n-1}{t-1}*(1+[t==k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<p>然后第三类小球只能把所有我们相邻的位置杀掉</p>
<p>考虑我们一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(k+t+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个位置颜色相邻不相同</p>
<p>而我们现在加入了2n个球,所以我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1-k-t-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个位置颜色相邻相同</p>
<p>所以说我们需要插入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mo>(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n-(2n-k-t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>个第三类小球干掉这些位置</p>
<p>然后剩下的第三类小球从左向右依次蹦进我们相邻颜色不相同的位置就行了</p>
<p>因为其实就是每个第三类小球匹配了前面的一些合法空当位置,变成了有标号</p>
<p>然后我们再把他们拿出一些分给不相同就是无标号组合数了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 1e6 + 7;
inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
ll f[MAXN];
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	f[1] = 6;
	f[2] = 30;
	for(int i = 3; i &lt;= n; ++i) {
		f[i] = (f[i - 1] * (7 * i - 4) % P * (i + 1) % P + f[i - 2] * 8 % P * (i - 2) % P * (i - 2) % P) % P * ksm(1ll * i * (i + 1) % P, P - 2) % P;
		f[i] %= P;
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR20秋季普转提day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/">
        </link>
        <updated>2020-09-15T14:41:19.000Z</updated>
        <content type="html"><![CDATA[<p>zzzz</p>
<p>孙笑川都干了那些坏事?</p>
<p>A</p>
<p>考虑他的转化问题:随机一个n个点的排列,从左往右删除每次删掉一个点之后我们把他的所有祖先都删除掉</p>
<p>那么答案就是这样一个排列的期望删除次数</p>
<p>不难发现可以变成每个数期望删除次数之和</p>
<p>然后就会发现概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>,也就是说我有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>的几率在排列中比我儿子都靠前</p>
<p>对上述求和即可</p>
<p>复杂度O(n)</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
const int P = 998244353;
const int MAXN = 1e7 + 7;
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], n, siz[MAXN];
ll ans, A[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;24)
	char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = nc();
		int x = 0;
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
};
using namespace fastIO;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		dfs(v);
		siz[u] += siz[v];
	}
	ans = (ans + A[siz[u]]) % P;
}

int main() {
	n = read();
	for(int i = 2, x; i &lt;= n; ++i) {
		x = read();
		ct(x, i);
	}
	A[0] = 1;
	A[1] = 1;
	for(int i = 2; i &lt;= n; ++i)		{
		A[i] = (P - (P / i)) * A[P % i] % P;
	}
	dfs(1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}



</code></pre>
<p>B</p>
<p>考场上用数据结构写了个很能卡的贪心hhh</p>
<p>但是出题人不一定想的到,数据也很水就过了</p>
<p>正确做法:</p>
<p>n为偶数,随便拿走一个变成奇数的情况</p>
<p>n为奇数,我们按照a排序,然后拿走第一个,</p>
<p>然后剩下的我们两组两组之间拿走b值较大的那个</p>
<p>可以证明我们拿走了最大的那个a就能保证我们剩下一定不会卡</p>
<p>也可以证明因为我们每次都拿了两两较大的b,rank最劣也是倒2,倒4,倒6.....一定大于倒1,倒3....即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
int n;
ll S1, S2;
struct rec {
	int x, y, id;
	bool operator&lt;(const rec &amp;w)const {
		return x &gt; w.x;
	}
} a[MAXN];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].x);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].y);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	int i = 0;
	printf(&quot;%d\n&quot;, n / 2 + 1);
	if(!(n &amp; 1)) {
		printf(&quot;%d %d &quot;, a[1].id, a[2].id);
		i = 3;
	} else {
		printf(&quot;%d &quot;, a[1].id);
		i = 2;
	}
	for(; i &lt;= n; i += 2) {
		if(a[i].y &gt;= a[i + 1].y) {
			printf(&quot;%d &quot;, a[i].id);
		} else {
			printf(&quot;%d &quot;, a[i + 1].id);
		}
	}
	puts(&quot;&quot;);
	return 0;
}


</code></pre>
<p>C</p>
<p>二分之后限制二变成了子树内至多有一些点能染色</p>
<p>然后我们按照这个range的性质dp去判断可不可行</p>
<p>细节有一堆</p>
<ol>
<li>上界更新的时候注意+1</li>
<li>不要阴间的重设上界范围</li>
<li>注意判断siz和down大小范围,all和up的范围</li>
</ol>
<p>坑死了,因为造不出很强的数据所以过拍不过题调了好久</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 3e5 + 7;
const int inf = 1e9 + 7;
int n, ccnt, home[MAXN], nxt[MAXN], to[MAXN];
int up[MAXN], down[MAXN], A, B, g[MAXN];
int f[MAXN], flg, siz[MAXN], all,rc[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs1(int u, int F) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		siz[u] += siz[v];
	}
	if(n - siz[u] &lt; up[u]) {
		flg = 0;
	}
	return ;
}

inline void dfs(int u, int F) {
	bool tflg = 0;
	int tmp = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		f[u] += f[v];
		tmp += up[v];
	}
	up[u] = min(tmp, up[u]);
	if(f[u] &lt; down[u])
		f[u] = down[u];
	if(f[u] &gt; siz[u])flg = 0;
	if(f[u] &gt; up[u] || f[u] &gt; all)flg = 0;
	return;
}

inline int chk(int x) {
	all = x;
	for(int i = 1; i &lt;= n; ++i) {
		rc[i] = up[i];
		up[i] = x - up[i];
	}
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	flg = 1;
	dfs(1, 0);
	if(x &gt; up[1]) flg=0;
	for(int i = 1; i &lt;= n; ++i) {
		up[i] = rc[i];
	}
	return flg;
}

inline void solve() {
	int l = 0, r = n + 1, ans = -1, mid = 1;
	for(int i = 1; i &lt;= n; ++i) {
		l = max(l, down[i] + up[i]);
	}
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			ans = mid;
		} else {
			l = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return;
}

signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	scanf(&quot;%lld&quot;, &amp;A);
	for(int i = 1, x, y; i &lt;= A; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		down[x] = max(down[x], y);
	}
	scanf(&quot;%lld&quot;, &amp;B);
	for(int i = 1, x, y; i &lt;= B; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		up[x] = max(up[x], y);
	}
	flg = 1;
	dfs1(1, 0);
	if(!flg)return puts(&quot;-1&quot;), 0;
	solve();
	return 0;
}

/*

3
1 3
1 2
1 4
0
3
2 3
3 2
4 2


*/


</code></pre>
<p>D</p>
<p>博弈论+计数dp</p>
<p>非常烦啊</p>
<p>首先预处理两个数组g[0/1][x][i]表示alice/bob在x子树任意总方案(包括染色方案和重儿子选择方案)下保证权值小于等于i的方案数,这个方案可以不均衡</p>
<p>转移:,以alice层为例</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[1][x][i]=g[1][ls][i]*a[rs]+g[1][rs][i]*a[ls]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p>
<p>a数组是任意选择的方案数(不限制权值)</p>
<p>表示我们Alice在转移的时候可以选择左子树走下去也可以选择右子树走下去</p>
<p>但是我们选择什么就是什么,所以另一颗子树随便选择</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[2][x][i]=2*g[2][ls][i]*g[2][rs][i]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
<p>表示我们bob在转移时,左右子树必须都能够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">&lt;=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>否则一切换可能会导致最后走下去权值变大</p>
<p>然后处理f数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{0/1,i,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示alice/bob从上到下走到点x,权值等于i的均衡方案数</p>
<p>转移的时候(假设我们在转移)我们会发现,如果这个正好是他的层,就直接从上面继承下来就好了</p>
<p>否则我们可能要面临对手切换子树的风险,所以要保证另一颗子树走下去权值不会超过i</p>
<p>也就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{0/1,i,rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>最后到叶子的时候,你会发现我们这个方案乘起来一定包括了整棵树的决策,所以只需要f数组求个和然后对应相乘了</p>
<p>因为我们再alice层只会让bob去计算另一颗子树的选择方案,而在bob层只会让alice算,那么和你的第二维没关系,之和你这条链长啥样有关</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 5e3 + 7;
int n, K, ans;
int dep[MAXN], fa[MAXN], ls[MAXN], rs[MAXN];
int g[3][MAXN][MAXN], f[3][MAXN][MAXN], a[MAXN];

inline void add(int &amp;x, ll y) {
	x = x + y &gt; P ? (x + y - P) : (x + y);
}

inline void dfs(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = g[2][u][i] = 1ll * i * K % P;
		}
		a[u] = 1ll * K * K % P;
		return ;
	}
	dep[ls[u]] = dep[u] + 1;
	dep[rs[u]] = dep[u] + 1;
	if(ls[u])dfs(ls[u]);
	if(rs[u])dfs(rs[u]);
	a[u] = 2ll * a[ls[u]] % P * a[rs[u]] % P;
	if(dep[u] &amp; 1) {//奇数,bob
		for(int i = 1; i &lt;= K; ++i) {
			add(g[1][u][i], 1ll * g[1][ls[u]][i] * a[rs[u]] % P + 1ll * g[1][rs[u]][i] * a[ls[u]] % P);
			g[2][u][i] = 2ll * g[2][ls[u]][i] % P * g[2][rs[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = 2ll * g[1][ls[u]][i] % P * g[1][rs[u]][i] % P;
			add(g[2][u][i], 1ll * g[2][ls[u]][i] * a[rs[u]] % P + 1ll * g[2][rs[u]][i] * a[ls[u]] % P);
		}
	}
	return ;
}

inline void dfs2(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		int suma = 0, sumb = 0;
		for(int i = 1; i &lt;= K; ++i) {
			add(suma, f[1][u][i]);
			add(sumb, f[2][u][i]);
		}
		add(ans, 1ll * suma * sumb % P);
		return ;
	}
	if(dep[u] &amp; 1) {
		for(int i = 1; i &lt;= K; ++i) {
			f[1][rs[u]][i] = f[1][ls[u]][i] = f[1][u][i];
			f[2][ls[u]][i] = 1ll * f[2][u][i] * g[2][rs[u]][i] % P;
			f[2][rs[u]][i] = 1ll * f[2][u][i] * g[2][ls[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			f[2][rs[u]][i] = f[2][ls[u]][i] = f[2][u][i];
			f[1][ls[u]][i] = 1ll * f[1][u][i] * g[1][rs[u]][i] % P;
			f[1][rs[u]][i] = 1ll * f[1][u][i] * g[1][ls[u]][i] % P;
		}
	}
	if(ls[u])dfs2(ls[u]);
	if(rs[u])dfs2(rs[u]);
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
	for(int i = 2, x; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		if(!ls[x])ls[x] = i;
		else rs[x] = i;
	}
	dfs(1);
	for(int i = 1; i &lt;= K; ++i)f[1][1][i] = f[2][1][i] = 1;
	dfs2(1);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020提高组十连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/">
        </link>
        <updated>2020-09-13T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<p>锅是锅了,但是还是有本质很好的题目的...</p>
<p>出锅原因:</p>
<ol>
<li>数据和题面不符</li>
<li>二三题数据随机,导致暴力与正解一样</li>
</ol>
<p>A</p>
<p>有毒</p>
<p>我们会发现,本质上就是求一个图的染色方案,使得异色边数最大....大于m/2</p>
<p>做法很简单,直接dfs实现二分图染色即可,然后如果一遍不行我们randomshuffle存图顺序多dfs几遍</p>
<p>其实有个结论是如果我们二分图染色能做到每个奇环只有一条边是没有用的...</p>
<p>而奇环最小三个边</p>
<p>而且这样我们就有重复的边,如果选了一个包含了多个奇环就能变得很优....</p>
<p>当然这个最优化是NPh的</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
const int MAXM = 2e6 + 7;

int n, m, ccnt, ans;
int home[MAXN], nxt[MAXM], to[MAXM];
int eu[MAXM], ev[MAXM], col[MAXN];

struct rec {
	int u, v;
} e[MAXM];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!col[v]) {
			col[v] = -col[u];
			dfs(v);
		}
	}
}

inline void solve() {
	ccnt = 0;
	memset(home, 0, sizeof(home));
	for(int i = 1; i &lt;= m; ++i) {
		ct(e[i].u, e[i].v);
		ct(e[i].v, e[i].u);
	}
	memset(col, 0, sizeof(col));
	for(int i = 1; i &lt;= n; ++i) {
		if(!col[i]) {
			col[i] = 1;
			dfs(i);
		}
	}
	int cnt = 0;
	for(int i = 1; i &lt;= m; ++i) {
		if(col[e[i].u] != col[e[i].v]) {
			cnt++;
		}
	}
	if(cnt &gt; m / 2) {
		// for(int i = 1; i &lt;= n; ++i) {
		// 	printf(&quot;%d %d\n&quot;, i, col[i]);
		// }
		ans = 1;
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(m == 0) {
		puts(&quot;No&quot;);
		return 0;
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	}
	for(int i = 1; i &lt;= 17; ++i) {
		random_shuffle(e + 1, e + m + 1);
		solve();
		if(ans)break;
	}
	if(ans)
		printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	return 0;
}



</code></pre>
<p>B</p>
<p>不需要构造方案不够妙啊!</p>
<p>但是本质上还是很妙的</p>
<p>我们观察一下,交换更简化的是什么</p>
<p>k=3</p>
<p>000101<br>
-&gt;<br>
101000</p>
<p>可以通过把错位k来把有些1搞过去,操作前提是我们有连续k个空格0</p>
<p>啊!你会发现这个相当于一个翻转操作啊</p>
<p>所以说我们一定可以把连续长为k的一段相同的和然后把一段长度小于等于k的随意位置搞到前面去</p>
<p>所以我们可以先把所有的空白段移动到最后然后看前面那些不是空白段的是不是完全匹配</p>
<p>因为如果不一样我们没法动就暴毙了</p>
<p>做法很简单,我们开一个栈然后把长度等于k的平移消除掉就好了,因为他们相当于没用了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
int T, n, k;
char s1[MAXN], s[MAXN], t1[MAXN], t[MAXN];

inline void init(char *str, char *res, int &amp;x) {
	static int len[MAXN], st[MAXN];
	x = 0;
	st[0] = -1;
	len[0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		++x;
		res[x] = str[i];
		if(str[i] - 'a' == st[x - 1]) {
			len[x] = len[x - 1] + 1;
			st[x] = st[x - 1];
		} else {
			len[x] = 1;
			st[x] = str[i] - 'a';
		}
		while(x &gt; 0 &amp;&amp; len[x] == k) {
			x -= k;
		}
	}
}

inline void solve() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s%s&quot;, s + 1, t + 1);
	int sl = 0, tl = 0;
	init(s, s1, sl);
	init(t, t1, tl);
	bool flg = sl == tl;
	for(int i = 1; i &lt;= tl; ++i) {
		flg &amp;= (s1[i] == t1[i]);
	}
	if(flg)puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		solve();
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>考虑直接计数</p>
<p>你会发现只有两两之间的差一起取gcd,然后得到的d的所有的因数可能成为答案</p>
<p>然后要判断这个约数可不可以合法,就是能不能过被卡的位置</p>
<p>首先但凡中间的一定不行,因为我们就不能同时过开头和结尾了</p>
<p>判断条件是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>+</mo><mi>k</mi><mi>b</mi><mo>=</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">st+kb==j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">st==j(mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后两边的就有毒,他会限制我们合法序列的数量....</p>
<p>仔细思考一下应该可</p>
<p>如果两个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">%b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>同余就能限制</p>
<p>那么就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>s</mi><mi>t</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(st-x-1)/x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>暴力实现上面的</p>
<p>复杂度显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d(n)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>std:</p>
<p>复杂度在两个方面,计算合法的序列,判断合法的约数</p>
<p>对于第一步,我们可以lowerbound!</p>
<p>对于第二步,我们可以压所有的质因数指数然后dp,因为一个不合法他的子集就都不合法....</p>
<p>具体的:我们可以用一个dfs类似的东西传导一下我们的限制和前后limit</p>
<p>std:</p>
<p>code:</p>
<pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
#define rep(i, a, b) for (int i = (a); i &lt;= int(b); i++)
#define per(i, a, b) for (int i = (a); i &gt;= int(b); i--)
#define fir first
#define sec second
#define tct template&lt;class type&gt;
using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; P;
const int maxn = 1e5, maxm = 2e6, mod = 1e9 + 7;
int m, c, q[maxn + 5], S[maxn + 5], T, C[maxm + 5];
ll N, K, p[maxn + 5], lst[maxn + 5], nxt[maxn + 5], A[maxm + 5], B[maxm + 5], Num[maxm + 5];

inline void red(int &amp;x) {
	x += x &gt;&gt; 31 &amp; mod;
}
tct inline void cmax(type &amp;x, type y) {
	x &lt; y ? x = y : 0;
}
tct inline void cmin(type &amp;x, type y) {
	x &gt; y ? x = y : 0;
}

struct event {
	int t; ll x;
	bool operator &lt; (const event &amp;o) const {
		return x &lt; o.x;
	}
} ev[maxn + 5];

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

void work(ll N) {
	for (ll i = 2; i * i &lt;= N; i++) if (N % i == 0) {
			p[++c] = i;
			while (N % i == 0) N /= i, q[c]++;
		}
	if (N &gt; 1) p[++c] = N, q[c] = 1;
}

map&lt;ll, int&gt; M;

void dfs(int x, ll y, int z) {
	if (x == c + 1) {//预处理所有约数
		M[y] = z;
		Num[z] = y;
		return;
	}
	z *= q[x] + 1;
	dfs(x + 1, y, z);
	rep(i, 1, q[x]) {
		y *= p[x];
		dfs(x + 1, y, z + i);
	}
}

void dfs0(int x, int z, int y) {
	if (x == c + 1) {//传导
		cmax(A[z], A[z + S[y]]);
		cmin(B[z], B[z + S[y]]);
		C[z] |= C[z + S[y]];
		return;
	}
	z *= q[x] + 1;
	per(i, q[x], 0) {
		if (i == q[x] &amp;&amp; x == y) continue;
		dfs0(x + 1, z + i, y);
	}
}

int main() {
	scanf(&quot;%lld %d&quot;, &amp;N, &amp;m);
	rep(i, 1, m) scanf(&quot;%d %lld&quot;, &amp;ev[i].t, &amp;ev[i].x);
	sort(ev + 1, ev + m + 1);
	ll x = 0, mx = 0, mn = N + 1;
	rep(i, 1, m) if (ev[i].t == 1) {
		if (x) K = gcd(K, ev[i].x - x);
		x = ev[i].x;
		cmax(mx, ev[i].x), cmin(mn, ev[i].x);
	}
	x = 0;
	rep(i, 1, m) {
		if (ev[i].t == 0) lst[i] = x;
		else x = ev[i].x;
	}
	x = N + 1;
	per(i, m, 1) {
		if (ev[i].t == 0) nxt[i] = x;
		else x = ev[i].x;
	}
	work(K);
	dfs(1, 1, 0);
	S[c] = 1;
	per(i, c, 1) S[i - 1] = S[i] * (q[i] + 1);
	T = S[0];
	fill(B, B + T, N + 1);
	rep(i, 1, m) if (ev[i].t == 0) {
		if (!lst[i]) {
			cmax(A[M[gcd(K, nxt[i] - ev[i].x)]], ev[i].x);
		} else if (nxt[i] == N + 1) {
			cmin(B[M[gcd(K, ev[i].x - lst[i])]], ev[i].x);
		} else {
			C[M[gcd(K, gcd(nxt[i] - ev[i].x, ev[i].x - lst[i]))]] = 1;
		}
	}
	rep(i, 1, c) dfs0(1, 0, i);
	int res = 0;
	rep(i, 0, T - 1) if (!C[i]) {
		ll x = (mn - A[i] - 1) / Num[i] + 1;
		ll y = (B[i] - 1 - mx) / Num[i] + 1;
		res = (res + x % mod * y % mod) % mod;
	}
	printf(&quot;%d\n&quot;, res);
	return 0;
}



</code></pre>
<p>数据太水了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
const int P = 1e9 + 7;
int m, T1, T2;
ll N, ans, tot, cnt[MAXN];
struct  rec {
	ll id, x;
	bool operator&lt;(const rec &amp;w)const {
		return x &lt; w.x;
	}
} a[MAXN], b[MAXN], c[MAXN];
int vis[MAXN];


inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

inline void solve(ll x) {
	ll rc1 = 0, rc2 = 0;
	// for(int i = 0; i &lt;= x; ++i)vvis[i] = 0;
	ll tmp1 = 0;
	for(int i = 1; i &lt;= T1; ++i) {
		if(b[i].x &gt; c[1].x) {
			break;
		} else {
			if(b[i].x % x == c[1].x % x)
				tmp1 = b[i].x;
		}
	}
	// printf(&quot;c1 %lld\n&quot;, tmp1);
	rc1 = (c[1].x - tmp1 - 1) / x + 1;
	ll tmp2 = N + 1;
	for(int i = T1; i &gt;= 1; --i) {
		if(b[i].x &lt; c[T2].x) {
			break;
		} else {
			if(b[i].x % x == c[T2].x % x)
				tmp2 = b[i].x;
		}
	}
	// printf(&quot;c2 %lld\n&quot;, tmp2);
	rc2 = (tmp2 - c[T2].x - 1) / x + 1;
	if(tmp2 == N - N % x + c[1].x % x)rc2 += ((N - c[T2].x) % x == 0);
	// printf(&quot;QAQ%lld??%lld %lld %lld %lld\n&quot;, x, rc1, rc2, c[1].x / x + 1, ((N - c[T2].x) / x + 1));
	ans += rc1 * rc2 % P;
	ans %= P;
}

inline void build(ll x) {
	for(ll i = 1; i * i &lt;= x; ++i) {
		if(x % i == 0) {
			cnt[++tot] = i;
			if(i * i != x) {
				cnt[++tot] = x / i;
			}
		}
	}
	sort(cnt + 1, cnt + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		bool flg = 1;
		if(vis[i])continue;
		// printf(&quot;%lld??\n&quot;, cnt[i]);
		for(int k = 1; k &lt;= m; ++k) {
			if((a[k].id == 1) &amp;&amp; ((a[k].x % cnt[i] != c[1].x % cnt[i]) || (c[1].x &gt; a[k].x))) {
				// printf(&quot;%d?\n&quot;, k);
				flg = 0;
			}
			if((a[k].id == 0) &amp;&amp; (a[k].x % cnt[i] == c[1].x % cnt[i]) &amp;&amp; ((c[1].x &lt; a[k].x) &amp;&amp; (c[T2].x &gt; a[k].x))) {
				// printf(&quot;%d!%lld %lld\n&quot;, k, c[1].x, a[k].x);
				flg = 0;
			}
			if(!flg)break;
		}
		if(flg) {
			// printf(&quot;qwq\n&quot;);
			for(int j = i; j &lt;= tot; ++j) {
				if(cnt[j] % cnt[i] == 0 &amp;&amp; !vis[j]) {
					solve(cnt[j]);
					vis[j] = 1;
				}
			}
		}
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%lld%d&quot;, &amp;N, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].id, &amp;a[i].x);
		if(a[i].id == 0) {
			b[++T1] = a[i];
		} else {
			c[++T2] = a[i];
		}
	}
	sort(a + 1, a + m + 1);
	// for(int i = 1; i &lt;= m; ++i) {
	// 	printf(&quot;%lld %lld\n&quot;, a[i].id, a[i].x);
	// }
	sort(b + 1, b + T1 + 1);
	sort(c + 1, c + T2 + 1);
	ll tmp1 = 1;
	tmp1 = c[2].x - c[1].x;
	for(int i = 2; i &lt; T2; ++i) {
		// printf(&quot;%lld %lld\n&quot;, tmp1, c[i + 1].x - c[i].x);
		tmp1 = gcd(tmp1, c[i + 1].x - c[i].x);
		//预处理
	}
	// printf(&quot;%lld\n&quot;, tmp1);
	build(tmp1);//建图
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>