<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-07-31T13:32:49.269Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/">
        </link>
        <updated>2020-07-31T13:26:02.000Z</updated>
        <content type="html"><![CDATA[<p><s>自己抄自己</s></p>
<p>C</p>
<p>50pts直接for就for过去了吧</p>
<p>100pts考虑选取一个素数p，然后mod p意义下只会有n^2/p个</p>
<p>然后先for第一个点，再for第二个点的第一维，然后就能算出y坐标是多少了，再去查表，看那个点是哪个点</p>
<p>你可以发现我们能够exgcd去解决，对于一个点，首先解出一个最小解，然后我们从这个解上去+a'找看有没有对应的，花费总解数solve，如果解很多的放入一个vector中就暴力一下</p>
<p>你会发现由于只有1e9所以很快的，大部分解都很少</p>
<p>B</p>
<p>很套路？分段权值为逆序对数+W</p>
<p>猜一下有决策单调性</p>
<p>结果我们没法在O(1)时间算出逆序对，其实可以莫队？的思路</p>
<p>决策单调性：单调栈/队列上二分</p>
<p>CDQ分治+决策单调性二分</p>
<p>决策单调性二分里面的操作可以参考CF868F Yet Another Minimization Problem</p>
<p>就能做到O(nlog^3n)</p>
<p>如果可以离线可以O(\sqrt n)修改O(1)分块</p>
<p>值域分块就是首先我们处理出每个块内部的前缀和，那么查询时块块之间前缀和+块内前缀和</p>
<p>然后强制在线可以可持久化分块，空间复杂度是带根号的，绝对完蛋啊</p>
<p>A</p>
<p>带  花  树</p>
<p>路径简单，而且颜色交替，而且端点不同，两两不交，端点标记，权值和最大</p>
<p>要么带权匹配，要么带权拟阵交</p>
<p>相当于拆下点然后路径要从黑到白从白到黑，而且两个点之间有一个被选用</p>
<p>并且我们对于两个拆出的点之间连一条边权为0的边</p>
<p>然后对于两个颜色不同的拆点，是一个端点，我们可以再拆出一个新建点来把<br>
点权变成边权</p>
<p>然后对于那个新点连向的那两个拆点的边的边权就是那个点的点权</p>
<p>新建的点两两连边连成完全图，防止我们没有用上而没有完备匹配</p>
<p>然后如果有奇数个标记点我们就再额外开一个新建点，使得这个图有完美匹配</p>
<p>为什么要完备匹配？因为最大权只有完备匹配</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day3/">
        </link>
        <updated>2020-07-30T01:30:05.000Z</updated>
        <content type="html"><![CDATA[<p>考时思路+考后题解</p>
<p>A</p>
<p>首先想了想指数上做操作感觉不太行</p>
<p>然后思考能不能用用他的性质,比如说求和什么的</p>
<p>于是乎对于一个固定的r和右边那个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>确定,你会发现有唯一的一个l与之对应</p>
<p>因为但凡l之后还有可以的一定会导致区间和大于l</p>
<p>于是乎我们不难发现答案小于等于nlogV,因为如果大于的话一定存在一个r和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>对应了多个l</p>
<p>然后考虑对于一个r预处理那个l?可以二分!</p>
<p>不太行,这好像很正解</p>
<p>于是我们利用之前的那个结论就可以解决<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">a_i&lt;=30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>的部分了</p>
<p>再往上有两个问题,1是我们的x是哪log个,2是怎么二分</p>
<p>B</p>
<p>暴力,考虑可以剪枝</p>
<p>不难发现当某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b_i&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>今后也都是0了,所以就可以T掉了</p>
<p>考后std</p>
<p>A</p>
<p>首先这个x显然和区间的最大值比较接近,不会超过一个log!</p>
<p>然后考虑怎么判断这个式子是否成立,考虑随便选几个素数看是否mod左右一下是否相等</p>
<p>然后考虑有个max有两种做法,第一个是笛卡尔树,第二个是分治,第三个是单调栈!</p>
<p>这里用分治</p>
<p>假设最大值在右边...,枚举个右端点假设右边的最大值是M,那么x此时有M+log种</p>
<p>然后我们钦定右边的取到最大值,然后左边的不是最大值,这个可以双指针</p>
<p>然后我们从左边做差一下,因为右边的和已经为S了,左边的和就要是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">2^x-S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,因为双指针我们就一定知道</p>
<p>右端点右移时左端点也只会单调向左移动qwq一层复杂度就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(len)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了</p>
<p>笛卡尔树就可以考虑把每个都变成前缀和然后大概率两两数不同所以就可以一开始就建出来然后查询即可qwq</p>
<p>就是说我们每次只走小的一侧</p>
<p>B</p>
<p>一个初始的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对应了点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_i,b_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,然后那些组合数加起来...</p>
<p>其实就是点(x,y)走到x轴一排点(0,0),(x,0)的方案数</p>
<p>有神仙把两个int压成一个longlong然后循环展开重载取模就n^2过十万......了</p>
<p>考虑先把y轴分块,把每个序列切成一条条的,y坐标相差w</p>
<p>然后把每个点走到底下的方案数记成一个数组f</p>
<p>如果我们求出了上面的一条的f方案数就能求出下面一条的g方案数</p>
<p>因为对于下面一条线的一个点i<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>i</mi></mrow></msub><msub><mi>f</mi><mi>j</mi></msub><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>+</mo><mi>w</mi></mrow><mi>w</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g_i=\sum_{j&gt;=i}f_{j}\binom {j-i+w} {w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.341482em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&gt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>然后两条之间的点怎么加入?相当于加上了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>a</mi></msup><mo>∗</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^a*(1-x)^{-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span>你发现这个东西是全部都要变的</p>
<p>然后你会发现最后要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mo>−</mo><mi>w</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {(1-x)^{-w}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7026642857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>就可以使得我们加上的东西变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>a</mi></msup><mo>∗</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mi>w</mi><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^a*(1-x)^{w-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span>这个是卷积的,是最多w的qwq</p>
<p>注意我们把整个数组要翻转一下!!</p>
<p>具体的</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596097928930.png" alt="" loading="lazy"></figure>
<p>你考虑其中负的那个就是对应了计数个-1相乘,而偶数的则是mod P的花样写法</p>
<p>然后f数组应该乘上那个从那一行走下去的方案数</p>
<p>但是最后我们还要卷上一个东西</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596094800297.png" alt="" loading="lazy"></figure>
<p>我承认还是不会,弃了弃了/se</p>
<p>暂切掉</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
#define ll long long
using namespace std;
const int MAXN = (1 &lt;&lt; 18) + 5;
const int P = 998244353;
const int G0 = 332748118;
const int G1 = 3;
int n, a[MAXN], b[MAXN];
vector&lt;pair&lt;int, int&gt; &gt; v[MAXN];

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void reduce(ll &amp;x) {
	x += x &gt;&gt; 31 &amp; P;
}

int fac[MAXN], ifac[MAXN];
ll  f[MAXN], g[MAXN], h[MAXN];

int C(int n, int k) {
	return 1ll * fac[n] * ifac[k] % P * ifac[n - k] % P;
}

inline void Init() {
	fac[0] = 1;
	ifac[0] = 1;
	for(int i = 1; i &lt; MAXN; ++i)fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[MAXN - 1] = ksm(fac[MAXN - 1], P - 2);
	for(int i = MAXN - 2; i; i--)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	ifac[1] = 1;
}

int L, len;
int R[MAXN];
void init(int n) {
	len = 1;
	while(len &lt;= n) {
		len &lt;&lt;= 1;
		L++;
	}
	for(int i = 1; i &lt; len; ++i) {
		R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1));
	}
	return ;
}

void NTT(ll *F, int typ = 0) {
	for(int i = 0; i &lt; len; ++i)
		if(i &lt; R[i])swap(F[i], F[R[i]]);
	int s, t;
	for(int mid = 1; mid &lt; len; mid &lt;&lt;= 1) {
		ll wn = ksm(typ == -1 ? G0 : G1, (P - 1) / (mid &lt;&lt; 1));
		for(int j = 0; j &lt; len; j += (mid &lt;&lt; 1)) {
			ll w = 1;
			for(int k = 0; k &lt; mid; ++k, w = wn * w % P) {
				ll x = 1ll * F[j + k], y = 1ll * w * F[j + k + mid] % P;
				F[j + k] = (1ll * x + y) % P;
				F[j + k + mid] = (1ll * x - y + P) % P;
			}
		}
	}
	if(typ == -1) {
		ll iv = ksm(len, P - 2);
		for(int i = 0; i &lt; len; ++i) {
			F[i] = 1ll * F[i] * iv % P;
		}
	}
	return ;
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int B = sqrt(n * log(n)) + 1;
	Init();
	for(int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);
		a[i] = n - a[i] - 1;
		b[i] = n - b[i] - 1;
		v[a[i] / B].push_back(mkp(a[i], b[i]));
	}
	// printf(&quot;%d %d\n&quot;, C(5, 2), C(3, 1));
	init(2 * n + 1);
	for(int i = n / B; i &gt;= 0; --i) {
		if(!v[i].empty()) {
			memset(f, 0, sizeof(f));
			memset(g, 0, sizeof(g));
			for(int j = 0; j &lt;= i * B; ++j) {
				f[j] = (j &amp; 1 ? P - C(i * B, j) : C(i * B, j));
			}

			for(auto j : v[i]) {
				int t = j.first % B;
				// printf(&quot;%d %d %d\n&quot;, t, j.second + k, C(t, k));
				for(int k = 0; k &lt;= t; ++k) {
					// printf(&quot;%d %d %d\n&quot;, t, j.second + k, C(t, k));

					reduce(g[j.second + k] += (k &amp; 1 ? -C(t, k) : C(t, k) - P));
				}
			}

			// for(int j = 0; j &lt; len; ++j) {
			// 	printf(&quot;%d %d\n&quot;, g[j], f[j]);
			// 	// h[j] = (h[j] + 1ll * f[j] * g[j] % P) % P;
			// }
			NTT(f);
			NTT(g);
			for(int j = 0; j &lt; len; ++j) {
				// printf(&quot;%d %d?\n&quot;, g[j], f[j]);
				h[j] = (h[j] + 1ll * f[j] * g[j] % P) % P;
			}
		}
	}
	NTT(h, -1);
	for(int i = 0; i &lt; n; ++i)g[i] = 1ll * fac[i + n - 1] * ifac[n - 1] % P * ifac[i] % P;
	for(int i = n; i &lt; len; ++i)h[i] = g[i] = 0;
	NTT(h);
	NTT(g);
	for(int i = 0; i &lt; len; ++i)h[i] = 1ll * h[i] * g[i] % P;
	NTT(h, -1);
	for(int i = n - 1; i &gt;= 0; --i)printf(&quot;%d &quot;, h[i]);
	puts(&quot;&quot;);
	return 0;
}

</code></pre>
<p>C</p>
<p>两个点匹配的权值是他们中间的最大值,中间的那些数字是随机的,问最大权期望是多少</p>
<p>最直接找规律???每个元素在答案中的贡献只和他是第几大有关系</p>
<p>四个点你会发现最优的一定是下图中中间的那个</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596094791364.png" alt="" loading="lazy"></figure>
<p>所以每四个点都要长成这样子</p>
<p>所以有n个点必然要前n/2和后面连接</p>
<p>然后问题变成了所有长度为n/2的最大值之和然后这个就可以发现他只和第几大有关系了(有多少个比他少)</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596094622143.png" alt="" loading="lazy"></figure>
<p>意思就是我们从比他小的选出n/2-1个构成,然后这一段再有n/2个位置可以放,然后再考虑其中顺序是有(n/2-1)!种,然后再考虑其他n/2个数随便排序为(n/2)!</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
const int MAXN = 3e5 + 7;
const int P = 998244353;

int n, a[MAXN];

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int fac[MAXN], ifac[MAXN];

inline ll C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	sort(a + 1, a + n + 1);
	fac[0] = 1;
	for(int i = 1; i &lt;= n * 2; ++i) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n * 2] = ksm(fac[n * 2], P - 2);
	for(int i = n * 2 - 1; i &gt;= 2; --i) {
		ifac[i] = 1ll * (i + 1) * ifac[i + 1] % P;
	}
	ifac[0] = 1;
	ifac[1] = 1;
	ll ans = 0;
	int m = (n + 1) &gt;&gt; 1;
	for(int i = m; i &lt;= n; ++i) {
		ll tmp = 1ll * C(i - 1, m - 1) * (m) % P;
		tmp = tmp * fac[m] % P * fac[m - 1] % P;
		ans = (ans + tmp * a[i] % P) % P;
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF区间最小差]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf-qu-jian-zui-xiao-chai/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf-qu-jian-zui-xiao-chai/">
        </link>
        <updated>2020-07-29T14:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>忘了原题题号了QAQ</p>
<p>https://acm.nflsoj.com/problem/442</p>
<p>这是个加强版,带上了个系数,做法可能有所不同</p>
<p>查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">i,j \in [l,r]min|a_i-a_j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></p>
<p>然后考虑怎么做,可以利用值域减半原理</p>
<p>我们尝试处理出每个点i的最优点对(i,j),即能在i,j区间作为i的最优答案的数对</p>
<p>首先我们对于i,i-1可以算出一个最近点对,然后考虑能不能作为目标更新下一个</p>
<p>首先你要发现i-1肯定也按照我们的原则处理出了一些最近点对....</p>
<p>那么也就是说下一个更靠前的j要作为答案,当且仅当不能和i-1成为最优而和i成为最优</p>
<p>也就是说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>而不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>更近</p>
<p>于是乎就可以发现这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>&lt;</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_j&lt;|a_{i-1}-a_{i}|/2+a_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>那么你会发现这个值域减少了一半</p>
<p>所以我们对于i最多会有logX个最优点对</p>
<p>全局一共有nlogX个</p>
<p>那么对于所有询问可以离线到右端点上</p>
<p>然后每次到点i时把点i所形成的最优点对以左端点为下标放入到线段树上,相当于扫描线</p>
<p>你会发现答案就是一个区间查询最小值</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2nlog_2X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>实际可以跑不满</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF377E Cookie Clicker]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf377e-cookie-clicker/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf377e-cookie-clicker/">
        </link>
        <updated>2020-07-24T14:45:29.000Z</updated>
        <content type="html"><![CDATA[<p>每日推荐</p>
<p>建议标签:凸包+栈</p>
<p>首先我们可以考虑怎么二分,因为如果一个时间点之前的可以那么之后的也一定可以</p>
<p>然后你会发现好像不太会写check函数,因为如果使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>DP的话就不需要二分了.....</p>
<p>有一个显然的性质是我们只会使用当前最优的工厂,而且我们达到S之前一定有一段连续使用一个工厂...</p>
<p>然后我冥思苦想了一下,突然脑袋里浮现出<s>斜率优化时的</s>凸包</p>
<p>如果我们把time当做x轴,value当做y轴的话,我们就可以把每个工厂看成一个直线了,不用管截距,至少他的斜率很显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>那么截距其实就是达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时的最优金币数X可以算出的!</p>
<p>哎?如果我们知道了截距,每个工厂的射线是不是就能围成一个<strong>每秒最优金币数的凸包</strong>了啊?</p>
<p>所以我们就是要对这些个直线进行处理,我们先把工厂按照代价排序,这样我们一定先可解锁之前的再解锁之后的</p>
<p>问题就变成我们对于之前的某个凸包状态可以计算出下一条新直线然后update新凸包的状态</p>
<p>做法也就很显然了:维护一个单调栈,栈中记录一条射线的起点坐标和斜率</p>
<p>然后枚举下个工厂,计算与凸包的交点,就是用单调栈计算出对于那个代价第一次达到的时间点以及最优金币数X,得到就可得到下一条射线</p>
<p>用这条射线加入单调栈,就是找他和凸包的交点,然后弹出不再是凸包的直线,可以证明在排序后一定是从栈顶连续的一些被弹出,而且之前计算的过程也一定是从栈底单调递增的一些射线和他求交,所以维护凸包的过程复杂度O(n)</p>
<p>最后复杂度在于排序的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>思路有些凌乱繁琐,但是做法还是很好懂的吧</p>
<p>未完code待续</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1100F Ivan and Burgers]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/">
        </link>
        <updated>2020-07-23T14:49:57.000Z</updated>
        <content type="html"><![CDATA[<p>静态区间线性基</p>
<p>考虑chz菜者的做法:离线扫描线,然后从1~n维护一个后缀线性基,每次插入一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,就暴力从i到1全部更新一遍,更新不动了就停止,可以证明此复杂度均摊<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>6</mn><msup><mn>4</mn><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*64^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,荣获0pts的好成绩!</p>
<p>然后您发现我们复杂度主要在于插入时的更新,如果我们只更新<strong>1次</strong>就能起到n次的效果就好了...</p>
<p>于是我们有一个贪心的想法,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">pos[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示前i个数第j个基最靠右的位置,然后我们对于插入x的过程,可以贪心的只找最靠右的位置进行更新....</p>
<p>其实这个思想并不巧妙,早在区间数字种类的时候就用到过这样的扫描线贪心,但是对于线性基不太会所以没做出来QAQ</p>
<p>然后您发现有点细节,就是pos的更新,想想就好了,我们其实是在<strong>多个线性基上横跳的</strong>过程</p>
<p>所以一次可能会更新多个pos?不过没关系,因为我们但凡要更新新的值就一定要^上之前某个基,那么我们之后的就相当于只能更新之前某个基之后的某个基了!</p>
<p>其实看看代码就好</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXN = 5e5 + 7;
int n, Q;
int a[MAXN];
int bsc[MAXN][22], lst[MAXN][22];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1, t, npos; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		for(int k = 0; k &lt;= 21; ++k)bsc[i][k] = bsc[i - 1][k], lst[i][k] = lst[i - 1][k];
		t = a[i];
		npos = i;
		for(int k = 21; k &gt;= 0; --k) {
			if(!(t &gt;&gt; k) &amp; 1)continue;
			if(!bsc[i][k]) {
				bsc[i][k] = t;
				lst[i][k] = npos;
				break;
			}
			if(lst[i][k] &lt; npos) {
				swap(t, bsc[i][k]);
				swap(lst[i][k], npos);
			}
			t ^= bsc[i][k];
		}
	}
	scanf(&quot;%d&quot;, &amp;Q);
	for(int i = 1, x, y; i &lt;= Q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		int ans = 0;
		for(int k = 21; k &gt;= 0; --k) {
			// printf(&quot;%d %d %d %d\n&quot;, bsc[y][k], lst[y][k], ans ^ bsc[y][k], ans);
			if(lst[y][k] &gt;= x &amp;&amp; (ans ^ bsc[y][k]) &gt; ans)
				ans ^= bsc[y][k];
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF613E Puzzle Lover]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf613e-puzzle-lover/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf613e-puzzle-lover/">
        </link>
        <updated>2020-07-21T14:38:33.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020国家集训队作业</p>
<p>重 操 旧 业 估计应该能做完part1,part2,part3都是AT题不太行啊</p>
<ul>
<li>给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2 \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵，每个位置上有一个小写字母。</li>
<li>有一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的小写字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，询问矩阵中有多少条有向路径满足以下条件：
<ul>
<li>路径上的字母连起来恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>。</li>
<li>不多次经过同一个位置。</li>
<li>只能向上下左右四个方向走。</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n,k \le 2 \times 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。</li>
</ul>
<p>首先想少的我想DP,dp[i][j][k][l]表示前i列第j行,然后匹配了k个位置,前一个转折点在l的最多方案数是什么</p>
<p>显然是没法转移的,因为我们成环,而且可能像蛇一样弯曲前行...</p>
<p>但是转念一想这个环是不是太过basic了?好像不会复杂</p>
<p>就是说一个回头路一定是在字符串的开头或者结尾才有可能?</p>
<p>就例如下图,这是最复杂的路径情况了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1595342780332.png" alt="" loading="lazy"></figure>
<p>然后我们可以想办法搞定这个...中间部分?</p>
<p>你发现中间部分是蜿蜒曲折的,两边的回头路是简单的</p>
<p>所以我们可以只考虑中间设计dp,f[i][j][k]表示点i,j匹配了k的方案数并且<strong>下一步</strong>只能走同一行的点,g[i][j]表示点i,j匹配了k的方案数并且下一步只能走同一列的点转移</p>
<p>然后怎么算呢?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f_{i,j,k}=\sum{f_{i,j-1,k-1}[ch_{i,j+1}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">g_{3-i,j,k}=\sum{f_{i,j,k-1}[ch_{3-i,j}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f_{i,j,k}=\sum{g_{i,j-1,k-1}[ch_{i,j+1}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p>第三个转移的意思是我们考虑转一个弯之后又向前走了一步,当然也是可以的qwq,3-i是第一二行之间切换</p>
<p>然后两边部分QAQ,你发现我们决定哪个为起点会影响中间这个DP过程啊</p>
<p>不过您又机智的发现这个是一个可以预处理然后特判能不能相等的部分,也就是说我们可以搞搞DP数组的初值来解决他?</p>
<p>具体的,对于如果从S走长度为大于1的x的回头路,我们可以看这个回头路能不能匹配串的前2x个字符,如果能,说明从S另一列的位置处<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>2</mn><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{3-i,j,2x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可以置为1</p>
<p>若长为等于1,说明就是从S向下走了一步,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可以置为1</p>
<p>同时,如果这个点本身就是能匹配的,说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可置为1</p>
<p>为什么只用g数组初始化?因为f数组可以和g相互update,同时我们统计答案也是看g数组的</p>
<p>然后我们再考虑T的部分,也就是统计答案这部分QAQ</p>
<p>首先我们第三维小于m,<s>给T一点面子</s></p>
<p>然后如果T处一个长为x的后缀回头路可以匹配后2x个字符的话,我们就把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msub><mo>+</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j-1,m-2x}+g_{i,j-1,m-2x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>统计入答案,相当于我们手动走这最后一步</p>
<p>然后我们发现我们没有处理从右往左走的情况,所以可以把串翻转之后再跑一遍上述过程....</p>
<p>然后您惊人的发现我们算重了,但是只算重了S和T在<strong>同一列</strong>的情况,所以这个很好用hash处理,就可以放在外面再加上!</p>
<p>然后我们就完成了一道国家集训队作业题....QAQ</p>
<p>未完code待续</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4310 绝世好题]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4310-jue-shi-hao-ti/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4310-jue-shi-hao-ti/">
        </link>
        <updated>2020-07-20T14:38:32.000Z</updated>
        <content type="html"><![CDATA[<p>这个DP妙啊</p>
<p>首先拿到题我们有dp[i][j]表示到i为止前一个数为j的最长and不为0序列是什么</p>
<p>然后转移时考虑枚举上一个哪个and起来不为0就好</p>
<p>但是这样你会发现没办法优化,问题是出在状态不够优秀上....</p>
<p>考虑二进制每一位都是独立的,那我们可不可以dp第二维记某一位为1的然后转移呢?</p>
<p>好像可以,但是转移的时候要小心了,对于数a,它能使所有二进制下a&amp;为1的状态都加一,<strong>也能使所有二进制为1的状态之间互相转移!</strong></p>
<p>举个例子,3可以使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>)</mo><mo>+</mo><mn>1....</mn></mrow><annotation encoding="application/x-tex">dp[2]=max(dp[1],dp[2])+1....</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>代码也就不难了</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN=1e5+7;

int n;
int a[MAXN],dp[MAXN],ans;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1; i&lt;=n; ++i) {
		int qwq=0;
		for(int j=0; j&lt;=30; ++j) {
			if(a[i]&amp;(1&lt;&lt;j)) {
				qwq=max(dp[j],qwq);
			}
		}
		for(int j=0; j&lt;=30; ++j) {
			if(a[i]&amp;(1&lt;&lt;j)) {
				dp[j]=max(dp[j]+1,qwq+1);
			}
		}
	}
	for(int j=0; j&lt;=30; ++j) {
		ans=max(ans,dp[j]);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;

}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5894 [IOI2013]robots 机器人]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5894-ioi2013robots-ji-qi-ren/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5894-ioi2013robots-ji-qi-ren/">
        </link>
        <updated>2020-07-20T14:28:31.000Z</updated>
        <content type="html"><![CDATA[<p><code>&quot;当苦夏簌簌扑着扇，听过最后一声蝉&quot;</code></p>
<p>蛮不错的贪心,<s>不过灰题真的香</s></p>
<p>首先为啥具有二分性呢?因为如果我们k秒可以完成那么k+1秒也一定可以完成</p>
<p>然后我们就可以考虑二分一个ans,然后题目中的限制可以建图跑网络流,然后一看数据范围直接放弃</p>
<p>所以<s>网络流不过就是贪心</s>,因为只有两维我们能很简单的贪一下qwq</p>
<p>对于弱机器人,我们把玩具按照重量排序,然后每个机器人尽可能拿能拿的体积大的,并且机器人从小到大去选择,可以拿堆维护</p>
<p>剩下的玩具如果有小机器人拿不了的就完蛋</p>
<p>看上去很简单,但是要小心我们堆里存的东西一定是当前可以拿的...</p>
<p>吐槽一下神翻译小机器人和弱机器人让我笑好久</p>
<p>以及特判一些情况/xyx</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
const int MAXN = 1e6 + 7;
using namespace std;
int n, A, B, ans = -1;
int a[MAXN], b[MAXN];
struct rec {
	int w, s;
	bool operator&lt;(const rec &amp;x) {
		if(w == x.w)return s &lt; x.s;
		return w &lt; x.w;
	}
} t[MAXN];

priority_queue&lt;int&gt; heap;
inline int chk(int x) {
	int l = 1, j = 1;
	while(!heap.empty())heap.pop();
	for(int i = 1; i &lt;= n; ++i) {
		if(l &gt; A) {
			heap.push(t[i].s);
			continue;
		}
		if(a[l] &gt; t[i].w) {
			heap.push(t[i].s);
		} else {
			while(a[l] &lt;= t[i].w &amp;&amp; l &lt;= A) {
				j = 1;
				while(j &lt;= x &amp;&amp; !heap.empty()) {
					++j;
					heap.pop();
				}
				++l;
			}
			heap.push(t[i].s);
		}
	}
	for(int i = l; i &lt;= A; ++i) {
		j = 1;
		while(j &lt;= x &amp;&amp; !heap.empty()) {
			++j;
			heap.pop();
		}
	}
    //特判有的强机器人能拿光所有的
	for(int i = B; i &gt;= 1; --i) {
		j = 1;
		while(j &lt;= x &amp;&amp; !heap.empty()) {
			++j;
			l = heap.top();
			if(l &gt;= b[i])return 0;
			heap.pop();
		}
		if(heap.empty())break;
	}
	if(!heap.empty())return 0;
	//还有没空的
	return 1;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;n);
	for(int i = 1; i &lt;= A; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	sort(a + 1, a + A + 1);
	for(int i = 1; i &lt;= B; ++i)scanf(&quot;%d&quot;, &amp;b[i]);
	sort(b + 1, b + B + 1);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d%d&quot;, &amp;t[i].w, &amp;t[i].s);
	sort(t + 1, t + n + 1);
	int L = 1, R = n, mid;
	while(L &lt;= R) {
		mid = (L + R) &gt;&gt; 1;
		if(chk(mid)) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3177 [HAOI2015]树上染色]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3177-haoi2015shu-shang-ran-se/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3177-haoi2015shu-shang-ran-se/">
        </link>
        <updated>2020-07-20T14:19:26.000Z</updated>
        <content type="html"><![CDATA[<p><code>“将我大汉军旗插遍大漠草原！”</code></p>
<p><s>封面图小姐姐好色气啊</s></p>
<p>及树上DP的一些总结qwq</p>
<p>首先说说这个题,dp[i][j]表示点i的子树里选了j个黑点目前得到的最大贡献是什么</p>
<p>贡献是指i子树里所有边的贡献,转移时考虑i到v这条边的贡献,两侧共有多少个黑白点乘一下就好啦</p>
<p>然后这样子好像再套个树形背包就解决了!</p>
<p>下面说下树形DP的坑点</p>
<ol>
<li>
<p>转移时,我们枚举要从大到小枚举,第一重循环不这样做会导致完全背包,第二重循环不这样做如果循环内有0(比如这题0个黑点情况)就会导致先更新后又更新</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">siz[u]+=siz[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>要之后加,否则一条链就卡掉了</p>
</li>
</ol>
<p>别的好像没啥了</p>
<p>再说下树的直径?</p>
<p>dp[u]表示点u最长链</p>
<p>当发现dp[v]+1&gt;dp[u]时,我们先把这两条链拼起来更新答案再update u</p>
<p>别的没了qwq<s>可能还有什么树上容斥?没做啊</s></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define int long long
const int MAXN = 3500;

int n, M, ccnt, N;
int dp[MAXN][MAXN], siz[MAXN];
int home[MAXN * 2], nxt[MAXN * 2], to[MAXN * 2], len[MAXN * 2];

inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	to[ccnt] = y;
	home[x] = ccnt;
	len[ccnt] = z;
}

inline void dfs(int u, int F) {
	siz[u] = 1;
	for(int i = home[u], val; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		for(int j = min(M, siz[u]); j &gt;= 0; --j) {
			for(int k = min(M, siz[v]); k &gt;= 0; --k) {
				val = len[i] * k * (M - k) + len[i] * (siz[v] - k) * (N - siz[v] + k);
				dp[u][j + k] = max(dp[u][j + k], dp[u][j] + dp[v][k] + val);
			}
		}
		siz[u] += siz[v];
	}
	return ;
}


signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;M);
	N = n - M;
	for(int i = 2, x, y, z; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
		ct(x, y, z);
		ct(y, x, z);
	}
	dfs(1, 0);
	printf(&quot;%lld\n&quot;, dp[1][M]);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3523 [POI2011]DYN-Dynamite]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3523-poi2011dyn-dynamite/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3523-poi2011dyn-dynamite/">
        </link>
        <updated>2020-07-17T14:50:58.000Z</updated>
        <content type="html"><![CDATA[<p>读错题题</p>
<p>读错题的题面:</p>
<p>给一棵树,您要选择m个地方放点,满足两两之间最小值最大</p>
<p>相当于二分答案后,每个点之间都要相差x....</p>
<p>然后这个显然可以N^2,但是O(n)?</p>
<p>贪心的想,我们坑定要从深度大的开始选才能最多</p>
<p>好像我们可以放一个点就把一些点缩起来,然后这些点之后一定不能再被选,而其他点一定可选,但是这样我们虽然保证了每次缩的是一个连通块,却不能在合法的时间复杂度里解决....</p>
<p>比如一个大块,然后边上有很多小点,每次我们判断能不能再缩都是O(n)的....QAQ</p>
<p>不过跑不太满</p>
<p>给一棵树,树上有一些关键节点，要求你选m个点，使得关键节点到这些点中距离的最小值的最大值最小，求这个值</p>
<p>也是考虑二分+贪心,那么我们对于二分出的值,我们要满足key点到放置点的距离不能大于了</p>
<p>所以可以从底层开始贪心,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树中最远的key点距离,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树最近的choice点距离</p>
<p>那么如果f_i+g_i&lt;=mid,就可以凑齐,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>变为-inf</p>
<p>否则如果f_i==mid,就要把i设置为新点啦</p>
<p>你说莫名的TLE?我尼玛咋知道啊?</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf = 1e7 + 7;
const int MAXN = 6e5 + 7;

int is[MAXN / 2], f[MAXN / 2], g[MAXN / 2], Cnt, n, m, Mid;
int home[MAXN], nxt[MAXN], to[MAXN], ccnt;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u, int F) {
	f[u] = -inf;
	g[u] = inf;
	if(is[u])f[u] = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		f[u] = max(f[v] + 1, f[u]); //update f
		g[u] = min(g[u], g[v] + 1); //update g
	}
	if(f[u] + g[u] &lt;= Mid) {
		f[u] = -inf;
	}
	if(f[u] == Mid) { //furthst
		++Cnt;
		g[u] = 0;
		f[u] = -inf;
	}
	//	printf(&quot;%d %d %d\n&quot;,u,f[u],g[u]);
	return ;
}

inline int chk() {
	Cnt = 0;
	dfs(1, 0);
	if(f[1] &gt;= 0)Cnt++;
	if(Cnt &lt;= m)return 1;
	else return 0;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;is[i]);
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	int L = 0, R = n, ans;
	while(L &lt;= R) {
		Mid = (L + R) &gt;&gt; 1;
		if(chk()) {
			ans = Mid;
			R = Mid - 1;
		} else L = Mid + 1;
	}

	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>