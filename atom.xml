<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-08-26T14:56:41.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[P4099 [HEOI2013]SAO ]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/">
        </link>
        <updated>2020-08-26T11:21:51.000Z</updated>
        <content type="html"><![CDATA[<p>n-1条边有向弱联通图拓扑序计数</p>
<p>咋做啊?</p>
<p>首先我们应该注意到是树,而不是那个阴间的npc问题</p>
<p>类似于一坨坨的序列合并...我们就要想是整个一坨合并还是插入合并?</p>
<p>这个题显然拓扑序列是可以两个子树之间穿插的,所以我们转移的时候就要用穿插的方式转移</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 8: f_{i,j}$̲$表示点i在拓扑序的j号位置的…'>f_{i,j}$$表示点i在拓扑序的j号位置的方案数是什么

转移时,对于一条连向儿子的边,u要么能放在v前,要么能放在v后

也就是说.......u.....v......,或者...v.....u......

这个其实限制了状态的转移,也就是那些状态能够转移过来

然后我们要分配儿子,因为我们还有兼具合并v的重任所以上组合数把!

钦定$v&lt;u$硬点u在拓扑序原来的排名为l,而合并之后的排名为k,所以前面的总可能是$\binom{k-1}{l-1}$,就是l-1个点分在原子树里

紧接着会发现我们有$siz[u]+siz[v]-k$个数还没用呢....因为我们枚举了原来的排名为l,所以$siz[u]-l$就是原来放在另外拓扑序后面的数数量,所以我们再$*\binom{siz[u]+siz[v]-k}{siz[u]-l}$表示我们把后面部分选好

$$f_{u,j}=\sum_{l&lt;siz[v]}\sum_{k&lt;l}f_{u,l}*f_{v,k}*\binom{j-1}{l-1}\binom{siz[u]+siz[v]-k}{siz[u]-l}</p>
<p>就是这个转移方程了</p>
<p>钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>&gt;</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">v&gt;u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span></p>
<p>其实很对称啊,我们会发现之前组合数的部分都不用变,改变的是转移的范围</p>
<p>假设第一维枚举原来的点数,第二维枚举v向前给出多少个点的贡献(就是u新的排名会后移啊.....),因为此时v可能不会再影响u原来的排名后移了</p>
<p>第三维枚举的就是我们实际的比u多的rank,这里一开始自闭了一下,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{v,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>其实也可以表示v比u大k的方案..</p>
<p>总的来说,这个转移共有两个细节</p>
<ol>
<li>计算新排名时要组合新排名前面的数和新排名之后的数</li>
<li>计算新排名的时候要仔细想想枚举什么,以及对应乘上的dp状态</li>
</ol>
<p>按理说应该直接枚举新u的排名的,代码没有这样写</p>
<p>最后对了还有一个前缀和优化,仔细看看代码就会感觉是临时加上去的.....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 1e3 + 7;
const int MAXM = 2e3 + 7;
int n, ccnt, T, home[MAXN], nxt[MAXM], to[MAXM], flg[MAXM];

inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	flg[ccnt] = z;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int dp[MAXN][MAXN], siz[MAXN], f[MAXN][MAXN], C[MAXN][MAXN], sum[MAXN][MAXN];
// ll fac[MAXN], ifac[MAXN];
inline void INIT() {
	C[0][0] = 1;
	for(int i = 1; i &lt; MAXN; ++i) {
		C[i][0] = 1;
		for(int j = 1; j &lt;= i; ++j) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;
		}
	}
	return ;
}

inline void init() {
	memset(home, 0, sizeof(home));
	ccnt = 0;
	memset(dp, 0, sizeof(dp));
}

inline void add(int &amp;x, ll y) {
	x += y;
	// printf(&quot;?%d?%d?\n&quot;, x, y);
	if(x &gt; P)
		x -= P;
}

inline void dfs(int u, int F) {
	siz[u] = 1;
	dp[u][1] = 1;
	// printf(&quot;u is :%d?\n&quot;, u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		// printf(&quot;u %d and back v %d?\n&quot;, u, v);
		for(int k = 1; k &lt;= n; ++k)
			f[u][k] = 0;
		if(flg[i] == 1) {//之前边,u在v之前
			// printf(&quot;u is v front front is :%d back is :%d\n&quot;, u, v);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举u原来点数
				for(int k = 0; k &lt;=  siz[v]; ++k) { //枚举v给出的贡献
					// for(int l = k + 1; l &lt;= siz[v]; ++l) {
					int del = ((sum[v][siz[v]] - sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[j + k - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][ siz[u] - j] % P);
					// printf(&quot;but each size is%d %dget ans:%d\n&quot;, siz[u], siz[v], f[u][j + k]);
					// }
				}
			}
		} else {//u在v之后
			// printf(&quot;u is v back front is :%d back is :%d\n&quot;, v, u);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举新u的点数
				for(int k = 1; k &lt;= siz[v]; ++k) {
					// for(int l = 1; l &lt;= k; ++l) {
					int del = ((sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[k + j - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][siz[u] - j] % P) ;
					// printf(&quot;but each size is%d %d\n&quot;, siz[u], siz[v]);
					// }
				}
			}
		}
		siz[u] += siz[v];
		for(int k = 1; k &lt;= n; ++k)
			dp[u][k] = f[u][k];
	}
	// printf(&quot;%d?\n&quot;, u);
	for(int i = 1; i &lt;= n; ++i) {
		sum[u][i] = (sum[u][i - 1] + dp[u][i]) % P;
		// add(sum[u][i], sum[u][i - 1]);
		// add(sum[u][i], dp[u][i]);
		// printf(&quot;!%d??%d %d\n&quot;, sum[u][i], sum[u][i - 1], dp[u][i]);
	}
	return ;

}
char s[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;T);
	INIT();//大预处理
	// printf(&quot;%d %d %d\n&quot;, C[10][2], C[5][3], C[6][4]);
	while(T-- &gt; 0) {
		init();
		scanf(&quot;%d&quot;, &amp;n);
		for(int i = 1, x, y; i &lt; n; ++i) {
			scanf(&quot;%d&quot;, &amp;x);
			cin &gt;&gt; s;
			scanf(&quot;%d&quot;, &amp;y);
			++x;
			++y;
			// printf(&quot;%d %d\n&quot;, x, y);
			//&lt;说明x在y之前打
			if(s[0] == '&lt;') {
				// puts(&quot;Y&quot;);
				ct(x, y, 1);
				ct(y, x, 0);
				//变向说明y在x之后
			} else {
				// puts(&quot;N&quot;);
				//x在y之后打
				ct(x, y, 0);
				ct(y, x, 1);
				//说明y在x之前打
			}
		}
		dfs(1, 0);
		int ans = 0;
		for(int i = 1; i &lt;= n; ++i)
			add(ans, dp[1][i]);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<p>zzz</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3515 [POI2011]Lightning Conductor]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/">
        </link>
        <updated>2020-08-26T10:30:21.000Z</updated>
        <content type="html"><![CDATA[<p>唉...二分是又一个细节吧.....</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>+</mo><msqrt><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow></msqrt><mo>&lt;</mo><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">a_j+\sqrt{|i-j|}&lt;=a_i+p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.25612499999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.983875em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span></span></span><span style="top:-2.9438750000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25612499999999994em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p>
<p>拿到题我们就应该想到找每个数上述式子最大的j</p>
<p>观察后面根号函数,你会发现他的导函数单调递减!有决策单调性了</p>
<p>而与此同时我们要求的是最大值,所以可以用单调队列来优化</p>
<p>就是单调队列优化决策单调性的板子.....</p>
<p>直接上就好了,正着做一遍反着来一遍</p>
<p>然后最后处理答案随便搞一下就好</p>
<p><strong>但是nmd卡细节</strong></p>
<p>记得我们决策单调性有一个二分的步骤吗?</p>
<p>里面我们的l,r一定要限制好范围!!!!</p>
<p>对于r,如果k[r]存在(即有右端点的限制)我们就设置右端点为r</p>
<p>对于l,我们输入了x,y两个决策点想要找一个不错的,所以我们左端点应该在y之后!</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><msub><mi>k</mi><mi>y</mi></msub><mo>?</mo><msub><mi>k</mi><mi>y</mi></msub><mo>+</mo><mn>1</mn><mo>:</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=k_y?k_y+1:n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">?</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>但是这样诗人小G又不能过,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">k_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>一看就很扯吗...),所以我暴力改改参数得到了普适应的一组参数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>以后就用这组</p>
<p>二分用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l&lt;r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>锁定答案形式</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define db double
const int MAXN = 5e5 + 7;
int n, a[MAXN], que[MAXN], k[MAXN];
db sq[MAXN], f[MAXN];

inline db calc(int x, int y) {
	return a[y] + sq[x - y];
}

inline int bound(int x, int y) {
	int l = y, r = k[y] ? k[y] + 1 : n + 1, mid;
	while(l &lt; r) {
		mid = (l + r) &gt;&gt; 1;
		calc(mid, x) &gt; calc(mid, y) ? l = mid + 1 : r = mid;
	}
	return r;
}	 

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	for(int i = 0; i &lt;= n; ++i)
		sq[i] = sqrt(i);
	int h = 1, t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;calc in -&gt;%d by%d\n&quot;, i, que[h]);
		f[i] = calc(i, que[h]);
		// printf(&quot;we get :%lf?\n&quot;, f[i]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;she controlled :%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	reverse(a + 1, a + n + 1);
	reverse(f + 1, f + n + 1);
	h = 1, t = 0;
	memset(k, 0, sizeof(k));
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;qwq-&gt;:%d %d %lf\n&quot;, i, que[h], f[n - i + 1]);
		f[i] = max(f[i], calc(i, que[h]));
		// printf(&quot;we get :%lf?\n&quot;, f[n - i + 1]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	// reverse(a + 1, a + n + 1);
	for(int i = n; i &gt;= 1; --i) {
		// printf(&quot;%lf %d\n&quot;, f[i], a[i]);
		printf(&quot;%d\n&quot;, max((int)ceil(f[i] - a[i]), 0));
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2511 [HAOI2008]木棍分割]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/">
        </link>
        <updated>2020-08-26T08:17:13.000Z</updated>
        <content type="html"><![CDATA[<p>nmd细节</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个棍分成j组的方案数</p>
<p>转移式子很简单f_{i,j}=\sum_{k&lt;i,sum[i]-sum[k]&lt;=Max}f_{k,j-1}</p>
<p>然后j这维可以滚动,同时可以前缀和优化...</p>
<p>不过这个有个你妈的细节,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>t</mi><mi>p</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=sum_{i-1,j-1}-sum_{tp-1,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>这个是不能转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的....毕竟<strong>没有空组</strong>!!</p>
<p>唉...但是只WA了一个点,让人麻木</p>
<p>写的时候多想了好多强加了好多限制使得看上去繁琐了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e4 + 7;
const int MAXN = 1e5 + 7;
int n, m, S;
int a[MAXN], pre[MAXN];
int Max, MM;

inline int chk(int x) {
	int tmp = 0;
	int ccnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(tmp + a[i] &gt; x) {
			ccnt++;
			tmp = a[i];
		} else tmp += a[i];
	}
	return (m &gt;= ccnt);
}

inline void solve1() {
	int l = MM, r = S, mid;
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			Max = mid;
		} else l = mid + 1;
	}
}

ll f[2][MAXN], sum[2][MAXN], ans;
inline void solve2() {
	int tp = 0;
	int t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(pre[i] &lt;= Max)
			f[1][i] = 1;
		sum[1][i] = sum[1][i - 1] + f[1][i];
	}
	for(int j = 2; j &lt;= m + 1; ++j) {
		tp = 0;
		// puts(&quot;qwq&quot;);
		for(int i = j; i &lt;= n; ++i) {
			while(tp &lt;= i &amp;&amp; pre[i] - pre[tp] &gt; Max)++tp;
			sum[t][i] = sum[t][i - 1];
			// printf(&quot;%d %din-&gt;%lld %lld\n&quot;, i, tp, sum[t ^ 1][i], sum[t ^ 1][tp - 1]);
			if(tp != 0)
				f[t][i] = sum[t ^ 1][i - 1] - sum[t ^ 1][tp - 1];
			else
				f[t][i] = sum[t ^ 1][i - 1];
			// printf(&quot;%lld??\n&quot;, f[t][i]);
			f[t][i] = (f[t][i] + P) % P;
			sum[t][i] = (sum[t][i] + f[t][i]) % P;
		}
		ans = (ans + f[t][n]) % P;
		t ^= 1;
		for(int i = 0; i &lt;= n; ++i)
			f[t][i] = sum[t][i] = 0;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		pre[i] = pre[i - 1] + a[i];
		S += a[i];
		MM = max(MM, a[i]);
	}
	solve1();//解决第一问
	printf(&quot;%d &quot;, Max);
	solve2();//缀和优化第二维
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5504 [JSOI2011]柠檬]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/">
        </link>
        <updated>2020-08-26T03:29:35.000Z</updated>
        <content type="html"><![CDATA[<p>决策单调性优化2</p>
<p>我爱</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mo>(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">f_j=max{f_{i-1}+col(i)*(s_{j}-s_{i}+1)^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">col_i==col_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,这个是满足的才行</p>
<p>观察后面函数导函数是单调递增的,而要最大化,由上一篇博客可知要决策单调性优化单调栈形式了....</p>
<p>具体怎么说呢?</p>
<p>不难发现,正是因为我们要<strong>最大化</strong>,对于一个颜色j,越靠前后面那个转移的值越大!</p>
<p>也就是说对于一个决策点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,j当前不是最优的,j可能会在某个时间点之后成为了最优点</p>
<p>也就是说我们一个单调栈内决策点的最优时间是<strong>递减</strong>的.....而最优时间可以反映到颜色数上,因为相当于颜色数越多我们最优时间越靠后</p>
<p>辣么我们就可以想出一些方法去维护这个单调栈了....</p>
<ol>
<li>如果栈顶的两个元素的最优时间早于新决策点i和栈顶的最优时间我们就弹出栈顶</li>
</ol>
<p>显然i是最优的,但是栈顶的最优时间还在i之前,所以说明他无论如何都不会成为最优时间了,所以我们可以弹出栈顶....</p>
<ol start="2">
<li>如果栈顶的两个元素的最优时间小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>即i颜色数就弹出栈顶</li>
</ol>
<p>也就是说他已经不再能成为那个决策点了,也就是最优时间已经过了...</p>
<p>做完这两个操作我们再去更新i即可</p>
<p>而怎么求出两个决策点的最优时间比较呢?</p>
<p>可以二分,因为两个决策点一定是某段时间之前一个更优,之后另一个更优,直接二分那个颜色数然后类似的转移一下就好了</p>
<p>所以最后整个算法流程也就是这样了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
#define ll long long
int n, a[MAXN], s[MAXN], vis[MAXN];
vector&lt;int&gt; st[MAXN], rc[MAXN];
ll f[MAXN];

inline ll calc(int x, int y) {
	// if(x == y)return f[y] + a[x];
	return f[x - 1] + 1ll * y * y * a[x];
}

inline int bound(int x, int y) {//在x,y中update
	int l = 1, r = n, mid, ret = n + 1;
	// printf(&quot;%d %d?%d %d\n&quot;, l, r, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		// printf(&quot;in-&gt;%lld %lld?\n&quot;, calc(x, mid - s[x] + 1), calc(y, mid - s[y] + 1));
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			ret = mid;
			r = mid - 1; 
		} else l = mid + 1;
	}
	// printf(&quot;!!!%d\n&quot;, ret);
	return ret;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	//直接用st维护
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// printf(&quot;%d?\n&quot;, st[t].size());
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1])
				&lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;%d %d?\n&quot;, bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]), bound(st[t][st[t].size() - 1], i));
			st[t].pop_back();//只要结尾一段的决策点i最优就一直...
		} st[t].push_back(i);
		// printf(&quot;st:%d st2:%d low:%d \n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2], bound(st[t][st[t].size() - 1], i));
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// printf(&quot;%d\n&quot;, st[t][st[t].size() - 1]);
			st[t].pop_back();
		}
		// printf(&quot;i:%d best choic: %d!\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finial:%lld\n&quot;, f[i]);
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}

</code></pre>
<p>还有noi.ac的一道抄袭这个题的决策单调性优化</p>
<p><strong>有一个至关重要的细节就是如果我们的二分二分不出时间</strong></p>
<p>说明前面的决策点永远都不可能成为最优决策点了....</p>
<p>那么这个时候我们只需要压住栈即可,因为珍贵的栈顶是最优的</p>
<p>即bound函数返回n+1</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long double
const int MAXN = 1e6 + 7;

int n, k;
int a[MAXN], vis[MAXN], s[MAXN];
vector&lt;int&gt; st[MAXN];
ll f[MAXN], qwq[MAXN];

inline ll calc(int x, int y) {
	return f[x - 1] + qwq[y];
}

inline int bound(int x, int y) {
	int l = 1, r = n, ret = n + 1, mid;
	// printf(&quot;in-&gt;%d %d?\n&quot;, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			// printf(&quot;this mid is ok%d\n&quot;, mid);
			ret = mid;
			r = mid - 1;//这个决策点x更优,再靠前
		} else l = mid + 1;
	}
	// printf(&quot;end with %d\n&quot;, ret);
	return ret;
}

inline void init() {
	if(k == 2) {
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i;
		}
	} else if(k == 3)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = pow(i, 1.5);
			// printf(&quot;%d %Lf\n&quot;, i, qwq[i]);
		} else if(k == 4)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i * i;
		}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;k, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	init();
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// puts(&quot;Ha1&quot;);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;out..-&gt;%d?%d?\n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2]);
			st[t].pop_back();
		}
		// puts(&quot;Ha2&quot;);
		st[t].push_back(i);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// puts(&quot;qwq&quot;);
			st[t].pop_back();
		}
		// printf(&quot;wei shen me?%d %d?\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finish:%Lf\n&quot;, f[i]);
	}
	printf(&quot;%.6Lf\n&quot;, f[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1912 [NOI2009]诗人小G]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1912-noi2009shi-ren-xiao-g/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1912-noi2009shi-ren-xiao-g/">
        </link>
        <updated>2020-08-26T01:38:52.000Z</updated>
        <content type="html"><![CDATA[<p>决策单调性优化</p>
<p>钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为前i个串的前缀和</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><mi>L</mi><mo>+</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><msup><mo>)</mo><mi>P</mi></msup></mrow><annotation encoding="application/x-tex">f_i=f_j+abs(s_i-s_j-L+(i-j-1))^P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中i-j-1是空格的数量</p>
<p>然后我们这个式子就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求,并且得出每个i的最优决策点来输出方案</p>
<p>30pts好成绩,因为还有两个点L很小,所以处理的好一点能拿到50pts</p>
<p>紧接着斜率优化就70pts了</p>
<p>最后我们可以决策单调性优化</p>
<p>根据第一篇博客:导函数单增,求最小值,可以使用单调队列</p>
<p>就是说我们i的决策点每次更新的是队列最后的一段,而计算新数的时候用靠前的一段</p>
<p>导函数单增求最大值用单调栈,就是更新的是靠前的一段而计算的时候也用靠前的一段</p>
<p>也就是说导函数增减和最大小值相同就是队列,否则就是栈</p>
<p>二分的时候有点细节,不要写l=m-1,r=m+1那种,因为我们可能连续一段区间都满足,但我们要的是左端点(lower_bound)</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long double
using namespace std;
const int MAXN = 2e5 + 7;
const int P = 1e9 + 7;
int T, n, l, p;
int s[MAXN], que[MAXN], k[MAXN], pr[MAXN];
ll f[MAXN];
char str[MAXN][33];//每组数据字符串

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline ll calc(int x, int y) {
	// printf(&quot;x: %dy: %df[y]:%Lf del:%d P:%d %d %d\n&quot;, x, y, f[y], s[x], s[y], abs(s[x] - s[y] - l), p);
	// printf(&quot;calc:%d %d??\n&quot;, x, y);
	return f[y] + ksm(abs(s[x] - s[y] + (x - y - 1) - l), p);
}

inline int bound(int x, int y) {
	int l = x, r = n + 1, m;
	while(l &lt; r) {
		m = (l + r) &gt;&gt; 1;
		if(calc(m, x) &gt;= calc(m, y)) {
			r = m;
		} else {
			l = m + 1;
		}
	}
	// printf(&quot;%d %d %d\n&quot;, l, r, ans);
	return r;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;p);
		memset(s, 0, sizeof(s));
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, str[i]);
			s[i] = s[i - 1] + strlen(str[i]);
		}
		// for(int i = 1; i &lt;= n; ++i)printf(&quot;%d \n&quot;, s[i]);
		int i = 1, h = 1, t = 1;
		for(que[1] = 0; i &lt;= n; ++i) {
			while(h &lt; t &amp;&amp; k[h] &lt;= i)
				++h;//k是右端点
			f[i] = calc(i, que[h]);
			// printf(&quot;our choice: %Lf %d %d\n&quot;, f[i], que[h], i);
			pr[i] = que[h];//记录决策点
			while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
				--t;//如果右端点大于我们栈内二分的端点
			k[t] = bound(que[t], i);
			que[++t] = i;
		}
		if(f[n] &gt; 1e18)puts(&quot;Too hard to arrange&quot;);
		else {
			printf(&quot;%.0Lf\n&quot;, f[n]);
			for(que[t = 0] = i = n; i; que[++t] = i = pr[i]);
			for(; t; --t) {
				for(i = que[t] + 1; i &lt; que[t - 1]; ++i)printf(&quot;%s &quot;, str[i]);
				puts(str[i]);
			}
		}
		puts(&quot;--------------------&quot;);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF710F String Set Queries]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf710f-string-set-queries/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf710f-string-set-queries/">
        </link>
        <updated>2020-08-25T12:59:29.000Z</updated>
        <content type="html"><![CDATA[<p>AC自动机好题</p>
<p>删除的答案其实很好统计qwq,我们先查询在删除自动机里面的答案,再查询在全体自动机的答案</p>
<p>然后做一个差就是答案....</p>
<p>不过我们AC自动机这个东西没法边着插入边维护fail树QAQ</p>
<p>所以我们肯定要用一些定期重构之类的想法去维护AC自动机</p>
<p>根号分块是肯定可以的,就是每根号m的开一个自动机,如果不到根号m个没有存入可以直接暴力匹配</p>
<p>(当然也最推荐写这个)</p>
<p>然而复杂度不好看,我们有一个log的做法...</p>
<p>二进制分组....</p>
<p>假设现在有n个,n的第k位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>2</mn><mi>i</mi><mi>a</mi></msubsup></mrow><annotation encoding="application/x-tex">2^a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>个串构成</p>
<p>然后查询的时候暴力把log个自动机都跑一遍</p>
<p>修改n的时候进位我们就把那些都暴力重构组成一个新的自动机放在新的二进制位上</p>
<p>由于一个串最多重构log次所以是对的</p>
<p>这样子我们只需要把一些AC自动机中的串拿出来重构</p>
<p>具体实现的时候我们对于每个二进制位都弄一个链表记录该位存储的哪些串就行了</p>
<p>这个二进制分组的思想好像也仅适用于这类数据结构的情况?</p>
<p>有一个大大的细节就是清空ch树的时候要延迟清空.....具体可看看代码实现</p>
<p>code:</p>
<pre><code class="language-cpp">
//二进制分组
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 4e5 + 7;
char s[MAXN];

struct ACF {//ACFUN
	string data[MAXN];
	int ch[MAXN][26], fail[MAXN], ed[MAXN], T, n;
	inline void ins(int r, char *s) {
		int n = strlen(s + 1);
		int u = r;
		for(int i = 1, t; i &lt;= n; ++i) {
			t = s[i] - 'a';
			if(ch[u][t] == r) {//要把这个点重构然后再把其他的重构
				ch[u][t] = ++T;
				for(int j = 0; j &lt; 26; ++j)
					ch[T][j] = r;
			}
			u = ch[u][t];
		}
		ed[u]++;
	}
	void build(int r) {
		fail[r] = r;
		queue&lt;int&gt; q;
		for(int i = 0; i &lt; 26; ++i) {
			if(ch[r][i] &gt; r) {
				q.push(ch[r][i]);
				fail[ch[r][i]] = r;
				//fail....
			}
		}
		while(!q.empty()) {
			int u = q.front();
			q.pop();
			for(int i = 0; i &lt; 26; ++i) {
				int v = ch[u][i];
				if(v == r)
					ch[u][i] = ch[fail[u]][i];
				else {
					fail[v] = ch[fail[u]][i];
					ed[v] += ed[ch[fail[u]][i]];
					q.push(v);//fail重构
				}
			}
		}
	}
	int search(int r, char *s) {
		int n = strlen(s + 1);
		int u = r;
		int ret = 0;
		for(int i = 1, t; i &lt;= n; ++i) {
			t = s[i] - 'a';
			u = ch[u][t];
			ret += ed[u];
		}
		return ret;
	}
	int stk[MAXN], fr[MAXN], siz[MAXN], N;
	void merge() {
		--N;
		siz[N] &lt;&lt;= 1;
		for(int i = stk[N]; i &lt;= T; ++i) {
			ed[i] = fail[i] = 0;
			for(int j = 0; j &lt; 26; ++j) {
				ch[i][j] = 0;
			}
		}
		T = stk[N];
		for(int i = 0; i &lt; 26; ++i)
			ch[T][i] = T;
		for(int L = fr[N]; L &lt;= n; ++L)
			ins(stk[N], &amp;data[L][0]);
		build(stk[N]);
	}
	void ins(char *s) {
		stk[++N] = ++T;
		for(int i = 0; i &lt; 26; ++i)
			ch[T][i] = T;
		siz[N] = 1;
		ins(T, s);
		build(stk[N]);
		int L = strlen(s + 1);
		data[fr[N] = ++n] = &quot; &quot;;
		for(int i = 1; i &lt;= L; ++i)
			data[n] += s[i];
		while(siz[N] == siz[N - 1])
			merge();
	}
	int Count(char *s) {
		int ans = 0;
		for(int i = 1; i &lt;= N; ++i)
			ans += search(stk[i], s);
		return ans;
	}
} Add, Sub;

int m;
int main() {
	scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1, typ; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;typ);
		cin &gt;&gt; (s + 1);
		if(typ == 1) {
			Add.ins(s);
		} else if(typ == 2) {
			Sub.ins(s);
		} else {
			printf(&quot;%d\n&quot;, Add.Count(s) - Sub.Count(s));//做差即可
		}
		fflush(stdout);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4198 楼房重建]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4198-lou-fang-chong-jian/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4198-lou-fang-chong-jian/">
        </link>
        <updated>2020-08-25T11:39:51.000Z</updated>
        <content type="html"><![CDATA[<p>合并需要log的线段树</p>
<p>其实本质上是线段树维护单调栈,但是我们直接在某个点上记录一整个栈不太阳间</p>
<p>我们会发现其实有很多儿子的信息我们没有很好利用,所以我们可以考虑用儿子节点的信息拼成一个单调栈合并的信息</p>
<p>单调栈合并的时候需要从后面某个地方砍一刀然后把后面剩下的地方接到前面去</p>
<p>所以这个也是一样的,我记录了区间最大值和区间单调栈长度直接写TLE了好几发</p>
<p>因为我是直接递归看看右边能不能再去划分,只用最大值当做剪枝的判据</p>
<p>所以这个是能被卡成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的qwq两边都有可能递归</p>
<p>不被卡成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>就要只递归一边......</p>
<p>如果左边最大值小于V,我们直接递归右边</p>
<p><strong>否则我们能根据这个区间的单调栈长度和左区间的单调栈长度算出右边区间在左边成单调栈时的长度</strong></p>
<p>换句话说:右边区间的长度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mo>[</mo><mi>k</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>L</mi><mo>−</mo><mi>t</mi><mi>r</mi><mo>[</mo><mi>l</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>]</mo><mi mathvariant="normal">.</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">tr[k].L-tr[ls[k]].L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">L</span></span></span></span></p>
<p>这样就只递归左边即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
using namespace std;
#define sort(a,b) random_shuffle(a,b)
const int MAXN = 7e5 + 7;
const db eps = 1e-11;
int n, m, x, y;
struct rec {
	db Max;
	int L;//记录最大值和单调栈长度
	rec(int L = 0, db x = 0): Max(x), L(L) {};
} tr[MAXN];
db a[MAXN];
namespace seg {
	int ls[MAXN], rs[MAXN], T, root;
#define mid ((l+r)&gt;&gt;1)
	inline void build(int &amp;k, int l, int r) {
		if(!k)k = ++T;
		if(l == r) {
			tr[k].Max = 0;
			tr[k].L = 1;
			return ;
		}
		build(ls[k], l, mid);
		build(rs[k], mid + 1, r);
		tr[k].L = 1;
	}
	inline int query(int k, int l, int r, db V) {
		if(tr[k].Max &lt;= V)return 0;
		if(a[l] &gt; V)return tr[k].L;
		if(l == r)return a[l] &gt; V;
		int tmp = 0;
		if(tr[ls[k]].Max &lt;= V) {
			return query(rs[k], mid + 1, r, V);
		} else {
			return query(ls[k], l, mid, V) + tr[k].L - tr[ls[k]].L;
		}
		return tmp;
	}
	inline int pushup(int k, int l, int r) {
		//找到第一个位置
		//然后再那个位置之后的区间都提出来
		// printf(&quot;in %d!%d %d\n&quot;, k, l, r);
		if(tr[rs[k]].Max - tr[ls[k]].Max &gt; eps) {
			return query(rs[k], mid + 1, r, tr[ls[k]].Max) + tr[ls[k]].L;
		} else {
			// printf(&quot;?%d %lf\n&quot;, tr[ls[k]].L, tr[ls[k]].Max);
			return tr[ls[k]].L;
		}
	}
	inline void modify(int &amp;k, int l, int r, int x, db V) {
		if(!k)k = ++T;
		if(l == r) {
			tr[k].Max = V;
			tr[k].L = 1;
			return ;
		}
		if(x &lt;= mid)modify(ls[k], l, mid, x, V);
		else modify(rs[k], mid + 1, r, x, V);
		// printf(&quot;merge !:-&gt;%d %d %d\n&quot;, k, l, r);
		tr[k].L = pushup(k, l, r);
		tr[k].Max = max(tr[ls[k]].Max, tr[rs[k]].Max);
	}
}
using namespace seg;
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	// build(root, 1, n);
	for(int i = 1, x, y; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		a[x] = (1.00 * y) / (1.00 * x);
		modify(root, 1, n, x, (1.00 * y) / (1.00 * x));
		printf(&quot;%d\n&quot;, tr[root].L);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2403 [SDOI2010]所驼门王的宝藏]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2403-sdoi2010suo-tuo-men-wang-de-bao-cang/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2403-sdoi2010suo-tuo-men-wang-de-bao-cang/">
        </link>
        <updated>2020-08-25T09:27:28.000Z</updated>
        <content type="html"><![CDATA[<p>啊这</p>
<p>优化建图题调的时候一定要把整个图画出来然后自己慢慢看</p>
<p>还有就是图论中基础板子一定不能写错了</p>
<p>对于此题,我们建n+R+C个点</p>
<p>R:表示行电梯,乘上该电梯可以到达所有同一行的点</p>
<p>C:表示列电梯....</p>
<p>然后对于一个点i,如果是一二类边,我们就把另一类的电梯向他连边,并从该点向对应特征电梯连边!</p>
<p>最后还有第三类边,可以直接暴力,用一个map存一下每个点的pair即可!</p>
<p>时间复杂度O(nlogn),复杂度在于map</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
const int MAXN = 5e5 + 7;
const int MAXM = 2e6 + 7;
using namespace std;
map&lt;pair&lt;int, int&gt;, int&gt; mp;
int n, R, C, T;
const int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
const int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};
int H[MAXM], L[MAXM], in[MAXN], d[MAXN], first[MAXN];
int hd, que[MAXN], tl, dis[MAXN], fl[MAXN];
int ccnt2, exn;
int a[MAXN], S[MAXN];

struct rec {
	int nxt, to;
} e[MAXM];
struct NODE {
	int x, y, t;
} nd[MAXN];


inline void tpdp() {
	puts(&quot;In tpdp&quot;);
	for(int i = 1; i &lt;= exn; ++i) {
		if(in[i] == 0) {
			que[tl++] = i;
			dis[i] = S[i];
			// printf(&quot;起点 :%d %d? %d\n&quot;,  i, S[i], in[i]);
		}
	}

	while(hd &lt;= tl) {
		int u = que[hd];
		++hd;
		// printf(&quot;poor boy:%d?\n&quot;, u);
		for(int i = first[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			in[v]--;
			// printf(&quot;update%d %d %d-&gt;\n&quot;, dis[u], dis[v], S[v]);
			dis[v] = max(dis[u] + S[v], dis[v]);
			if(!in[v]) {
				que[++tl] = v;
			}
		}
	}

	return ;
}
int ccnt, home[MAXN], nxt[MAXM], to[MAXM];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void ct2(int x, int y) {
	ccnt2++;
	e[ccnt2].nxt = first[x];
	first[x] = ccnt2;
	e[ccnt2].to = y;
	in[y]++;
}

int dfn[MAXN], low[MAXN], depp, st[MAXN], tp;
inline void tarjan(int u) {
	dfn[u] = ++depp;
	low[u] = dfn[u];
	st[++tp] = u;
	fl[u] = 1;
	// printf(&quot;now we in node:%d %d?\n&quot;, u, dfn[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u] = min(low[u], low[v]);
		} else if(!fl[v])continue;
		low[u] = min(low[u], dfn[v]);
	}
	// printf(&quot;so the %d' low is %d?\n&quot;, u, low[u]);
	if(low[u] == dfn[u]) {
		exn++;
		while(st[tp] != u) {
			int v = st[tp];
			--tp;
			S[exn] += a[v];
			d[v] = exn;
			fl[v] = 0;
		}
		tp--;
		S[exn] += a[u];
		d[u] = exn;
		fl[u] = 0;
		// printf(&quot;%d?%d\n&quot;, tp, exn);
	}
	return ;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;R, &amp;C);
	T = n;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;nd[i].x, &amp;nd[i].y, &amp;nd[i].t);
		if(!L[nd[i].y])L[nd[i].y] = ++T;
		if(!H[nd[i].x])H[nd[i].x] = ++T;
		// printf(&quot;%d %d\n&quot;, L[nd[i].y], H[nd[i].x]);
		if(nd[i].t == 1) {
			ct(H[nd[i].x], i);
			ct(i, H[nd[i].x]);
			ct(L[nd[i].y], i);//列只能被动接受
		}
		if(nd[i].t == 2) {
			ct(H[nd[i].x], i);//行只能被动接受
			ct(L[nd[i].y], i);
			ct(i, L[nd[i].y]);
		}
		if(nd[i].t == 3) {
			ct(H[nd[i].x], i);
			ct(L[nd[i].y], i);//都只能被迫接受
		}
		a[i] = 1;
		mp[mkp(nd[i].x, nd[i].y)] = i;
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(nd[i].t == 3) {
			for(int k = 0; k &lt; 8; ++k) {
				int nx = dx[k] + nd[i].x;
				int ny = dy[k] + nd[i].y;
				// printf(&quot;%d %d?\n&quot;, nx, ny);
				if(mp.find(mkp(nx, ny)) != mp.end()) {
					// printf(&quot;U:%d?%d\n&quot;, nx, ny);
					ct(i, mp[mkp(nx, ny)]);
				}
			}
		}
	}
	for(int i = 1; i &lt;= T; ++i) {
		if(!dfn[i])
			tarjan(i);
	}
	for(int u = 1; u &lt;= T; ++u) {
		// printf(&quot;where is Kindom!:%d here %d have lots of %d\n&quot;, u, d[u], S[d[u]]);
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			if(d[u] == d[v])continue;
			// printf(&quot;I'm %d and belong to %d:edge to %d?\n&quot;, u, d[u], d[v]);
			ct2(d[u], d[v]);
		}
	}
	tpdp();
	int ans = 0;
	for(int i = 1; i &lt;= exn; ++i) {
		// printf(&quot;%d %d\n&quot;, i, dis[i]);
		ans = max(ans, dis[i]);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6329 【模板】点分树 | 震波]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6329-mo-ban-dian-fen-shu-or-zhen-bo/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6329-mo-ban-dian-fen-shu-or-zhen-bo/">
        </link>
        <updated>2020-08-25T02:16:39.000Z</updated>
        <content type="html"><![CDATA[<p>看到模板两字,先建出点分树吧</p>
<p>就是在点分治的过程把每个点记录下来,然后另开一张图记录下来</p>
<p>然后再在新图上dfs一遍,我们把每个点的子树全部压入一个线段树</p>
<p>由于我们一些奇怪的原因只能用动态开点线段树 保证空间合法,下标是子树内所有点到他的距离</p>
<p>然后查询的时候暴力向父亲跳,然后每次log查询一下,注意容斥容斥,就是减去跳上去的儿子距离他小的部分</p>
<p>但是这个容斥并不简单,所以要对于每个点再开一个线段树记录子树内所有点到(点分树父亲的距离)为下标的权值</p>
<p>算法流程:</p>
<ol>
<li>
<p>建出点分树</p>
</li>
<li>
<p>在点分树上用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>∑</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>s</mi><mi>i</mi><mi>z</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\sum sizlogsiz)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>的复杂度建出两棵线段树,一个记录到父亲的一个记录到自己的</p>
</li>
<li>
<p>查询和修改的时候暴力跳父亲</p>
</li>
</ol>
<p>extra细节:</p>
<p>建点分树的时候第一步要把全局中心找出来当做根</p>
<p>查询时如果跳到某个点距离大于了阈值不能停下,继续向上跳,因为可能某个祖先的距离到他又合法了...</p>
<p>修改的时候要改两棵树</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 3e5 + 7;
const int MAXM = 7e5 + 7;
const int MAXT = 2e7 + 7;
int n, m, a[MAXN];
int ccnt, home[MAXN], nxt[MAXM], to[MAXM];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int first[MAXN], cccnt, dep[MAXN];
struct rec {
	int to, nxt;
} e[MAXM];
inline void ct2(int x, int y) {
	cccnt++;
	e[cccnt].nxt = first[x];
	first[x] = cccnt;
	e[cccnt].to = y;
}

int rt, S, RT, rt2;
int siz[MAXN], dp[MAXN], vis[MAXN];
inline void getroot(int u, int F) {
	siz[u] = 1;
	dp[u] = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F || vis[v])continue;
		getroot(v, u);
		siz[u] += siz[v];
		dp[u] = max(dp[u], siz[v]);
	}
	dp[u] = max(dp[u], S - siz[u]);
	if(dp[rt] &gt; dp[u])
		rt = u;
	return;
}

inline void solve(int u) {
	vis[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		rt = 0;
		dp[rt] = n;
		S = siz[v];
		getroot(v, u);
		ct2(u, rt);
		ct2(rt, u);
		// printf(&quot;%d %d??\n&quot;, u, rt);
		solve(rt);
	}
	return ;
}

int fa[MAXN], son[MAXN], top[MAXN];
inline void dfs1(int u, int F) {
	siz[u] = 1;
	fa[u] = F;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dep[v] = dep[u] + 1;
		dfs1(v, u);
		siz[u] += siz[v];
		if(siz[v] &gt; siz[son[u]])son[u] = v;
	}
	return ;
}

inline void dfs2(int u, int topf) {
	top[u] = topf;
	if(!son[u])return ;
	dfs2(son[u], topf);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa[u] || v == son[u])continue;
		dfs2(v, v);
	}
	return ;
}

inline int LCA(int x, int y) {
	while(top[x] != top[y]) {
		// printf(&quot;%d?%d\n&quot;, x, y);
		if(dep[top[x]] &lt; dep[top[y]])x ^= y ^= x ^= y;
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])x ^= y ^= x ^= y;
	return x;
}

inline void init() {
	dep[1] = 1;
	dfs1(1, 0);//预处理LCA相关
	dfs2(1, 1);
	S = n;
	dp[rt = 0] = n;
	getroot(1, 0);
	RT = rt;
	solve(rt);//建出点分树
	return ;
}

int root[MAXN];
namespace seg {
	int ls[MAXT], rs[MAXT], T, sum[MAXT];
#define mid ((l+r)&gt;&gt;1)
	inline void modify(int &amp;k, int l, int r, int pos, int V) {
		if(!k)k = ++T;
		if(l == r) {
			sum[k] += V;
			return ;
		}
		if(pos &lt;= mid)modify(ls[k], l, mid, pos, V);
		else modify(rs[k], mid + 1, r, pos, V);
		sum[k] = sum[ls[k]] + sum[rs[k]];
	}
	inline int query(int k, int l, int r, int x, int y) {
		if(x &lt;= l &amp;&amp; y &gt;= r) {
			return sum[k];
		}
		if(y &lt;= mid)return query(ls[k], l, mid, x, y);
		else if(x &gt; mid)return query(rs[k], mid + 1, r, x, y);
		else return query(ls[k], l, mid, x, y) + query(rs[k], mid + 1, r, x, y);
	}
}
using namespace seg;
int  fa2[MAXN];

inline int DIS(int x, int y) {
	return dep[x] + dep[y] - 2 * dep[LCA(x, y)];
}

inline void add(int u, int F) {
	// printf(&quot;in- &gt; %d %d %d %d %d\n&quot;, u, rt, S, DIS(u, rt), a[u]);
	// printf(&quot;try!%d %d %d %d?\n&quot;, u, F, DIS(u, rt), a[u]);
	modify(root[rt], 0, S, DIS(u, rt2), a[u]);
	// printf(&quot;query -&gt;:%d?\n&quot;, query(root[rt], 0, S, 0, S));
	for(int i = first[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == F)continue;
		add(v, u);
	}
	return;
}

inline void dfs3(int u, int F) {
	fa2[u] = F;
	rt = u;
	S = siz[u];
	rt2 = u;
	// printf(&quot;in-&gt;%d?%d %d\n&quot;, u, F, root[u]);
	add(u, F);
	S = siz[F];
	rt = u + n;
	rt2 = F;
	add(u, F);//到父亲的答案...
	// printf(&quot;%d %d?\n&quot;, u, F);
	for(int i = first[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(v == F)continue;
		dfs3(v, u);
	}
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, a + i);
	for(int i = 2, u, v; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct(v, u);
	}
	init();
	dfs3(RT, 0);//dfs new tree
	int lsa = 0;
	for(int i = 1, x, y, z; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;z, &amp;x, &amp;y);
		x ^= lsa;
		y ^= lsa;
		if(z == 1) {
			int anc = x;
			while(anc) {
				// printf(&quot;%d??\n&quot;, DIS(x, anc));
				modify(root[anc], 0, siz[anc], DIS(x, anc), y - a[x]);
				if(fa2[anc])
					modify(root[anc + n], 0, siz[fa2[anc]], DIS(x, fa2[anc]), y - a[x]);
				anc = fa2[anc];
			}
			a[x] = y;
		} else {
			int anc = x, tmp = 0, lst = 0;
			lsa = 0;
			while(anc) {
				tmp = y - DIS(x, anc);
				// printf(&quot;now step : anc%d  lstanc:%d  jl:%d\n&quot;, anc, lsa, tmp);
				if(tmp &lt; 0) {
					lst = anc;
					anc = fa2[anc];
					continue;
				}
				lsa += query(root[anc], 0, siz[anc], 0, tmp);
				// printf(&quot;ans is ?:%d &quot;, query(root[anc], 0, siz[anc], 0, tmp));

				// printf(&quot;- %d??\n&quot;, query(root[anc + n], 0, siz[fa2[anc]], 0, tmp));
				if(lst)
					lsa -= query(root[lst + n], 0, siz[anc], 0, tmp);
				lst = anc;
				anc = fa2[anc];
			}
			printf(&quot;%d\n&quot;, lsa);
		}
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3242 [HNOI2015]接水果]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3242-hnoi2015jie-shui-guo/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3242-hnoi2015jie-shui-guo/">
        </link>
        <updated>2020-08-24T03:25:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="预处理部分">预处理部分:</h1>
<p>考虑怎么判断一条路径是否被另一条覆盖</p>
<p>设要被包含的路径是(u,v),而去包含的是(x,y)</p>
<h2 id="对于lcauvu的">对于LCA(u,v)==u的,</h2>
<p>(x,y)中至少有一个在v子树里面</p>
<p>钦定x在v的子树里,那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>x</mi></msub><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn_v&lt;=dfn_x&lt;=dfn_v+siz[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span></p>
<p>而且钦定g为uv方向的儿子,就是y向v走一步走到的节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>g</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>&lt;</mo><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dfn_g+siz[g]&lt;=dfn_y&lt;=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>&lt;</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">1&lt;=dfn_y&lt;dfn_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>也就是说在除了g子树外任意一点都可以!</p>
<p>会发现这6个上下界和(x,y)没有关系</p>
<p>这相当于四维限制,只能转换到平面上,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>y</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_x,dfn_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>要在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>g</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v,dfn_g+siz[g])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>为左下角,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v+siz[v],n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>为右上角的矩形或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>为左下角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>v</mi></msub><mo>+</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>f</mi><msub><mi>n</mi><mi>g</mi></msub><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(dfn_v+siz[v],dfn_g-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>为右上角的矩形里面(这样你会发现x,y坐标都满足了限制)</p>
<p>也就是说,我们如果搞两个矩形加,那么(x,y)包含的路径数查询就是单点查询了!</p>
<p>但是还没完,我们再看看另一类路径</p>
<h2 id="lcauvuv"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">lca(u,v)!=(u||v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></h2>
<p>那么我们有(x,y)包括(u,v)的话....</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 27: …x&lt;=dfn_v+siz[v]$̲$即x在v的子树里!

$$d…'>dfn_v&lt;=dfn_x&lt;=dfn_v+siz[v]$$即x在v的子树里!

$$dfn_u&lt;=dfn_y&lt;=dfn_u+siz[u]$$即x在u的子树里!

这个矩阵加的信息也和$(x,y)$是什么没有关系,所以可以处理!

$(dfn_v,dfn_u)$为左下角,$(dfn_v+siz[v],dfn_u+siz[u])$为右上角的矩形

这样我们可以搞到一个二维平面上,但是问题是第k大怎么处理...QAQ

# 搞事情部分:

既然我们只能很快的查出**有多少个**,不妨把第k大用个二分去解决

1. 二分一个答案,对于一个询问,把所有大于二分值的盘子加入平面

2. 查询水果点上有多少个数,如果多了就调大二分值,否则调小二分值

但是这样也太太太慢了

 ##  整体二分!

所有水果我们一起二分一个答案,把大于这个值的盘子加入平面

然后所有都查询一遍$O(mlogm)$

之后我们把数量小于k的(说明要调小)放入左边区间递归,同时把盘子中小于k的放入左边,然后把数量大于k的放入右边区间递归,同时把盘子中大于k的放入右边

## 最后一步!如何实现矩阵+单点求和?

扫描线好题/se

可以考虑用扫描线,把所有的矩形和询问点都加入分界点中,然后遇到修改在线段树上改,遇到查询就查一下

这样复杂度就会O(nlogn)了

总复杂度我们不难得出

$O((m+n)lognlogV)$

4e4的范围应该能过了....

后记:

写代码的时候注意线段树清空,以及第一步建边的时候拆询问,可能导致一些在几千组询问的时候WA掉的锅

还有整体二分的时候同时分盘子和水果....不过相对坑较小

附带7.33kb未删除调试code:

```cpp

//你知道真正的写吐了吗....
//整体分毒
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e5 + 7;
int n, p, q, V;
struct rec {
	int x, y, z, w, id;
	bool operator&lt;(const rec &amp;x) const {
		return z &lt; x.z;
	}
} b[MAXN], a[MAXN], mdf[MAXN], qry[MAXN], C[MAXN], D[MAXN], A[MAXN], B[MAXN];
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], dep[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int depp, siz[MAXN], dfn[MAXN], son[MAXN], fa[MAXN];
inline void dfs(int u, int F) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		fa[v] = u;
		dep[v] = dep[u] + 1;
		dfs(v, u);
		siz[u] += siz[v];
		if(siz[v] &gt; siz[son[u]])son[u] = v;
	}
	return ;
}
int top[MAXN];
inline void dfs2(int u, int topf) {
	top[u] = topf;
	dfn[u] = ++depp;
	if(!son[u])return ;
	dfs2(son[u], topf);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa[u] || v == son[u])continue;
		dfs2(v, v);
	}
	return ;
}

inline int LCA(int x, int y) {
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])x ^= y ^= x ^= y;
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])x ^= y ^= x ^= y;
	return x;
}

inline int getG(int x, int y) {//y到x第一个点
	if(x == y)return x;
	while(top[x] != top[y]) {
		if(dep[top[x]] &lt; dep[top[y]])x ^= y ^= x ^= y;
		if(fa[top[x]] == y) {
			// printf(&quot;G:%d %d? %d\n&quot;, x, top[x], y);
			return top[x];//不在一个重链
		}
		x = fa[top[x]];
	}
	if(dep[x] &gt; dep[y])x ^= y ^= x ^= y;
	return son[x];//如果正好在一个重链
}


inline void init() {
	int rc = p;
	for(int i = 1; i &lt;= rc; ++i) {
		int u = b[i].x;
		int v = b[i].y;
		if(dep[u] &gt; dep[v])u ^= v ^= u ^= v;
		int anc = LCA(u, v);
		// printf(&quot;%d?/cy\n&quot;, i);
		if(anc == u) {//first
			// printf(&quot;u,v,anc is %d %d %d?\n&quot;, u, v, anc);
			int g = getG(v, anc);
			int nxt = i;
			if(dfn[g] + siz[g] &lt;= n) {
				nxt = p + 1;
				mdf[i].x = dfn[v];
				mdf[i].y = dfn[g] + siz[g];
				mdf[i].w = dfn[v] + siz[v] - 1;
				mdf[i].id = n;
			}
			// printf(&quot;%d?\n&quot;, nxt);
			if(1 &lt;= dfn[g] - 1) {//好像没用
				if(nxt == p + 1)
					++p;
				mdf[nxt].x = 1;
				mdf[nxt].y = dfn[v];
				mdf[nxt].w = dfn[g] - 1;
				mdf[nxt].id = dfn[v] + siz[v] - 1;
				mdf[nxt].z = b[i].z;
			}
			// printf(&quot;%d %d???\n&quot;, nxt, p);
			// printf(&quot;g is :%d ,(%d,%d)and (%d,%d) bing! (%d,%d)and (%d,%d)\n&quot;, g, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id, mdf[nxt].x, mdf[nxt].y, mdf[nxt].w, mdf[nxt].id);
		} else {
			if(dfn[u] &lt; dfn[v])swap(u, v);
			mdf[i].x = dfn[v];
			mdf[i].y = dfn[u];
			mdf[i].w = dfn[v] + siz[v] - 1;
			mdf[i].id = dfn[u] + siz[u] - 1;
			// printf(&quot;u:%d v:%d (%d,%d)and (%d,%d) \n&quot;, u, v, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id);
		}
		mdf[i].z = b[i].z;
	}
	// for(int i = 1; i &lt;= p; ++i) {
	// 	printf(&quot;%d %d %d %d %d\n&quot;, mdf[i].x, mdf[i].y, mdf[i].w, mdf[i].id, mdf[i].z);
	// }
	for(int i = 1; i &lt;= q; ++i) {
		int u = a[i].x;
		int v = a[i].y;
		// printf(&quot;%d %dqwerty\n&quot;, dfn[u], dfn[v]);
		qry[i].x = dfn[u];
		qry[i].y = dfn[v];
		qry[i].id = a[i].id;
		qry[i].z = a[i].z;
	}
	// puts(&quot;It&#039;s OK!&quot;);
	return;
}

namespace seg {
	int ls[MAXN], rs[MAXN], T, sum[MAXN], tag[MAXN], root;
	inline void pushdown(int k) {
		if(!tag[k])return ;
		if(!ls[k]) {
			ls[k] = ++T;
			ls[T] = 0;
			rs[T] = 0;
			sum[T] = 0;
			tag[T] = 0;
		}
		if(!rs[k]) {
			rs[k] = ++T;
			ls[T] = 0;
			rs[T] = 0;
			sum[T] = 0;
			tag[T] = 0;
		}
		tag[ls[k]] += tag[k];
		sum[ls[k]] += tag[k];
		tag[rs[k]] += tag[k];
		sum[rs[k]] += tag[k];
		tag[k] = 0;
	}
	inline void modify(int &amp;k, int l, int r, int x, int y, int V) {
		if(!k) {
			k = ++T;
			ls[k] = 0;
			rs[k] = 0;
			sum[k] = 0;
			tag[k] = 0;
		}
		// printf(&quot;%d?\n&quot;, tag[k]);
		if(x &lt;= l &amp;&amp; y &gt;= r) {
			// printf(&quot;%d?%d %d %d\n&quot;, l, r, x, y);
			tag[k] += V;
			sum[k] += V; //非叶节点的这个没用
			// printf(&quot;%d?\n&quot;, sum[k]);
			return ;
		}
		pushdown(k);
		int mid = (l + r) &gt;&gt; 1;
		if(x &lt;= mid)modify(ls[k], l, mid, x, y, V);
		if(y &gt; mid)modify(rs[k], mid + 1, r, x, y, V);
	}
	inline int query(int k, int l, int r, int pos) {
		if(!k)return 0;
		// printf(&quot;%d %d %d\n&quot;, k, sum[k], tag[k]);
		if(l == r) {
			// printf(&quot;%d %d %d %d\n&quot;, l, r, k, sum[k]);
			return sum[k];
		}
		pushdown(k);
		int mid = (l + r) &gt;&gt; 1;
		if(pos &lt;= mid)return query(ls[k], l, mid, pos);
		else return query(rs[k], mid + 1, r, pos);
	}
}
using namespace seg;
int ans[MAXN];

struct SEG {
	int x, L, R;
	bool operator&lt;(const SEG &amp;y) {
		return x == y.x ? L &gt; y.L : x &lt; y.x;
	}
} que[MAXN];

bool cmp(const int &amp;x, const int &amp;y) {
	return mdf[x].z &lt; mdf[y].z;
}
//l1,r1 is mdf
//l2,r2 is ask
inline void fz(int L, int R, int l1, int r1, int l2, int r2) {
	if(L == R) {
		for(int i = l2; i &lt;= r2; ++i) {
			ans[qry[i].id] = L;
		}
		return ;
	}
	if(L &gt; R)return ;
	int mid = (L + R) &gt;&gt; 1;
	// printf(&quot;qwq in?%d %d %d %d %d %d %d\n&quot;, L, mid, R, l1, r1, l2, r2);
	assert(R &gt;= L);
	int T1 = 0, T2 = 0;
	for(int i = l1; i &lt;= r1; ++i) {
		// printf(&quot;%d?%d\n&quot;, mdf[i].x, mdf[i].y);
		if(mdf[i].z &lt;= mid) {
			B[++T1] = mdf[i];
		} else {
			A[++T2] = mdf[i];
		}
	}
	int T3 = 0;
	for(int i = 1; i &lt;= T1; ++i) {
		que[++T3].x = B[i].x;
		que[T3].L = B[i].y;
		que[T3].R = B[i].id;
		que[++T3].x = B[i].w + 1;
		que[T3].L = B[i].y;
		que[T3].R = -B[i].id;//del
	}
	//B is &lt; mid;
	for(int i = l2; i &lt;= r2; ++i) {
		que[++T3].x = qry[i].x;
		que[T3].L = -i;
		que[T3].R = qry[i].y;
		// printf(&quot;%d???%d\n&quot;, qry[i].y, qry[i].x);
	}
	sort(que + 1, que + T3 + 1);
	// for(int i = 1; i &lt;= T3; ++i)if(que[i].L &lt;= 0)printf(&quot;%d %d\n&quot;, que[i].x, que[i].L);
	// printf(&quot;??%d?\n&quot;, T3);
	root = T = 0;
	int tot1 = 0, tot2 = 0;
	for(int i = 1; i &lt;= T3; ++i) {
		assert(que[i].L != 0);
		// printf(&quot;%d?-&gt;\n&quot;, que[i].x);
		if(que[i].R &lt; 0) {
			que[i].R = -que[i].R;
			// printf(&quot;???what?:%d %d %d\n&quot;, que[i].x, que[i].L, que[i].R);
			modify(root, 1, n, que[i].L, que[i].R, -1);
		} else if(que[i].L &lt; 0) {
			que[i].L = -que[i].L;
			int P = que[i].L;
			int tmp = query(root, 1, n, que[i].R);
			// printf(&quot;Yes I am :%d?%d %d %d?%d\n&quot;, tmp, qry[P].id, qry[P].z, que[i].x, que[i].R);
			if(tmp &lt; qry[P].z) {
				// printf(&quot;I am a poor boy&quot;);
				C[++tot1] = qry[P];
				C[tot1].z -= tmp;
			} else {
				D[++tot2] = qry[P];//decrease
				ans[qry[P].id] = mid;
			}
		} else {
			// printf(&quot;%d %d\n&quot;, que[i].L, que[i].R);
			modify(root, 1, n, que[i].L, que[i].R, 1);
		}
	}
	for(int i = 0; i &lt; tot2; ++i) {
		qry[i + l2] = D[i + 1];
	}//C is who need less
	for(int i = 1; i &lt;= tot1; ++i) {
		qry[i + l2 + tot2 - 1] = C[i];
	}//D is who need big
	int fja = tot2 + l2;//分界点
	for(int i = 0; i &lt; T1; ++i) {
		mdf[i + l1] = B[i + 1];
	}//B is who need less
	for(int i = 1; i &lt;= T2; ++i) {
		mdf[i + l1 + T1 - 1] = A[i];
	}//A is who need big
	int fjb = T1 + l1;
	// printf(&quot;New R1 :%d,New R2 :	%d\n&quot;, fja, fjb);
	if(fjb - 1 &gt;= l1 &amp;&amp; fja - 1 &gt;= l2)
		fz(L, mid, l1, fjb - 1, l2, fja - 1);
	if(r1 &gt;= fjb &amp;&amp; r2 &gt;= fja)
		fz(mid + 1, R, fjb, r1, fja, r2);
	return;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;q);
	for(int i = 2, a, b; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
		ct(a, b);
		ct(b, a);
	}
	for(int i = 1; i &lt;= p; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;b[i].x, &amp;b[i].y, &amp;b[i].z);
		V = max(V, b[i].z);
	}
	dep[1] = 1;
	dfs(1, 0); //init dfn,siz
	dfs2(1, 1);
	// for(int i = 1; i &lt;= n; ++i)printf(&quot;well finished....%d %d\n&quot;, i, dfn[i]);
	for(int i = 1; i &lt;= q; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);
		if(dfn[a[i].x] &gt; dfn[a[i].y])
			swap(a[i].x, a[i].y);
		a[i].id = i;
	}
	init();
	fz(1, V, 1, p, 1, q); //整体二分!!
	for(int i = 1; i &lt;= q; ++i) {
		printf(&quot;%d\n&quot;, ans[i]);
	}
	return 0;
}


```

~~调了一个晚上+上午50min....~~</p>
]]></content>
    </entry>
</feed>