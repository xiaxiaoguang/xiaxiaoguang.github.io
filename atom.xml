<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-09-24T15:15:30.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[ 【LGR-076】洛谷 ⑨ 月月赛 I & Cnoi2020 ]]></title>
        <id>https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/</id>
        <link href="https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/">
        </link>
        <updated>2020-09-24T14:55:05.000Z</updated>
        <content type="html"><![CDATA[<p>呃呃呃本来想打的然后因为数学物理考试咕咕咕了...</p>
<p>说实话都是纸老虎仔细想想就切掉了....</p>
<p>P6832 [Cnoi2020]子弦</p>
<p>可以冲sam吗?.....1e7不太能啊</p>
<p>答案显然就是每个最短的串的出现次数</p>
<p>即统计a~z出现次数</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e7 + 8;
char s[MAXN];
int cnt[50], ans;
int main() {
	scanf(&quot;%s&quot;, s);
	int n = strlen(s);
	for(int i = 0; i &lt; n; ++i) {
		cnt[s[i] - 'a']++;
	}
	for(int i = 0; i &lt; 26; ++i)ans = max(ans, cnt[i]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
<p>P6833 [Cnoi2020]雷雨</p>
<p>一开始就发现了正解然后心里暗示自己是错误的/cy</p>
<p>显然可以做三遍最短路:第一遍是从最上层任意一个点出发到剩下所有点的,第二遍是从红魔馆,第三遍是迷途竹林</p>
<p>然后枚举中间点三者求和即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nmlog(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>因为点数和边数同阶所以dijkstra可过</p>
<p>spfa???老哥这是<strong>网格图</strong>啊</p>
<p>code:</p>
<p>咕咕咕</p>
<p>P6834 [Cnoi2020]梦原</p>
<p>纸老虎1</p>
<p>先想想给出一个树的形态咋做吧....</p>
<p>显然一定每次选极大连通块??</p>
<p>然后如果是链上好像就是积木大赛???</p>
<p>差分数组所有正值加起来???</p>
<p>啊啊啊这好像树上是一样的....</p>
<p>然后树形态不固定好像也会了....</p>
<p>因为显然一个值会在1/k个区间出现啊,他的贡献就是value*1/k</p>
<p>用一个二维数点,求区间比一个数大的数的和/数的出现次数</p>
<p>离线+树状数组即可</p>
<p>注意特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>此时概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>讲述写代码的时候一个sb错误:树状数组的add和取模优化的add重了QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int n,k;
ll fac[MAXN],ifac[MAXN],inv[MAXN];
struct rec {
	int x,id;
	bool operator&lt;(const rec &amp;w) const {
		return x&lt;w.x;
	}
} a[MAXN];

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
const int MAXT=2e6+7;
struct BIT {
#define lowbit(x) (x&amp;-x)
	ll tr[MAXT];
	inline ll qry(int x) {
		ll ret=0;
		if(x==0)return 0;
		for(; x; x-=lowbit(x)) {
			add(ret,tr[x]);
		}
		return ret;
	}
	inline void mdf(int x,ll V) {
		for(; x&lt;=n; x+=lowbit(x))add(tr[x],V);
	}
} tr1,tr2;

inline ll ksm(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&amp;1)ans=ans*x%P;
		x=x*x%P;
		y&gt;&gt;=1;
	}
	return ans;
}

inline void init() {
	fac[0]=1;
	for(int i=1; i&lt;=k; ++i)fac[i]=1ll*fac[i-1]*i%P;
	ifac[k]=ksm(fac[k],P-2);
	ifac[0]=ifac[1]=1;
	for(int i=k-1; i&gt;=2; --i)ifac[i]=1ll*ifac[i+1]*(i+1)%P;
	for(int i=1; i&lt;=k; ++i) {
		inv[i]=1ll*fac[i-1]*ifac[i]%P;
	}
	return ;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf,*pend=buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

signed main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	k=read();
	for(int i=1; i&lt;=n; ++i) {
		a[i].x=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	init();
	ll ans=0;
	for(int i=1; i&lt;=n; ++i) {
		if(a[i].id==1) {
			add(ans,a[i].x);
			tr1.mdf(a[i].id,a[i].x);
			tr2.mdf(a[i].id,1);
			continue;
		}
		int L=max(1ll,a[i].id-k);
		int sum=tr1.qry(a[i].id-1)-tr1.qry(L-1);
		int num=tr2.qry(a[i].id-1)-tr2.qry(L-1);
		add(ans,1ll*(num*a[i].x%P-sum+P)%P*inv[a[i].id-L]%P);
		tr1.mdf(a[i].id,a[i].x);
		tr2.mdf(a[i].id,1);
		//一个统计个数一个统计sum
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}

/*

5 4
1 2 3 4 5

*/


</code></pre>
<p>P6835 [Cnoi2020]线形生物</p>
<p>哇偶!</p>
<p>我:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i走到n的期望值</p>
<p>ljh:太棒了你可以高斯消元!</p>
<p>我:QAQ!</p>
<p>ljh随手在黑板上写了几个式子,然后切掉了!</p>
<p>我:!!!!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>走到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的期望步数</p>
<p>由期望的线性性质我们可以得到答案就是求个和</p>
<p>怎么求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>sum表示f数组前缀和</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></mfrac><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=\frac 1 {in[i]}*(\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+f_i+1)+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>然后我们随便化简一下</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]!=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>做完了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int id,n,m;
ll f[MAXN],sum[MAXN];

int home[MAXN],nxt[MAXN],to[MAXN],ccnt,in[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}

int main() {
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;=m; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		in[x]++;
	}
	for(int i=1; i&lt;=n; ++i) {
		in[i]++;
	}
	//dp！
	ll ans=0;
	for(int u=1; u&lt;=n; ++u) {
		f[u]=1;
		sum[u]=sum[u-1];
		if(in[u]==1) { //只有一步QAQ
			add(ans,1);
			add(sum[u],f[u]);
			continue;
		}
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			add(f[u],(sum[u]-sum[v-1]+1+P)%P);
		}
		add(sum[u],f[u]);
		add(ans,f[u]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr提高组十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/">
        </link>
        <updated>2020-09-22T15:05:50.000Z</updated>
        <content type="html"><![CDATA[<p>阴间的dmy</p>
<p>http://www.zhengruioi.com/contest/703</p>
<p>A</p>
<p>提高组D2T1送分题</p>
<p>但是题面不够长所以qwq</p>
<p>做法:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第一个串匹配到i第二个串匹配到j的最小代价</p>
<p>然后转移:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>!</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i!=b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{i,j}=min(f_{i-1,j-1},min(f_{i-1,j},f_{i,j-1}))+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i==b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>优化:因为答案不会超过50,所以第二维有用的只有100个状态</p>
<p>直接用这些dp即可</p>
<p>其实本题造数据很难把</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+7;
int n;
int f[MAXN][105];
char s[MAXN],t[MAXN];
int main() {
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%s&quot;,t+1);
	int n1=strlen(s+1);
	int n2=strlen(t+1);
	if(n1&lt;n2) {
		swap(n1,n2);
		swap(s,t);
	}
	if(n1-n2&gt;50)return printf(&quot;-1&quot;),0;
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0][50]=0;
	for(int i=1; i&lt;=n1; ++i) {
		for(int j=50; j&gt;=-50; --j) {
			int p=i-j;
			if(p&lt;0 || p&gt;n2)continue;
			if(s[i]==t[p]) {
				f[i][j+50]=f[i-1][j+50];
			} else {
				f[i][j+50]=min(f[i][j+1+50],min(f[i-1][j-1+50],f[i-1][j+50]))+1;
			}
		}
	}
	if(f[n1][n1-n2+50]&gt;50)return printf(&quot;-1&quot;),0;
	printf(&quot;%d\n&quot;,f[n1][n1-n2+50]);
	return 0;
}


</code></pre>
<p>B</p>
<p>神仙数学题</p>
<p>你考虑维护两个L,R是2的幂次,同时满足形式:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111111</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111111(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111112</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111112(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>然后考虑合法成为答案的数x一定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之间</p>
<p>那么这个数字的幂次要尽可能的小于是想到再维护两个和这个差不多的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>Lx表示把前200位拿出来的前缀幂次最小值,<strong>如果不够两百位我们后面用0补齐两百位</strong></p>
<p>Rx表示把前两百位拿出来的前缀幂次最大值<strong>不够两百位也是用零补齐</strong></p>
<p>然后每次用x*Lx,如果正好大于L就是答案,否则我们如果小于Rx就留下更新然后不乘了</p>
<p>否则然后更新一次后我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo>∗</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx*Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>这个值去考虑更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>如果大于Rx更新Rx否则更新Lx</p>
<h2 id="因为我们lxrx的性质他一定满足大于或小于">因为我们Lx,Rx的性质他一定满足大于或小于!</h2>
<p>那你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">LxRx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>的形式都是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000000000</mn><mo>(</mo><mi>x</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1000000000(x个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9999999999</mn><mo>(</mo><mi>y</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9999999999(y个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>所以仔细思考一下我们一定能倍增出第一个合法的了</p>
<p>然后做完了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 100005 /*rem*/
#define mod 998244353
#define db double
#define vi vector&lt;int&gt;
#define pb push_back
#define mp make_pair
#define pi pair&lt;int, int&gt;
#define fi first
#define se second
using namespace std;
ll ksm(ll a, ll b) {
   if (!b) return 1;
   ll ns = ksm(a, b &gt;&gt; 1);
   ns = ns * ns % mod;
   if (b &amp; 1) ns = ns * a % mod;
   return ns;
}
const int mxs = 230; /*reme*/
void upd(vi &amp;a) {
	for (int i = 0; i &lt; a.size(); i++)
		if (a[i] &gt;= 10) {
			if (i == a.size() - 1)
				a.pb(a[i] / 10);
			else a[i + 1] += a[i] / 10;
			a[i] %= 10;
		}	
	if (a.size() &gt; mxs) {
		for (int j = 0; j &lt; mxs; j++)
			a[j] = a[a.size() - mxs + j];
		a.resize(mxs);
	} 
}
void otp(vi a) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		cout &lt;&lt; a[i];
	cout &lt;&lt; endl;
}
vi operator * (vi &amp;a, vi &amp;b) {
	vi c(a.size() + b.size() - 1);
	for (int i = 0; i &lt; c.size(); i++) c[i] = 0;
	for (int i = 0; i &lt; a.size(); i++)
		for (int j = 0; j &lt; b.size(); j++)
			c[i + j] += a[i] * b[j];
	upd(c);
//	cout &lt;&lt;&quot;NUL&quot; &lt;&lt; endl;
//	otp(a), otp(b), otp(c);
	return c;
}
bool operator &lt; (vi &amp;a, vi &amp;b) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		if (a[i] != b[i]) return a[i] &lt; b[i];
	return 0;
} 
vi operator + (vi &amp;a, vi &amp;b) {
	vi c(max(a.size(), b.size()));
	for (int i = 0; i &lt; c.size(); i++) {
		c[i] = 0;
		if (i &lt; a.size())
			c[i] += a[i];
		if (i &lt; b.size())
			c[i] += b[i];
	}
	upd(c);
	return c;
}
struct pw {
	vi a;
	vi b; // ��
	pw(){a.clear(), b.clear();}
	pw(vi x, vi y) {
		a = x, b = y;
	} 
	pw operator * (pw c) {
		
		return pw(a * c.a, b + c.b);
	}
};
pw L, R, cur;
vi lb, mx;
char inp[mxs];
void otp(pw a) {
	otp(a.a), otp(a.b);
}
int main() {
//	freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);
	int l;
	cin &gt;&gt; l;
	for (int i = 0; i &lt; l; i++)
		inp[i] = '1';
	vi u, v;
	for (int i = 0; i &lt; mxs - 1; i++)
		u.pb(0);
	u.pb(2), v.pb(1);	
	for (int i = 0; i &lt; mxs - l; i++)
		lb.pb(0), mx.pb(9);
	for (int i = l - 1; i &gt;= 0; i--)
		lb.pb(inp[i] - '0'), mx.pb(inp[i] - '0'); 
	L = pw(u, v);
	R = pw(u, v);		
	v[0] = 0, u[mxs - 1] = 1;
	cur = pw(u, v);
	while (1) {
	//	otp(L), otp(R);
		while (1) {
			pw ed = cur * L;
		//	otp(ed);
			if (cur.a &lt; ed.a &amp;&amp; ed.a &lt; mx) {
				cur = ed;
				if (!(cur.a &lt; lb)) {
					for (int i = cur.b.size() - 1; i &gt;= 0; i--)
						cout &lt;&lt; cur.b[i];
					cout &lt;&lt; endl;
					return 0;
				}
			}
			else break;
		}
		while (1) {
			pw nr = L * R;
			if (nr.a[mxs - 1] == 1) {
				L = nr;
				break;
			}
			else R = nr;
		}
	}
	return 0;
}



不是自己写的
</code></pre>
<p>C</p>
<p>倒序染色</p>
<p>然后你会发现我们每次还没有染色的相邻的不能染同一种颜色</p>
<p>其他的随便染上当前颜色即可</p>
<p>这个k的构造方式就是每次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">n-n/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">3</span></span></span></span>的迭代到0的次数....</p>
<p>可以证明最后这样染出颜色的方案一定不会存在一个区间的没有出现次数为1的</p>
<p>因为不管怎么样你都会被一个新颜色叉掉</p>
<p>倒序是因为前面的限制严,要用出现次数少的颜色</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
int n, k, a[MAXN];
//考虑用一种颜色染大于sum/3的灯然后我们递归剩下的解决
//我们要小心任何时刻都不能有相临相同的?
int b[MAXN], vis[MAXN], c[MAXN];
vector&lt;int&gt;  near[MAXN];
set&lt;int&gt; st;
inline void init() {
	st.clear();
	st.insert(n + 1);
	st.insert(0);
	for(int i = 1; i &lt;= n; ++i) {
		near[i].clear();
	}
	for(int i = 1; i &lt;= n; ++i)
		if(!vis[i]) {
			auto qwq1 = st.lower_bound(i);
			auto qwq2 = st.upper_bound(i);
			// printf(&quot;%d?%d\n&quot;, qwq1, qwq2);
			// near[a[i]].push_back(*qwq2);
			// near[*qwq2].push_back(a[i]);
			qwq1--;
			near[i].push_back(*qwq1);
			near[i].push_back(*qwq2);
			near[*qwq1].push_back(i);
			near[*qwq2].push_back(i);
			st.insert(i);
		}
	for(int i = 1; i &lt;= n; ++i) {
		if(!vis[i]) {
			sort(near[i].begin(), near[i].end());
			near[i].erase(unique(near[i].begin(), near[i].end()), near[i].end());
			// printf(&quot;%d\n&quot;, i);
			// for(auto v : near[i]) {
			// 	printf(&quot;%d &quot;, v);
			// }
			// puts(&quot;??&quot;);
		}
	}
	return ;
}

inline void solve(int l, int r, int dep) {
	if(l &gt; r)return;
	// printf(&quot;%d %d %d\n&quot;, l, r, dep);
	init();
	int limit = ceil((double)(r - l + 1) / 3);
	// if(limit == 0)limit = 1;
	for(int i = r; i &gt;= l; --i) {
		int p = a[i];
		if(!vis[p]) {
			bool flg = 1;
			// printf(&quot;in- &gt; %d\n&quot;, p);
			for(auto v : near[p]) {
				if(b[v] == dep) {
					// printf(&quot;%d %d???\n&quot;, v, dep);
					flg = 0;
				}
			}
			if(flg) {
				vis[p] = 1;
				b[p] = dep;
				limit--;
				// printf(&quot;%d %d\n&quot;, p, dep);
			}
		}
		if(!limit)break;
	}
	int tot = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(!vis[a[i]]) {
			// printf(&quot;%d?\n&quot;, i);
			c[++tot] = a[i];
		}
	}
	// printf(&quot;tot-&gt;%d\n&quot;, tot);
	for(int i = l; i &lt;= l + tot - 1; ++i) {
		// printf(&quot;%d\n&quot;, c[i - l + 1]);
		a[i] = c[i - l + 1];
	}
	// if(l = l + tot - 1)
	solve(l, l + tot - 1, dep + 1);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	init();
	solve(1, n, 1);
	for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, b[i]);
	puts(&quot;&quot;);
	return 0;
}

/*

3 3
1  2  3

4 3
4 3 2 1

*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020普转提七连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/">
        </link>
        <updated>2020-09-21T14:56:57.000Z</updated>
        <content type="html"><![CDATA[<p>http://www.zhengruioi.com/contest/704</p>
<p>没有上场毒瘤啊</p>
<p>A</p>
<p>打眼一看好像直接模拟就好了</p>
<p>但是可能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>情况</p>
<p>这种情况下根据kmp的错位相同原理,我们可能有很多字符是要一样的</p>
<p>那么我们用一个并查集把这样的字符形成的连通块找出来然后暴力看看每一块改成什么就好了</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>a</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nalogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>属于不精细的实现QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7;
int n, k, ans;
char a[MAXN];
int fa[MAXN], num[MAXN][26];
inline int getf(int x) {
	return fa[x] == x ? x : fa[x] = getf(fa[x]);
}

inline void merge(int x, int y) {
	for(int i = 0; i &lt; 26; ++i) {
		num[getf(x)][i] += num[getf(y)][i];
	}
	fa[getf(y)] = getf(x);

	return ;
}

inline void init() {
	for(int i = 1; i &lt;= n; ++i) {
		fa[i] = i;
		num[i][a[i] - 'a'] = 1;
	}
	return ;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s&quot;, a + 1);
	init();
	int l = n - k + 1, r, tmp;
	//错位相同,显然我们错位不能多了
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] != i)continue;
		r = l + i - 1;
		merge(i, r);
		tmp = r - 1 + l;
		while(tmp &lt;= n) {
			merge(i, tmp);
			if(tmp &gt; k) {
				break;
			}
			tmp = tmp - 1 + l;
		}
	}
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] == i) {
			int S = 0, Max = -1;
			for(int j = 0; j &lt; 26; ++j) {
				if(num[i][j] &gt; Max)Max = num[i][j];
				S += num[i][j];
			}
			ans += S - Max;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

10 7
aabaabaabc
5 4
abcde
5 3
abcba
6 4
abbbaa

*/


</code></pre>
<p>B</p>
<p>每一位只要出现011三个字符就一定可以判断出三种运算了</p>
<p>因为&amp;和其他可以用01去试,然后xor和|可以用11去试</p>
<p>显然不存在其他的不包括这个011的方案能验证出来....</p>
<p>答案每一位取max即可</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 505;

int n, m, T;
char a[MAXN][MAXN];
int cnt[MAXN], flg[MAXN];

inline void init() {
	for(int i = 1; i &lt;= m; ++i) {
		cnt[i] = flg[i] = 0;
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		init();
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, a[i] + 1);
		}
		for(int i = 1; i &lt;= n; ++i) {
			for(int j = 1; j &lt;= m; ++j) {
				if(a[i][j] == '0') {
					flg[j] = 1;
				}
				if(a[i][j] == '1') {
					cnt[j]++;
				}
			}
		}
		int ans = 0;
		for(int i = 1; i &lt;= m; ++i) {
			if(flg[i] &amp;&amp; cnt[i] &gt;= 2) {//110
				continue;
			} else if(!flg[i] &amp;&amp; cnt[i] &gt;= 2) {//111
				ans = max(ans, 1);
			} else if(flg[i] &amp;&amp; cnt[i] &lt; 2) {//0??
				ans = max(ans, 2 - cnt[i]);
			} else if(!flg[i] &amp;&amp; cnt[i] &lt; 2) {//???
				ans = max(ans, 3 - cnt[i]);
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>md....好像做过啊!</p>
<p>结论:大于53的质数没有用处,大于60的数没有用处</p>
<p>因为我们改成1一定更优秀</p>
<p>所以你会发现我们最后序列每个质因数一定只用了一次....</p>
<p>所以状压一下这16个质因数</p>
<p>然后考虑dp,f_{i,S}表示考虑了前i个数已经用了的质因数集合为S的最小代价</p>
<p>转移枚举下个数填什么,然后一定要是某个补集的子集才行</p>
<p>有很多种优化的方法</p>
<ol>
<li>60个数不用全部枚举,可以剪掉一些显然sb的</li>
<li>只枚举当前有用集合中的,而有用集合可以预处理</li>
</ol>
<p>code就没有了</p>
<p>D</p>
<p>重题</p>
<p>跟沈睿哥哥吐糟还被骂了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1600701080965.png" alt="" loading="lazy"></figure>
<p>参照某篇叫[国家集训队]等差子序列的题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5384 [Cnoi2019]雪松果树]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/">
        </link>
        <updated>2020-09-19T14:51:07.000Z</updated>
        <content type="html"><![CDATA[<p>单独腾一篇博客吧!</p>
<p>关于树上k级祖先和树上k级儿子的绝对快做法</p>
<p>首先枚举下各种做法吧!</p>
<h1 id="树上k级祖先">树上k级祖先</h1>
<h2 id="onlogn预处理"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>预处理</h2>
<ol>
<li>倍增求k级祖先</li>
</ol>
<p>显然,回答一组询问也是严格log的</p>
<p>访问空间太慢而且会被卡空间所以很屑</p>
<ol start="2">
<li>树剖求k级祖先</li>
</ol>
<p>当重链长度大于k,我们k级祖先就在这条链上,对于一个链都记录了直接访问即可...</p>
<p>这个显然不如:</p>
<ol start="3">
<li>长链剖分求k级祖先</li>
</ol>
<p>预处理每个长链数组还是要的</p>
<p>预处理倍增数组还是要的QAQ否则你可以尝试OnO1rmq!</p>
<p>然后你会发现我们如果一步跳到k最高二进制位的祖先后</p>
<p>由于k级祖先的长链长度一定大于这个数的</p>
<p>所以我们可以再从那个点向上或者向下沿着长链跳一步即可</p>
<p>时间复杂度回答起来是O1的</p>
<h2 id="on离线">O(n)离线</h2>
<p>开一个栈记录从根到x dfs经过的所有点</p>
<p>然后我们考虑dfs到x回答x的所有询问即可</p>
<h1 id="k级儿子个数和">k级儿子个数和</h1>
<p>hh</p>
<ol>
<li>线段树合并</li>
</ol>
<p>按照深度为下标建树然后每个位置记录有多少数</p>
<p>线段树合并</p>
<ol start="2">
<li>dsu on tree</li>
</ol>
<p><code>树上启发式合并</code></p>
<p>线段树合并另一种实现形式....</p>
<ol start="3">
<li>离线树状数组</li>
</ol>
<p>相当于数一个区间的某一个深度的个数</p>
<ol start="4">
<li>二分+vector</li>
</ol>
<p>每个深度的点开一个vector全部记录下来,然后在哪个vector处二分即可</p>
<p>当然可以压成所有的一个数组来优化空间</p>
<ol start="5">
<li>长链剖分</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">O(n)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
<p>出现了线性做法!</p>
<p>其实是利用了长链性质优化了dsu on tree</p>
<h1 id="finally">Finally</h1>
<p>my choice : (你谷最快)</p>
<p>可以离线求k级祖先</p>
<p>然后第二个数点我们可以树上差分</p>
<p>因为只求等于某个数的个数啊...</p>
<p>附上你谷rank 1代码</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e6+7;
const int MAXQ=3e6+7;
int n,m;
int ccnt,home[MAXN],id[MAXQ],nxt[MAXQ],to[MAXQ],fst[MAXN],sec[MAXN],dep[MAXN];
int ans[MAXN],st[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}

	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
	int _C=-1,_Z;
	char _sr[1&lt;&lt;21],_z[20];
	inline void Ot() {
		fwrite(_sr,1,_C+1,stdout),_C=-1;
	}
	inline void print(int x) {
		if(_C&gt;1&lt;&lt;20)Ot();
		while(_z[++_Z]=x%10+48,x/=10);
		while(_sr[++_C]=_z[_Z],--_Z);
		_sr[++_C]=' ';
	}
}
using namespace fastIO;

inline void ct(const int &amp;u,const int &amp;v) {
	ccnt++;
	nxt[ccnt]=home[u];
	home[u]=ccnt;
	to[ccnt]=v;
}

inline void ct2(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=fst[u];
	fst[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

inline void ct3(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=sec[u];
	sec[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

int tp,cnt[MAXN];
inline void dfs(int u) {
	st[++tp]=u;
	int v;
	for(int i=fst[u]; i; i=nxt[i]) {
		v=to[i];
		if(v&lt;tp) {
			ct3(st[tp-v],v,id[i]);
		}
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dep[v]=dep[u]+1;
		dfs(v);
	}
	--tp;
}

inline void dfs2(int u) {
	int v;
	cnt[dep[u]]++;
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]-=cnt[dep[u]+v];
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dfs2(v);
	}
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]+=cnt[dep[u]+v]-1;
	}
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	m=read();
	for(int i=2,x; i&lt;=n; ++i) {
		x=read();
		ct(x,i);
	}
	for(int i=1,x,y; i&lt;=m; ++i) {
		x=read();
		y=read();
		ct2(x,y,i);
	}
	dep[1]=1;
	dfs(1);
	dfs2(1);
	for(int i=1; i&lt;=m; ++i)print(ans[i]);
	Ot();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/">
        </link>
        <updated>2020-09-18T15:02:37.000Z</updated>
        <content type="html"><![CDATA[<p>哎...人总有写挂的一天吗?</p>
<p>A</p>
<p>傻逼题用map直接模拟即可</p>
<p>最后剩下的那个就是答案</p>
<p>卡双模hash</p>
<p>时间复杂度O(nlogn)</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int bas1 = 12344;
const int bas2 = 67891;
const int P1 = 1e9 + 9;
const int P2 = 1e9 + 3;
const int MAXS = 30;
const int MAXN = 1e5 + 7;
#define pii pair&lt;ll,ll&gt;
#define se second
#define fi first
#define mkp(x,y) make_pair(x,y)
int n;
string s;
map&lt;string, int&gt; mp;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 0; i &lt; n + n - 1; ++i) {
		cin &gt;&gt; s;
		mp[s]++;
	}
	for(auto v : mp) {
		if(v.se &amp; 1)
			cout &lt;&lt; v.fi &lt;&lt; endl;
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>就是base为2i的进制转换</p>
<p>直接模拟即可</p>
<p>这个可以看看代码</p>
<p>注意</p>
<ol>
<li>输出虚数部分的+时要小心,因为可能前面那个数是0啊</li>
<li>特判0</li>
</ol>
<p>而又没法对拍,只能手动....</p>
<p>code:</p>
<pre><code class="language-cpp">/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/
//orzEI!
#include&lt;bits/stdc++.h&gt;
#define ll __int128
using namespace std;
const int MAXN = 100;

ll t1, t2, p1, p2, q1, q2;
char s[MAXN];
int cnt;
ll qwq[MAXN];

namespace fastIO {
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(ll x) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
	}
	inline void print2(char s) {
		_sr[++_C] = s;
	}
}
using namespace fastIO;

inline void init() {
	qwq[0] = 1;
	for(int i = 1; i &lt; 80; ++i)qwq[i] = qwq[i - 1] * 2;
	return ;
}

inline ll ksm(int x) {
	return qwq[x];
}

inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

int main() {
	scanf(&quot;%s&quot;, s + 1);
	int a = strlen(s + 1);
	if(a == 1 &amp;&amp; s[1] == '0') {
		return puts(&quot;0&quot;), 0;
	}
	init();
	cnt = a + 1;
	for(int i = 1; i &lt;= a; ++i) {
		if(s[i] == '.') {
			cnt = i;
			break;
		}
	}
	//处理整数部分
	for(int i = 1; i &lt; cnt; ++i) {
		int t = (cnt - i) % 4;
		if(t == 1) { //正数
			t1 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if(t == 2) { //正数i
			t2 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if (t == 3) { //负数
			t1 -= ksm(cnt - i - 1) * (s[i] - '0');
		} else {//负数i
			t2 -= ksm(cnt - i - 1) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',t1,t2,i);
	}
	//处理小数部分
	//使用最大的那一部分，然后除除gcd吧QAQ
	for(int i = a; i &gt; cnt; --i) {
		if(s[i] == '0')continue;
		int t = (i - cnt) % 4;
		//		printf(&quot;%d?%d\n&quot;,t,i);
		if((t == 1 || t == 3) &amp;&amp; !q2) {
			q2 = ksm(i - cnt);
		}
		if((t == 2 || t == 0) &amp;&amp; !q1) {
			q1 = ksm(i - cnt);
		}
	}
	if(!q1)q1 = 1;
	if(!q2)q2 = 1;
	//	printf(&quot;%lld %lld\n&quot;,q1,q2);
	for(int i = cnt + 1; i &lt;= a; ++i) {
		int t = (i - cnt) % 4;
		if(t == 1) { //负数i
			p2 -= q2 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 2) { //负数
			p1 -= q1 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 3) { //正数i
			p2 += q2 / ksm(i - cnt) * (s[i] - '0');
		} else {//正数
			p1 += q1 / ksm(i - cnt) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',p1,p2,i);
	}
	//	printf(&quot;%lld %lld %lld %lld %lld %lld\n&quot;,p1,q1,t1,p2,q2,t2);
	p2 += q2 * t2;
	p1 += q1 * t1;
	ll qwq1 = gcd(p1, q1);
	ll qwq2 = gcd(p2, q2);
	p2 /= qwq2;
	q2 /= qwq2;
	p1 /= qwq1;
	q1 /= qwq1;
	if(q1 &lt; 0)p1 = -p1, q1 = -q1; //同时乘-1
	if(q2 &lt; 0)p2 = -p2, q2 = -q2;
	if(p1 != 0) {
		if(p1 &lt; 0) {
			print2('-');
			p1 = -p1;
		}
		if(q1 == 1) {
			print(p1);
		} else {
			print(p1);
			print2('/');
			print(q1);
		}
	}
	if(p2 != 0) {
		if(p2 &lt; 0) {
			print2('-');
			p2 = -p2;
		} else {
			if(p1 != 0)
				print2('+');//死因啊
		}
		if(q2 == 1) {
			if(p2 != 1)
				print(p2);
		} else {
			print(p2);
			print2('/');
			print(q2);
		}
		print2('i');
	}
	Ot();
	return 0;
}

/*

311111111.11111
11111111.11111
111111111111111111111111111111.11111111111111111111111111111111
11111111111111111111111111111111

*/



</code></pre>
<p>哎...这尼玛的都能卡</p>
<p>C</p>
<p>就差一步啊QAQTAT</p>
<p>首先把整个序列变成一个前1后-1的差分的形式后</p>
<p>我们可以发现相邻的1,-1可以用后面的一个1替代,然后相邻的-1,1 可以用后面的一个-1替代....</p>
<p>就做完了....最后数数序列中有数的位置有多少个即可</p>
<pre><code class="language-cpp">
/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int T;
char a[MAXN];
int b[MAXN];


// inline void solve() {
// 	int n = strlen(a + 1);
// 	int cnt = 0;
// 	ans = 0;
// 	bool flg = 1;
// 	memset(b, 0, sizeof(b));
// 	a[n + 1] = '0';
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(flg &amp;&amp; a[i] == '1') {
// 			//			ans++;
// 			b[i] = 1;
// 			continue;
// 		}
// 		if(flg &amp;&amp; a[i] == '0') {
// 			flg = 0;
// 		}
// 		cnt += a[i] - '0';
// 		if(cnt == 1 &amp;&amp; a[i + 1] == '0') {
// 			//			++ans;
// 			b[i] = 1;
// 			cnt = 0;
// 		} else if(a[i + 1] == '0' &amp;&amp; cnt &gt; 1) {
// 			b[i - cnt] = 1;
// 			b[i] = -1;
// 			cnt = 0;
// 			//			ans+=2;
// 		}
// 	}
// 	//	puts(&quot;qwq&quot;);
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
// 			b[i + 1] = -1;
// 			b[i] = 0;
// 		}
// 		ans += (b[i] != 0);
// 		//		printf(&quot;%d &quot;,b[i]);

// 	}
// 	//	puts(&quot;&quot;);
// 	//	printf(&quot;%d\n&quot;,ans);
// }

inline void solve2() {
	int n = strlen(a + 1);
	int cnt = 0;
	int ans = 0;
	bool flg = 1;
	memset(b, 0, sizeof(b));
	a[n + 1] = '0';
	for(int i = 1; i &lt;= n; ++i) {
		if(flg &amp;&amp; a[i] == '1') {
			//			ans++;
			b[i] = 1;
			continue;
		}
		if(flg &amp;&amp; a[i] == '0') {
			flg = 0;
		}
		cnt += a[i] - '0';
		if(a[i + 1] == '0' &amp;&amp; cnt &gt;= 1) {
			b[i - cnt] = 1;
			b[i] = -1;
			cnt = 0;
			//			ans+=2;
		}
	}
	//	puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(b[i] == 1 &amp;&amp; b[i + 1] == -1) {
			b[i + 1] = 1;
			b[i] = 0;
		}
		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
			b[i + 1] = -1;
			b[i] = 0;
		}
		ans += (b[i] != 0);
		//		printf(&quot;%d &quot;,b[i]);

	}
	//	puts(&quot;&quot;);
	printf(&quot;%d\n&quot;, ans);
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, a + 1);
		// solve();
		solve2();
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>OEIS</p>
<p>i*(i+1)爆int了</p>
<p>正确做法:</p>
<p>考虑组合数学</p>
<p>首先我们枚举k表示把第一类小球分成几组</p>
<p>然后方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>然后我们在此基础上把第二类小球加进去,就是考虑我们只能插在第一类小球之间,和第一类放在一起</p>
<p>假设有t种,方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>那么我们第一种是第一类小球两侧都是第二类小球,第二种是左侧或者右侧是第二类小球,第三种是第二类小球两侧都是第一类小球</p>
<p>对应t的k+1,k,k-1三种可能</p>
<p>方案数就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><mo>∗</mo><mo>(</mo><mn>1</mn><mo>+</mo><mo>[</mo><mi>t</mi><mo>=</mo><mo>=</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\binom{n-1}{k-1}\binom{n-1}{t-1}*(1+[t==k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2984390000000001em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.895108em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<p>然后第三类小球只能把所有我们相邻的位置杀掉</p>
<p>考虑我们一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mo>+</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(k+t+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>个位置颜色相邻不相同</p>
<p>而我们现在加入了2n个球,所以我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>k</mi><mo>−</mo><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2n+1-k-t-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个位置颜色相邻相同</p>
<p>所以说我们需要插入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mo>(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">n-(2n-k-t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>个第三类小球干掉这些位置</p>
<p>然后剩下的第三类小球从左向右依次蹦进我们相邻颜色不相同的位置就行了</p>
<p>因为其实就是每个第三类小球匹配了前面的一些合法空当位置,变成了有标号</p>
<p>然后我们再把他们拿出一些分给不相同就是无标号组合数了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 1e6 + 7;
inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
ll f[MAXN];
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	f[1] = 6;
	f[2] = 30;
	for(int i = 3; i &lt;= n; ++i) {
		f[i] = (f[i - 1] * (7 * i - 4) % P * (i + 1) % P + f[i - 2] * 8 % P * (i - 2) % P * (i - 2) % P) % P * ksm(1ll * i * (i + 1) % P, P - 2) % P;
		f[i] %= P;
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR20秋季普转提day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/">
        </link>
        <updated>2020-09-15T14:41:19.000Z</updated>
        <content type="html"><![CDATA[<p>zzzz</p>
<p>孙笑川都干了那些坏事?</p>
<p>A</p>
<p>考虑他的转化问题:随机一个n个点的排列,从左往右删除每次删掉一个点之后我们把他的所有祖先都删除掉</p>
<p>那么答案就是这样一个排列的期望删除次数</p>
<p>不难发现可以变成每个数期望删除次数之和</p>
<p>然后就会发现概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>,也就是说我有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>的几率在排列中比我儿子都靠前</p>
<p>对上述求和即可</p>
<p>复杂度O(n)</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
const int P = 998244353;
const int MAXN = 1e7 + 7;
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], n, siz[MAXN];
ll ans, A[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;24)
	char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = nc();
		int x = 0;
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
};
using namespace fastIO;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		dfs(v);
		siz[u] += siz[v];
	}
	ans = (ans + A[siz[u]]) % P;
}

int main() {
	n = read();
	for(int i = 2, x; i &lt;= n; ++i) {
		x = read();
		ct(x, i);
	}
	A[0] = 1;
	A[1] = 1;
	for(int i = 2; i &lt;= n; ++i)		{
		A[i] = (P - (P / i)) * A[P % i] % P;
	}
	dfs(1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}



</code></pre>
<p>B</p>
<p>考场上用数据结构写了个很能卡的贪心hhh</p>
<p>但是出题人不一定想的到,数据也很水就过了</p>
<p>正确做法:</p>
<p>n为偶数,随便拿走一个变成奇数的情况</p>
<p>n为奇数,我们按照a排序,然后拿走第一个,</p>
<p>然后剩下的我们两组两组之间拿走b值较大的那个</p>
<p>可以证明我们拿走了最大的那个a就能保证我们剩下一定不会卡</p>
<p>也可以证明因为我们每次都拿了两两较大的b,rank最劣也是倒2,倒4,倒6.....一定大于倒1,倒3....即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
int n;
ll S1, S2;
struct rec {
	int x, y, id;
	bool operator&lt;(const rec &amp;w)const {
		return x &gt; w.x;
	}
} a[MAXN];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].x);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].y);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	int i = 0;
	printf(&quot;%d\n&quot;, n / 2 + 1);
	if(!(n &amp; 1)) {
		printf(&quot;%d %d &quot;, a[1].id, a[2].id);
		i = 3;
	} else {
		printf(&quot;%d &quot;, a[1].id);
		i = 2;
	}
	for(; i &lt;= n; i += 2) {
		if(a[i].y &gt;= a[i + 1].y) {
			printf(&quot;%d &quot;, a[i].id);
		} else {
			printf(&quot;%d &quot;, a[i + 1].id);
		}
	}
	puts(&quot;&quot;);
	return 0;
}


</code></pre>
<p>C</p>
<p>二分之后限制二变成了子树内至多有一些点能染色</p>
<p>然后我们按照这个range的性质dp去判断可不可行</p>
<p>细节有一堆</p>
<ol>
<li>上界更新的时候注意+1</li>
<li>不要阴间的重设上界范围</li>
<li>注意判断siz和down大小范围,all和up的范围</li>
</ol>
<p>坑死了,因为造不出很强的数据所以过拍不过题调了好久</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 3e5 + 7;
const int inf = 1e9 + 7;
int n, ccnt, home[MAXN], nxt[MAXN], to[MAXN];
int up[MAXN], down[MAXN], A, B, g[MAXN];
int f[MAXN], flg, siz[MAXN], all,rc[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs1(int u, int F) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		siz[u] += siz[v];
	}
	if(n - siz[u] &lt; up[u]) {
		flg = 0;
	}
	return ;
}

inline void dfs(int u, int F) {
	bool tflg = 0;
	int tmp = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		f[u] += f[v];
		tmp += up[v];
	}
	up[u] = min(tmp, up[u]);
	if(f[u] &lt; down[u])
		f[u] = down[u];
	if(f[u] &gt; siz[u])flg = 0;
	if(f[u] &gt; up[u] || f[u] &gt; all)flg = 0;
	return;
}

inline int chk(int x) {
	all = x;
	for(int i = 1; i &lt;= n; ++i) {
		rc[i] = up[i];
		up[i] = x - up[i];
	}
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	flg = 1;
	dfs(1, 0);
	if(x &gt; up[1]) flg=0;
	for(int i = 1; i &lt;= n; ++i) {
		up[i] = rc[i];
	}
	return flg;
}

inline void solve() {
	int l = 0, r = n + 1, ans = -1, mid = 1;
	for(int i = 1; i &lt;= n; ++i) {
		l = max(l, down[i] + up[i]);
	}
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			ans = mid;
		} else {
			l = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return;
}

signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	scanf(&quot;%lld&quot;, &amp;A);
	for(int i = 1, x, y; i &lt;= A; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		down[x] = max(down[x], y);
	}
	scanf(&quot;%lld&quot;, &amp;B);
	for(int i = 1, x, y; i &lt;= B; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		up[x] = max(up[x], y);
	}
	flg = 1;
	dfs1(1, 0);
	if(!flg)return puts(&quot;-1&quot;), 0;
	solve();
	return 0;
}

/*

3
1 3
1 2
1 4
0
3
2 3
3 2
4 2


*/


</code></pre>
<p>D</p>
<p>博弈论+计数dp</p>
<p>非常烦啊</p>
<p>首先预处理两个数组g[0/1][x][i]表示alice/bob在x子树任意总方案(包括染色方案和重儿子选择方案)下保证权值小于等于i的方案数,这个方案可以不均衡</p>
<p>转移:,以alice层为例</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[1][x][i]=g[1][ls][i]*a[rs]+g[1][rs][i]*a[ls]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p>
<p>a数组是任意选择的方案数(不限制权值)</p>
<p>表示我们Alice在转移的时候可以选择左子树走下去也可以选择右子树走下去</p>
<p>但是我们选择什么就是什么,所以另一颗子树随便选择</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[2][x][i]=2*g[2][ls][i]*g[2][rs][i]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
<p>表示我们bob在转移时,左右子树必须都能够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">&lt;=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>否则一切换可能会导致最后走下去权值变大</p>
<p>然后处理f数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{0/1,i,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示alice/bob从上到下走到点x,权值等于i的均衡方案数</p>
<p>转移的时候(假设我们在转移)我们会发现,如果这个正好是他的层,就直接从上面继承下来就好了</p>
<p>否则我们可能要面临对手切换子树的风险,所以要保证另一颗子树走下去权值不会超过i</p>
<p>也就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{0/1,i,rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>最后到叶子的时候,你会发现我们这个方案乘起来一定包括了整棵树的决策,所以只需要f数组求个和然后对应相乘了</p>
<p>因为我们再alice层只会让bob去计算另一颗子树的选择方案,而在bob层只会让alice算,那么和你的第二维没关系,之和你这条链长啥样有关</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 5e3 + 7;
int n, K, ans;
int dep[MAXN], fa[MAXN], ls[MAXN], rs[MAXN];
int g[3][MAXN][MAXN], f[3][MAXN][MAXN], a[MAXN];

inline void add(int &amp;x, ll y) {
	x = x + y &gt; P ? (x + y - P) : (x + y);
}

inline void dfs(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = g[2][u][i] = 1ll * i * K % P;
		}
		a[u] = 1ll * K * K % P;
		return ;
	}
	dep[ls[u]] = dep[u] + 1;
	dep[rs[u]] = dep[u] + 1;
	if(ls[u])dfs(ls[u]);
	if(rs[u])dfs(rs[u]);
	a[u] = 2ll * a[ls[u]] % P * a[rs[u]] % P;
	if(dep[u] &amp; 1) {//奇数,bob
		for(int i = 1; i &lt;= K; ++i) {
			add(g[1][u][i], 1ll * g[1][ls[u]][i] * a[rs[u]] % P + 1ll * g[1][rs[u]][i] * a[ls[u]] % P);
			g[2][u][i] = 2ll * g[2][ls[u]][i] % P * g[2][rs[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = 2ll * g[1][ls[u]][i] % P * g[1][rs[u]][i] % P;
			add(g[2][u][i], 1ll * g[2][ls[u]][i] * a[rs[u]] % P + 1ll * g[2][rs[u]][i] * a[ls[u]] % P);
		}
	}
	return ;
}

inline void dfs2(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		int suma = 0, sumb = 0;
		for(int i = 1; i &lt;= K; ++i) {
			add(suma, f[1][u][i]);
			add(sumb, f[2][u][i]);
		}
		add(ans, 1ll * suma * sumb % P);
		return ;
	}
	if(dep[u] &amp; 1) {
		for(int i = 1; i &lt;= K; ++i) {
			f[1][rs[u]][i] = f[1][ls[u]][i] = f[1][u][i];
			f[2][ls[u]][i] = 1ll * f[2][u][i] * g[2][rs[u]][i] % P;
			f[2][rs[u]][i] = 1ll * f[2][u][i] * g[2][ls[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			f[2][rs[u]][i] = f[2][ls[u]][i] = f[2][u][i];
			f[1][ls[u]][i] = 1ll * f[1][u][i] * g[1][rs[u]][i] % P;
			f[1][rs[u]][i] = 1ll * f[1][u][i] * g[1][ls[u]][i] % P;
		}
	}
	if(ls[u])dfs2(ls[u]);
	if(rs[u])dfs2(rs[u]);
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
	for(int i = 2, x; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		if(!ls[x])ls[x] = i;
		else rs[x] = i;
	}
	dfs(1);
	for(int i = 1; i &lt;= K; ++i)f[1][1][i] = f[2][1][i] = 1;
	dfs2(1);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020提高组十连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/">
        </link>
        <updated>2020-09-13T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<p>锅是锅了,但是还是有本质很好的题目的...</p>
<p>出锅原因:</p>
<ol>
<li>数据和题面不符</li>
<li>二三题数据随机,导致暴力与正解一样</li>
</ol>
<p>A</p>
<p>有毒</p>
<p>我们会发现,本质上就是求一个图的染色方案,使得异色边数最大....大于m/2</p>
<p>做法很简单,直接dfs实现二分图染色即可,然后如果一遍不行我们randomshuffle存图顺序多dfs几遍</p>
<p>其实有个结论是如果我们二分图染色能做到每个奇环只有一条边是没有用的...</p>
<p>而奇环最小三个边</p>
<p>而且这样我们就有重复的边,如果选了一个包含了多个奇环就能变得很优....</p>
<p>当然这个最优化是NPh的</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
const int MAXM = 2e6 + 7;

int n, m, ccnt, ans;
int home[MAXN], nxt[MAXM], to[MAXM];
int eu[MAXM], ev[MAXM], col[MAXN];

struct rec {
	int u, v;
} e[MAXM];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!col[v]) {
			col[v] = -col[u];
			dfs(v);
		}
	}
}

inline void solve() {
	ccnt = 0;
	memset(home, 0, sizeof(home));
	for(int i = 1; i &lt;= m; ++i) {
		ct(e[i].u, e[i].v);
		ct(e[i].v, e[i].u);
	}
	memset(col, 0, sizeof(col));
	for(int i = 1; i &lt;= n; ++i) {
		if(!col[i]) {
			col[i] = 1;
			dfs(i);
		}
	}
	int cnt = 0;
	for(int i = 1; i &lt;= m; ++i) {
		if(col[e[i].u] != col[e[i].v]) {
			cnt++;
		}
	}
	if(cnt &gt; m / 2) {
		// for(int i = 1; i &lt;= n; ++i) {
		// 	printf(&quot;%d %d\n&quot;, i, col[i]);
		// }
		ans = 1;
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(m == 0) {
		puts(&quot;No&quot;);
		return 0;
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	}
	for(int i = 1; i &lt;= 17; ++i) {
		random_shuffle(e + 1, e + m + 1);
		solve();
		if(ans)break;
	}
	if(ans)
		printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	return 0;
}



</code></pre>
<p>B</p>
<p>不需要构造方案不够妙啊!</p>
<p>但是本质上还是很妙的</p>
<p>我们观察一下,交换更简化的是什么</p>
<p>k=3</p>
<p>000101<br>
-&gt;<br>
101000</p>
<p>可以通过把错位k来把有些1搞过去,操作前提是我们有连续k个空格0</p>
<p>啊!你会发现这个相当于一个翻转操作啊</p>
<p>所以说我们一定可以把连续长为k的一段相同的和然后把一段长度小于等于k的随意位置搞到前面去</p>
<p>所以我们可以先把所有的空白段移动到最后然后看前面那些不是空白段的是不是完全匹配</p>
<p>因为如果不一样我们没法动就暴毙了</p>
<p>做法很简单,我们开一个栈然后把长度等于k的平移消除掉就好了,因为他们相当于没用了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
int T, n, k;
char s1[MAXN], s[MAXN], t1[MAXN], t[MAXN];

inline void init(char *str, char *res, int &amp;x) {
	static int len[MAXN], st[MAXN];
	x = 0;
	st[0] = -1;
	len[0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		++x;
		res[x] = str[i];
		if(str[i] - 'a' == st[x - 1]) {
			len[x] = len[x - 1] + 1;
			st[x] = st[x - 1];
		} else {
			len[x] = 1;
			st[x] = str[i] - 'a';
		}
		while(x &gt; 0 &amp;&amp; len[x] == k) {
			x -= k;
		}
	}
}

inline void solve() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s%s&quot;, s + 1, t + 1);
	int sl = 0, tl = 0;
	init(s, s1, sl);
	init(t, t1, tl);
	bool flg = sl == tl;
	for(int i = 1; i &lt;= tl; ++i) {
		flg &amp;= (s1[i] == t1[i]);
	}
	if(flg)puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		solve();
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>考虑直接计数</p>
<p>你会发现只有两两之间的差一起取gcd,然后得到的d的所有的因数可能成为答案</p>
<p>然后要判断这个约数可不可以合法,就是能不能过被卡的位置</p>
<p>首先但凡中间的一定不行,因为我们就不能同时过开头和结尾了</p>
<p>判断条件是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>+</mo><mi>k</mi><mi>b</mi><mo>=</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">st+kb==j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">st==j(mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后两边的就有毒,他会限制我们合法序列的数量....</p>
<p>仔细思考一下应该可</p>
<p>如果两个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">%b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>同余就能限制</p>
<p>那么就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>s</mi><mi>t</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(st-x-1)/x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>暴力实现上面的</p>
<p>复杂度显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d(n)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>std:</p>
<p>复杂度在两个方面,计算合法的序列,判断合法的约数</p>
<p>对于第一步,我们可以lowerbound!</p>
<p>对于第二步,我们可以压所有的质因数指数然后dp,因为一个不合法他的子集就都不合法....</p>
<p>具体的:我们可以用一个dfs类似的东西传导一下我们的限制和前后limit</p>
<p>std:</p>
<p>code:</p>
<pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
#define rep(i, a, b) for (int i = (a); i &lt;= int(b); i++)
#define per(i, a, b) for (int i = (a); i &gt;= int(b); i--)
#define fir first
#define sec second
#define tct template&lt;class type&gt;
using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; P;
const int maxn = 1e5, maxm = 2e6, mod = 1e9 + 7;
int m, c, q[maxn + 5], S[maxn + 5], T, C[maxm + 5];
ll N, K, p[maxn + 5], lst[maxn + 5], nxt[maxn + 5], A[maxm + 5], B[maxm + 5], Num[maxm + 5];

inline void red(int &amp;x) {
	x += x &gt;&gt; 31 &amp; mod;
}
tct inline void cmax(type &amp;x, type y) {
	x &lt; y ? x = y : 0;
}
tct inline void cmin(type &amp;x, type y) {
	x &gt; y ? x = y : 0;
}

struct event {
	int t; ll x;
	bool operator &lt; (const event &amp;o) const {
		return x &lt; o.x;
	}
} ev[maxn + 5];

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

void work(ll N) {
	for (ll i = 2; i * i &lt;= N; i++) if (N % i == 0) {
			p[++c] = i;
			while (N % i == 0) N /= i, q[c]++;
		}
	if (N &gt; 1) p[++c] = N, q[c] = 1;
}

map&lt;ll, int&gt; M;

void dfs(int x, ll y, int z) {
	if (x == c + 1) {//预处理所有约数
		M[y] = z;
		Num[z] = y;
		return;
	}
	z *= q[x] + 1;
	dfs(x + 1, y, z);
	rep(i, 1, q[x]) {
		y *= p[x];
		dfs(x + 1, y, z + i);
	}
}

void dfs0(int x, int z, int y) {
	if (x == c + 1) {//传导
		cmax(A[z], A[z + S[y]]);
		cmin(B[z], B[z + S[y]]);
		C[z] |= C[z + S[y]];
		return;
	}
	z *= q[x] + 1;
	per(i, q[x], 0) {
		if (i == q[x] &amp;&amp; x == y) continue;
		dfs0(x + 1, z + i, y);
	}
}

int main() {
	scanf(&quot;%lld %d&quot;, &amp;N, &amp;m);
	rep(i, 1, m) scanf(&quot;%d %lld&quot;, &amp;ev[i].t, &amp;ev[i].x);
	sort(ev + 1, ev + m + 1);
	ll x = 0, mx = 0, mn = N + 1;
	rep(i, 1, m) if (ev[i].t == 1) {
		if (x) K = gcd(K, ev[i].x - x);
		x = ev[i].x;
		cmax(mx, ev[i].x), cmin(mn, ev[i].x);
	}
	x = 0;
	rep(i, 1, m) {
		if (ev[i].t == 0) lst[i] = x;
		else x = ev[i].x;
	}
	x = N + 1;
	per(i, m, 1) {
		if (ev[i].t == 0) nxt[i] = x;
		else x = ev[i].x;
	}
	work(K);
	dfs(1, 1, 0);
	S[c] = 1;
	per(i, c, 1) S[i - 1] = S[i] * (q[i] + 1);
	T = S[0];
	fill(B, B + T, N + 1);
	rep(i, 1, m) if (ev[i].t == 0) {
		if (!lst[i]) {
			cmax(A[M[gcd(K, nxt[i] - ev[i].x)]], ev[i].x);
		} else if (nxt[i] == N + 1) {
			cmin(B[M[gcd(K, ev[i].x - lst[i])]], ev[i].x);
		} else {
			C[M[gcd(K, gcd(nxt[i] - ev[i].x, ev[i].x - lst[i]))]] = 1;
		}
	}
	rep(i, 1, c) dfs0(1, 0, i);
	int res = 0;
	rep(i, 0, T - 1) if (!C[i]) {
		ll x = (mn - A[i] - 1) / Num[i] + 1;
		ll y = (B[i] - 1 - mx) / Num[i] + 1;
		res = (res + x % mod * y % mod) % mod;
	}
	printf(&quot;%d\n&quot;, res);
	return 0;
}



</code></pre>
<p>数据太水了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
const int P = 1e9 + 7;
int m, T1, T2;
ll N, ans, tot, cnt[MAXN];
struct  rec {
	ll id, x;
	bool operator&lt;(const rec &amp;w)const {
		return x &lt; w.x;
	}
} a[MAXN], b[MAXN], c[MAXN];
int vis[MAXN];


inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

inline void solve(ll x) {
	ll rc1 = 0, rc2 = 0;
	// for(int i = 0; i &lt;= x; ++i)vvis[i] = 0;
	ll tmp1 = 0;
	for(int i = 1; i &lt;= T1; ++i) {
		if(b[i].x &gt; c[1].x) {
			break;
		} else {
			if(b[i].x % x == c[1].x % x)
				tmp1 = b[i].x;
		}
	}
	// printf(&quot;c1 %lld\n&quot;, tmp1);
	rc1 = (c[1].x - tmp1 - 1) / x + 1;
	ll tmp2 = N + 1;
	for(int i = T1; i &gt;= 1; --i) {
		if(b[i].x &lt; c[T2].x) {
			break;
		} else {
			if(b[i].x % x == c[T2].x % x)
				tmp2 = b[i].x;
		}
	}
	// printf(&quot;c2 %lld\n&quot;, tmp2);
	rc2 = (tmp2 - c[T2].x - 1) / x + 1;
	if(tmp2 == N - N % x + c[1].x % x)rc2 += ((N - c[T2].x) % x == 0);
	// printf(&quot;QAQ%lld??%lld %lld %lld %lld\n&quot;, x, rc1, rc2, c[1].x / x + 1, ((N - c[T2].x) / x + 1));
	ans += rc1 * rc2 % P;
	ans %= P;
}

inline void build(ll x) {
	for(ll i = 1; i * i &lt;= x; ++i) {
		if(x % i == 0) {
			cnt[++tot] = i;
			if(i * i != x) {
				cnt[++tot] = x / i;
			}
		}
	}
	sort(cnt + 1, cnt + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		bool flg = 1;
		if(vis[i])continue;
		// printf(&quot;%lld??\n&quot;, cnt[i]);
		for(int k = 1; k &lt;= m; ++k) {
			if((a[k].id == 1) &amp;&amp; ((a[k].x % cnt[i] != c[1].x % cnt[i]) || (c[1].x &gt; a[k].x))) {
				// printf(&quot;%d?\n&quot;, k);
				flg = 0;
			}
			if((a[k].id == 0) &amp;&amp; (a[k].x % cnt[i] == c[1].x % cnt[i]) &amp;&amp; ((c[1].x &lt; a[k].x) &amp;&amp; (c[T2].x &gt; a[k].x))) {
				// printf(&quot;%d!%lld %lld\n&quot;, k, c[1].x, a[k].x);
				flg = 0;
			}
			if(!flg)break;
		}
		if(flg) {
			// printf(&quot;qwq\n&quot;);
			for(int j = i; j &lt;= tot; ++j) {
				if(cnt[j] % cnt[i] == 0 &amp;&amp; !vis[j]) {
					solve(cnt[j]);
					vis[j] = 1;
				}
			}
		}
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%lld%d&quot;, &amp;N, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].id, &amp;a[i].x);
		if(a[i].id == 0) {
			b[++T1] = a[i];
		} else {
			c[++T2] = a[i];
		}
	}
	sort(a + 1, a + m + 1);
	// for(int i = 1; i &lt;= m; ++i) {
	// 	printf(&quot;%lld %lld\n&quot;, a[i].id, a[i].x);
	// }
	sort(b + 1, b + T1 + 1);
	sort(c + 1, c + T2 + 1);
	ll tmp1 = 1;
	tmp1 = c[2].x - c[1].x;
	for(int i = 2; i &lt; T2; ++i) {
		// printf(&quot;%lld %lld\n&quot;, tmp1, c[i + 1].x - c[i].x);
		tmp1 = gcd(tmp1, c[i + 1].x - c[i].x);
		//预处理
	}
	// printf(&quot;%lld\n&quot;, tmp1);
	build(tmp1);//建图
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day1]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day1/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day1/">
        </link>
        <updated>2020-09-12T10:15:37.000Z</updated>
        <content type="html"><![CDATA[<p>水</p>
<p>A</p>
<p>首先按照题意写一个n!的做法</p>
<p>然后你会发现答案是斐波那契</p>
<p>然后矩阵加速递推即可</p>
<p>正确思考:</p>
<p>考虑第n个放什么</p>
<p>如果第n个放n-1,那么第n-1个只能放n</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_n+=f_{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>随便放</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_n+=f_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=6;
const int B=2;
const int P=998244353;
ll n;
inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
struct rec {
	ll a[MAXN][MAXN];
	inline void init() {
		for(int i=0; i&lt;B; ++i) {
			for(int j=0; j&lt;B; ++j) {
				a[i][j]=0;
			}
		}
	}

} w,tmp;
inline rec mul(rec &amp;x,rec &amp;y) {
	rec c;
	c.init();
	for(int i=0; i&lt;B; ++i) {
		for(int j=0; j&lt;B; ++j) {
			for(int k=0; k&lt;B; ++k) {
				add(c.a[i][j] ,1ll*x.a[k][j] * y.a[i][k]%P);
			}
		}
	}
	return c;
}
inline void ksm() {
	rec ans;
	n-=2;
	ans.init();
	for(int i=0; i&lt;B; ++i)ans.a[i][i]=1;
	while(n) {
		if(n&amp;1)ans=mul(tmp,ans);
		tmp=mul(tmp,tmp);
		n&gt;&gt;=1;
	}
	ans=mul(w,ans);
	printf(&quot;%lld\n&quot;,ans.a[0][0]);
	return ;
}

int main() {
	scanf(&quot;%lld&quot;,&amp;n);
	w.a[0][0]=2;
	w.a[1][0]=1;
	tmp.a[0][0]=1;
	tmp.a[1][0]=1;
	tmp.a[0][1]=1;
	if(n&lt;=2)printf(&quot;%lld\n&quot;,w.a[2-n][0]);
	else ksm();
	return 0;
}



</code></pre>
<p>B</p>
<p>考场写了假代码过了...</p>
<p>首先我们考虑路径可能长什么样子,第一想法</p>
<ol>
<li>两个子树全部走,中间的走一次</li>
</ol>
<p>然而这个可能是错的我们一个子树可能并不这样走</p>
<ol start="2">
<li>两个子树走部分中间走一次</li>
</ol>
<p>然后也是错的我们可能不止两个子树</p>
<ol start="3">
<li>一条链走一次挂了其他一些部分子树</li>
</ol>
<p>好像不能求</p>
<p>但是你会发现那条链只可能是从某个点到根的一部分</p>
<p>所以做完了</p>
<p>假在答案可能大于n,但是数据太水没卡</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=3e5+7;
int n,m;
int ccnt,home[MAXN],nxt[MAXN],to[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

int dep=0,ans;

inline void dfs(int u,int F) {
	if(m&gt;dep) {
		ans=max(ans,(m-dep)/2+dep + 1);
	} else {
		ans=max(ans,m + 1);
	}
	++dep;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dfs(v,u);
	}
	--dep;
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;n; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		ct(y,x);
	}
	if(m&gt;=2*(n-1)-1) {
		printf(&quot;%d\n&quot;,n);
		return 0;
	}
	dfs(1,0);
    ans=min(ans,n);//考场没有
	printf(&quot;%d\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>考虑每种颜色的贡献,然后容斥一下</p>
<p>正难则反的补集转换/cy</p>
<p>我们只需要求出有多少路径没有经过某种关键颜色即可</p>
<p>答案就是把某种颜色去掉之后所有连通块内部算答案</p>
<p>考虑枚举每个点,然后计算他当做连通块最高的那个点的父亲的答案</p>
<p>那么我们只需要这个点的某个儿子减去儿子子树中和他颜色相同的点</p>
<p>显然可以用一个栈维护</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=2e5+7;
const int MAXM=5e5+7;
int ccnt,home[MAXN],nxt[MAXM],to[MAXM],a[MAXN],n,vis[MAXN];
ll rc[MAXN],ans;

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

stack&lt;int&gt; v[MAXN];
int dfnn,dfn[MAXN],siz[MAXN];

inline void dfs(int u,int F) {
	dfn[u]=++dfnn;
	siz[u]=1;
	for(int i=home[u]; i; i=nxt[i]) {
		int T=to[i];
		if(T==F)continue;
		dfs(T,u);
		siz[u]+=siz[T];
		ll tmp=0;
		while(!v[a[u]].empty()) {
			int x=v[a[u]].top();
			if(dfn[x]&gt;=dfn[T] &amp;&amp; dfn[x]&lt;=dfn[T]+siz[T]-1) {
				tmp+=siz[x];
				v[a[u]].pop();
			} else break;
		}
		rc[a[u]]+=1ll*(siz[T]-tmp)*(siz[T]-tmp-1)/2;
	}
	v[a[u]].push(u);
	return ;
}

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		vis[a[i]]=1;
	}
	for(int i=1,x,y; i&lt;n; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		ct(y,x);
	}
	dfs(1,0);
	for(int i=1; i&lt;=n; ++i) {
		if(vis[i]) {
			ll tmp=0;
			while(!v[i].empty()) {
				tmp+=siz[v[i].top()];
				v[i].pop();
			}
			rc[i]+=(siz[1]-tmp)*(siz[1]-tmp-1)/2;
			ans=ans+1ll*n*(n-1)/2-rc[i];
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}



</code></pre>
<p>D</p>
<p>神仙计数题</p>
<p>不难发现我们就是要找到一种合法的区间方案然后分配给每个人</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个容器,有j个区间已经使用,然后有k个区间我们还在延伸</p>
<p>然后转移的时候枚举两维</p>
<p>第一维是考虑我们新开多少个区间,然后他们开始延伸</p>
<p>第二维是考虑我们终结多少个区间,然后把他们乘上一个组合数分配给每个人</p>
<p>这样做复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>难以接受</p>
<p>我们可以发现其实是有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的转移</p>
<p>如果我们能拆开两步,变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>O(n)转移给另一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的点,然后再O(n)转移复杂度就只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>了</p>
<p>做法很简单,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑了前i个容器用了j个区间然后这j个区间还没有确定是不是i为右端点,然后k个延续</p>
<p>那么这样转移的时候我们只需要枚举下f向g转移即可</p>
<ol>
<li>以i为左端点区间l个</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>l</mi><mo separator="true">,</mo><mi>k</mi><mo>+</mo><mi>l</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>∗</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo>−</mo><mi>j</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g_{i,j+l,k+l}+=f_{i-1,j,k}*C(m-j,l)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p>
<ol start="2">
<li>以i为右端点区间l个</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mi>l</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>∗</mo><mi>C</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{i,j,k-l}+=g_{i,j,k}*C(k,l)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751388em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p>
<p>答案是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{n,m,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>本题有标号的是人,无标号的是区间,所以只需要区间匹配人</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 105;
const int P = 998244353;
int c[MAXN][MAXN];
int f[MAXN][MAXN][MAXN], g[MAXN][MAXN][MAXN];
int n, m, t;

inline void add(int &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);
	c[0][0] = 1;
	for(int i = 1; i &lt;= m; ++i) {
		c[i][0] = 1;
		for(int j = 1; j &lt;= m; ++j) {
			add(c[i][j], c[i - 1][j - 1]);
			add(c[i][j], c[i - 1][j]);
		}
	}
	f[0][0][0] = 1;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 0; j &lt;= m; ++j) {
			for(int k = 0; k &lt;= min(j, t); ++k) {
				for(int l = 0; l &lt;= min(m - j, t); ++l)
					add(g[i][j + l][k + l], 1ll * f[i - 1][j][k] * c[m - j][l] % P);
				for(int l = 0; l &lt;= min(k, t); ++l)
					add(f[i][j][k - l], 1ll * g[i][j][k] * c[k][l] % P);
			}
		}
	}
	printf(&quot;%d\n&quot;, f[n][m][0]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR20秋季普转提day1]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day1/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day1/">
        </link>
        <updated>2020-09-11T15:00:02.000Z</updated>
        <content type="html"><![CDATA[<p>毒瘤T4</p>
<p>A</p>
<p>按照题意进行模拟</p>
<p>但是你会发现我们最后朝向可能有点问题,就是他可能没有朝向一个和开头一样正确的方向</p>
<p>那么我们多做几遍把它转到开头一样,然后把这个当做循环节蹦跶就好了</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
const ll dx[] = {0, 1, 0, -1};
const ll dy[] = {1, 0, -1, 0};
int n, T, a[MAXN];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;T);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	ll nx = 0, ny = 0, nd = 0, qwq = 0;
	do {
		for(int i = 1; i &lt;= n; ++i) {
			nx += dx[nd] * a[i];
			ny += dy[nd] * a[i];
			(nd += a[i] % 4) %= 4;
		}
		++qwq;
	} while(nd != 0);
	nx *= T / qwq;
	ny *= T / qwq;
	for(int i = 1; i &lt;= T % qwq; ++i) {
		for(int i = 1; i &lt;= n; ++i) {
			nx += dx[nd] * a[i];
			ny += dy[nd] * a[i];
			(nd += a[i] % 4) %= 4;
		}
	}
	nx = nx &lt; 0 ? -nx : nx;
	ny = ny &lt; 0 ? -ny : ny;
	printf(&quot;%lld\n&quot;, nx + ny);
	return 0;
}



</code></pre>
<p>B</p>
<p>会发现我们可以找出他走的路径是什么样子的</p>
<p>那么就是走到某个餐馆停下然后之前进去过某些餐馆</p>
<p>所以我们枚举到哪个餐馆停下来,然后用一个线段树二分去解决前面最多可以选择多少可行的餐馆即可</p>
<h2 id="注意m是longlong">注意m是longlong!!!</h2>
<p>像m,n这样的数需要开ll我老是忘!</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e5 + 7;
const int MAXT = (1 &lt;&lt; 18) + 1;
int n, vis[MAXN], ans;
struct rec {
	ll x, t;
	int id;
	bool operator&lt;(const rec &amp;w)const {
		return x == w.x ? t &gt; w.t : x &lt; w.x;
	}
} a[MAXN], b[MAXN];
bool cmp(const rec &amp;x, const rec &amp;y) {
	return x.t &lt; y.t;
}
ll m;
struct BIT {
#define lowbit(x) (x&amp;(-x))
	ll tr[MAXT];
	inline void modify(int x, ll V) {
		for(; x &lt; MAXT; x += lowbit(x))tr[x] += V;
	}
	inline ll query2(int x) {
		ll ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
	inline ll query1(ll S) {
		int l = 0, r = MAXT - 1;
		while(l + 1 != r) {
			int mid = (l + r) &gt;&gt; 1;
			if(tr[mid] &gt; S)r = mid;
			else S -= tr[mid], l = mid;
		}
		return l;
	}
} t1, t2;

int main() {
	scanf(&quot;%d%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].x, &amp;a[i].t);
		a[i].id = i;
		b[i] = a[i];
	}
	sort(a + 1, a + n + 1);//枚举数组
	sort(b + 1, b + n + 1, cmp);//下标数组
	for(int i = 1; i &lt;= n; ++i) {
		vis[b[i].id] = i;
	}
	ll S = 0;
	for(int i = 1; i &lt;= n; ++i) {
		S = m - a[i].t - a[i].x;
		if(S &lt; 0)continue;
		int pos = t1.query1(S);
		int res = t2.query2(pos);
		ans = max(res + 1, ans);
		t1.modify(vis[a[i].id], a[i].t);
		t2.modify(vis[a[i].id], 1);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>结论:只要我们选择的数弹出次数总和少于n就一定可行</p>
<p>证明....好像很显然...</p>
<p>因为我们首先一定存在第一个可以弹出的,否则我们个数一定大于n</p>
<p>然后把第一个弹出,我们第一个之前的那个也一定能弹出,就这样把能弹的弹下去即可</p>
<p>问题变成背包</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
ll n, L[MAXN], D[MAXN], f[MAXN];

int main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;L[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;D[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = n; j &gt;= L[i]; --j) {
			f[j] = max(f[j], f[j - L[i]] + D[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}


</code></pre>
<p>D</p>
<p>唯一有质量的一道题/se</p>
<p>思想是我们只维护可能成为答案的,然后就能做到分离限制</p>
<p>首先我们第i个只能选i个的限制,可以考虑用一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">mulitiset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>维护前i大的,再用一个维护所有的,然后我们插入一个数分类讨论我们这个前i大的满没满,如果满了,我们看他能不能替代最小的那个,如果可以我们就把最小的那个弹出换成他</p>
<p>然后删除也是一样,如果我们能够删除的这个数在bst集合里,我们就看能不能从整体集合中拿出一个填入bst集合</p>
<p>具体分类讨论可以看看代码,非常非常的细节毒瘤</p>
<p>然后我们就能知道哪些元素是最优的了</p>
<p>问题变成了带修前k大的和,平衡树解决</p>
<p>当然好像也可以线段树二分实现这个qwq不过我喜欢显然</p>
<p><s>wyz的线段树二分还比我慢!</s></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 3e5 + 7;
const int MAXT = 6e5 + 7;
int siz[MAXT], rs[MAXT], ls[MAXT], rnd[MAXT];
ll val[MAXN], sum[MAXN];
int T, cnt, n, x, y, z, p, a, root;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar())if(c == '-')f = -1;
	for(; isdigit(c); c = getchar())x = x * 10 + c - '0';
	return x * f;
}

inline void update(int x) {
	siz[x] = 1 + siz[ls[x]] + siz[rs[x]];
	sum[x] = sum[ls[x]] + sum[rs[x]] + val[x];
}

inline int nw_(int x) {
	siz[++cnt] = 1;
	val[cnt] = x;
	sum[cnt] = x;
	rnd[cnt] = rand();
	return cnt;
}

inline int merge(int A, int B) {
	if(!A || !B)return A + B;
	if(rnd[A] &lt; rnd[B]) {
		rs[A] = merge(rs[A], B);
		update(A);
		return A;
	} else {
		ls[B] = merge(A, ls[B]);
		update(B);
		return B;
	}
}

inline void split(int now, int k, int &amp;x, int &amp;y) {
	if(!now)x = y = 0;
	else {
		if(val[now] &lt;= k) {
			x = now;
			split(rs[now], k, rs[now], y);
		} else {
			y = now;
			split(ls[now], k, x, ls[now]);
		}
		update(now);
	}
}

inline ll ksum(int nw, int k) {
	ll ret = 0;
	if(k &gt;= siz[nw])return sum[nw];
	while(nw) {
		if(k &lt;= siz[rs[nw]]) {
			nw = rs[nw];
		} else if(k == siz[rs[nw]] + 1) {
			return ret + val[nw] + sum[rs[nw]];
		} else {
			k -= siz[rs[nw]] + 1;
			ret += sum[rs[nw]] + val[nw];
			nw = ls[nw];
		}
	}
	return ret;
}

char s[20];

inline void del(ll a) {
	split(root, a, x, z);
	split(x, a - 1, x, y);
	y = merge(ls[y], rs[y]);
	root = merge(merge(x, y), z);
}

inline void ins(ll a) {
	split(root, a, x, y);
	root = merge(merge(x, nw_(a)), y);
}

multiset&lt;int&gt; hve[MAXN], bst[MAXN];

int main() {
	srand((unsigned)time(NULL));
	n = read();
	T = read();
	int t, x;
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, s);
		scanf(&quot;%d%d&quot;, &amp;t, &amp;x);
		if(s[0] == 'B') {//借入
			//考虑我们顶替掉一个,然后对应点删
			if((int)bst[t].size() &lt; t) {
				bst[t].insert(x);
				ins(x);
			} else {
				auto u = (bst[t].begin());
				if(*u &lt; x) {
					del(*u);
					bst[t].erase(u);
					bst[t].insert(x);
					ins(x);
				}
			}
			hve[t].insert(x);
		} else {//删除QAQ
			auto u = hve[t].find(x);
			hve[t].erase(u);
			if((int)bst[t].size() &lt; t || (int)hve[t].size() == t - 1) {
				auto u = bst[t].find(x);
				del(*u);
				bst[t].erase(u);
			} else {
				auto y = (bst[t].begin());
				if(*y &lt;= x) {//x在bst里面
					auto z = *(--hve[t].lower_bound(*y));
					auto u = (bst[t].find(x));
					del(*u);
					bst[t].erase(u);
					bst[t].insert(z);
					ins(z);
				}
			}
		}
		printf(&quot;%lld\n&quot;, ksum(root, n));
	}
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3648 [APIO2014]序列分割]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3648-apio2014xu-lie-fen-ge/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3648-apio2014xu-lie-fen-ge/">
        </link>
        <updated>2020-09-09T14:45:37.000Z</updated>
        <content type="html"><![CDATA[<p>卡精度,你知道什么叫前人的经验的重要性吗?</p>
<p>首先我们考虑只砍第一刀,所以可以写出转移方程</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">f_i=min_{j&lt;i} {g_j + sum_j*(sum_i-sum_j)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p>
<p>然后我们能有:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=min_{j&lt;i} {g_j -sum_j*sum_j + sum_j*sum_i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>显然可以斜率优化</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>g</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y=g_j -sum_j*sum_j,x=sum_j,k_i=sum_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751388em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最小化截距,所以维护的是上凸壳</p>
<p>然后你会发现这个y是小于0的,也就是说我们对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x&lt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">gety(x)-gety(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>大于0,但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>x</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">sum_x-sum_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>小于0</p>
<p>那么我们可以把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">sum_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>*-1来去截取,也可以把斜率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">*-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>来适配</p>
<p>但是正确性就没法用凸包想象了</p>
<p>另外一种思路是直接像推决策单调性一样找出更优的条件,好像也很适配,可以试试</p>
<h1 id="细节">细节</h1>
<p>本题核心开始:</p>
<ol>
<li>卡精度,也就是说我们如果强制转换多了就人没了</li>
</ol>
<p>你可能会说叉积判</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是非负整数,我们可以存在x相同的两个点</li>
</ol>
<p>叉积判没了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
#define db double
using namespace std;
const int MAXN = 1e5 + 7;
int n, m, k;
int a[MAXN], bck[205][MAXN];
ll f[MAXN], sum[MAXN], g[MAXN];

inline ll gety(int x) {
	return 1ll * g[x] - sum[x] * sum[x];
}

inline ll getk(int x) {
	return sum[x];
}

inline ll getx(int x) {
	return sum[x];
}

int hd, tl, que[MAXN];

inline db getslope(int i, int j) {
	if(getx(j) == getx(i))return -1e19;
	return (gety(i) - gety(j)) / ((db)getx(j) - getx(i));
}

inline ll calc(int j, int i) {
	return gety(j) + sum[j] * sum[i];
}

inline void solve() {
	hd = 1;
	tl = 0;
	que[1] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		//		printf(&quot;%d %d %lf %lld\n&quot;,que[hd],que[hd+1],getslope(que[hd+1],que[hd]),getk(i));
		while(hd &lt; tl &amp;&amp; getslope(que[hd + 1], que[hd]) &lt;= getk(i)) {
			++hd;
		}
		//		printf(&quot;%d %d %d %d\n&quot;,i,que[hd],hd,tl);
		f[i] = calc(que[hd], i);
		bck[k][i] = que[hd];
		//		printf(&quot;%lld?\n&quot;,f[i]);
		while(hd &lt; tl &amp;&amp; getslope(que[tl - 1], que[tl]) &gt;= getslope(que[tl], i))
			tl--;
		que[++tl] = i;
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for(k = 1; k &lt;= m; ++k) {
		for(int i = 1; i &lt;= n; ++i) {
			f[i] = 0;
		}
		solve();
		//		puts(&quot;\nqwq\n&quot;);
		for(int i = 1; i &lt;= n; ++i) {
			g[i] = f[i];
		}
	}
	printf(&quot;%lld\n&quot;, g[n]);
	int nw = n;
	for(int i = m; i &gt;= 1; --i) {
		printf(&quot;%d &quot;, bck[i][nw]);
		nw = bck[i][nw];
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>