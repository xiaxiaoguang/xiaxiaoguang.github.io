<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-08-05T13:00:29.657Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day9]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day9/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day9/">
        </link>
        <updated>2020-08-05T07:02:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm0SOkVW2obInHocXot*aVjuHsZ4*isoWzDeZ2xEnbp4kt4c2.mlEj*WHKJ79Hmlrdc!/r" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1I2UcDYqmlQb0.SVBuJnWFJUtVNhaMuUAHZISyj70ItxcinVPqFNQZjoimuOzNwHk!/r" alt="" loading="lazy"></figure>
<p>A</p>
<p>zhq切掉了</p>
<p>u和v xor起来最大那么如果不他在两条链上答案就就是u和vxor起来的答案</p>
<p>那么相当于只有两条链啊,对于包括u和v的两条链,那么我们就可以考虑这两个链不加入,然后其他的点都加进去,然后随着链下降我们会加入一些新点,这都问题不大</p>
<p>O(nw)极其好写</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;map&gt;
#define ll long long
using namespace std;
const int MAXM = 1e6 + 7;
const int MAXN = 5e5 + 7;
map&lt;ll, int&gt;  mp;
int n, fa[MAXN], ccnt, ansu, ansv;
int home[MAXN], nxt[MAXM], to[MAXM];
ll a[MAXN], ans[MAXN], Nans, tmpans;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

const int MAXT = 1e7 + 7;
struct rec {
	int ch[MAXT][2];
	int siz[MAXT];
	int T, root;
	inline void ins(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			if(!ch[u][t])ch[u][t] = ++T;
			siz[u]++;
			u = ch[u][t];
		}
		siz[u]++;
		return ;
	}
	inline void del(ll V) {
		int u = root;
		for(int i = 60; i &gt;= 0; --i) {
			int t = (V &gt;&gt; i) &amp; 1;
			siz[u]--;
			u = ch[u][t];
		}
		siz[u]--;
		return;
	}
	inline ll query(ll V) {
		ll qwq = 0;
		int u = root;
		for(ll i = 60; i &gt;= 0; --i) {
			int t = V &gt;&gt; i &amp; 1;
			if(!ch[u][t ^ 1])u = ch[u][t];
			else if(siz[ch[u][t ^ 1]] &gt;= 1)
				u = ch[u][t ^ 1], qwq |= (1ll &lt;&lt; i);
			else u = ch[u][t];
		}
		return qwq;
	}
} T2;

inline void init() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ll tmp = T2.query(a[i]);
		T2.ins(a[i]);
		if(tmp &gt; Nans) {
			ansu = i;
			ansv = mp[tmp ^ a[i]];
			Nans = tmp;
		}
	}
	// printf(&quot;%d %d %d?\n&quot;, Nans, ansu, ansv);
	return ;
}

inline void add(int u, int F) {
	tmpans = max(T2.query(a[u]), tmpans);
	T2.ins(a[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		add(v, u);
	}
}

int tp, tk[MAXN];
inline void solve(int x) {
	memset(T2.ch, 0, sizeof(T2.ch));
	T2.T = 1;
	T2.root = 1;
	memset(T2.siz, 0, sizeof(T2.siz));
	tp = 0;
	while(x != 0) {
		tk[++tp] = x;
		x = fa[x];
	}
	tmpans = 0;
	for(int i = tp; i &gt;= 1; --i) {
		int u = tk[i];
		// printf(&quot;!%d \n&quot;, u);
		ans[u] = tmpans;
		for(int k = home[u]; k; k = nxt[k]) {
			int v = to[k];
			if(v == tk[i - 1] || v == fa[u])continue;
			// printf(&quot;%d?\n&quot;, v);
			add(v, u);
			//插入顺便更新答案qwq
		}
		tmpans = max(tmpans, T2.query(a[u]));
		T2.ins(a[u]);
	}
	return ;
}

inline void solve2() {
	Nans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		ans[i] = Nans;
		T2.ins(a[i]);
		Nans = max(Nans, T2.query(a[i]));
	}
	for(int i = 1; i &lt;= n; ++i)
		printf(&quot;%lld\n&quot;, ans[i]);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;fa[i]);
		if(fa[i] != i - 1)flg = 0;
		ct(i, fa[i]);
		ct(fa[i], i);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		mp[a[i]] = i;
	}
	if(flg) {
		solve2();
		return 0;
	}
	memset(ans, -1, sizeof(ans));
	init();//get u,v
	solve(ansu);
	// puts(&quot;--------&quot;);
	solve(ansv);
	for(int i = 1; i &lt;= n; ++i)
		if(ans[i] != -1)printf(&quot;%lld\n&quot;, ans[i]);
		else printf(&quot;%lld\n&quot;, Nans);
	return 0;
}

</code></pre>
<figure data-type="image" tabindex="3"><img src="http://r.photo.store.qq.com/psc?/V13b3duC210Fox/45NBuzDIW489QBoVep5mcVjvqbii3iHnCJzixyRiSm1nlwmcC*RLBJETPoIOfL2XIWbfFg2sJ90eAUvTHvz1LHwQiDUpVNklFj5D6c3f6Uc!/r" alt="" loading="lazy"></figure>
<p>B</p>
<p>构造</p>
<p>角上X&lt;=4</p>
<p>边上加角上我们可以最多的能放就放放出答案</p>
<p>X+Y&lt;=4+R-y/2</p>
<p>就是小于等于2* R/2 +2* C/2 +4</p>
<p>点数小于等于边数-1</p>
<p>总边数减去黑格删去的边数角落边界和内部黑格删去的不同</p>
<p>x+2Y+3Z&lt;=(R-1)(C-1)</p>
<p>3(X+Y+Z)&lt;=2R/2+2C/2+4</p>
<p>当然这个上界可能取不到</p>
<p>n=3k 上界是n^2/3</p>
<p>n=6k+1,6k+5 n^2+2/3</p>
<p>n=6k+2,6k+4 n^2+1/3</p>
<p>如果9要取到等号边界要放满5个格子...</p>
<p>然后根据连通性我们边界上都要是</p>
<p>然后偶数就可以...由题解构造...</p>
<p>先定下中间的部分,再一步步扩张</p>
<p>C</p>
<p>考虑把所有d压成一个d维向量S记在每个点上....</p>
<p>然后对于一个向量,他的出边就是随机一个权值然后*该点向量然后再</p>
<p>对于一个点,他的最小割就是所有入边形成的线性空间的秩...就是基底</p>
<p>那会发现最小割大小不超过3,则构成这个点向量的秩数就不超过3...</p>
<p>求秩就是求线性基的大小,所有的入边构成一个线性基,然后考虑用这个线性基去求这个向量的秩数...</p>
<p>然后我们不要每次拿所有的入边去做,每次削成一个线性基,然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>e</mi><mi>j</mi></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=\sum{w_{i,j}*e_j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span>就解决了</p>
<p>首先秩小于等于最小割啊....另外我们由于随机所以大概率对吗</p>
<p>其实就是入边是一些不同的线性组合构成的就大概率能保证这个点也是对的...</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define ll long long
const int MAXN = 2e5 + 7;
const int MAXM = 1e6 + 7;
const int P = 998244353;
int n, K, m;
int vis[MAXN], home[MAXN], nxt[MAXM], to[MAXM], first[MAXN], ccnt;
int c[MAXN], que[MAXM], d[MAXN], ans[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void ct2(int x, int y) {
	ccnt++;
	nxt[ccnt] = first[x];
	first[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	vis[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(vis[v])continue;
		dfs(v);
	}
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

struct rec {
	int a[12];
	inline rec &amp;operator+=(const rec &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (a[i] + x.a[i]) % P;
		}
		return *this;
	}
	inline rec operator+(const rec &amp;x) const {
		rec c = *this;
		c += x;
		return c;
	}
	inline rec &amp;operator*=(const ll &amp;x) {
		for(int i = 0; i &lt;= K; ++i) {
			a[i] = (1ll * x * a[i]) % P;
		}
		return *this;
	}
	inline rec operator *(const int &amp;x) const {
		rec c = *this;
		c *= x;
		return c;
	}
} b[MAXN];

struct _list {
	int n;
	vector&lt;rec&gt; V;
	inline int gs() {
		int n = V.size();
		for(int i = 0; i &lt; n; ++i)b[i] = V[i];
		//拿b消元才行
		for(int i = n; i &lt; max(n, K); ++i) {
			for(int j = 0; j &lt; K; ++j) {
				b[i].a[j] = 0;//init
			}
		}
		n = max(n, K);
		//个数和列数取最大
		V.clear();
		for(int i = 0; i &lt; K; ++i) {
			c[i] = 0;
		}
		for(int i = 0; i &lt; K; ++i) {
			if(!b[i].a[i]) {
				//如果这个对角线是空的...
				for(int j = 0; j &lt; n; ++j) {
					if(!c[j] &amp;&amp; b[j].a[i]) {
						swap(b[i], b[j]);
						//交换两行
						//就是我们之后的的有一个没有被动过的这个位置有数
						break;
					}
				}
			}
			if(!b[i].a[i])continue;
			c[i] = 1;
			V.push_back(b[i]);
			//加入这一行
			//说明这一行有东西啊
			int t = P - ksm(b[i].a[i], P - 2);
			//求下逆
			for(int j = 0; j &lt; n; ++j) {
				if(j != i &amp;&amp; b[j].a[i]) {
					//高斯消元
					int c = 1ll * t * b[j].a[i] % P;
					//乘上这个再加就可以使他变为0
					b[j] = b[j] + b[i] * c;
					//一行加一列
				}
			}
		}
		return V.size();
	}
} a[MAXN];

inline int mrand() {
	return (rand() &lt;&lt; 16)^rand() + rand();
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1, u, v; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct2(v, u);
	}
	dfs(1);
	// puts(&quot;qwq&quot;);
	for(int u = 1; u &lt;= n; ++u) {
		for(int i = first[u]; i; i = nxt[i]) {
			int v = to[i];
			if(vis[v])
				d[u]++;
		}
	}


	// for(int i = 1; i &lt;= n; ++i)
	// 	printf(&quot;%d\n&quot;, d[i]);
	srand(114514);
	for(int i = home[1]; i; i = nxt[i])++K;
	// b[1].a[1] = 1;
	// b[1] *= 2;
	// b[1] += b[1];
	// printf(&quot;%d\n&quot;, b[1].a[1]);
	// printf(&quot;%d\n&quot;, K);
	int N = 0, head = 1, tail = 1;
	que[tail] = 1;
	while(head &lt;= tail) {
		int u = que[head];
		// printf(&quot;%d*&amp;\n&quot;, u);
		++head;
		if(u != 1)
			ans[u] = a[u].gs();
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			rec t;
			for(int k = 0; k &lt; K; ++k)
				t.a[k] = 0;
			if(u == 1)
				t.a[N++] = 1;//初始基底
			else {
				for(int i = 0; i &lt; a[u].V.size(); ++i) {
					t = t + a[u].V[i] * (mrand() % P);
				}
			}
			a[v].V.push_back(t);
			d[v]--;
			if(!d[v])que[++tail] = v;
			//拓扑
		}
	}
	for(int i = 2; i &lt;= n; ++i)
		printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}

</code></pre>
<p>强烈推荐弹丸论破</p>
<p>尤其是狛枝凪斗的希望教...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day8]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day8/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day8/">
        </link>
        <updated>2020-08-04T08:10:33.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>传统的博弈论,k-nim模型,对于k-nim模型他的SG值显然还是石子个数</p>
<p>而是否决胜是对于每一个二进制位求和能不能被k+1整除</p>
<p>然后就是统计有多少种方案使他们最后是0</p>
<p>这样我们就可以DP啦QwQ</p>
<p>三进制xor就是每一位加起来%3</p>
<p>那么我们是数位DP,从高向低去确定每一位,所以我们要记下是否卡到上/下界</p>
<p>然后这是三种状态,压一压就是3^n种状态,一共有log位,每一位记为w</p>
<p>每次转移时可以枚举a1~n第w位值是什么</p>
<p>就可以做到O(6^nlog)</p>
<p>显然可以优化转移变为一个个枚举</p>
<p>那么我们就再记两维表示我们已经转移了前i个数的他们的w一位的和</p>
<p>f[S][w][i][sum]表示所有a的w上面的位,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1...</mn><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1...i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的第w已经定好了</p>
<p>sum表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mn>1...</mn><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{1...w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在第w为的值</p>
<p>然后这样子就能做到像插头dp一样转移</p>
<p>三进制处理?</p>
<p>预处理每个3的i次是什么,然后(x/3^i)%3就是某个数x三进制下第i位是几</p>
<p>然后code:</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define pii pair&lt;int,int&gt;
#define fi first
#define se second
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int P = 998244353;
const int MAXN = 14;
const int MAXM = 6e5 + 7;
int n, l[MAXN], r[MAXN];
int f[2][MAXM][3];
int p3[MAXN];
#define BIT(x,i) ((x)/p3[(i)]%3)//qwq

int trans(int w, int L, int R, int o, int e) {
	//w就是那一位
	//L是我们这个数的下界
	//R是上界
	//O是S的第i-1位
	//e是当前的我们想要加上的数
	int tmp = (L / (1 &lt;&lt; (w + 1))) == (R / (1 &lt;&lt; (w + 1)));
	//L是否在这一位是等于R的
	int eqL = (o == 0);
	//如果为0表示我们卡下界
	int eqR = (o == 1) | (o == 0 &amp;&amp; tmp);
	//为1我们卡上界
	//或者卡下界,下界==上界
	int wL = (L &gt;&gt; w) &amp; 1;
	//wL是表示L第w是否为1
	int wR = (R &gt;&gt; w) &amp; 1;
	//...
	if(eqL &amp;&amp; e &lt; wL)return -1;
	//eqL表示卡了下界,我们没法凑出
	if(eqR &amp;&amp; e &gt; wR)return -1;
	//这个是卡了上界
	eqL &amp;= (e == wL);
	eqR &amp;= (e == wR);
	//如果我们完全卡下界就没了
	//只能返回0
	if(eqL)return 0;
	//否则我们返回3^下的那个,相当于异或成功了
	return 2 - eqR;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	p3[0] = 1;
	for(int i = 1; i &lt;= n; ++i)
		p3[i] = p3[i - 1] * 3;
	for(int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);
	memset(f, 0, sizeof(f));
	int nw = 0;
	f[nw][0][0] = 1;
	for(int bit = 29; bit &gt;= 0; --bit) {
		//枚举每个数位
		//显然这货被我们滚掉了
		//因为他只是可行性判断的一部分
		for(int i = 1; i &lt;= n; ++i) {
			//枚举我们去确定的前i位
			memset(f[nw ^ 1], 0, sizeof(f[nw ^ 1]));
			for(int S = 0; S &lt;= p3[n] - 1; ++S) {
				//枚举所有已经定好的w上面的位
				for(int v3 = 0; v3 &lt;= 2; ++v3) {
					//枚举所有可能的w和
					if(f[nw][S][v3]) {
						int w = f[nw][S][v3];
						for(int v = 0; v &lt;= 1; ++v) {
							//枚举我这位是0还是1
							if(i == n &amp;&amp; ((v3 + v) % 3 != 0))continue;
							int nv = trans(bit, l[i], r[i], BIT(S, i - 1), v);
							//trans出新nv
							if(nv == -1)continue;
							int nS = S - p3[i - 1] * BIT(S, i - 1) + p3[i - 1] * nv;
							//计算S的变化
							//就是减去原来的i-1位然后加上新的i-1位
							//是三进制下的
							f[nw ^ 1][nS][(v3 + v) % 3] = (f[nw ^ 1][nS][(v3 + v) % 3] + w) % P;
						}
					}
				}
			}
			nw ^= 1;
		}
	}
	long long ans = 0;
	for(int i = 0; i &lt; p3[n]; ++i)
		ans = (ans + f[nw][i][0]) % P;
	//当最后为0时,也是一切尘埃落定之时
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
<p>B</p>
<p>首先我们发现去重是个有毒的东西,所以我们可以考虑转为数组下标的数组</p>
<p>然后钦定对于一个b,对应其字典序最小的S这样就不会算重</p>
<p>然后怎么算Si+1是字典序最小的那个呢?</p>
<p>首先对于s_i+1要满足x<sub>y中没有y,y</sub>z中没有z.....</p>
<p>然后如果没有任何一个存在的情况就是字典序最小的qwq</p>
<p>h_i是最大的D,满足i \in S_D</p>
<p>求几个合法的h就是求几个合法的树状图...</p>
<p>显然我们对于i&lt;j,a_i==a_j,弱h_j&gt;h_i,则就由于被挡住而存在k在i,j之间h_k&gt;h_i</p>
<p>不然考虑S_k+1可以把j替换为i</p>
<p>然后考虑这个限制,g[L][R][K]表示对于L~R所有i,若a_i=a_R+1</p>
<p>那么L~R一定有一个比h_i大的</p>
<p>首先我们可以枚举有哪些h_i=k</p>
<p>首先不能等于a_R+1否则我们会发生平移操作</p>
<p>枚举完之后又会分成若干个子区间啦</p>
<p>第一个转移时被保护的</p>
<p>f是没有R+1的限制下的方案数</p>
<p>R+1的限制就是对于一个a_i=a_R+1,中间一定要有一个h_i帮他挡着</p>
<p>因为我们区间是在一点点定值下去的...</p>
<p>如果随便定会使得不满足i~R+1的限制,所以只能在某个地方才能定值</p>
<p>我们定值的过程相当于定K的位置,就是说从大到小去定每个h的值</p>
<p>然后我们g有限制的就要转移时不能给a_i=a_r+1先定值</p>
<p>而f则可以通过g数组在我们定好值的位置上加上限制来转移</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596530560212.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596530578596.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596530572566.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596530584634.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1596530589866.png" alt="" loading="lazy"></figure>
<p>K=3</p>
<p>枚举i=1~n,记一下S2和S3上一步是什么....</p>
<p>最后说实话讲的有点乱</p>
<p>其实就是a_i==a_j,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>,那么i一定出现在j前面的S里,也就是说只有两个都选上时的序列才行</p>
<p>然后这个是限制,求一下本质不同的h序列个数</p>
<p>code:</p>
<pre><code class="language-cpp">
//From Ultimate Destroy
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXN = 111;
const int P = 998244353;

int n, a[MAXN], K, g[MAXN][MAXN][MAXN], f[MAXN][MAXN][MAXN];
//妈的讲的和实际上是反的
inline void init() {
	int flg = 0;
	//初始化部分
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = i; j &lt;= n; ++j) {
			f[1][i][j] = 1;
			//这显然只有一种方案
			if(j &lt; n) {
				//对于小于n的情况
				//如果定他大于n会与这个dp状态不太符合
				flg = 0;
				for(int k = i; k &lt;= j; ++k) {
					//枚举
					if(a[k] == a[j + 1])flg = 1;
					//如果满足这两个相等,那么就是说这之前的才行!
					//也就是这个区间会被卡r+1啊
				}
				if(!flg)g[1][i][j] = 1;
			}
		}
	}
}

inline void dp() {

	for(int k = 2; k &lt;= K; ++k) {
		for(int L = 1; L &lt;= n; ++L) {
			for(int l = 1; l &lt;= n - L + 1; ++l) {
				int r = l + L - 1;
				int w = f[k - 1][l][r] * (L != n);
				//如果L是n长度就太长了
				//显然就成了个初始态
				for(int p = l; p &lt;= r; ++p) {
					int t = 1;
					//枚举转折点
					if(p &lt; r)t = t * 1ll * f[k][p + 1][r] % P;
					//如果不是右端点,我们可以乘上之后那段区间随意的方案数
					if(p &gt; l)t = t * 1ll * g[k - 1][l][p - 1] % P;
					//但是前面那段区间是受到限制的
					//不能放k-1
					w = (w + t) % P;
				}
				f[k][l][r] = w;

				if(r &lt; n) {
					//r+1&lt;=n
					w = g[k - 1][l][r] * (L != n);
					for(int p = l; p &lt;= r; ++p)
						if(a[p] != a[r + 1]) {
							//我彪掉了...
							//这个a_p显然只能先定值k啊!!!
							int t = 1;
							if(p &lt; r)t = t * 1ll * g[k][p + 1][r] % P;
							//显然由于本身我们更新的缘故,这个东西就要受到限制
							if(p &gt; l)t = t * 1ll * g[k - 1][l][p - 1] % P;
							//然后又要受到新限制啦qwq
							w = (w + t) % P;
							//这是那个西格玛
						}
					g[k][l][r] = w;
				}
			}
		}
	}
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	init();
	dp();
	printf(&quot;%d\n&quot;, f[K][1][n]);//QAQ
	return 0;
}

</code></pre>
<p>C</p>
<p>Q=1的暴力</p>
<p>首先二分答案S</p>
<p>统计一下最多选多少个数</p>
<p>首先小于S/2一定被选</p>
<p>而&gt;S/2的两个区间内肯定只能选一个数,所以可以枚举每个区间看最小值能不能选,能选答案+1</p>
<p>多次询问就用个数据结构维护一下,对于小于S/2的个数可以主席树</p>
<p>但是第二个统计有点毒啊...</p>
<p>于是我们思考有多少个三元组(x,y,z)满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mi>z</mi><mo>&lt;</mo><mi>y</mi><mo>&lt;</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L&lt;x&lt;z&lt;y&lt;R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>&lt;</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a[x],a[y]&lt;S/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[x+1,y-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>最小值</p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>&gt;</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a[k]&gt;S/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span></span></span></span>否则会跨两个区间</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo><mo>&lt;</mo><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">a[k]+max(a[x],a[y])&lt;=S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></p>
<p>观察第2,3,4,三个条件我们可以发现对于一个k有唯一的一组x,y能与之对应</p>
<p>那么对于一个三元组k,有两个限制,值域限制和位置限制</p>
<p>首先我们可以算出s的范围</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>∈</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>a</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mn>2</mn><mi>a</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">S \in  [a[k]+max(a[x],a[y]),2a[k])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么显然我们一个k就是一个区间加,然后S是单点查</p>
<p>当然也可以k单点加(差分)S区间查,可主席树</p>
<p>然后这是三维数点</p>
<p>显然我们可以找到对于L,R中左边第一个dL,右边第一个dR满足小于等于S/2的</p>
<p>那么满足条件的三元组都在这个区间里面而且也一定都在这个区间里面</p>
<p>所以就变成了k在dL,dR之间,就变成了了二维数点</p>
<p>实际上我们要找小于的,否则可能会因为相等的值而找重复了,实测这也是对的</p>
<p>这样就可以二分+树状数组两个log解决了</p>
<p>minmax卷积 : a_i+j=min(max(b_i,c_j))</p>
<p>首先我们考场上有一个类似笛卡尔树的堆的做法</p>
<p>就是考虑一开始都选上,然后我们删去相邻最大和的,就一直删下去知道满足了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#define se second
#define fi first
#define mkp(x,y) (make_pair(x,y))
#define ins insert
using namespace std;
const int MAXN = 1e5 + 7;
multiset&lt;pair&lt;int, pair&lt;int, int&gt; &gt; &gt; st;
int nxt[MAXN], pre[MAXN], a[MAXN], n, Q, vis[MAXN];

inline void del(int x) {
	nxt[pre[x]] = nxt[x];
	pre[nxt[x]] = pre[x];
}

inline void solve(int l, int r, int z) {
	for(int i = l; i &lt; r; ++i) {
		st.ins(mkp(a[i] + a[i + 1], mkp(i, i + 1)));
		// printf(&quot;%d\n&quot;, a[i] + a[i + 1]);
		// printf(&quot;%d?\n&quot;, st.size());
		nxt[i] = i + 1;
		pre[i] = i - 1;
	}
	pre[l] = r;
	st.ins(mkp(a[r] + a[l], mkp(r, l)));
	nxt[r] = l;
	pre[r] = r - 1;
	int k1, k2;
	// printf(&quot;%d?\n&quot;, st.size());
	while(st.size() &gt; z) {
		auto it = st.end();
		--it;
		int u = (*it).se.fi;
		int v = (*it).se.se;
		// printf(&quot;%d?%d %d\n&quot;, u, v, (*it).fi);
		if(vis[u] &amp;&amp; vis[v]) {
			st.erase(it);
			continue;
		}
		if(vis[u] || (a[u] &lt; a[v] &amp;&amp; !vis[v]))u = v;
		// printf(&quot;%d?\n&quot;, u);
		//我们只删除u
		k1 = a[u] + a[nxt[u]];
		k2 = a[u] + a[pre[u]];
		vis[u] = 1;
		st.erase(it);
		if(u != v)st.erase(st.find(mkp(k2, mkp(pre[u], u))));
		else st.erase(st.find(mkp(k1, mkp(u, nxt[u]))));
		del(u);
		st.ins(mkp(a[pre[u]] + a[nxt[u]], mkp(pre[u], nxt[u])));
	}
	auto it = st.end();
	--it;
	printf(&quot;%d\n&quot;, (*it).fi);
	st.clear();
	return;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;Q);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	if(n &lt;= 10000 || Q &lt;= 10000) {
		for(int i = 1, x, y, z; i &lt;= Q; ++i) {
			scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
			for(int i = x; i &lt;= y; ++i)vis[i] = 0;
			solve(x, y, z);
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day7]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day7/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day7/">
        </link>
        <updated>2020-08-03T07:03:09.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>每个点求第k小的路径长,保证树随机</p>
<p>二分+线段树+树上爬</p>
<p>我们考虑对于一个LCA是不是存在大于二分值的路径K条</p>
<p>发现这个可以对于一个唯一的u建立线段树存子树</p>
<p>然后就可以用点分树的思想<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>3</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">Olog^3n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
<p>然后发现我们可以换种思路,就是使得点x所有的距离都记录到线段树里</p>
<p>但你发现直接做不太好</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dep[u]+dep[i]-2dep[LCA]&lt;=ans
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<p>也就意味着我们可以用一个线段树维护<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>d</mi><mi>e</mi><mi>p</mi><mo>[</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dep[i]-2dep[LCA]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mclose">]</span></span></span></span></p>
<p>然后我们depi显然不变,但2deplca随着x走可能会发生改变,因为lca可能会发生改变</p>
<p>x子树外的i他们的lca显然不会变,然后你会发现只有对于x子树里那些i他们的lca会变为x下面的点...所以只需要每走一步做一个简单的子树全部修改操作即可</p>
<p>然后查询就是一个树状数组二分,您会发现树状数组在开2的次幂时正好是和二分时的mid一样的</p>
<p>看code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define R register
const int MAXN = 5e5 + 7;
using std::max;
int n, K;
int dfn[MAXN], dep, dp[MAXN], dfm[MAXN], topE[MAXN], ans[MAXN];
int ccnt, len[MAXN], home[MAXN], nxt[MAXN], to[MAXN];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	len[ccnt] = z;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = 0;
		int x = 0;
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(int x, char s) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
		_sr[++_C] = s;
	}
}
using namespace fastIO;

const int MAXM = (1 &lt;&lt; 20) + 1;
namespace  BIT {
	int sum[MAXM];
#define lowbit(x) (x&amp;-x)
	inline void add(int x, int y) {
		for(; x &lt; MAXM; x += lowbit(x))sum[x] += y;
	}
	inline int query() {
		R int l = 0, r = MAXM - 1, s = K;
		while(l + 1 != r) {
			int mid = (l + r) / 2;
			if(sum[mid] &gt;= s)r = mid;
			else s -= sum[mid], l = mid;
		}
		return l + 1;
	}
}
using namespace BIT;

int nwdp[MAXN], mdp;

inline void dfs(int u, int F) {
	dfn[u] = ++dep;
	mdp = max(mdp, dp[u]);
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		topE[v] = len[i];
		dp[v] = dp[u] + len[i];
		dfs(v, u);
	}
	dfm[u] = dep;
}

inline void dfs1(int u, int F) {
	if(u != 1)
		for(R int i = dfn[u]; i &lt;= dfm[u]; ++i) {
			add(nwdp[i], -1);
			nwdp[i] -= 2 * topE[u];
			add(nwdp[i], 1);
		}
	ans[u] = dp[u] + query() - mdp;
	//-mdp是为了防止负数
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		dfs1(v, u);
	}
	if(u != 1) {
		for(R int i = dfn[u]; i &lt;= dfm[u]; ++i) {
			add(nwdp[i], -1);
			nwdp[i] += 2 * topE[u];
			add(nwdp[i], 1);
		}
	}
}

int main() {
	n = read();
	K = read();
	for(R int i = 1, x, y, z; i &lt; n; ++i) {
		x = read();
		y = read();
		z = read();
		ct(x, y, z);
		ct(y, x, z);
	}
	dfs(1, 0);
	++mdp;
	for(R int i = 1; i &lt;= n; ++i) {
		nwdp[dfn[i]] = dp[i] + mdp;
		add(nwdp[dfn[i]], 1);
	}
	dfs1(1, 0);
	for(R int i = 1; i &lt;= n; ++i)print(ans[i], '\n');
	Ot();
	return 0;
}


</code></pre>
<p>B</p>
<p>dp[x][k][0/1]表示x的子树access了k次后不同的子树形态,x到他儿子的边中有没有实边</p>
<p>然后考虑合并</p>
<p>但是你会发现子树之间的access顺序会决定不同的树的形态</p>
<p>所以我们可以钦定那条边是实边,然后考虑其他的就顺序任意即可,而钦定的放在最后access</p>
<p>您发现我们不需要考虑access具体操作顺序,只需要知道这个是最后的</p>
<p>无效操作?意义不大,我们统计答案的时候搞一下就行了</p>
<p>代码中g就是对应了0那一维,f对应了1</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define R register
using namespace std;
const int P = 998244353;
const int MAXN = 1e4 + 7;
const int MAXM = 5e4 + 7;
int siz[MAXN], n, m, k, a[MAXN], f[MAXN][520], g[MAXN][520];
int to[MAXM], nxt[MAXM], home[MAXM], ccnt;

inline void ct(const int &amp;x, const int &amp;y) {
	ccnt++;
	nxt[ccnt] = home[x];
	to[ccnt] = y;
	home[x] = ccnt;
}

inline void dfs(const int &amp;u, const int &amp;F) {
	f[u][0] = 1;
	for(R int i = home[u], v; i; i = nxt[i]) {
		v = to[i];
		if(v == F)continue;
		dfs(v, u);
		for(R int j = siz[u]; j &gt;= 0; --j) {
			g[u][j + 1] = (g[u][j + 1] + f[u][j]) % P;
			//g,f相互转移
			for(R int k = 0; k + j &lt;= m &amp;&amp; k &lt;= siz[v]; ++k) {//限制次数上限,sizv,m
				if(g[v][k]) { //如果不是空
					g[u][j + k] = (g[u][j + k] + 1ll * f[u][j] * g[v][k]) % P;
					//f是考虑access的,所以可以从f向之后g更新
					g[u][j + k] = (g[u][j + k] + 1ll * g[u][j] * g[v][k]) % P;
					//直接乘即可,g是任意的?
					f[u][j + k] = (f[u][j + k] + 1ll * f[u][j] * g[v][k]) % P;
					//都可以这样更新
				}
			}
		}
		siz[u] += siz[v];
		siz[u] = min(siz[u], m);
	}
	for(R int i = 1; i &lt;= siz[u]; ++i) {
		g[u][i + 1] = (g[u][i + 1] + f[u][i]) % P;
		//可以认为我们能多access一次然后不access的都不考虑了
	}
	siz[u] = siz[u] + 1;
	siz[u] = min(siz[u], m);
	//大于就价值不大
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(R int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	dfs(1, 0);
	int ans = 1;
	for(R int i = 1; i &lt;= m; ++i)ans = (ans + g[1][i]) % P;
	//g是DP数组,表示我们access几次
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>考虑对于每一位1算出他的方案数</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示有几对数满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>+</mo><mi>i</mi></mrow></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">|a_{i}-a_{3+i}|=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>x</mi><mi>o</mi><mi>r</mi><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">a_i xor a_i+3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></p>
<p>而且我们可以枚举绝对值符号的正负性</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596440062532.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596440067548.png" alt="" loading="lazy"></figure>
<p>然后会发现是一个卷积,优化一下就是blog^2b的</p>
<p>i^(i+x)第w位的值是有i在第w位的值和i+x在第w位的值</p>
<p>(i+x)在o~w-1时是否进位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i%2^w+x%2^w&gt;2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></p>
<p>然后就可以枚举一下</p>
<p>bit(i,w)=0,bit(x,w)=0,那么i+x必须要进位所以i%2<sup>w&gt;=2</sup>w-x%2^w</p>
<p>从而计算出x在哪个范围里...就可以发现我们的i和i+w了</p>
<p>本质上是一个数位dp,但是我们可以通过钦定一个然后直接计数</p>
<p>虞皓翔大佬的解法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day6]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day6/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day6/">
        </link>
        <updated>2020-08-02T07:04:27.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>|S|=n</p>
<p>显然下面那个dp的答案是m*(m-1)^(n-1)</p>
<p>然后我们需要用二项式反演来容斥</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mi>j</mi></munder><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>j</mi></msup><mi>C</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">ans_i=C(m,i)*(\sum_{j} (-1)^j C(i,j) g(i))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>zhq:显然可以NTT优化mlogm</p>
<p>自闭了....</p>
<p>K=1</p>
<p>答案相当于对于一个颜色i,有多少染色方案满足包括这个颜色</p>
<p>首先显然颜色之间没有本质区别,所以他们的方案数是一样的</p>
<p>然后问<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">g_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>这...显然是树形DP啊</p>
<p>你会发现这个DP是没法快速合并的qwq要自上而下去DP</p>
<p>首先对于每个子树规定一个点y</p>
<p>然后递归到y这个子树</p>
<p>所以各个儿子之间就互不影响了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{x,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示x的颜色已经定好,是否为1的情况下子树染色方案数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo>∏</mo><mrow><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>(</mo><mi>m</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>+</mo><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">f_{x,0}=\prod {f_{y,0}(m-2)+f_{y,1}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>∏</mo><mrow><msub><mi>f</mi><mrow><mi>y</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mrow></mrow><annotation encoding="application/x-tex">f_{x,1}=\prod {f_{y,0}{m-1}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∏</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span></span></span></span></p>
<p>x如果为S,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f[x][1]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p>
<p>只能自上而下去搞是特别</p>
<p>k&gt;1显然对于x^k我们有斯特林展开公式!</p>
<pre><code>证明:

$$x^n=x^{n-1}*x$$

$$x^n=x \sum_{i=k}^{n-1} S(n-1,k) x^{k!} $$

$$x^n=\sum_{i=k}^{n-1} S(n-1,k) x^{k+1!} + \sum_{i=k}^{n-1} S(n-1,k) kx^{k}$$

把x^k下降幂提出来,里面就是斯特林数递推式

然后就能等于x^k的那个式子了

k!表示k次下降幂

</code></pre>
<p>变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>c</mi></msub><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></msubsup><mrow><mi>S</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_c\sum_{i=0}^k {S(k,i)C(|S(C)|,i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2887179999999998em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0016819999999999613em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><mrow><mi>S</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mi>i</mi><mo>!</mo></mrow><munder><mo>∑</mo><mi>c</mi></munder><mrow><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>c</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=0}^k {S(k,i)*i!} \sum_c{C(|S(c)|,i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">!</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>=</mo><munder><mo>∑</mo><mi>c</mi></munder><mrow><mi>C</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">g=\sum_c{C(|S(C)|,i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>如果后面的g能算出来就好了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mi>c</mi></munder><munder><mo>∑</mo><mrow><mi>T</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi></mrow></munder><mo>[</mo><mi>T</mi><mo>∈</mo><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{c} \sum_{T,|T|=i} [T \in S(C)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mpunct mtight">,</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>T</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mi>i</mi></mrow></munder><munder><mo>∑</mo><mi>c</mi></munder><mo>[</mo><mi>T</mi><mo>∈</mo><mi>S</mi><mo>(</mo><mi>C</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{T,|T|=i} \sum_{c} [T \in S(C)]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mpunct mtight">,</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">∣</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<p>就是i个颜色在关键点上都出现的方案数</p>
<p>令上面那个东西为h,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mi>h</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(i)=C(m,i)h(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p>
<p>dp可以考虑容斥</p>
<p>我们可以考虑枚举有多少个颜色不在这里面,然后用一个容斥算出答案</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>j</mi></msup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>j</mi><mi>i</mi></mfrac><mo fence="true">)</mo></mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">h(i)=\sum_{j=0}^i(-1)^j\binom {j} {i} dp[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p>
<p>dp[j]表示至少有j个不在S(c)中的方案数,即某个大小为j的集合ban满足与上S(c)为空集</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[x][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>是C_x不在ban里面的,1C_x表示在ban里面的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">f_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的颜色是父亲定好的</p>
<p>转移式子</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596352951787.png" alt="" loading="lazy"></figure>
<p>这个是父亲决定了儿子的颜色</p>
<p>统计答案</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596352959365.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mo>+</mo><msup><mi>k</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk+k^2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>B</p>
<p>切开两个边会使得整个树变成三个连通块ABC</p>
<p>然后要求AB不连通,BC也不连通,就是把A+C和B之间的边割掉</p>
<p>d[x]表示子树x内连出去的边有几条因为LCA==1</p>
<p>然后您会发现dA+dC包含了子树A-&gt;C会较多,要减去cnt(A,C)</p>
<p>然后子树搞一个dfs序就变成了区间,放到平面上就可以二维前缀和优化!</p>
<p>然后发现会有一个割子节点和祖先的关系,这样挨着一定最优</p>
<p>这就意味着我们可以用一颗模板树维护一下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>−</mo><mn>2</mn><mi>c</mi><mi>n</mi><mi>t</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d[y]-2cnt(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,然后用dfs去枚举x</p>
<p>然后可以发现对于x的一条非树边我们要把y到根节点的路径上所有点的权值都减去2</p>
<p>然后对于点x优先dfs他的重儿子再从重儿子那里继承线段树</p>
<p>也就是说我们对于一条重链只开了1个线段树,而只有log线段树</p>
<p>然后轻儿子的线段树可以开垃圾桶回收靠</p>
<p>空间复杂度就不是两个log了!</p>
<p>但是能写出来是不可能的了</p>
<p>所以我们可以dsuontree</p>
<p>喜提3个log解决了,但是您认为3个log难看?全局平衡二叉树解决了</p>
<p>C</p>
<p>回文浓度小于$$\sum_{C(cnt_i+1,2)}$$</p>
<p>所以直接排序就是最优的!</p>
<p>cnt_i表示由几种数他的总数为i</p>
<p>cnt_a==cnt_b-&gt;abababab,babababababa</p>
<p>cnt_a==cnt_b+1-&gt;ababa</p>
<p>cnt_a==2可以作为左右括号抱起来!</p>
<p>除此之外没有任何回文方法了!可以打表验证一下,对于所有满足条件的方案有多少混合方式!</p>
<p>出现次数为2的数可以作为左右括号把别人抱起来的</p>
<p>对于2最后我们再去合并</p>
<p>对于ababab,这个外面不能被抱</p>
<p>而本身是回文的就是aaa,ababa可以抱</p>
<p>f[A][B]表示由A个不可套段,B个可套段方案数</p>
<p>然后还是要记录一下这类长度剩下几个,cnt_a的数剩下几个</p>
<p>对于cnt_a==2的数,可以作为左右括号去套可套段,也可以去套空气</p>
<p>ccbb</p>
<p>所以肯定可以枚举这两种选择分别有几种数,然后再去枚举一共套了几段空气</p>
<p>最后我们用一些组合计数去算答案</p>
<p>就解决了!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day5]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day5/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day5/">
        </link>
        <updated>2020-08-01T07:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">dp_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从点i开始的答案然后求和+最大值</p>
<p>直接写的话有30pts,用一个longlong可以记一下答案,但是这里是不能直接做的</p>
<p>显然DP不能优化,考虑优化转移</p>
<p>两个set比较的复杂度是O(min(S1,S2),logn)的,然后对于合并可以启发式合并,这个是均摊O<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的</p>
<p>为啥写挂了?因为没有启发式合并啊</p>
<p>注意最大的那个数我们找出来后要打个*2标记然后加的时候就直接不考虑他就能保证复杂度不会被卡成O(n^2)了!!</p>
<p>而且我们父亲要继承最大的儿子才行/kk.</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
#define int long long
#define ll long long
const int P = 998244353;
const int MAXN = 1e5 + 7;
const int MAXM = 3e5 + 7;
int n, ccnt;
int home[MAXM], to[MAXM], nxt[MAXM], len[MAXM];
inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	len[ccnt] = z;
}

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
	return ans;
}

ll dp[MAXN];
inline void dfs(int u, int F) {
	ll maxson = 0;
	for(int i = home[u]; i ; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		ll val = ksm(2, len[i]);
		dp[u] += dp[v] + val;
		maxson = max(dp[v] + val, maxson);
	}
	dp[u] += maxson;
	return ;
}
//queue?vector?set ba....
inline ll ksm2(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
set&lt;int&gt; st[MAXM]; //I am not afraid of TLE
int id[MAXM], tag[MAXM];
#define ins insert

inline int getf(int x) {
	return id[x] == x ? x : id[x] = getf(id[x]);
}

inline void add(int u, int x) {
	x -= tag[u];
	// printf(&quot;%d?%d\n&quot;, u, x);
	while(st[u].find(x) != st[u].end()) {
		st[u].erase(x);
		++x;
	}
	st[u].ins(x);//qwq?
	// printf(&quot;%d?%d?%d?\n&quot;, u, x, st[u].size());
}

inline int merge(int x, int y) {
	int qaq = min(st[x].size(), st[y].size());
	if(qaq == st[x].size()) {
		swap(st[x], st[y]);
		swap(tag[x], tag[y]);
	}
	// printf(&quot;merge : %d %d %d\n&quot;, x, y, qaq);
	for(auto it : st[y]) {
		add(x, it + tag[y]);
	}//fake启发式合并
	return x;
}

inline int pd(int x, int y) {
	auto itx = st[x].end();
	auto ity = st[y].end();
	if(st[y].size() == 0 &amp;&amp; st[x].size() != 0)return 1;
	else if(st[y].size() == 0 &amp;&amp; st[x].size() == 0)return 0;
	else if(st[x].size() == 0)return 0;
	itx--;
	ity--;
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	while((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; (itx != st[x].begin()) &amp;&amp; (ity != st[y].begin())) {
		// printf(&quot;%d %d\n&quot;, *itx, *ity);
		itx--;
		ity--;
	}
	// printf(&quot;%d %d\n&quot;, *itx, *ity);
	if((*itx) + tag[x] == (*ity) + tag[y] &amp;&amp; st[x].size() &lt;= st[y].size())//leny&gt;lenx
		return 0;
	else if( (*ity) + tag[y] == (*itx) + tag[x] &amp;&amp; st[y].size() &lt; st[x].size())
		return 1;
	else return ((*itx) + tag[x]) &gt; ((*ity) + tag[y]);
}

inline void dfs2(int u, int F) {
	// printf(&quot;%d %d %d!@#\n&quot;, u, F, id[u]);
	int maxid = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		// printf(&quot;%d???\n&quot;, v);
		dfs2(v, u);
		add(getf(v), len[i]);
		// printf(&quot;%d&amp; %d?\n&quot;, getf(v), len[i]);
		if(getf(v) != getf(maxid) &amp;&amp; pd(getf(v), getf(maxid))) {
			maxid = v;
		}
	}
	// printf(&quot;%d %d??\n&quot;, u, maxid);
	if(maxid)id[u] = getf(maxid);
	tag[getf(u)]++;
	// printf(&quot;%d?\n&quot;,)
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		if(maxid != v) {
			merge(getf(u), getf(v));
			// printf(&quot;%d %d!!\n&quot;, u, v);
		}
	}
	// ll ans = 0;
	// for(auto it : st[getf(u)]) {
	// 	// printf(&quot;%lld\n&quot;, it);
	// 	ans = (ans + ksm2(2, (it + tag[getf(u)])) % (P - 1)) % P;
	// }
	// printf(&quot;%lld\n&quot;, ans);
	return ;
}

inline void solve() {
	for(int i = 1; i &lt;= n; ++i)id[i] = i;
	dfs2(1, 0);
	// puts(&quot;QAQ&quot;);
	ll ans = 0;
	for(auto it : st[getf(1)]) {
		// printf(&quot;%lld\n&quot;, it);
		ans = (ans + ksm2(2, (it + tag[getf(1)])) % (P - 1)) % P;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}


signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	bool flg = 1;
	for(int i = 2, x, y; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		if(y &gt; 30)flg = 0;
		ct(x, i, y);
		ct(i, x, y);
	}
	// if(flg) {
	// 	dfs(1, 0);
	// 	printf(&quot;%lld\n&quot;, dp[1] % P);
	// } else {
	solve();
	// }
	return 0;
}

我都好调死了
</code></pre>
<p>C</p>
<p>考虑left表示前面加一个字符,right表示后面加一个</p>
<p>然后转移的时候就是在前缀树和后缀树上重新定位一下就能决定我们是在哪个方向加入字符了</p>
<p>就是ch和fa上</p>
<p>所以我们可以强制每个节点在左边加字符(向下走)走到最长的串,算出第一部分的答案,然后再考虑向后面加字符,这个就是一个后缀自动机上拓扑序DP一下</p>
<p>然后如果我们边有长度其实决定了我们可以等等再走,所以转移又会不太一样</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#define R register
const int MAXN = 1e6 + 7;
const int MAXM = 5e5 + 7;
using std::max;
char s[MAXM];
int  c[MAXN], a[MAXN];
long long dp[MAXN];
int ch[MAXN][26], fa[MAXN], siz[MAXN], len[MAXN], T, lst;
inline void init() {
	T = lst = 1;
}
inline void ins(char c) {
	R int p = lst, np = lst = ++T;
	len[np] = len[p] + 1;
	siz[np] = 1;
	for(; !ch[p][c] &amp;&amp; p; p = fa[p])ch[p][c] = np;
	if(!p) {
		fa[np] = 1;
	} else {
		R int q = ch[p][c];
		if(len[q] == len[p] + 1) {
			fa[np] = q;
		} else {
			R int nq = ++T;
			len[nq] = len[p] + 1;
			memcpy(ch[nq], ch[q], sizeof(ch[nq]));
			fa[nq] = fa[q];
			fa[q] = fa[np] = nq;
			for(; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
		}
	}

}


int main() {
	scanf(&quot;%s&quot;, s + 1);
	int n = strlen(s + 1);
	init();
	R int i;
	for(i = 1; i &lt;= n; ++i) {
		ins(s[i] - 'a');
	}
	for(i = 1; i &lt;= T; ++i) {
		c[len[i]]++;
	}
	for(i = 1; i &lt;= n; ++i) {
		c[i] += c[i - 1];
	}
	for(i = T; i &gt;= 1; --i) {
		a[c[len[i]]--] = i;
	}
	for(i = T; i &gt;= 2; --i) {
		siz[fa[a[i]]] += siz[a[i]];
	}
	dp[1] = 0;
	R int u, F, v;
	for(i = 1; i &lt;= T; ++i) {
		u = a[i];
		F = fa[u];
		dp[u] = max(dp[u], dp[F] + (long long)siz[u] * (len[u] - len[F]));
		for(F = 0; F &lt; 26; ++F) {
			if((v = ch[u][F]) != 0) {
				dp[v] = max(dp[v], dp[u] + (long long)siz[v] * (len[v] - len[u]));
			}
		}
	}
	printf(&quot;%lld\n&quot;, dp[lst]);
	return 0;
}

</code></pre>
<p>B</p>
<p>是个多项式算法都给您放过去</p>
<p>考场上我神仙的遇上了土豆电池T掉了</p>
<p>一个序列有多种划分方式,但是我们只需满足一种,所以就可以考虑容斥了!</p>
<p>然后对于前中后三段其实是可以考虑各种情况然后状压DP的....</p>
<p>然后考虑dp,dp_{i,j}表示前i个数经过了j个互不相等的数</p>
<p>1/231/321/32</p>
<p>则要经过dp(1,1)-&gt;dp(4,3)-&gt;dp(3,3)-&gt;dp(9,2)</p>
<p>这样子就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo><mo>−</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mo>&gt;</mo><mo>=</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp(a,a)-&gt;dp(b,k)-&gt;dp(n,&gt;=b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>如果n比较大,中间会有很长一段令人相同的限制,这些都一样就可以快速幂把它优化掉</p>
<p>就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>k</mi><msup><mo>)</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mi>f</mi><mi>i</mi><mo>−</mo><mi>e</mi><mi>d</mi></mrow><mi>k</mi></mfrac></msup></mrow><annotation encoding="application/x-tex">P(k,k)^{\frac {n-fi-ed} {k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.28389em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.03389em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9584142857142857em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4623857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>枚举fi,ed暴力用之前的dp计算fi和ed的方案数,中间再乘上这个即可qwq,然后记得要容斥就要乘上方案数</p>
<p>因为我们有一个fi就能算出ed了,所以只有本质不同的k个fi作为限制,然后用于容斥qwq</p>
<p>然后我们就可以得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>∗</mo><mo>(</mo><msup><mi>k</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">2^k*(k^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然后又会发现我们有个第一段a,他要最大,就能转移到的最小的c最优</p>
<p>而且maxa能转移到minb,maxb能转移到minc,b是k<sub>2k或n-k</sub>n</p>
<p>这样每个状态都是O(k)种</p>
<p>然后我们发现他们可以通过一些长度小于k的方案数</p>
<p>从1-&gt;3,3-&gt;k-2再从k-2-&gt;1一直循环就是可以加速的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>k</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>实际状态数很少,压一压状态还可以更少??</p>
<p>对于n&lt;=k的情况我们只需要枚举最大值和最小值然后前i个要求互补相同,后n-i个要求互不相同,i&lt;n时有这样的而i&gt;n的时候我们有(n,k)n!?</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596268289265.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596268283405.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596268271417.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day4/">
        </link>
        <updated>2020-07-31T13:26:02.000Z</updated>
        <content type="html"><![CDATA[<p><s>自己抄自己</s></p>
<p>C</p>
<p>50pts直接for就for过去了吧</p>
<p>100pts考虑选取一个素数p，然后mod p意义下只会有n^2/p个</p>
<p>然后先for第一个点，再for第二个点的第一维，然后就能算出y坐标是多少了，再去查表，看那个点是哪个点</p>
<p>你可以发现我们能够exgcd去解决，对于一个点，首先解出一个最小解，然后我们从这个解上去+a'找看有没有对应的，花费总解数solve，如果解很多的放入一个vector中就暴力一下</p>
<p>你会发现由于只有1e9所以很快的，大部分解都很少</p>
<p>B</p>
<p>很套路？分段权值为逆序对数+W</p>
<p>猜一下有决策单调性</p>
<p>结果我们没法在O(1)时间算出逆序对，其实可以莫队？的思路</p>
<p>决策单调性：单调栈/队列上二分</p>
<p>CDQ分治+决策单调性二分</p>
<p>决策单调性二分里面的操作可以参考CF868F Yet Another Minimization Problem</p>
<p>就能做到O(nlog^3n)</p>
<p>如果可以离线可以O(\sqrt n)修改O(1)分块</p>
<p>值域分块就是首先我们处理出每个块内部的前缀和，那么查询时块块之间前缀和+块内前缀和</p>
<p>然后强制在线可以可持久化分块，空间复杂度是带根号的，绝对完蛋啊</p>
<p>A</p>
<p>带  花  树</p>
<p>路径简单，而且颜色交替，而且端点不同，两两不交，端点标记，权值和最大</p>
<p>要么带权匹配，要么带权拟阵交</p>
<p>相当于拆下点然后路径要从黑到白从白到黑，而且两个点之间有一个被选用</p>
<p>并且我们对于两个拆出的点之间连一条边权为0的边</p>
<p>然后对于两个颜色不同的拆点，是一个端点，我们可以再拆出一个新建点来把<br>
点权变成边权</p>
<p>然后对于那个新点连向的那两个拆点的边的边权就是那个点的点权</p>
<p>新建的点两两连边连成完全图，防止我们没有用上而没有完备匹配</p>
<p>然后如果有奇数个标记点我们就再额外开一个新建点，使得这个图有完美匹配</p>
<p>为什么要完备匹配？因为最大权只有完备匹配</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr暑期AB班十连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-shu-qi-ab-ban-shi-lian-ce-day3/">
        </link>
        <updated>2020-07-30T01:30:05.000Z</updated>
        <content type="html"><![CDATA[<p>考时思路+考后题解</p>
<p>A</p>
<p>首先想了想指数上做操作感觉不太行</p>
<p>然后思考能不能用用他的性质,比如说求和什么的</p>
<p>于是乎对于一个固定的r和右边那个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>确定,你会发现有唯一的一个l与之对应</p>
<p>因为但凡l之后还有可以的一定会导致区间和大于l</p>
<p>于是乎我们不难发现答案小于等于nlogV,因为如果大于的话一定存在一个r和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span>对应了多个l</p>
<p>然后考虑对于一个r预处理那个l?可以二分!</p>
<p>不太行,这好像很正解</p>
<p>于是我们利用之前的那个结论就可以解决<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">a_i&lt;=30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>的部分了</p>
<p>再往上有两个问题,1是我们的x是哪log个,2是怎么二分</p>
<p>B</p>
<p>暴力,考虑可以剪枝</p>
<p>不难发现当某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">b_i&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>今后也都是0了,所以就可以T掉了</p>
<p>考后std</p>
<p>A</p>
<p>首先这个x显然和区间的最大值比较接近,不会超过一个log!</p>
<p>然后考虑怎么判断这个式子是否成立,考虑随便选几个素数看是否mod左右一下是否相等</p>
<p>然后考虑有个max有两种做法,第一个是笛卡尔树,第二个是分治,第三个是单调栈!</p>
<p>这里用分治</p>
<p>假设最大值在右边...,枚举个右端点假设右边的最大值是M,那么x此时有M+log种</p>
<p>然后我们钦定右边的取到最大值,然后左边的不是最大值,这个可以双指针</p>
<p>然后我们从左边做差一下,因为右边的和已经为S了,左边的和就要是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">2^x-S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>,因为双指针我们就一定知道</p>
<p>右端点右移时左端点也只会单调向左移动qwq一层复杂度就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(len)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了</p>
<p>笛卡尔树就可以考虑把每个都变成前缀和然后大概率两两数不同所以就可以一开始就建出来然后查询即可qwq</p>
<p>就是说我们每次只走小的一侧</p>
<p>B</p>
<p>一个初始的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i,b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对应了点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(a_i,b_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,然后那些组合数加起来...</p>
<p>其实就是点(x,y)走到x轴一排点(0,0),(x,0)的方案数</p>
<p>有神仙把两个int压成一个longlong然后循环展开重载取模就n^2过十万......了</p>
<p>考虑先把y轴分块,把每个序列切成一条条的,y坐标相差w</p>
<p>然后把每个点走到底下的方案数记成一个数组f</p>
<p>如果我们求出了上面的一条的f方案数就能求出下面一条的g方案数</p>
<p>因为对于下面一条线的一个点i<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>i</mi></mrow></msub><msub><mi>f</mi><mi>j</mi></msub><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>j</mi><mo>−</mo><mi>i</mi><mo>+</mo><mi>w</mi></mrow><mi>w</mi></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">g_i=\sum_{j&gt;=i}f_{j}\binom {j-i+w} {w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.341482em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&gt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>然后两条之间的点怎么加入?相当于加上了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>a</mi></msup><mo>∗</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^a*(1-x)^{-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span>你发现这个东西是全部都要变的</p>
<p>然后你会发现最后要加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mo>−</mo><mi>w</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {(1-x)^{-w}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7026642857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>就可以使得我们加上的东西变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>a</mi></msup><mo>∗</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>x</mi><msup><mo>)</mo><mrow><mi>w</mi><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^a*(1-x)^{w-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span>这个是卷积的,是最多w的qwq</p>
<p>注意我们把整个数组要翻转一下!!</p>
<p>具体的</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1596097928930.png" alt="" loading="lazy"></figure>
<p>你考虑其中负的那个就是对应了计数个-1相乘,而偶数的则是mod P的花样写法</p>
<p>然后f数组应该乘上那个从那一行走下去的方案数</p>
<p>但是最后我们还要卷上一个东西</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1596094800297.png" alt="" loading="lazy"></figure>
<p>我承认还是不会,弃了弃了/se</p>
<p>暂切掉</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
#define ll long long
using namespace std;
const int MAXN = (1 &lt;&lt; 18) + 5;
const int P = 998244353;
const int G0 = 332748118;
const int G1 = 3;
int n, a[MAXN], b[MAXN];
vector&lt;pair&lt;int, int&gt; &gt; v[MAXN];

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void reduce(ll &amp;x) {
	x += x &gt;&gt; 31 &amp; P;
}

int fac[MAXN], ifac[MAXN];
ll  f[MAXN], g[MAXN], h[MAXN];

int C(int n, int k) {
	return 1ll * fac[n] * ifac[k] % P * ifac[n - k] % P;
}

inline void Init() {
	fac[0] = 1;
	ifac[0] = 1;
	for(int i = 1; i &lt; MAXN; ++i)fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[MAXN - 1] = ksm(fac[MAXN - 1], P - 2);
	for(int i = MAXN - 2; i; i--)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	ifac[1] = 1;
}

int L, len;
int R[MAXN];
void init(int n) {
	len = 1;
	while(len &lt;= n) {
		len &lt;&lt;= 1;
		L++;
	}
	for(int i = 1; i &lt; len; ++i) {
		R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1));
	}
	return ;
}

void NTT(ll *F, int typ = 0) {
	for(int i = 0; i &lt; len; ++i)
		if(i &lt; R[i])swap(F[i], F[R[i]]);
	int s, t;
	for(int mid = 1; mid &lt; len; mid &lt;&lt;= 1) {
		ll wn = ksm(typ == -1 ? G0 : G1, (P - 1) / (mid &lt;&lt; 1));
		for(int j = 0; j &lt; len; j += (mid &lt;&lt; 1)) {
			ll w = 1;
			for(int k = 0; k &lt; mid; ++k, w = wn * w % P) {
				ll x = 1ll * F[j + k], y = 1ll * w * F[j + k + mid] % P;
				F[j + k] = (1ll * x + y) % P;
				F[j + k + mid] = (1ll * x - y + P) % P;
			}
		}
	}
	if(typ == -1) {
		ll iv = ksm(len, P - 2);
		for(int i = 0; i &lt; len; ++i) {
			F[i] = 1ll * F[i] * iv % P;
		}
	}
	return ;
}


int main() {
	scanf(&quot;%d&quot;, &amp;n);
	int B = sqrt(n * log(n)) + 1;
	Init();
	for(int i = 0; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);
		a[i] = n - a[i] - 1;
		b[i] = n - b[i] - 1;
		v[a[i] / B].push_back(mkp(a[i], b[i]));
	}
	// printf(&quot;%d %d\n&quot;, C(5, 2), C(3, 1));
	init(2 * n + 1);
	for(int i = n / B; i &gt;= 0; --i) {
		if(!v[i].empty()) {
			memset(f, 0, sizeof(f));
			memset(g, 0, sizeof(g));
			for(int j = 0; j &lt;= i * B; ++j) {
				f[j] = (j &amp; 1 ? P - C(i * B, j) : C(i * B, j));
			}

			for(auto j : v[i]) {
				int t = j.first % B;
				// printf(&quot;%d %d %d\n&quot;, t, j.second + k, C(t, k));
				for(int k = 0; k &lt;= t; ++k) {
					// printf(&quot;%d %d %d\n&quot;, t, j.second + k, C(t, k));

					reduce(g[j.second + k] += (k &amp; 1 ? -C(t, k) : C(t, k) - P));
				}
			}

			// for(int j = 0; j &lt; len; ++j) {
			// 	printf(&quot;%d %d\n&quot;, g[j], f[j]);
			// 	// h[j] = (h[j] + 1ll * f[j] * g[j] % P) % P;
			// }
			NTT(f);
			NTT(g);
			for(int j = 0; j &lt; len; ++j) {
				// printf(&quot;%d %d?\n&quot;, g[j], f[j]);
				h[j] = (h[j] + 1ll * f[j] * g[j] % P) % P;
			}
		}
	}
	NTT(h, -1);
	for(int i = 0; i &lt; n; ++i)g[i] = 1ll * fac[i + n - 1] * ifac[n - 1] % P * ifac[i] % P;
	for(int i = n; i &lt; len; ++i)h[i] = g[i] = 0;
	NTT(h);
	NTT(g);
	for(int i = 0; i &lt; len; ++i)h[i] = 1ll * h[i] * g[i] % P;
	NTT(h, -1);
	for(int i = n - 1; i &gt;= 0; --i)printf(&quot;%d &quot;, h[i]);
	puts(&quot;&quot;);
	return 0;
}

</code></pre>
<p>C</p>
<p>两个点匹配的权值是他们中间的最大值,中间的那些数字是随机的,问最大权期望是多少</p>
<p>最直接找规律???每个元素在答案中的贡献只和他是第几大有关系</p>
<p>四个点你会发现最优的一定是下图中中间的那个</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1596094791364.png" alt="" loading="lazy"></figure>
<p>所以每四个点都要长成这样子</p>
<p>所以有n个点必然要前n/2和后面连接</p>
<p>然后问题变成了所有长度为n/2的最大值之和然后这个就可以发现他只和第几大有关系了(有多少个比他少)</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1596094622143.png" alt="" loading="lazy"></figure>
<p>意思就是我们从比他小的选出n/2-1个构成,然后这一段再有n/2个位置可以放,然后再考虑其中顺序是有(n/2-1)!种,然后再考虑其他n/2个数随便排序为(n/2)!</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
const int MAXN = 3e5 + 7;
const int P = 998244353;

int n, a[MAXN];

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int fac[MAXN], ifac[MAXN];

inline ll C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	sort(a + 1, a + n + 1);
	fac[0] = 1;
	for(int i = 1; i &lt;= n * 2; ++i) {
		fac[i] = 1ll * fac[i - 1] * i % P;
	}
	ifac[n * 2] = ksm(fac[n * 2], P - 2);
	for(int i = n * 2 - 1; i &gt;= 2; --i) {
		ifac[i] = 1ll * (i + 1) * ifac[i + 1] % P;
	}
	ifac[0] = 1;
	ifac[1] = 1;
	ll ans = 0;
	int m = (n + 1) &gt;&gt; 1;
	for(int i = m; i &lt;= n; ++i) {
		ll tmp = 1ll * C(i - 1, m - 1) * (m) % P;
		tmp = tmp * fac[m] % P * fac[m - 1] % P;
		ans = (ans + tmp * a[i] % P) % P;
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF区间最小差]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf-qu-jian-zui-xiao-chai/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf-qu-jian-zui-xiao-chai/">
        </link>
        <updated>2020-07-29T14:23:07.000Z</updated>
        <content type="html"><![CDATA[<p>忘了原题题号了QAQ</p>
<p>https://acm.nflsoj.com/problem/442</p>
<p>这是个加强版,带上了个系数,做法可能有所不同</p>
<p>查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">i,j \in [l,r]min|a_i-a_j|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></p>
<p>然后考虑怎么做,可以利用值域减半原理</p>
<p>我们尝试处理出每个点i的最优点对(i,j),即能在i,j区间作为i的最优答案的数对</p>
<p>首先我们对于i,i-1可以算出一个最近点对,然后考虑能不能作为目标更新下一个</p>
<p>首先你要发现i-1肯定也按照我们的原则处理出了一些最近点对....</p>
<p>那么也就是说下一个更靠前的j要作为答案,当且仅当不能和i-1成为最优而和i成为最优</p>
<p>也就是说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>而不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>更近</p>
<p>于是乎就可以发现这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>&lt;</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>a</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_j&lt;|a_{i-1}-a_{i}|/2+a_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>那么你会发现这个值域减少了一半</p>
<p>所以我们对于i最多会有logX个最优点对</p>
<p>全局一共有nlogX个</p>
<p>那么对于所有询问可以离线到右端点上</p>
<p>然后每次到点i时把点i所形成的最优点对以左端点为下标放入到线段树上,相当于扫描线</p>
<p>你会发现答案就是一个区间查询最小值</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>X</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2nlog_2X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>实际可以跑不满</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF377E Cookie Clicker]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf377e-cookie-clicker/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf377e-cookie-clicker/">
        </link>
        <updated>2020-07-24T14:45:29.000Z</updated>
        <content type="html"><![CDATA[<p>每日推荐</p>
<p>建议标签:凸包+栈</p>
<p>首先我们可以考虑怎么二分,因为如果一个时间点之前的可以那么之后的也一定可以</p>
<p>然后你会发现好像不太会写check函数,因为如果使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>DP的话就不需要二分了.....</p>
<p>有一个显然的性质是我们只会使用当前最优的工厂,而且我们达到S之前一定有一段连续使用一个工厂...</p>
<p>然后我冥思苦想了一下,突然脑袋里浮现出<s>斜率优化时的</s>凸包</p>
<p>如果我们把time当做x轴,value当做y轴的话,我们就可以把每个工厂看成一个直线了,不用管截距,至少他的斜率很显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>那么截距其实就是达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时的最优金币数X可以算出的!</p>
<p>哎?如果我们知道了截距,每个工厂的射线是不是就能围成一个<strong>每秒最优金币数的凸包</strong>了啊?</p>
<p>所以我们就是要对这些个直线进行处理,我们先把工厂按照代价排序,这样我们一定先可解锁之前的再解锁之后的</p>
<p>问题就变成我们对于之前的某个凸包状态可以计算出下一条新直线然后update新凸包的状态</p>
<p>做法也就很显然了:维护一个单调栈,栈中记录一条射线的起点坐标和斜率</p>
<p>然后枚举下个工厂,计算与凸包的交点,就是用单调栈计算出对于那个代价第一次达到的时间点以及最优金币数X,得到就可得到下一条射线</p>
<p>用这条射线加入单调栈,就是找他和凸包的交点,然后弹出不再是凸包的直线,可以证明在排序后一定是从栈顶连续的一些被弹出,而且之前计算的过程也一定是从栈底单调递增的一些射线和他求交,所以维护凸包的过程复杂度O(n)</p>
<p>最后复杂度在于排序的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>思路有些凌乱繁琐,但是做法还是很好懂的吧</p>
<p>未完code待续</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1100F Ivan and Burgers]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/">
        </link>
        <updated>2020-07-23T14:49:57.000Z</updated>
        <content type="html"><![CDATA[<p>静态区间线性基</p>
<p>考虑chz菜者的做法:离线扫描线,然后从1~n维护一个后缀线性基,每次插入一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,就暴力从i到1全部更新一遍,更新不动了就停止,可以证明此复杂度均摊<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>6</mn><msup><mn>4</mn><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*64^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,荣获0pts的好成绩!</p>
<p>然后您发现我们复杂度主要在于插入时的更新,如果我们只更新<strong>1次</strong>就能起到n次的效果就好了...</p>
<p>于是我们有一个贪心的想法,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">pos[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示前i个数第j个基最靠右的位置,然后我们对于插入x的过程,可以贪心的只找最靠右的位置进行更新....</p>
<p>其实这个思想并不巧妙,早在区间数字种类的时候就用到过这样的扫描线贪心,但是对于线性基不太会所以没做出来QAQ</p>
<p>然后您发现有点细节,就是pos的更新,想想就好了,我们其实是在<strong>多个线性基上横跳的</strong>过程</p>
<p>所以一次可能会更新多个pos?不过没关系,因为我们但凡要更新新的值就一定要^上之前某个基,那么我们之后的就相当于只能更新之前某个基之后的某个基了!</p>
<p>其实看看代码就好</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXN = 5e5 + 7;
int n, Q;
int a[MAXN];
int bsc[MAXN][22], lst[MAXN][22];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1, t, npos; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		for(int k = 0; k &lt;= 21; ++k)bsc[i][k] = bsc[i - 1][k], lst[i][k] = lst[i - 1][k];
		t = a[i];
		npos = i;
		for(int k = 21; k &gt;= 0; --k) {
			if(!(t &gt;&gt; k) &amp; 1)continue;
			if(!bsc[i][k]) {
				bsc[i][k] = t;
				lst[i][k] = npos;
				break;
			}
			if(lst[i][k] &lt; npos) {
				swap(t, bsc[i][k]);
				swap(lst[i][k], npos);
			}
			t ^= bsc[i][k];
		}
	}
	scanf(&quot;%d&quot;, &amp;Q);
	for(int i = 1, x, y; i &lt;= Q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		int ans = 0;
		for(int k = 21; k &gt;= 0; --k) {
			// printf(&quot;%d %d %d %d\n&quot;, bsc[y][k], lst[y][k], ans ^ bsc[y][k], ans);
			if(lst[y][k] &gt;= x &amp;&amp; (ans ^ bsc[y][k]) &gt; ans)
				ans ^= bsc[y][k];
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>