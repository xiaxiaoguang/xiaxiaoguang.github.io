<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-04-28T10:21:40.485Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[P4769 [NOI2018]冒泡排序]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4769-noi2018mou-pao-pai-xu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4769-noi2018mou-pao-pai-xu/">
        </link>
        <updated>2020-04-28T00:46:33.000Z</updated>
        <content type="html"><![CDATA[<p>NOI2018D1T2</p>
<p>.</p>
<p>题目可以转化为：要求排列中不存在长度&gt;=3的下降子序列。</p>
<p>因为如果出现的话，那么这个下降子序列中间的元素需要先与左边比它大的元素交换再与右边比它小的元素交换，需要折返一下，显然就不合法了。</p>
<p>这又等价于可以将序列划分为2个上升子序列。</p>
<p>这个怎么证明呢?好像显然啊....因为如果能分为三个那一定有&gt;=3的下降子序列</p>
<p>然后假设前i个位置最大数是j,那么我们在后面放的时候,会发现大于j的数目是可以随便填的,而小于j的数只能从小到大挨个放,他们构成第二个上升子序列</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示我们还剩下i个数没有填,后j个数值是大于当前最大值的&quot;非限制元素&quot;答案</p>
<p>然后转移时枚举下一个位置填一个限制元素或某个非限制元素</p>
<p>如果放限制元素,非限制的数量不变,否则假设放入第k个非限制元素,非限制元素的数量要减少k个,因为最大值发生了变化,能够填的非限制元素减少k个</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>j</mi></munderover><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f[i][j]=\sum_{k=0}^j{f[i-1][j-k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.16089em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000001em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></span></p>
<p>注意我们第二维是还有多少个非限制哦</p>
<p>边界<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[0][0]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>这好像是前缀和?qwq</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j]=f[i][j-1]+f[i-1][j]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p>
<p>另外如果打个表或者直接看会发现这个是卡特兰数qaq</p>
<p>再考虑限制吧,假设当前做到第i位,给定的排列这一位是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,后面有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个数比他大,前面有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>比他小,然后现在非限制元素还有nw个</p>
<p>所以如果填入数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>先把nw和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>取个min,因为填完之后非限制元素小于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>个</p>
<p>如果此时nw为0了,后面只能按顺序填入了qaq,这个字典序是严格不大于给定排列的,可以退出了</p>
<p>否则我们就要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{k=0}^{nw-1}{f[n-i][k]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span>这个就是前缀和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>n</mi><mi>w</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[n-i+1][nw-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>然后再考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i=a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是否合法呢?</p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">b_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>更新了nw,说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>本身就非限制啊</p>
<p>否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>一定要是当前最小的,相当于填入了一个限制元素,也是合法的</p>
<p>否则就填入了一个不合法元素,一定会导致全局不合法,就不能</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 6e5 + 7;
const int  P = 998244353;
#define ll long long
ll fac[MAXN &lt;&lt; 1], ifac[MAXN &lt;&lt; 1];
int n, T, a[MAXN], mi[MAXN];

inline ll C(int n, int m) {
    return (m &gt;= 0) ? (fac[n] * ifac[m] % P * ifac[n - m] % P) : 0;
}

inline ll ksm(ll x, ll y) {
    ll  ans = 1;
    while(y) {
        if(y &amp; 1)ans = ans * x % P;
        x = x * x % P;
        y &gt;&gt;= 1;
    }
    return ans;
}

inline ll S(ll n, ll m) {
    if(m &gt; n)return 0;
    return (C((n &lt;&lt; 1) - m, n - m) - C((n &lt;&lt; 1) - m, n - m - 1) + P ) % P;
}

struct Bit {
    int tr[MAXN];
#define lowbit(x) (x&amp;(-x))
    inline void add(int x, int val) {
        for(; x &lt;= n; x += lowbit(x))tr[x] += val;
    }
    inline int query(int x) {
        ll ret = 0;
        for(; x; x -= lowbit(x))ret += tr[x];
        return ret;
    }
    inline void clear() {
        for(int i = 1; i &lt;= n; ++i)tr[i] = 0;
    }
} tree;

inline void solve() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
    for(int i = n; i &gt;= 1; --i)tree.add(a[i], 1);
    mi[n] = a[n];
    for(int i = n - 1; i &gt;= 1; --i)mi[i] = min(mi[i + 1], a[i]);
    int mx = 0;
    int cmx = 0;
    ll ans = 0;
    for(int i = 1; i &lt;= n; ++i) {
        // printf(&quot;%d %d\n&quot;, mi[i], mx);
        if(cmx &gt; mi[i])break;
        ans = (ans + S(n - i + 1, tree.query(max(mx, a[i])) + 1)) % P;
        if(a[i] &lt; mx)cmx = max(cmx, a[i]);
        mx = max(mx, a[i]);
        tree.add(a[i], -1);
    }
    printf(&quot;%lld\n&quot;, ans);
}

inline void init() {
    fac[0] = 1;
    int up = (MAXN &lt;&lt; 1) - 10;
    for(int i = 1; i &lt;= up; ++i)fac[i] = fac[i - 1] * i % P;
    ifac[up] = ksm(fac[up], P - 2);
    for(int i = up - 1; i &gt;= 2; --i) {
        ifac[i] = ifac[i + 1] * (i + 1) % P;
    }
    ifac[0] = ifac[1] = 1;
    // printf(&quot;%d %d\n&quot;, ifac[2], ifac[3]);
    // printf(&quot;%lld %lld %d\n&quot;, C(3, 2), C(5, 4), fac[5]*ifac[4] % P * ifac[1]);
}

int main() {
    init();
    scanf(&quot;%d&quot;, &amp;T);
    for(int i = 1; i &lt;= T; ++i)solve(), tree.clear();
    return 0;
}

</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[扫描线详解]]></title>
        <id>https://xiaxiaoguang.github.io/post/sao-miao-xian-xiang-jie/</id>
        <link href="https://xiaxiaoguang.github.io/post/sao-miao-xian-xiang-jie/">
        </link>
        <updated>2020-04-27T10:36:33.000Z</updated>
        <content type="html"><![CDATA[<p>被迫营业</p>
<p><s>按理说这个博客是不应该有算法专讲的?</s></p>
<p>扫描线就是字面意思,一条从1到n扫过去,差分一切的线qwq</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1587985991190.png" alt="" loading="lazy"></figure>
<p>直接上例题</p>
<p>矩阵并面积和</p>
<p>线段树维护出现次数和当前出现长度</p>
<p>然后把每条竖着的线段离线下来按照x坐标排序,对于同一矩阵,x小的为+,反之为-</p>
<p>[模板]扫描线</p>
<p>固定大小矩阵最大值</p>
<p>把一个点的权值变成考虑右上角在哪个范围能够覆盖到这个点,从而得到一个右上角集合的矩形</p>
<p>然后扫描线变成区间加,区间查询最大值</p>
<p>窗口的星星</p>
<p>NOI online T2</p>
<p>扫描线变成考虑右端点在i的所有区间的贡献</p>
<p>然后线段树维护后缀平方和+HH的项链</p>
<p>七彩EI下的愿望花环</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1587985327180.png" alt="" loading="lazy"></figure>
<p>这个题我们假设增量是出现的颜色种类数<em>K,也就是说问你所有区间中权值和+种类数</em>K的最大区间的值是什么</p>
<p>还是扫描线,线段树维护一下从i到r的区间和</p>
<p>颜色种类还是HH的项链,用pre[a[i]]</p>
<p>每次把1<sub>pre[a[i]]的加上a[i],把pre[i]+1</sub>i的加上a[i]+K</p>
<p>答案就是每次的全局最大值</p>
<p>区间mex</p>
<p>考虑离线,然后权值线段树维护值为i的最后出现时间</p>
<p>对于所有右端点在r的询问,二分一个最小的k,使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>&lt;</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">val[k]&lt;l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></p>
<p>k就是答案,在线可以可持久化线段树</p>
<p>矩阵周长</p>
<p>扫描线,矩阵周长可以拆成两部分,从上到下和从左到右扫描线分别扫一遍</p>
<p>然后线段树维护这个位置出现次数以及出现了的长度,和直线矩阵并面积一样</p>
<p>常数*2警告?</p>
<p>Iron man</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1587985926723.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1587986049603.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5539 【XR-3】Unknown Mother-Goose]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5539-xr-3-unknown-mother-goose/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5539-xr-3-unknown-mother-goose/">
        </link>
        <updated>2020-04-26T23:56:18.000Z</updated>
        <content type="html"><![CDATA[<p>EI强力推荐神题</p>
<p>小 X 得到了一个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和一个正整数集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，他想知道有多少个正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 满足以下所有条件：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">3 \le x \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li>存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a \in S, x \equiv 0 \pmod a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></li>
<li>存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">b \in S,x-1 \equiv 0 \pmod b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li>
<li>存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>∈</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo>−</mo><mn>2</mn><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo>(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c \in S,x-2 \equiv 0 \pmod c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>请你帮小 X 求出来。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>9</mn><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e9,|S|&lt;=20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></p>
<p>你发现我竟然贴出了数据范围,说明这个题一定不一般</p>
<p>你想<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi mathvariant="normal">∣</mi></msup><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">2^|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∣</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span>?其实出题人挺坏的,如果他开到|S|=21你就不会这样想了?</p>
<p>复杂度其实是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">/</mi><mi>ω</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n|S|/\omega)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span></span></span></span><s>啊,这罪恶的欧米伽</s></p>
<p><s>古有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>过十万,今有我<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>9</mn><mo>∗</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">1e9*20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>随便跑</s></p>
<p>bitset优化其实不简单,因为是基于cpu去优化的,所以理论上不行但实际上cpu使劲跑是可以的</p>
<p>做法也很简单,开个1e9,然后考虑把每个S中的数的倍数设置为1,那么答案就是有多少个连续三个1</p>
<p>统计答案怎么bitset?</p>
<p>如果在同一个w内,直接bs&amp;bs&gt;&gt;1&amp;bs&gt;&gt;2</p>
<p>如果跨过一个w,可以把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">bs_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有两个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msub><mi>s</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">bs_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>有1个算在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">bs_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的第二个</p>
<p>而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">bs_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有一个的那种就记在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">bs_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>第一个位置</p>
<p>具体我们需要手写bitset,然后看代码吧</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ull unsigned long long
const int MAXN = 1e9 + 7;
using namespace std;
ull bs[(MAXN &gt;&gt; 6) + 10];//就硬开啊qwq
ull tmp[65];
int n, m, s, l, ans;

inline int count(ull x) {
	return __builtin_popcountll(x);
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;s);
	m = (n &gt;&gt; 6) + 1;
	while(s--) {
		scanf(&quot;%d&quot;, &amp;l);
		if(l &lt; 64) {
			memset(tmp, 0, sizeof(tmp));
			for(register int i = 0; i &lt; (l &lt;&lt; 6); i += l)tmp[i &gt;&gt; 6] |= 1ull &lt;&lt; (i &amp; 63);//这个可以考虑把这个数暴力倍增直到大小大于w
			for(register int i = 0; i &lt;= m; i += l)
				for(register int j = 0; j &lt; l; ++j)bs[i + j] |= tmp[j];//同时处理w大小的

		} else {
			for(register int i = 0; i &lt;= n; i += l) {
				bs[i &gt;&gt; 6] |= 1ull &lt;&lt; (i &amp; 63);//这个可以直接加
			}
		}
	}
	--m;
	if((n &amp; 63) != 63)bs[m] &amp;= (1ull &lt;&lt; (n + 1 - (m &lt;&lt; 6))) - 1;
	bs[0] &amp;= -2ull;//超过边界的1搞掉
	for(register int i = 0; i &lt;= m; ++i)ans += count(bs[i] &amp; (bs[i] &lt;&lt; 1) &amp; (bs[i] &lt;&lt; 2));//考虑一个w内连续的3这样一定计算一次
	for(register int i = 1; i &lt;= m; ++i)ans += count(bs[i] &amp; (bs[i - 1] &gt;&gt; 62) &amp; ((bs[i - 1] &gt;&gt; 63) | (bs[i] &lt;&lt; 1)));//考虑跨过w的3连
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mi>w</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">qwq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF585F Digits of Number Pi]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf585f-digits-of-number-pi/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf585f-digits-of-number-pi/">
        </link>
        <updated>2020-04-26T23:07:55.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>其实一开始没把他当做集训队作业去做的,没想到清北的老师是集训队作业推送带师...</p>
<p><s>封面图的小姐姐为什么有角...</s></p>
<ul>
<li>给定长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数字串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 和长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 的不含前导零的数字串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>(</mo><mi>x</mi><mo>≤</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">x,y(x \le y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>。</li>
<li>求存在长度至少为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>d</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{d}{2}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301179999999998em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span> 的子串是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的子串的数字串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mo>[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">t \in [x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65418em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 的数量。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n \le 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">d \le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。</li>
</ul>
<p>首先这个大小在[x,y]之间一定是一个数位DP啊...而且是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>长度的数位DP</p>
<p>其次我们还要求一定出现在s中?直接DP好像不太行,所以我们考虑转化为是s一个子串</p>
<p>那么我们有一个显然的做法,把s中所有长度在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>d</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{d}{2}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301179999999998em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>的所有串建一个AC自动机,然后要求就是能在自动机上匹配完成的一个串</p>
<p>再仔细想一下我们只需要把长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>d</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{d}{2}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301179999999998em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span>的子串提出来就好,因为如果匹配了的串长度大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>d</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{d}{2}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301179999999998em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span>我们一定可以匹配一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">⌊</mo><mfrac><mi>d</mi><mn>2</mn></mfrac><mo fence="true">⌋</mo></mrow><annotation encoding="application/x-tex">\left\lfloor\frac{d}{2}\right\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2301179999999998em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">⌊</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">⌋</span></span></span></span></span></span>的串啊</p>
<p>嗯...现在我们可以着手设计DP状态了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][j][0/1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>表示我现在dp到了i这个位置,匹配到了AC自动机上j号节点,有没有卡上上界</p>
<p>转移时标准的枚举下一个字符是啥,设为c</p>
<h3 id="case-1如果j有c这个儿子">case 1如果j有c这个儿子</h3>
<p>那么j-&gt;ch[j][c],i到i+1,然后对于0/1这一维,如果之前为1而且c是上界,我们就转移到1,否则转移到0</p>
<h3 id="case-2-如果j没有c这个儿子">case 2 如果j没有c这个儿子</h3>
<p>这种情况其实比较难算,如果直接从j号点跳fail的话我们还需要知道现在有没有出现一个匹配完成的串,时间复杂度也可能不太对,所以我们考虑把这中情况提出来弄</p>
<p>我们处理出一个叫做p[i][0/1]的数组,表示从长度为1~d-i+1的,有没有卡上上界的随便填的串总方案数</p>
<p>然后你会发现如果AC自动机有个节点是ed的话我们就枚举一个长度然后把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>e</mi><mi>d</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>∗</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>e</mi><mi>d</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i][ed][0]*p[i+1][0]+f[i][ed][1]*p[i+1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>计入答案</p>
<p>拆开处理,在变化处统计,这也是对于某一维是0/1的一种很不错的处理方式啊qwq</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 1e3 + 7, D = 53, K = 11;
int n, d, trie[MAXN * D][K], ed[MAXN * D], fail[MAXN * D], T = 1;
char s[MAXN], a[D], b[D];
ll p[MAXN][2], f[D][MAXN * D][2];

inline void build() {
	int m = d / 2;
	for(int i = 1; i + m - 1 &lt;= n; ++i) {
		int p = 1;
		for(int j = i, k = 1; k &lt;= m; ++j, ++k) {
			int c = s[j] - '0';
			if(!trie[p][c])trie[p][c] = ++T;
			p = trie[p][c];
		}
		ed[p] = 1;
	}
	queue&lt;int&gt; q;
	for(int i = 0; i &lt; 10; ++i) {
		if(trie[1][i])fail[trie[1][i]] = 1, q.push(trie[1][i]);
		else trie[1][i] = 1;
	}
	while(q.size()) {
		int x = q.front();
		q.pop();
		for(int i = 0; i &lt; 10; ++i) {
			if(trie[x][i])fail[trie[x][i]] = trie[fail[x]][i], q.push(trie[x][i]);//因为我们要跳到相同模板串的这个字符啊
			else trie[x][i] = trie[fail[x]][i];
			//AC自动机,广搜实现fail
		}
	}
}

inline ll calc(char *t) {
	p[d + 1][0] = p[d + 1][1] = 1;
	for(int i = d; i; i--) {
		p[i][0] = p[i + 1][0] * 10 % P;
		p[i][1] = ((t[i] - '0') * p[i + 1][0] % P + p[i + 1][1]) % P;
        //p数组处理方法,真的是直接填啊qwq
	}
	ll ans = 0;
	for(int i = 1; i &lt;= d; ++i) {
		for(int j = 1; j &lt;= T; ++j) {
			for(int k = 0; k &lt; 2; ++k) {
				f[i][j][k] = 0;
			}
		}
	}
	f[0][1][1] = 1;
	for(int i = 0; i &lt; d; ++i) {
		for(int j = 1; j &lt;= T; ++j) {
			if(!ed[j]) {
				for(int k = 0; k &lt; 10; ++k) {
					int o = trie[j][k];
					(f[i + 1][o][0] = (f[i + 1][o][0] + f[i][j][0]) % P);
					if(k &lt; t[i + 1] - '0')(f[i + 1][o][0] = (f[i + 1][o][0] + f[i][j][1]) % P);
					if(k == t[i + 1] - '0')(f[i + 1][o][1] = (f[i + 1][o][1] + f[i][j][1]) % P);
					// assert(f[i + 1][o][0] &gt;= 0);
					// assert(f[i + 1][o][1] &gt;= 0);
//知道为什么asssert了吗?因为最后一步我们+P)%P0pts了/ll
				}
			}
		}
	}
	for(int i = 1; i &lt;= d; ++i) {
		for(int j = 1; j &lt;= T; ++j) {
			if(ed[j]) {
				ans = (ans + (f[i][j][0] * p[i + 1][0] % P + f[i][j][1] * p[i + 1][1] % P) % P) % P;
				// assert(ans &gt;= 0);
			}
		}
	}
	ans %= P;
	return ans;
}


int main() {
	cin &gt;&gt; s + 1;
	cin &gt;&gt; a + 1;
	cin &gt;&gt; b + 1;
	n = strlen(s + 1);
	d = strlen(a + 1);
	build();
	int k = d;
	while(a[k] == '0')a[k--] = '9';
	--a[k];
	printf(&quot;%lld\n&quot;, ((calc(b) - calc(a)) % P + P) % P );
	return 0;
}
</code></pre>
<p>我就是那<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>45</mn></mrow><annotation encoding="application/x-tex">1/45</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">4</span><span class="mord">5</span></span></span></span>qwq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NOI Online #2]]></title>
        <id>https://xiaxiaoguang.github.io/post/noi-online-2/</id>
        <link href="https://xiaxiaoguang.github.io/post/noi-online-2/">
        </link>
        <updated>2020-04-25T14:30:37.000Z</updated>
        <content type="html"><![CDATA[<p>第二场CCF线上凉心赛</p>
<p>期望得分200,实际得分90?</p>
<p>为什么呢?一共两个锅:</p>
<ol>
<li>T1 k = 1 要特判</li>
<li>T2 不defineintlonglong见祖宗</li>
</ol>
<p>总结出的解决办法:</p>
<ol>
<li>自己注意,注意不了你就命没</li>
<li>以后看上去要溢出的都define一下</li>
</ol>
<p>所以我以后将变成define大怪</p>
<p>T1题解</p>
<p>考虑直接同时倍增,显然只有小数的颜色能够连续k个,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_1&lt;p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后我们就可以找到在<span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">%p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>意义下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的最小开头</p>
<p>然后如果那个开头再向后跳都跳不出k个就绝不无聊,否则可以无聊</p>
<p>然后你会发现如果k=1则一定无聊<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>t</mi><mi>s</mi><mo>(</mo><mi mathvariant="normal">&quot;</mi><mi>N</mi><mi>o</mi><mi mathvariant="normal">&quot;</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">puts(&quot;No&quot;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord">&quot;</span><span class="mclose">)</span></span></span></span></p>
<p>T2</p>
<p>发现很像hh的项链,直接考虑扫描线</p>
<p>从左到右扫,我们只考虑计算右端点在当前扫到的pos的所有区间询问的答案</p>
<p>然后我们可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">pre[a[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>记<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>最近出现位置,这样你会发现对于左端点在l的询问,他的答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span></p>
<p>现在我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>组询问,所以要处理一个后缀和</p>
<p>考虑节点合并函数</p>
<p>维护一个len,sum,ans,suf表示这个点代表的长度,这个点内有多少1,后缀平方和,后缀和</p>
<p>然后sum,len的更新还用我说?</p>
<p>suf的更新考虑+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><msub><mi>n</mi><mrow><mi>l</mi><mi>s</mi></mrow></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">len_{ls}*sum_{rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>ans的更新?相当于</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mo>(</mo><mi>s</mi><mi>u</mi><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum(suf[i]+sum_{rs})^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>a</mi><mi>n</mi><msub><mi>s</mi><mrow><mi>l</mi><mi>s</mi></mrow></msub><mo>+</mo><mi>l</mi><mi>e</mi><msub><mi>n</mi><mrow><mi>l</mi><mi>s</mi></mrow></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub><mo>+</mo><mn>2</mn><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi></mrow></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">=ans_{ls}+len_{ls}*sum_{rs}*sum_{rs}+2*suf_{ls}*sum_{rs}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>最后别忘加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mrow><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">ans_{rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>T3</p>
<p>这个确实挺难,首先补集转换一下,为什么呢?因为看上去我们能求的从不是子孙后代变为是子孙后代的了...能简单一些</p>
<p>然后二项式反演(这我能想的到啊(#`O′))</p>
<p>我们记&quot;恰好k次非平局&quot;方案数是g(k),&quot;至少k次非平局方案数&quot;是f(k)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mi>m</mi></munderover><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow><mi>g</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>⇔</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><mi>m</mi></munderover><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mrow><mi>i</mi><mo>−</mo><mi>n</mi></mrow></msup><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow><mi>f</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\sum_{i=n}^m{i\choose n}g(i)\Leftrightarrow g(n)=\sum_{i=n}^m(-1)^{i-n}{i\choose n}f(i) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365199999999997em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.6769999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365199999999997em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.6769999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p>
<p>所以我们要求答案g(k)只需求下f(k)</p>
<p>dp啊!</p>
<p>dp[u][x]表示u的子树里选了x对子孙后代点对,然后你会发现我们转移就是一个背包卷一下</p>
<p>...饿他好像就做完了?</p>
<p>完结散花</p>
<p>T1:</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define int long long
using namespace std;
int p1, p2, k;

inline int gcd(int a, int b) {
	return (b == 0) ? (a) : (gcd(b, a % b));
}

signed main() {
	// freopen(&quot;color.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;color.out&quot;, &quot;w&quot;, stdout);
	int T;
	scanf(&quot;%lld&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;p1, &amp;p2, &amp;k);
		if(p1 &gt; p2)swap(p1, p2);
		int st = gcd(p1, p2);
		if(k == 1 &amp;&amp; p1 == p2) {
			puts(&quot;No&quot;);
			continue;
		}
		if ((k - 1)*p1 + st &lt; p2)puts(&quot;No&quot;);
		else puts(&quot;Yes&quot;);
	}
	return 0;
}
</code></pre>
<p>T2</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
#define int long long
#define ll long long
const int P = 1e9 + 7;
const int MAXN = 5e6 + 7;
vector&lt;int&gt; v;
int pre[MAXN], a[MAXN], n;
struct rec {
	int sum;
	ll ans, suf;
	rec(): sum(0), ans(0) {};
} tr[MAXN * 2];

namespace seg {
#define mid ((l+r)&gt;&gt;1)
	int ls[MAXN], rs[MAXN], root, T;
	inline rec pushup(rec ls, rec rs, int len) {
		rec qwq;
		// printf(&quot;%d %d %d %d  %d %d %d &quot;, ls.sum, rs.sum, ls.ans, rs.ans, ls.suf, rs.suf, len);
		qwq.suf = ((rs.suf + 1ll * len * rs.sum % P) % P + ls.suf) % P;
		qwq.ans = ((ls.ans + rs.sum * rs.sum * 1ll * len % P) % P + rs.ans) % P;
		(qwq.ans += 2 * ls.suf % P * rs.sum % P) % P;
		qwq.sum = ls.sum + rs.sum;
		return qwq;
	}
	inline void modify(int &amp;k, int l, int r, int pos, int val) {
		if(!k)k = ++T;
		if(l == r) {
			// printf(&quot;%d %d %d\n&quot;, l, r, pos);
			tr[k].sum += val;
			tr[k].suf = tr[k].sum;
			tr[k].ans = tr[k].sum * tr[k].sum % P;
			// printf(&quot;%d %d %d\n&quot;, tr[k].ans, tr[k].sum, tr[k].suf);

			return ;
		}
		if(pos &lt;= mid)modify(ls[k], l, mid, pos, val);
		else modify(rs[k], mid + 1, r, pos, val);
		// printf(&quot;!@#%d %d\n&quot;, l, r);
		tr[k] = pushup(tr[ls[k]], tr[rs[k]], mid + 1 - l);
		// printf(&quot; !!%d %d\n&quot;, tr[k].ans, tr[k].sum);
	}
	inline rec query(int k, int l, int r, int L, int R) {
		if(L &lt;= l &amp;&amp; r &lt;= R) {
			return tr[k];
		}
		if(L &gt; mid)return query(rs[k], mid + 1, r, L, R);
		if(R &lt;= mid)return query(ls[k], l, mid, L, R);
		return pushup(query(ls[k], l, mid, L, R), query(rs[k], mid + 1, r, L, R), mid + 1 - l);
	}
#undef mid
}

inline int getid(int x) {
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

inline void init() {
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for(int i = 1; i &lt;= n; ++i) {
		a[i] = getid(a[i]);
		// printf(&quot;%d\n&quot;, a[i]);
	}
	return;
}

signed main() {
	// freopen(&quot;sequence.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;sequence.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		v.push_back(a[i]);
	}
	init();
	memset(pre, -1, sizeof(pre));

	ll A = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(pre[a[i]] != -1)
			seg::modify(seg::root, 1, n, pre[a[i]], -1);
		seg::modify(seg::root, 1, n, i, 1);
		pre[a[i]] = i;
		rec tmp = seg::query(seg::root, 1, n, 1, i);
		// printf(&quot;\n%d^ %d?\n&quot;, tmp.sum, tmp.ans);
		A = (A + tmp.ans) % P;
	}
	printf(&quot;%lld\n&quot;, A);
	return 0;
}
</code></pre>
<p>T3</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define add(x,y) (ct(x,y),ct(y,x))
using namespace std;
#define int long long
#define ll long long
const int MAXN = 5050, P = 998244353;
int n, m, siz[MAXN], siz1[MAXN], sz[MAXN], c[MAXN][MAXN], A[MAXN], B[MAXN];
int dp[MAXN][MAXN], ccnt;
int home[MAXN * 2], nxt[MAXN * 2], to[MAXN * 2];
char s[MAXN];


inline void ct(const int &amp;u, const int &amp;v) {
	ccnt++;
	nxt[ccnt] = home[u];
	home[u] = ccnt;
	to[ccnt] = v;
}

inline void dfs(int u, int F) {
	dp[u][0] = 1;
	sz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		// printf(&quot;%d %d\n&quot;, u, v);
		if(v == F)continue;
		dfs(v, u);
		vector&lt;int&gt; tmp(sz[u] + sz[v] + 1);
		for(int i = 0; i &lt;= sz[u]; ++i) {
			for(int j = 0; j &lt;= sz[v]; ++j) {
				tmp[i + j] = (tmp[i + j] + 1ll * dp[u][i] * dp[v][j] % P) % P;
			}
		}
		sz[u] += sz[v];
		siz[u] += siz[v];
		siz1[u] += siz1[v];
		for(int i = 0; i &lt;= sz[u]; ++i)dp[u][i] = tmp[i];
	}
	// printf(&quot;%d %d %d %d\n&quot;, u, sz[u], siz[u], siz1[u]);
	if(s[u] == '0') {
		++siz[u];
		for(int i = siz1[u] - 1; i &gt;= 0; --i) {
			dp[u][i + 1] = (dp[u][i + 1] + dp[u][i] * 1ll * (siz1[u] - i) % P) % P;
		}
	} else {
		++siz1[u];
		for(int i = siz[u] - 1; i &gt;= 0; --i) {
			dp[u][i + 1] = (dp[u][i + 1] + dp[u][i] * 1ll * (siz[u] - i) % P) % P;
		}
	}
}

inline void inv(int *A, int *B, int n) {
	for(int i = 0; i &lt;= n; ++i) {
		for(int d = i; d &lt;= n; ++d) {
			if((d - i) &amp; 1)B[i] = (B[i] - c[d][i] * 1ll * A[d] % P + P) % P;
			else B[i] = (B[i] + c[d][i] * A[d] % P) % P;
		}
	}
}

signed main() {
	cin &gt;&gt; m;
	cin &gt;&gt; (s + 1);
	n = m / 2;
	for(int i = 1; i &lt; m; ++i) {
		int u, v;
		cin &gt;&gt; u &gt;&gt; v;
		add(u, v);
	}
	dfs(1, 0);
	c[0][0] = 1;
	vector&lt;int&gt; Pw(m + 1);
	Pw[0] = 1;
	for(int i = 1; i &lt;= m; ++i)Pw[i] = Pw[i - 1] * 1ll * i % P;
	for(int i = 1; i &lt;= m; ++i) {
		c[i][0] = c[i][i] = 1;
		for(int j = 1; j &lt; i; ++j) {
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % P;
		}
	}
	for(int i = 0; i &lt;= n; ++i)A[i] = 1ll * dp[1][i] * Pw[n - i] % P;// printf(&quot;%d??\n&quot;, A[i]);
	inv(A, B, n);
	for(int i = 0; i &lt;= n; ++i)printf(&quot;%d\n&quot;, B[i]);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6187 [NOI Online Round1 提高组]最小环（民间数据）]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6187-noi-online-round1-ti-gao-zu-zui-xiao-huan-min-jian-shu-ju/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6187-noi-online-round1-ti-gao-zu-zui-xiao-huan-min-jian-shu-ju/">
        </link>
        <updated>2020-04-24T13:33:00.000Z</updated>
        <content type="html"><![CDATA[<p>NOIonline提高T3</p>
<p>这个真不毒瘤,其实60pts做法很容易想到,但是当时太菜了真不太会啊</p>
<p>我们不考虑DP,直接贪心吧</p>
<p>首先我们会发现一个规律,要想让这个答案最大,我们必须要让大的数旁边的数尽可能大</p>
<p>然后我们去考虑构造这个东西,一个不难发现的东西是我们可以把这个大环变成几个小环,然后小环直接互不干扰</p>
<p>也就是我们有gcd(n,k)个环...证明...考虑我们一个数,走回原来的位置是需要n/gcd(n,k)步的,所以我<br>
们本质不同的环只有gcd(n.k)个</p>
<p>记p=n/gcd(n,k)</p>
<p>然后这个环问题我们可以这样安排:前1~p的我们可以放进第一个环,然后第p+1到2p放到第二个环里....</p>
<p>这样不难发现我们构造出的答案是最大的</p>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>&lt;</mo><mi>c</mi><mo>&lt;</mo><mi>d</mi><mo separator="true">,</mo><mi>a</mi><mi>d</mi><mo>+</mo><mi>b</mi><mi>c</mi><mo>&lt;</mo><mi>a</mi><mi>b</mi><mo>+</mo><mi>c</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">a&lt;b&lt;c&lt;d,ad+bc&lt;ab+cd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span></span></span></span></p>
<p>如果您敏锐的发现答案只和p有关,那么我们就可以记忆化一下每个不同的p的答案,然后有些询问就可以直接查了</p>
<p>具体构造过程有一点小边界问题:</p>
<p>我们要这样构造:i+1,i+3,i+5,i+7,i+...,i+n-1,i+n,i+n-2,i+n-4......i+2,i</p>
<p>所以对于任何一个pos,我们在不超过边界的情况下首先有pos*(pos-2)*(pos+2)</p>
<p>其次在边界处我们有i,i+1和i+n,i+n-1的关系要处理</p>
<p>复杂度O(nd(n)),d其实是log^2级别所以可行?</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
const int MAXN = 2e5 + 10;
ll a[MAXN], f[MAXN];
int n, m;
int gcd(int a, int b) {
	if(b == 0) return a;
	return gcd(b, a % b);
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	n = read();
	m = read();
	for(int i = 1; i &lt;= n; ++i)a[i] = read();
	sort(a + 1, a + n + 1);
	while(m--) {
		ll ans = 0;
		int k = read();
		if(k == 0 || n == 1) {
			for(int i = 1; i &lt;= n; ++i)ans += a[i] * a[i];
			printf(&quot;%lld\n&quot;, ans);
			continue;
		}
		int t = gcd(n, k), p = n / t;//有p个环
		// puts(&quot;QWQ&quot;);
		if(f[p]) {
			printf(&quot;%lld\n&quot;, f[p]);
			continue;
		}
		for(int i = 1; i &lt;= n; i += p) {
			for(int j = 0; j &lt; p - 2; ++j) {
				ans += a[i + j] * a[i + j + 2];//枚举每个乘积..
			}
			ans += (a[i] * a[i + 1] + a[i + p - 1] * a[i + p - 2]);//加上边界
		}
		printf(&quot;%lld\n&quot;, ans);
		f[p] = ans;
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4770 [NOI2018]你的名字]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4770-noi2018ni-de-ming-zi/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4770-noi2018ni-de-ming-zi/">
        </link>
        <updated>2020-04-23T01:45:31.000Z</updated>
        <content type="html"><![CDATA[<p>NOI2018D1T3</p>
<p>你指尖跃动的电光,是我此生不变的信仰,为我后缀自动姬永世长存</p>
<p><s>我走错片场了</s></p>
<p>与后缀自动姬大战到晚上12点才过掉....QAQ</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1587606588428.png" alt="" loading="lazy"></figure>
<p>以上是本题解全部娱乐部分</p>
<ul>
<li>给你一个模板串和一堆文本串,要求你求出有多少本质不同串出现在文本串中而不出现在模板串[l,r]区间里</li>
<li>复杂度要求线性</li>
</ul>
<p>首先我们有一个一眼的做法,因为</p>
<blockquote>
<p>对于前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>17</mn></mrow><annotation encoding="application/x-tex">17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">7</span></span></span></span> 个测试点的所有询问有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">l=1,r=|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span>。</p>
</blockquote>
<p>也就是说我们只需要看整个模板串里的就行</p>
<p>好像直接求有点复杂....我们考虑补集转化一下,变成求文本串中本质不同的子串-相同的本质不同的子串数</p>
<p>然后考虑前者,我们可以:</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1587606862895.png" alt="" loading="lazy"></figure>
<p>然后对于后者,我们可以考虑把模板串建成一个SAM,然后我们拿文本串上去跑匹配,如果失配了就回跳,然后就能统计出每个前缀(最后一个位置强制被选)最大的匹配长度,又因为我们这样显然是统计了所有的情况</p>
<p>好像我们答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span></span></span></span>前缀长度-最长匹配长度?</p>
<p>哎,不对啊,本质不同被你吃掉了?所以我们好像还要强制放到后缀自动机上实现减的过程...</p>
<p>所以我们考虑怎么放到后缀自动机上每个节点去处理答案</p>
<p>很简单,我们只需要知道每个节点向前的前缀一个匹配长度</p>
<p>然后我们处理本质不同的子串是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mi>f</mi><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{len[i]-len[fa[i]]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>现在设长度为i的前缀匹配长度为p[i]</p>
<p>答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>l</mi><mi>e</mi><mi>n</mi><mo>[</mo><mi>f</mi><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>−</mo><mi>p</mi><mo>[</mo><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{max(len[i]-max(len[fa[i]]-p[r[i]]),0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.22471em;vertical-align:-0.47471em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.22528999999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span><span class="mclose mtight">]</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span><span class="mclose mtight">]</span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.47471em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">r[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>是i的最近父亲某个前缀节点长度</p>
<p>为什么这样是对的呢?</p>
<p>考虑如果匹配长度为k,然后当前len[fa[i]]小于k,那么我们一定会有些串他是在S中出现所以不计数的</p>
<p>如果len[fa[i]]&gt;k?我们只会当本质不同的子串全部计入答案</p>
<p>然后再来考虑区间为[l,r]...</p>
<p>你会发现我们又需要后缀自动姬的好朋友线段树合并了</p>
<p>所以每个点就开一个线段树,然后从叶子合并上去</p>
<p>维护什么?什么都不需要维护,因为我们只需要知道这个串在[l,r]有没有出现过就好</p>
<p>那么我们怎么魔改匹配函数?</p>
<p>假设当前匹配长度为l,我们只需要查询[l+L,R]区间里有没有右端点就行</p>
<p>如果有,那么一定在[L,R]中有这个串</p>
<p>否则我们减少l,继续查询</p>
<p>这个好像会T,实际上不会qwq</p>
<p>没了,代码一点都不长,只有亿点细节而已</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
int n;
namespace Seg {
	const int MAXN = 2e7 + 7;
	int rs[MAXN], root[MAXN], ls[MAXN], T;
#define mid ((l+r)&gt;&gt;1)
	inline void ins(int &amp;k, int l, int r, int pos) {
		if(!k)k = ++T;
		// printf(&quot;%d %d %d %d\n&quot;, k, l, r, pos);
		if(l == r)return ;
		if(pos &lt;= mid)ins(ls[k],  l, mid, pos);
		else ins(rs[k], mid + 1, r, pos);
	}
	inline int qaq(int x) {
		int ret = ++T;
		ins(T, 1, n, x);
		return ret;
	}
	int merge(int x, int y) {
		// printf(&quot;%d %d\n&quot;, x, y);
		if(!x || !y)return x + y;
		int nw = ++T;
		ls[nw] = merge(ls[x], ls[y]);
		rs[nw] = merge(rs[x], rs[y]);
		return nw;
	}
	bool query(int k, int l, int r, int x, int y) {

		// printf(&quot;%d %d %d %d %d\n&quot;, k, x, y, l, r);
		if (!k || y &lt; l || r &lt; x) return 0;
		if (x &lt;= l &amp;&amp; r &lt;= y) return 1;
		return query(ls[k], l, mid, x, y) | query(rs[k], mid + 1, r, x, y);
	}
};
const int MAXN = 3e6 + 7;
int c[MAXN], a[MAXN];

struct SAM {
	int len[MAXN], fa[MAXN], R[MAXN], ch[MAXN][26], T, lst;
	inline void init() {
		T = lst = 1;
		memset(ch[1], 0, sizeof(ch[1]));
	}
	void ins(int c, int bel ) {
		int p = lst;
		int np = lst = ++T;
		R[np] = len[np] = len[p] + 1;
		if(bel)Seg::root[np] = Seg::qaq(bel);
		// printf(&quot;%d %d\n&quot;, np, root[np]);
		memset(ch[np], 0, sizeof(ch[np]));
		for(; p &amp;&amp; !ch[p][c]; p = fa[p])ch[p][c] = np;
		if(!p)fa[np] = 1;
		else {
			int q = ch[p][c];
			if(len[p] + 1 == len[q]) {
				return (void)(fa[np] = q);
			}
			int nq = ++T;
			len[nq] = len[p] + 1;
			R[nq] = R[q];
			memcpy(ch[nq], ch[q], sizeof(ch[q]));
			fa[nq] = fa[q];
			fa[np] = fa[q] = nq;
			for(; p &amp;&amp; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
		}
	}
	void find(int &amp;p, int &amp;l, int L, int R, int c) {
		for(;;) {

			if(ch[p][c] &amp;&amp; Seg::query(Seg::root[ch[p][c]], 1, n, L + l, R)) {
				++l;
				p = ch[p][c];
				return ;
			}
			if(!l)return ;
			if(--l == len[fa[p]])p = fa[p]; ///kk
		}
	}
	ll calc(int *p) {
		ll ret = 0;
		for(register int i = 2; i &lt;= T; ++i) {
			// printf(&quot;%d %d %d %d\n&quot;, len[i], len[fa[i]], R[i], p[R[i]]);
			ret += std::max(0, len[i] - std::max(len[fa[i]], p[R[i]]));
		}
		return ret;
	}
	inline void sort() {
		// printf(&quot;%d?\n&quot;, T);
		for(int i = 1; i &lt;= T; ++i) ++c[len[i]];
		for(int i = 1; i &lt;= n; ++i)c[i] += c[i - 1];//n?你长度大于n给我康康
		for(int i = 1; i &lt;= T; ++i)a[--c[len[i]]] = i;
		// for(int i = 1; i &lt;= T; ++i)printf(&quot;%d\n&quot;, Seg::root[i]);
		for(int i = T; --i;) {
			int u = a[i];
			// printf(&quot;%d %d %d\n&quot;, u, len[u], fa[u]);

			Seg::root[fa[u]] = Seg::merge(Seg::root[fa[u]], Seg::root[u]);
		}
		return ;
	}
};
SAM mac, mac2;

char S[MAXN], T[MAXN];
int p[MAXN];


int main() {
	scanf(&quot;%s&quot;, S + 1);
	mac.init();
	n = strlen(S + 1);
	// printf(&quot;%d\n&quot;, n);
	for(register int i = 1; i &lt;= n; ++i) {
		mac.ins(S[i] - 'a', i);
	}
	mac.sort();
	int Q;
	scanf(&quot;%d&quot;, &amp;Q);
	// printf(&quot;%d\n&quot;, Seg::root[1]);
	while(Q-- &gt; 0) {
		mac2.init();
		int l, r;
		scanf(&quot;%s%d%d&quot;, T + 1, &amp;l, &amp;r);
		int len = strlen(T + 1), zhqwq = 1;
		for(register int i = 1; i &lt;= len; ++i) {
			p[i] = p[i - 1];//先上一个拿过来~
			// printf(&quot;%d?\n&quot;, p[i]);
			mac.find(zhqwq, p[i], l, r, T[i] - 'a');
			// printf(&quot;%d!\n&quot;, p[i]);
			mac2.ins(T[i] - 'a', 0);
		}
		printf(&quot;%lld\n&quot;, mac2.calc(p));
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5074 Eat the Trees]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5074-eat-the-trees/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5074-eat-the-trees/">
        </link>
        <updated>2020-04-21T14:43:13.000Z</updated>
        <content type="html"><![CDATA[<p>国家队队长李佳衡推荐插头DP练习题</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>l</mi><mi>j</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">Orzljh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">h</span></span></span></span></p>
<p>不过这个题经过兔队之手真的好简单的样子啊</p>
<p>直接设计状态f[S],S的0/1表示轮廓线上这一位有没有插头</p>
<p>然后考虑继承前一个状态?直接右移1</p>
<p>然后分类讨论吧</p>
<p>考虑上面和左边的是0还是1</p>
<p>case1: 11</p>
<p>那么我们只能把他们在这个合成一个,不能向下右转移,00</p>
<p>case2:10</p>
<p>右边可以随便延伸或者停止,10,01,00</p>
<p>case3:01</p>
<p>好像和case2一样啊</p>
<p>case3:00</p>
<p>好像除了不铺线可以自由发挥啊,也就是说我们可以转移到10,01,11</p>
<p>总结一下,如果为00那我们可以转移到他某位异或</p>
<p>如果已获知为1可以转移到00和异或一样的</p>
<p>11只能转移00</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define ll long long
int T, n, m, s, c[12][12];
ll f[1 &lt;&lt; 13], g[1 &lt;&lt; 13];
int main() {
	for(scanf(&quot;%d&quot;, &amp;T); T--;) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		s = (1 &lt;&lt; m + 1);
		for(int i = 0; i &lt; n; ++i) {
			for(int j = 0; j &lt; m; ++j) {
				scanf(&quot;%d&quot;, &amp;c[i][j]);
			}
		}
		for(int i = 0; i &lt; s; ++i)g[i] = 0;
		g[0] = 1;
		for(int i = 0; i &lt; n; ++i) {
			for(int j = 0; j &lt; m; ++j) {
				for(int k = 0; k &lt; s; ++k)
					f[k] = j ? g[k] : (k &amp; 1 ? 0 : g[k &gt;&gt; 1]);//滚动数组

				if(!c[i][j])
					for(int k = 0; k &lt; s; ++k)g[k] = k &gt;&gt; j &amp; 3 ? 0 : f[k];//不能铺线,最后一定由0,0转移来
				else
					for(int k = 0; k &lt; s; ++k)g[k] = f[k ^ 3 &lt;&lt; j] + ((k &gt;&gt; j &amp; 1) ^ (k &gt;&gt; j + 1 &amp; 1) ? f[k] : 0);//不一样可以再一个转移
				//这个是直接做,考虑总结规律?
			}
		}
		printf(&quot;%lld\n&quot;, g[0]);//有一个插头都不行
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF576E Painting Edges]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf576e-painting-edges/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf576e-painting-edges/">
        </link>
        <updated>2020-04-20T14:35:01.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>不是上午发的那货能叫博客吗?也太简单了吧</p>
<p>所以这里再补一篇....虽然考砸了但还是要学下去啊</p>
<ul>
<li>给定一张 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>条边的无向图。</li>
<li>一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色，一开始，每条边都没有颜色。</li>
<li>定义合法状态为仅保留染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种颜色中的任何一种颜色的边，图都是一张二分图。</li>
<li>有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 次操作，第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次操作将第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​ 条边的颜色染成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>但并不是每次操作都会被执行，只有当执行后仍然合法，才会执行本次操作。</li>
<li>你需要判断每次操作是否会被执行。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mi>q</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">n,m,q \le 5 \times 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≤</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">k \le 50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span>。</li>
</ul>
<p>其实第一眼就应该看出来是一道[模板]线段树分治啊</p>
<ol>
<li>每条边可能出现可能消失,满足在时间轴上出现是一个区间</li>
<li>询问是否为二分图啊</li>
</ol>
<p>这样的一看就是线段树分治</p>
<p>具体怎么做?</p>
<p>我们按照dfs序去遍历线段树</p>
<p>然后记录从当且叶子到根的每个点的f数组状态,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>在线段树上遇到一条边我们就加入这条边,从一个点离开时我们再把这个边的影响删掉</p>
<p>就是方便我们回溯</p>
<p>这样在叶子结点就是具体的每个时刻可以用来回答答案啦</p>
<p>请仔细研读代码</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 5e5 + 7;
int n, m, k, q;
struct E {
	int u, v, c;
} e[MAXN];

struct P {
	int e, c;
} p[MAXN];

vector&lt;int&gt; chan[MAXN];
vector&lt;int&gt;::iterator pos[MAXN];

struct Dsuontree {
	int fa[MAXN];
	bool fw[MAXN];
	short h[MAXN];
	bool check(int id) {
		int u = e[id].u, v = e[id].v, w = 0;
		while(fa[u])w ^= fw[u], u = fa[u];
		while(fa[v])w ^= fw[v], v = fa[v];
		// w的奇偶性反应了,如果为偶数就存在奇环
		return u != v || w;//如果为奇数就没了啊!奇环...
	}
	E merge(int u, int v) {
		int w = 1;
		while(fa[u])w ^= fw[u], u = fa[u];
		while(fa[v])w ^= fw[v], v = fa[v];
		//我们得到u,v两个点的祖先以及异或和
		if(u == v)return (E) {
			0
		};//妈耶,和个毛
		h[u] &gt; h[v] ? swap(u, v) : void(), fa[u] = v, fw[u] = w;//这个w是因为我们路径压缩之后的
		//按秩合并啊
		return (E) {
			u, v, (h[u] == h[v]) ? h[v]++ : h[v]
		};
		//如果相同我们秩加1
	}
} dsu[51];

struct seg {
	vector&lt;E&gt; t[4 * MAXN], rec[202];
	void ins(int k, int d) {
		rec[d].clear();
		for(int i = 0; i &lt; t[k].size(); ++i) {
			rec[d].push_back(dsu[t[k][i].c].merge(t[k][i].u, t[k][i].v));
			//把k号节点记录的所有边添加进d号状态里面
		}
	}
	void del(int k, int d) {
		for(int i = t[k].size() - 1; i &gt;= 0; --i) {
			if(!rec[d][i].u)continue;
			int u = rec[d][i].u, v = rec[d][i].v, c = t[k][i].c;
			dsu[c].fa[u] = dsu[c].fw[u] = 0;//直接清掉...因为我们一定merge的是树根
			dsu[c].h[v] = rec[d][i].c;//然后v直接恢复秩
		}
	}
	void modi(int l, int r, int k, int st, int en, E v) {
		if(st &gt; r || en &lt; l)return ;
		if(st &lt;= l &amp;&amp; en &gt;= r)return t[k].push_back(v);//区间放线段
		int mid = l + r &gt;&gt; 1;
		modi(l, mid, k &lt;&lt; 1, st, en, v);
		modi(mid + 1, r, k &lt;&lt; 1 | 1, st, en, v);
	}
	void work(int l, int r, int k, int d) {
		ins(k, d);//插入线段
		if(l == r) {
			int id = p[l].e;
            //找到边
			++pos[id];
            //看看边该是哪个颜色了
			dsu[p[l].c].check(id) ? (puts(&quot;YES&quot;), e[id].c = p[l].c) : (puts(&quot;NO&quot;));//询问特定颜色中的情况,删边显然不会影响啊
			return modi(1, q, 1, l + 1, (*pos[id]) - 1, e[id]), del(k, d);
            //从l+1开始,这条边一直到*pos的时间,他都是这个颜色啊!
            //并且记得回溯时删除/kk
		}
		int mid = (l + r) &gt;&gt; 1;
		work(l, mid, k &lt;&lt; 1, d + 1);
		work(mid + 1, r, k &lt;&lt; 1 | 1, d + 1); //向左右子树递归啊,调用更多状态记录
		del(k, d);//回溯时删掉
	}
} seg;

int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;q);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	for(int i = 1; i &lt;= q; ++i) {
		scanf(&quot;%d%d&quot;, &amp;p[i].e, &amp;p[i].c), chan[p[i].e].push_back(i);
        //每条边上放下这个改变时间
	}
	for(int i = 1; i &lt;= m; ++i) {
		chan[i].push_back(q + 1), pos[i] = chan[i].begin();
        //每条边先初始化
	}
	seg.work(1, q, 1, 0);
	return 0;
}

</code></pre>
<p><s>zzz?</s></p>
<p>我也不想颓</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3763 [TJOI2017]DNA]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3763-tjoi2017dna/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3763-tjoi2017dna/">
        </link>
        <updated>2020-04-20T01:46:08.000Z</updated>
        <content type="html"><![CDATA[<p>TJOI2017DxTx</p>
<p>铁憨憨又进了一波新图片qwq</p>
<p>然后这道题在我的任务计划里躺了太久很不爽就做掉吧</p>
<ul>
<li>给你两个串,问有多少个l,r满足在第一个串中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>l</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">S_{l...r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与第二个串至多相差不超过三个字符,且<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 12: r-l+1=len_S_̲{2}'>r-l+1=len_S_{2}</span></li>
<li>字符集小于4</li>
</ul>
<p>哇偶,一看所有子串类型题就是SAM啦</p>
<p>我们先把SAM给建出来,然后从根节点开始往下搜,dfs函数中记录一下用了几个点,然后长度是什么</p>
<p>一旦长度刚好大于<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 7: {len_S_̲2}'>{len_S_2}</span>我们就加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中这个子串出现的次数</p>
<p>非常简单的一个搜索就可以了.....复杂度为啥是对的呢?QWQ</p>
<p>具体实现看看代码吧w<s>所以我们就考制胡窜这样的吗???</s></p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;

const int MAXN = 1e6 + 7;
char s[MAXN];
int ans, m, val[MAXN];
namespace SAM {
	int cnt[MAXN &lt;&lt; 1], fa[MAXN &lt;&lt; 1], ch[MAXN &lt;&lt; 1][4], len[MAXN &lt;&lt; 1], lst, T;
	int a[MAXN], c[MAXN];
	inline void init() {
		memset(SAM::ch, 0, sizeof(ch));
		memset(SAM::cnt, 0, sizeof(cnt));
		T = lst = 1;
	}
	inline void ins(int c) {
		int p = lst;
		int np = lst = ++T;
		len[np] = len[p] + 1;
		cnt[np] = 1;//endpos
		for(; p &amp;&amp; !ch[p][c]; p = fa[p])ch[p][c] = np;
		if(!p) {
			fa[np] = 1;
		} else {
			int q = ch[p][c];
			if(len[q] == len[p] + 1)fa[np] = q;
			else {
				int nq = ++T;
				len[nq] = len[p] + 1;
				memcpy(ch[nq], ch[q], sizeof(ch[q]));
				for(; ch[p][c] == q; p = fa[p])ch[p][c] = nq;
				fa[nq] = fa[q];
				fa[q] = fa[np] = nq;
			}
		}
	}
	inline void sort() {
		memset(a, 0, sizeof(a));
		for(int i = 1; i &lt;= T; ++i)++a[len[i]];
		for(int i = 1; i &lt;= T; ++i)a[i] += a[i - 1];
		for(int i = 1; i &lt;= T; ++i)c[a[len[i]]--] = i;
		for(int i = T; i; --i) {
			int p = c[i];
			// printf(&quot;%d %d\n&quot;, p, fa[p]);
			cnt[fa[p]] += cnt[p];
			//子树中本质不同子串个数
		}
	}
	inline void dfs(int u, int len, int j) {
		if(len &gt; m)return (void)(ans += cnt[u]);//就是这样...
		// printf(&quot;%d %d %d?\n&quot;, u, len, j);
		for(int i = 0; i &lt; 4; ++i) {
			if(!ch[u][i])continue;
			if(val[s[len]] == i)dfs(ch[u][i], len + 1, j);
			else if(j &lt; 3)dfs(ch[u][i], len + 1, j + 1);//不同?限制不能多选
		}
	}
};



int main() {
	val['T'] = 0;
	val['A'] = 1;
	val['C'] = 2;
	val['G'] = 3;
	int T;
	scanf(&quot;%d&quot;, &amp;T);
	while(T--) {
		SAM::init();
		ans = 0;
		scanf(&quot;%s&quot;, s + 1);
		int L = strlen(s + 1);
		for(int i = 1; i &lt;= L; ++i)SAM::ins(val[s[i]]);
		SAM::sort();
		scanf(&quot;%s&quot;, s + 1);
		m = strlen(s + 1);
		SAM::dfs(1, 1, 0);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p>
]]></content>
    </entry>
</feed>