<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-08-27T06:15:30.286Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[P1973 [NOI2011]NOI 嘉年华]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1973-noi2011noi-jia-nian-hua/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1973-noi2011noi-jia-nian-hua/">
        </link>
        <updated>2020-08-27T05:54:38.000Z</updated>
        <content type="html"><![CDATA[<p>init</p>
<p>首先预处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">tot_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示l,r时间段中的活动有哪些....</p>
<p>然后这个可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>的时间预处理</p>
<p>接下来我们再预处理两个数组</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pre_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示1~i时间我们第一个选了x的前提下,第二个选了活动个数的最大值</p>
<p>然后怎么求呢?dp一下</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mrow><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">pre_{i,j}=\max_{k&lt;i}{pre_{k,j}+tot_{i,k},pre_{k,j-tot_{i,k}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.394558em;vertical-align:-0.7794779999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7794779999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>你没看错,要么分给第一个会场要么分给第二个,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然后我们还能再处理出一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">suf_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,就是后缀的选择</p>
<p>很易得出转移方程:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow></munder><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">suf_{i,j}=\max_{k&gt;i}{suf_{k,j}+tot_{j,k},suf_{k,j-tot_{i,k}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4739179999999998em;vertical-align:-0.7794779999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7794779999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样就做完预处理啦qwq</p>
<p>我们还要计算一个求解的数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>区间的活动全部被一边选走,两边最优的最小值</p>
<p>然后我们还有枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后有多少活动给了这一边,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x+y+sum_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>就是第一边选的个数!</p>
<p>而另一边呢?你会发现我们的pre和suf就有用了,可以开眼了!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>r</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pre_{l,x}+suf_{r,y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>就是答案</p>
<p>两部分结合起来,转移方程就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mi>x</mi></munder><munder><mi>max</mi><mo>⁡</mo><mi>y</mi></munder><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>r</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">f_{l,r}=\max_{x}\max_{y}{x+y+tot_{l,r},pre_{l,x}+suf_{r,y}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.530548em;vertical-align:-0.8361080000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4305599999999999em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8361080000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>还没完.....答案并不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">f_{s_i,t_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为这个pre和suf只是局部最优,仅用他们并不能推出全局最优解,也就是说我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mo>?</mo><mo separator="true">,</mo><mo>?</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{?,?}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">?</span><span class="mpunct mtight">,</span><span class="mclose mtight">?</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>才可能是全局最优解,而我们无法知道这个?</p>
<p>解决方法也很简单<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>max</mi><mo>⁡</mo><mrow><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>l</mi></mrow></msub><msub><mi>max</mi><mo>⁡</mo><mrow><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\max_{i&lt;=l}\max_{j&gt;=r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999985em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&gt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>一定是答案,因为我们虽然每个状态并不一定是全局最优解,但最优解一定在这个数组中</p>
<p>这样我们就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求解f然后TLE了!</p>
<p>用脑袋仔细想想,pre数组随着第二维的增大,他的数组值只有可能变小,没有说我第一个会场活动多第二个会场跟着变多的道理</p>
<p>也就是说,随着x的增大,y如果随着增大, min前面那个只能越来越大,后面那个越来越小</p>
<p>所以对于x增加我们的y只能从大到小的变换....</p>
<p>然后x一增大y变小挨着找最优决策点就做完了....因为一定min在取到后面那个数之后一定不会再取回之前了.....只会越来越劣</p>
<p>这样决策单调性优化我们就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>了...</p>
<p>code:</p>
<pre><code class="language-cpp">



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1391D 505]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf1391d-505/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf1391d-505/">
        </link>
        <updated>2020-08-27T03:11:16.000Z</updated>
        <content type="html"><![CDATA[<p>做个D题还这么慢QAQ</p>
<p>首先我们必须猜出一个结论,n&gt;=4时无解</p>
<p>因为n&gt;=4的时候一定存在一个4*4的矩阵</p>
<p>而这个矩阵可以被分成4个2*2的小矩阵</p>
<p>同时每个矩阵都要是奇数个,那么4*4的那个矩阵就一定不能是奇数个了</p>
<p>这个还是很妙的</p>
<p>然后剩下我们就可以状压了...</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i行第i行的状态是S的最少次数</p>
<p>转移的时候预处理相邻状态合法的是那些以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cnt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示i的二进制位</p>
<p>然后直接做就好了....QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 15;
const int MAXM = 1e6 + 7;
int n, m;
char s[MAXM];
int vis[MAXN][MAXN];
int a[MAXN][MAXM], tmp[MAXM], dp[MAXM][MAXN], cnt[MAXN];

inline void init() {
	// printf(&quot;%d %d\n&quot;, n, m);
	for(int S1 = 0; S1 &lt; (1 &lt;&lt; n); ++S1) {
		for(int S2 = 0; S2 &lt; (1 &lt;&lt; n); ++S2) {
			int tmp1 = 0, tmp2 = 0;
			vis[S1][S2] = 1;
			for(int k = 0; k &lt; n; ++k) {
				tmp2 = (S1 &gt;&gt; k &amp; 1) + (S2 &gt;&gt; k &amp; 1);
				// printf(&quot;%d?%d\n&quot;, tmp2, tmp1);
				if(k != 0 &amp;&amp; ((tmp1 + tmp2) &amp; 1) == 0)
					vis[S1][S2] = 0;
				tmp1 = tmp2;
				tmp2 = 0;
			}
			// printf(&quot;%d %d %d?\n&quot;, S1, S2, vis[S1][S2]);
		}
	}
	// printf(&quot;%d %d\n&quot;, n, m);
	for(int S = 0; S &lt; (1 &lt;&lt; n); ++S) {
		for(int i = 0; i &lt; n; ++i) {
			if(S &amp; (1 &lt;&lt; i))cnt[S]++;
		}
		// printf(&quot;%d %d\n&quot;, S, cnt[S]);
	}
	memset(dp, 0x3f3f3f3f, sizeof(dp));
	for(int i = 1; i &lt;= m; ++i) {
		// printf(&quot;in - &gt;%d?\n&quot;, i);
		for(int j = 1; j &lt;= n; ++j) {
			// printf(&quot;%d?a :%d\n&quot;, j, a[j][i]);
			tmp[i] |= (a[j][i] &lt;&lt; (j - 1));
		}
		// printf(&quot;%d %d\n&quot;, i, tmp[i]);
		// dp[i][tmp[i]] = 0;
	}
	int MAXS = (1 &lt;&lt; n) - 1;
	for(int S = MAXS, qwq = 1; S || qwq; S = (S - 1)&amp;MAXS) {
		if(!S)qwq = 0;
		dp[1][S] = cnt[S ^ tmp[1]];
	}
	return;
}

inline void solve() {
	int MAXS = (1 &lt;&lt; n) - 1;
	for(int i = 2; i &lt;= m; ++i) {
		for(int S1 = MAXS, qwq = 1; S1 || qwq; S1 = (S1 - 1)&amp;MAXS) {
			if(!S1)qwq = 0;
			for(int S2 = MAXS, qaq = 1; S2 || qaq; S2 = (S2 - 1)&amp;MAXS) {
				if(!S2)qaq = 0;
				// printf(&quot;%d?%d?\n&quot;, S1, S2);
				if(!vis[S1][S2])continue;
				int qwq = cnt[S1 ^ tmp[i]];
				// printf(&quot;we are in-&gt;%d? %d? %d\n&quot;, S1, S2, i);
				dp[i][S1] = min(dp[i][S1], dp[i - 1][S2] + qwq);
				// printf(&quot;qwq is %d dp value is%d and %d\n&quot;, qwq, dp[i][S1], dp[i - 1][S2]);
			}
		}
	}
	int ans = 1e9;
	for(int S = 0; S &lt;= MAXS; ++S) {
		ans = min(ans, dp[m][S]);
	}
	if(ans != 1e9)
		printf(&quot;%d\n&quot;, ans);
	else puts(&quot;-1&quot;);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(n &gt;= 4 &amp;&amp; m &gt;= 4)return puts(&quot;-1&quot;), 0;
	if(n &lt;= m) {
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, s + 1);
			for(int j = 1; j &lt;= m; ++j) {
				a[i][j] = s[j] - '0';
			}
		}
	} else {
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, s + 1);
			for(int j = 1; j &lt;= m; ++j) {
				a[j][i] = s[j] - '0';
			}
		}
		n ^= m ^= n ^= m;
		// for(int i = 1; i &lt;= n; ++i) {
		// 	for(int j = 1; j &lt;= m; ++j) {
		// 		printf(&quot;shuchu a:%d %d %d\n&quot;, i, j, a[i][j]);
		// 	}
		// }
	}
	init();
	solve();
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1263 宫廷守卫]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1263-gong-ting-shou-wei/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1263-gong-ting-shou-wei/">
        </link>
        <updated>2020-08-27T03:06:19.000Z</updated>
        <content type="html"><![CDATA[<p>标准网络流建模</p>
<p>对于每一行,每一堵墙相当于把这行分成了很多部分</p>
<p>而每一列也是一样的qwq</p>
<p>然后我们发现一个空地代表了对应行的部分和对应列的部分只能放下一个兵</p>
<p>所以把对应行和列连边,表示如果这条边有流量这行和这列都不能有流量了</p>
<p>陷阱就相当于没有空地也不会增加新行划分列划分</p>
<p>所以最后建图就是行一排列一排s到行列到t类型的</p>
<p>输出方案的时候我们找这个二分图中间那些边即可qwq</p>
<p>做完了,其实建图和输出方案还是有一点难度的,但是没有细节啊</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int MAXN = 500;
const int inf = 1e9 + 7;
const int MAXM = 2e5 + 7;
int m, n, ccnt, a[MAXN][MAXN], T, s, t, maxflow;
int nxt[MAXM], to[MAXM], home[MAXM], flw[MAXM], cur[MAXM];
int vis[MAXN][MAXN][2];
map&lt;pair&lt;int, int&gt;, int&gt; mp;

inline void cuntu(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	flw[ccnt] = z;
}

inline void ct(int x, int y, int z) {
	cuntu(x, y, z);
	cuntu(y, x, 0);
}

inline int GET(int x, int y, int p) {
	if(!vis[x][y][p])
		vis[x][y][p] = ++T;
	return vis[x][y][p];
}

int queh[MAXN], quel[MAXN];
inline void build() {
	ccnt = 1;
	for(int i = 1; i &lt;= m; ++i) {
		// printf(&quot;H :%d\n&quot;, i);
		for(int j = 1; j &lt;= n; ++j) {
			// printf(&quot;in L-&gt;%d &quot;, j);
			if(a[i][j] == 2) {
				quel[j]++;//这一列点数+1
				queh[i]++;//这一行点数+1
				// printf(&quot;%d %d?\n&quot;, quel[j], queh[i]);
			} else if(a[i][j] == 0) {
				// printf(&quot;node :%d ct-&gt;node: %d?\n&quot;, GET(i, queh[i], 1), GET(j, quel[j], 0));
				ct(GET(i, queh[i], 1), GET(j, quel[j], 0), 1);
			}
		}
		// puts(&quot;&quot;);
	}
	++T;
	s = T;
	++T;
	t = T;
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 0; j &lt;= queh[i]; ++j) {
			// printf(&quot;s - &gt;%d\n&quot;, GET(i, j, 1));
			ct(s, GET(i, j, 1), 1);
		}
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 0 ; j &lt;= quel[i]; ++j) {
			// printf(&quot;t - &gt; %d\n&quot;, GET(i, j, 0));
			ct(GET(i, j, 0), t, 1);
		}
	}
	return ;
}

inline void solve() {
	for(int u = 1; u &lt;= T; ++u) {
		if(u == s || u == t)continue;
		bool flg = 0;
		for(int i = home[u]; i; i = nxt[i]) {
			int  v = to[i];
			if(v == s &amp;&amp; flw[i] == 1)flg = 1;
			if(v == t &amp;&amp; flw[i] == 0)flg = 2;//统计有没有流量
		}
		if(flg == 1) {//s出发有流量,说明这个点在匹配里
			for(int i = home[u]; i; i = nxt[i]) {
				int v = to[i];
				if(v != s &amp;&amp; flw[i] == 0) {
					mp[mkp(min(u, v), max(u, v))] = 1; //这个点有了
					break;
				}
			}
		} else if(flg == 2) {
			for(int i = home[u]; i; i = nxt[i]) {
				int v = to[i];
				if(v != t &amp;&amp; flw[i] == 1) {
					mp[mkp(min(u, v), max(u, v))] = 1;
					break;
				}
			}
		}
	}
	memset(quel, 0, sizeof(quel));
	memset(queh, 0, sizeof(queh));
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			if(a[i][j] == 2) {
				quel[j]++;
				queh[i]++;
			} else if(a[i][j] == 0) {
				int tmp1 = GET(i, queh[i], 1);
				int tmp2 = GET(j, quel[j], 0);
				if(tmp1 &gt; tmp2)
					tmp1 ^= tmp2 ^= tmp1 ^= tmp2;
				if(mp.find(mkp(tmp1, tmp2)) != mp.end())
					printf(&quot;%d %d\n&quot;, i, j);
			}
		}
	}
	return ;
}

int h[MAXM];
int que[MAXM];
inline int bfs() {
	memset(h, 0, sizeof(h));
	int hd = 1, tl = 1;
	que[hd] = s;
	h[s] = 1;
	while(hd &lt;= tl) {
		int u = que[hd];
		++hd;
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			if(!h[v] &amp;&amp; flw[i] &gt; 0) {
				h[v] = h[u] + 1;
				que[++tl] = v;
			}
		}
		if(h[t])return 1;
	}
	return h[t];
}

inline int dfs(int u, int nflw) {
	if(u == t || nflw == 0)return nflw;
	int ret = nflw, a = 0;
	for(int &amp;i = cur[u]; i; i = nxt[i]) {
		int v = to[i];
		if(h[v] == h[u] + 1 &amp;&amp; (a = dfs(v, min(ret, flw[i])))) {
			flw[i] -= a;
			flw[i ^ 1] += a;
			ret -= a;
			if(!ret)break;
		}
	}
	if(nflw == ret)h[u] = -1;
	return (nflw - ret);
}

inline void Dinic() {
	maxflow = 0;
	while(bfs()) {
		memcpy(cur, home, sizeof(cur));
		maxflow += dfs(s, inf);
	}
	printf(&quot;%d\n&quot;, maxflow);
	solve();
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			scanf(&quot;%d&quot;, &amp;a[i][j]);
		}
	}
	build();//建图
	Dinic();
	return 0;
}

</code></pre>
<p>别看长其实和昨天的DP比起来可好写了差老多了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4099 [HEOI2013]SAO ]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/">
        </link>
        <updated>2020-08-26T11:21:51.000Z</updated>
        <content type="html"><![CDATA[<p>n-1条边有向弱联通图拓扑序计数</p>
<p>咋做啊?</p>
<p>首先我们应该注意到是树,而不是那个阴间的npc问题</p>
<p>类似于一坨坨的序列合并...我们就要想是整个一坨合并还是插入合并?</p>
<p>这个题显然拓扑序列是可以两个子树之间穿插的,所以我们转移的时候就要用穿插的方式转移</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 8: f_{i,j}$̲$表示点i在拓扑序的j号位置的…'>f_{i,j}$$表示点i在拓扑序的j号位置的方案数是什么

转移时,对于一条连向儿子的边,u要么能放在v前,要么能放在v后

也就是说.......u.....v......,或者...v.....u......

这个其实限制了状态的转移,也就是那些状态能够转移过来

然后我们要分配儿子,因为我们还有兼具合并v的重任所以上组合数把!

钦定$v&lt;u$硬点u在拓扑序原来的排名为l,而合并之后的排名为k,所以前面的总可能是$\binom{k-1}{l-1}$,就是l-1个点分在原子树里

紧接着会发现我们有$siz[u]+siz[v]-k$个数还没用呢....因为我们枚举了原来的排名为l,所以$siz[u]-l$就是原来放在另外拓扑序后面的数数量,所以我们再$*\binom{siz[u]+siz[v]-k}{siz[u]-l}$表示我们把后面部分选好

$$f_{u,j}=\sum_{l&lt;siz[v]}\sum_{k&lt;l}f_{u,l}*f_{v,k}*\binom{j-1}{l-1}\binom{siz[u]+siz[v]-k}{siz[u]-l}</p>
<p>就是这个转移方程了</p>
<p>钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>&gt;</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">v&gt;u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span></p>
<p>其实很对称啊,我们会发现之前组合数的部分都不用变,改变的是转移的范围</p>
<p>假设第一维枚举原来的点数,第二维枚举v向前给出多少个点的贡献(就是u新的排名会后移啊.....),因为此时v可能不会再影响u原来的排名后移了</p>
<p>第三维枚举的就是我们实际的比u多的rank,这里一开始自闭了一下,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{v,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>其实也可以表示v比u大k的方案..</p>
<p>总的来说,这个转移共有两个细节</p>
<ol>
<li>计算新排名时要组合新排名前面的数和新排名之后的数</li>
<li>计算新排名的时候要仔细想想枚举什么,以及对应乘上的dp状态</li>
</ol>
<p>按理说应该直接枚举新u的排名的,代码没有这样写</p>
<p>最后对了还有一个前缀和优化,仔细看看代码就会感觉是临时加上去的.....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 1e3 + 7;
const int MAXM = 2e3 + 7;
int n, ccnt, T, home[MAXN], nxt[MAXM], to[MAXM], flg[MAXM];

inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	flg[ccnt] = z;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int dp[MAXN][MAXN], siz[MAXN], f[MAXN][MAXN], C[MAXN][MAXN], sum[MAXN][MAXN];
// ll fac[MAXN], ifac[MAXN];
inline void INIT() {
	C[0][0] = 1;
	for(int i = 1; i &lt; MAXN; ++i) {
		C[i][0] = 1;
		for(int j = 1; j &lt;= i; ++j) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;
		}
	}
	return ;
}

inline void init() {
	memset(home, 0, sizeof(home));
	ccnt = 0;
	memset(dp, 0, sizeof(dp));
}

inline void add(int &amp;x, ll y) {
	x += y;
	// printf(&quot;?%d?%d?\n&quot;, x, y);
	if(x &gt; P)
		x -= P;
}

inline void dfs(int u, int F) {
	siz[u] = 1;
	dp[u][1] = 1;
	// printf(&quot;u is :%d?\n&quot;, u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		// printf(&quot;u %d and back v %d?\n&quot;, u, v);
		for(int k = 1; k &lt;= n; ++k)
			f[u][k] = 0;
		if(flg[i] == 1) {//之前边,u在v之前
			// printf(&quot;u is v front front is :%d back is :%d\n&quot;, u, v);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举u原来点数
				for(int k = 0; k &lt;=  siz[v]; ++k) { //枚举v给出的贡献
					// for(int l = k + 1; l &lt;= siz[v]; ++l) {
					int del = ((sum[v][siz[v]] - sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[j + k - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][ siz[u] - j] % P);
					// printf(&quot;but each size is%d %dget ans:%d\n&quot;, siz[u], siz[v], f[u][j + k]);
					// }
				}
			}
		} else {//u在v之后
			// printf(&quot;u is v back front is :%d back is :%d\n&quot;, v, u);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举新u的点数
				for(int k = 1; k &lt;= siz[v]; ++k) {
					// for(int l = 1; l &lt;= k; ++l) {
					int del = ((sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[k + j - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][siz[u] - j] % P) ;
					// printf(&quot;but each size is%d %d\n&quot;, siz[u], siz[v]);
					// }
				}
			}
		}
		siz[u] += siz[v];
		for(int k = 1; k &lt;= n; ++k)
			dp[u][k] = f[u][k];
	}
	// printf(&quot;%d?\n&quot;, u);
	for(int i = 1; i &lt;= n; ++i) {
		sum[u][i] = (sum[u][i - 1] + dp[u][i]) % P;
		// add(sum[u][i], sum[u][i - 1]);
		// add(sum[u][i], dp[u][i]);
		// printf(&quot;!%d??%d %d\n&quot;, sum[u][i], sum[u][i - 1], dp[u][i]);
	}
	return ;

}
char s[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;T);
	INIT();//大预处理
	// printf(&quot;%d %d %d\n&quot;, C[10][2], C[5][3], C[6][4]);
	while(T-- &gt; 0) {
		init();
		scanf(&quot;%d&quot;, &amp;n);
		for(int i = 1, x, y; i &lt; n; ++i) {
			scanf(&quot;%d&quot;, &amp;x);
			cin &gt;&gt; s;
			scanf(&quot;%d&quot;, &amp;y);
			++x;
			++y;
			// printf(&quot;%d %d\n&quot;, x, y);
			//&lt;说明x在y之前打
			if(s[0] == '&lt;') {
				// puts(&quot;Y&quot;);
				ct(x, y, 1);
				ct(y, x, 0);
				//变向说明y在x之后
			} else {
				// puts(&quot;N&quot;);
				//x在y之后打
				ct(x, y, 0);
				ct(y, x, 1);
				//说明y在x之前打
			}
		}
		dfs(1, 0);
		int ans = 0;
		for(int i = 1; i &lt;= n; ++i)
			add(ans, dp[1][i]);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<p>zzz</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3515 [POI2011]Lightning Conductor]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/">
        </link>
        <updated>2020-08-26T10:30:21.000Z</updated>
        <content type="html"><![CDATA[<p>唉...二分是又一个细节吧.....</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>+</mo><msqrt><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow></msqrt><mo>&lt;</mo><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">a_j+\sqrt{|i-j|}&lt;=a_i+p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.25612499999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.983875em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span></span></span><span style="top:-2.9438750000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25612499999999994em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p>
<p>拿到题我们就应该想到找每个数上述式子最大的j</p>
<p>观察后面根号函数,你会发现他的导函数单调递减!有决策单调性了</p>
<p>而与此同时我们要求的是最大值,所以可以用单调队列来优化</p>
<p>就是单调队列优化决策单调性的板子.....</p>
<p>直接上就好了,正着做一遍反着来一遍</p>
<p>然后最后处理答案随便搞一下就好</p>
<p><strong>但是nmd卡细节</strong></p>
<p>记得我们决策单调性有一个二分的步骤吗?</p>
<p>里面我们的l,r一定要限制好范围!!!!</p>
<p>对于r,如果k[r]存在(即有右端点的限制)我们就设置右端点为r</p>
<p>对于l,我们输入了x,y两个决策点想要找一个不错的,所以我们左端点应该在y之后!</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><msub><mi>k</mi><mi>y</mi></msub><mo>?</mo><msub><mi>k</mi><mi>y</mi></msub><mo>+</mo><mn>1</mn><mo>:</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=k_y?k_y+1:n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">?</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>但是这样诗人小G又不能过,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">k_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>一看就很扯吗...),所以我暴力改改参数得到了普适应的一组参数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>以后就用这组</p>
<p>二分用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l&lt;r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>锁定答案形式</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define db double
const int MAXN = 5e5 + 7;
int n, a[MAXN], que[MAXN], k[MAXN];
db sq[MAXN], f[MAXN];

inline db calc(int x, int y) {
	return a[y] + sq[x - y];
}

inline int bound(int x, int y) {
	int l = y, r = k[y] ? k[y] + 1 : n + 1, mid;
	while(l &lt; r) {
		mid = (l + r) &gt;&gt; 1;
		calc(mid, x) &gt; calc(mid, y) ? l = mid + 1 : r = mid;
	}
	return r;
}	 

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	for(int i = 0; i &lt;= n; ++i)
		sq[i] = sqrt(i);
	int h = 1, t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;calc in -&gt;%d by%d\n&quot;, i, que[h]);
		f[i] = calc(i, que[h]);
		// printf(&quot;we get :%lf?\n&quot;, f[i]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;she controlled :%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	reverse(a + 1, a + n + 1);
	reverse(f + 1, f + n + 1);
	h = 1, t = 0;
	memset(k, 0, sizeof(k));
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;qwq-&gt;:%d %d %lf\n&quot;, i, que[h], f[n - i + 1]);
		f[i] = max(f[i], calc(i, que[h]));
		// printf(&quot;we get :%lf?\n&quot;, f[n - i + 1]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	// reverse(a + 1, a + n + 1);
	for(int i = n; i &gt;= 1; --i) {
		// printf(&quot;%lf %d\n&quot;, f[i], a[i]);
		printf(&quot;%d\n&quot;, max((int)ceil(f[i] - a[i]), 0));
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2511 [HAOI2008]木棍分割]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/">
        </link>
        <updated>2020-08-26T08:17:13.000Z</updated>
        <content type="html"><![CDATA[<p>nmd细节</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个棍分成j组的方案数</p>
<p>转移式子很简单f_{i,j}=\sum_{k&lt;i,sum[i]-sum[k]&lt;=Max}f_{k,j-1}</p>
<p>然后j这维可以滚动,同时可以前缀和优化...</p>
<p>不过这个有个你妈的细节,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>t</mi><mi>p</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=sum_{i-1,j-1}-sum_{tp-1,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>这个是不能转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的....毕竟<strong>没有空组</strong>!!</p>
<p>唉...但是只WA了一个点,让人麻木</p>
<p>写的时候多想了好多强加了好多限制使得看上去繁琐了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e4 + 7;
const int MAXN = 1e5 + 7;
int n, m, S;
int a[MAXN], pre[MAXN];
int Max, MM;

inline int chk(int x) {
	int tmp = 0;
	int ccnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(tmp + a[i] &gt; x) {
			ccnt++;
			tmp = a[i];
		} else tmp += a[i];
	}
	return (m &gt;= ccnt);
}

inline void solve1() {
	int l = MM, r = S, mid;
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			Max = mid;
		} else l = mid + 1;
	}
}

ll f[2][MAXN], sum[2][MAXN], ans;
inline void solve2() {
	int tp = 0;
	int t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(pre[i] &lt;= Max)
			f[1][i] = 1;
		sum[1][i] = sum[1][i - 1] + f[1][i];
	}
	for(int j = 2; j &lt;= m + 1; ++j) {
		tp = 0;
		// puts(&quot;qwq&quot;);
		for(int i = j; i &lt;= n; ++i) {
			while(tp &lt;= i &amp;&amp; pre[i] - pre[tp] &gt; Max)++tp;
			sum[t][i] = sum[t][i - 1];
			// printf(&quot;%d %din-&gt;%lld %lld\n&quot;, i, tp, sum[t ^ 1][i], sum[t ^ 1][tp - 1]);
			if(tp != 0)
				f[t][i] = sum[t ^ 1][i - 1] - sum[t ^ 1][tp - 1];
			else
				f[t][i] = sum[t ^ 1][i - 1];
			// printf(&quot;%lld??\n&quot;, f[t][i]);
			f[t][i] = (f[t][i] + P) % P;
			sum[t][i] = (sum[t][i] + f[t][i]) % P;
		}
		ans = (ans + f[t][n]) % P;
		t ^= 1;
		for(int i = 0; i &lt;= n; ++i)
			f[t][i] = sum[t][i] = 0;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		pre[i] = pre[i - 1] + a[i];
		S += a[i];
		MM = max(MM, a[i]);
	}
	solve1();//解决第一问
	printf(&quot;%d &quot;, Max);
	solve2();//缀和优化第二维
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5504 [JSOI2011]柠檬]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/">
        </link>
        <updated>2020-08-26T03:29:35.000Z</updated>
        <content type="html"><![CDATA[<p>决策单调性优化2</p>
<p>我爱</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mo>(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">f_j=max{f_{i-1}+col(i)*(s_{j}-s_{i}+1)^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">col_i==col_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,这个是满足的才行</p>
<p>观察后面函数导函数是单调递增的,而要最大化,由上一篇博客可知要决策单调性优化单调栈形式了....</p>
<p>具体怎么说呢?</p>
<p>不难发现,正是因为我们要<strong>最大化</strong>,对于一个颜色j,越靠前后面那个转移的值越大!</p>
<p>也就是说对于一个决策点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,j当前不是最优的,j可能会在某个时间点之后成为了最优点</p>
<p>也就是说我们一个单调栈内决策点的最优时间是<strong>递减</strong>的.....而最优时间可以反映到颜色数上,因为相当于颜色数越多我们最优时间越靠后</p>
<p>辣么我们就可以想出一些方法去维护这个单调栈了....</p>
<ol>
<li>如果栈顶的两个元素的最优时间早于新决策点i和栈顶的最优时间我们就弹出栈顶</li>
</ol>
<p>显然i是最优的,但是栈顶的最优时间还在i之前,所以说明他无论如何都不会成为最优时间了,所以我们可以弹出栈顶....</p>
<ol start="2">
<li>如果栈顶的两个元素的最优时间小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>即i颜色数就弹出栈顶</li>
</ol>
<p>也就是说他已经不再能成为那个决策点了,也就是最优时间已经过了...</p>
<p>做完这两个操作我们再去更新i即可</p>
<p>而怎么求出两个决策点的最优时间比较呢?</p>
<p>可以二分,因为两个决策点一定是某段时间之前一个更优,之后另一个更优,直接二分那个颜色数然后类似的转移一下就好了</p>
<p>所以最后整个算法流程也就是这样了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
#define ll long long
int n, a[MAXN], s[MAXN], vis[MAXN];
vector&lt;int&gt; st[MAXN], rc[MAXN];
ll f[MAXN];

inline ll calc(int x, int y) {
	// if(x == y)return f[y] + a[x];
	return f[x - 1] + 1ll * y * y * a[x];
}

inline int bound(int x, int y) {//在x,y中update
	int l = 1, r = n, mid, ret = n + 1;
	// printf(&quot;%d %d?%d %d\n&quot;, l, r, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		// printf(&quot;in-&gt;%lld %lld?\n&quot;, calc(x, mid - s[x] + 1), calc(y, mid - s[y] + 1));
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			ret = mid;
			r = mid - 1; 
		} else l = mid + 1;
	}
	// printf(&quot;!!!%d\n&quot;, ret);
	return ret;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	//直接用st维护
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// printf(&quot;%d?\n&quot;, st[t].size());
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1])
				&lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;%d %d?\n&quot;, bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]), bound(st[t][st[t].size() - 1], i));
			st[t].pop_back();//只要结尾一段的决策点i最优就一直...
		} st[t].push_back(i);
		// printf(&quot;st:%d st2:%d low:%d \n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2], bound(st[t][st[t].size() - 1], i));
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// printf(&quot;%d\n&quot;, st[t][st[t].size() - 1]);
			st[t].pop_back();
		}
		// printf(&quot;i:%d best choic: %d!\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finial:%lld\n&quot;, f[i]);
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}

</code></pre>
<p>还有noi.ac的一道抄袭这个题的决策单调性优化</p>
<p><strong>有一个至关重要的细节就是如果我们的二分二分不出时间</strong></p>
<p>说明前面的决策点永远都不可能成为最优决策点了....</p>
<p>那么这个时候我们只需要压住栈即可,因为珍贵的栈顶是最优的</p>
<p>即bound函数返回n+1</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long double
const int MAXN = 1e6 + 7;

int n, k;
int a[MAXN], vis[MAXN], s[MAXN];
vector&lt;int&gt; st[MAXN];
ll f[MAXN], qwq[MAXN];

inline ll calc(int x, int y) {
	return f[x - 1] + qwq[y];
}

inline int bound(int x, int y) {
	int l = 1, r = n, ret = n + 1, mid;
	// printf(&quot;in-&gt;%d %d?\n&quot;, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			// printf(&quot;this mid is ok%d\n&quot;, mid);
			ret = mid;
			r = mid - 1;//这个决策点x更优,再靠前
		} else l = mid + 1;
	}
	// printf(&quot;end with %d\n&quot;, ret);
	return ret;
}

inline void init() {
	if(k == 2) {
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i;
		}
	} else if(k == 3)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = pow(i, 1.5);
			// printf(&quot;%d %Lf\n&quot;, i, qwq[i]);
		} else if(k == 4)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i * i;
		}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;k, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	init();
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// puts(&quot;Ha1&quot;);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;out..-&gt;%d?%d?\n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2]);
			st[t].pop_back();
		}
		// puts(&quot;Ha2&quot;);
		st[t].push_back(i);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// puts(&quot;qwq&quot;);
			st[t].pop_back();
		}
		// printf(&quot;wei shen me?%d %d?\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finish:%Lf\n&quot;, f[i]);
	}
	printf(&quot;%.6Lf\n&quot;, f[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1912 [NOI2009]诗人小G]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1912-noi2009shi-ren-xiao-g/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1912-noi2009shi-ren-xiao-g/">
        </link>
        <updated>2020-08-26T01:38:52.000Z</updated>
        <content type="html"><![CDATA[<p>决策单调性优化</p>
<p>钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为前i个串的前缀和</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo>(</mo><msub><mi>s</mi><mi>i</mi></msub><mo>−</mo><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><mi>L</mi><mo>+</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><msup><mo>)</mo><mi>P</mi></msup></mrow><annotation encoding="application/x-tex">f_i=f_j+abs(s_i-s_j-L+(i-j-1))^P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中i-j-1是空格的数量</p>
<p>然后我们这个式子就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求,并且得出每个i的最优决策点来输出方案</p>
<p>30pts好成绩,因为还有两个点L很小,所以处理的好一点能拿到50pts</p>
<p>紧接着斜率优化就70pts了</p>
<p>最后我们可以决策单调性优化</p>
<p>根据第一篇博客:导函数单增,求最小值,可以使用单调队列</p>
<p>就是说我们i的决策点每次更新的是队列最后的一段,而计算新数的时候用靠前的一段</p>
<p>导函数单增求最大值用单调栈,就是更新的是靠前的一段而计算的时候也用靠前的一段</p>
<p>也就是说导函数增减和最大小值相同就是队列,否则就是栈</p>
<p>二分的时候有点细节,不要写l=m-1,r=m+1那种,因为我们可能连续一段区间都满足,但我们要的是左端点(lower_bound)</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long double
using namespace std;
const int MAXN = 2e5 + 7;
const int P = 1e9 + 7;
int T, n, l, p;
int s[MAXN], que[MAXN], k[MAXN], pr[MAXN];
ll f[MAXN];
char str[MAXN][33];//每组数据字符串

inline ll ksm(ll x, int y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x;
		x = x * x;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline ll calc(int x, int y) {
	// printf(&quot;x: %dy: %df[y]:%Lf del:%d P:%d %d %d\n&quot;, x, y, f[y], s[x], s[y], abs(s[x] - s[y] - l), p);
	// printf(&quot;calc:%d %d??\n&quot;, x, y);
	return f[y] + ksm(abs(s[x] - s[y] + (x - y - 1) - l), p);
}

inline int bound(int x, int y) {
	int l = x, r = n + 1, m;
	while(l &lt; r) {
		m = (l + r) &gt;&gt; 1;
		if(calc(m, x) &gt;= calc(m, y)) {
			r = m;
		} else {
			l = m + 1;
		}
	}
	// printf(&quot;%d %d %d\n&quot;, l, r, ans);
	return r;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;l, &amp;p);
		memset(s, 0, sizeof(s));
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, str[i]);
			s[i] = s[i - 1] + strlen(str[i]);
		}
		// for(int i = 1; i &lt;= n; ++i)printf(&quot;%d \n&quot;, s[i]);
		int i = 1, h = 1, t = 1;
		for(que[1] = 0; i &lt;= n; ++i) {
			while(h &lt; t &amp;&amp; k[h] &lt;= i)
				++h;//k是右端点
			f[i] = calc(i, que[h]);
			// printf(&quot;our choice: %Lf %d %d\n&quot;, f[i], que[h], i);
			pr[i] = que[h];//记录决策点
			while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
				--t;//如果右端点大于我们栈内二分的端点
			k[t] = bound(que[t], i);
			que[++t] = i;
		}
		if(f[n] &gt; 1e18)puts(&quot;Too hard to arrange&quot;);
		else {
			printf(&quot;%.0Lf\n&quot;, f[n]);
			for(que[t = 0] = i = n; i; que[++t] = i = pr[i]);
			for(; t; --t) {
				for(i = que[t] + 1; i &lt; que[t - 1]; ++i)printf(&quot;%s &quot;, str[i]);
				puts(str[i]);
			}
		}
		puts(&quot;--------------------&quot;);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF710F String Set Queries]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf710f-string-set-queries/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf710f-string-set-queries/">
        </link>
        <updated>2020-08-25T12:59:29.000Z</updated>
        <content type="html"><![CDATA[<p>AC自动机好题</p>
<p>删除的答案其实很好统计qwq,我们先查询在删除自动机里面的答案,再查询在全体自动机的答案</p>
<p>然后做一个差就是答案....</p>
<p>不过我们AC自动机这个东西没法边着插入边维护fail树QAQ</p>
<p>所以我们肯定要用一些定期重构之类的想法去维护AC自动机</p>
<p>根号分块是肯定可以的,就是每根号m的开一个自动机,如果不到根号m个没有存入可以直接暴力匹配</p>
<p>(当然也最推荐写这个)</p>
<p>然而复杂度不好看,我们有一个log的做法...</p>
<p>二进制分组....</p>
<p>假设现在有n个,n的第k位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mn>2</mn><mi>i</mi><mi>a</mi></msubsup></mrow><annotation encoding="application/x-tex">2^a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>个串构成</p>
<p>然后查询的时候暴力把log个自动机都跑一遍</p>
<p>修改n的时候进位我们就把那些都暴力重构组成一个新的自动机放在新的二进制位上</p>
<p>由于一个串最多重构log次所以是对的</p>
<p>这样子我们只需要把一些AC自动机中的串拿出来重构</p>
<p>具体实现的时候我们对于每个二进制位都弄一个链表记录该位存储的哪些串就行了</p>
<p>这个二进制分组的思想好像也仅适用于这类数据结构的情况?</p>
<p>有一个大大的细节就是清空ch树的时候要延迟清空.....具体可看看代码实现</p>
<p>code:</p>
<pre><code class="language-cpp">
//二进制分组
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 4e5 + 7;
char s[MAXN];

struct ACF {//ACFUN
	string data[MAXN];
	int ch[MAXN][26], fail[MAXN], ed[MAXN], T, n;
	inline void ins(int r, char *s) {
		int n = strlen(s + 1);
		int u = r;
		for(int i = 1, t; i &lt;= n; ++i) {
			t = s[i] - 'a';
			if(ch[u][t] == r) {//要把这个点重构然后再把其他的重构
				ch[u][t] = ++T;
				for(int j = 0; j &lt; 26; ++j)
					ch[T][j] = r;
			}
			u = ch[u][t];
		}
		ed[u]++;
	}
	void build(int r) {
		fail[r] = r;
		queue&lt;int&gt; q;
		for(int i = 0; i &lt; 26; ++i) {
			if(ch[r][i] &gt; r) {
				q.push(ch[r][i]);
				fail[ch[r][i]] = r;
				//fail....
			}
		}
		while(!q.empty()) {
			int u = q.front();
			q.pop();
			for(int i = 0; i &lt; 26; ++i) {
				int v = ch[u][i];
				if(v == r)
					ch[u][i] = ch[fail[u]][i];
				else {
					fail[v] = ch[fail[u]][i];
					ed[v] += ed[ch[fail[u]][i]];
					q.push(v);//fail重构
				}
			}
		}
	}
	int search(int r, char *s) {
		int n = strlen(s + 1);
		int u = r;
		int ret = 0;
		for(int i = 1, t; i &lt;= n; ++i) {
			t = s[i] - 'a';
			u = ch[u][t];
			ret += ed[u];
		}
		return ret;
	}
	int stk[MAXN], fr[MAXN], siz[MAXN], N;
	void merge() {
		--N;
		siz[N] &lt;&lt;= 1;
		for(int i = stk[N]; i &lt;= T; ++i) {
			ed[i] = fail[i] = 0;
			for(int j = 0; j &lt; 26; ++j) {
				ch[i][j] = 0;
			}
		}
		T = stk[N];
		for(int i = 0; i &lt; 26; ++i)
			ch[T][i] = T;
		for(int L = fr[N]; L &lt;= n; ++L)
			ins(stk[N], &amp;data[L][0]);
		build(stk[N]);
	}
	void ins(char *s) {
		stk[++N] = ++T;
		for(int i = 0; i &lt; 26; ++i)
			ch[T][i] = T;
		siz[N] = 1;
		ins(T, s);
		build(stk[N]);
		int L = strlen(s + 1);
		data[fr[N] = ++n] = &quot; &quot;;
		for(int i = 1; i &lt;= L; ++i)
			data[n] += s[i];
		while(siz[N] == siz[N - 1])
			merge();
	}
	int Count(char *s) {
		int ans = 0;
		for(int i = 1; i &lt;= N; ++i)
			ans += search(stk[i], s);
		return ans;
	}
} Add, Sub;

int m;
int main() {
	scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1, typ; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;typ);
		cin &gt;&gt; (s + 1);
		if(typ == 1) {
			Add.ins(s);
		} else if(typ == 2) {
			Sub.ins(s);
		} else {
			printf(&quot;%d\n&quot;, Add.Count(s) - Sub.Count(s));//做差即可
		}
		fflush(stdout);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4198 楼房重建]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4198-lou-fang-chong-jian/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4198-lou-fang-chong-jian/">
        </link>
        <updated>2020-08-25T11:39:51.000Z</updated>
        <content type="html"><![CDATA[<p>合并需要log的线段树</p>
<p>其实本质上是线段树维护单调栈,但是我们直接在某个点上记录一整个栈不太阳间</p>
<p>我们会发现其实有很多儿子的信息我们没有很好利用,所以我们可以考虑用儿子节点的信息拼成一个单调栈合并的信息</p>
<p>单调栈合并的时候需要从后面某个地方砍一刀然后把后面剩下的地方接到前面去</p>
<p>所以这个也是一样的,我记录了区间最大值和区间单调栈长度直接写TLE了好几发</p>
<p>因为我是直接递归看看右边能不能再去划分,只用最大值当做剪枝的判据</p>
<p>所以这个是能被卡成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的qwq两边都有可能递归</p>
<p>不被卡成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>就要只递归一边......</p>
<p>如果左边最大值小于V,我们直接递归右边</p>
<p><strong>否则我们能根据这个区间的单调栈长度和左区间的单调栈长度算出右边区间在左边成单调栈时的长度</strong></p>
<p>换句话说:右边区间的长度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mo>[</mo><mi>k</mi><mo>]</mo><mi mathvariant="normal">.</mi><mi>L</mi><mo>−</mo><mi>t</mi><mi>r</mi><mo>[</mo><mi>l</mi><mi>s</mi><mo>[</mo><mi>k</mi><mo>]</mo><mo>]</mo><mi mathvariant="normal">.</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">tr[k].L-tr[ls[k]].L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord">.</span><span class="mord mathdefault">L</span></span></span></span></p>
<p>这样就只递归左边即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
using namespace std;
#define sort(a,b) random_shuffle(a,b)
const int MAXN = 7e5 + 7;
const db eps = 1e-11;
int n, m, x, y;
struct rec {
	db Max;
	int L;//记录最大值和单调栈长度
	rec(int L = 0, db x = 0): Max(x), L(L) {};
} tr[MAXN];
db a[MAXN];
namespace seg {
	int ls[MAXN], rs[MAXN], T, root;
#define mid ((l+r)&gt;&gt;1)
	inline void build(int &amp;k, int l, int r) {
		if(!k)k = ++T;
		if(l == r) {
			tr[k].Max = 0;
			tr[k].L = 1;
			return ;
		}
		build(ls[k], l, mid);
		build(rs[k], mid + 1, r);
		tr[k].L = 1;
	}
	inline int query(int k, int l, int r, db V) {
		if(tr[k].Max &lt;= V)return 0;
		if(a[l] &gt; V)return tr[k].L;
		if(l == r)return a[l] &gt; V;
		int tmp = 0;
		if(tr[ls[k]].Max &lt;= V) {
			return query(rs[k], mid + 1, r, V);
		} else {
			return query(ls[k], l, mid, V) + tr[k].L - tr[ls[k]].L;
		}
		return tmp;
	}
	inline int pushup(int k, int l, int r) {
		//找到第一个位置
		//然后再那个位置之后的区间都提出来
		// printf(&quot;in %d!%d %d\n&quot;, k, l, r);
		if(tr[rs[k]].Max - tr[ls[k]].Max &gt; eps) {
			return query(rs[k], mid + 1, r, tr[ls[k]].Max) + tr[ls[k]].L;
		} else {
			// printf(&quot;?%d %lf\n&quot;, tr[ls[k]].L, tr[ls[k]].Max);
			return tr[ls[k]].L;
		}
	}
	inline void modify(int &amp;k, int l, int r, int x, db V) {
		if(!k)k = ++T;
		if(l == r) {
			tr[k].Max = V;
			tr[k].L = 1;
			return ;
		}
		if(x &lt;= mid)modify(ls[k], l, mid, x, V);
		else modify(rs[k], mid + 1, r, x, V);
		// printf(&quot;merge !:-&gt;%d %d %d\n&quot;, k, l, r);
		tr[k].L = pushup(k, l, r);
		tr[k].Max = max(tr[ls[k]].Max, tr[rs[k]].Max);
	}
}
using namespace seg;
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	// build(root, 1, n);
	for(int i = 1, x, y; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		a[x] = (1.00 * y) / (1.00 * x);
		modify(root, 1, n, x, (1.00 * y) / (1.00 * x));
		printf(&quot;%d\n&quot;, tr[root].L);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>