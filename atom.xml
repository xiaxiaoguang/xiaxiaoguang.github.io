<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-07-23T15:00:33.158Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CF1100F Ivan and Burgers]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf1100f-ivan-and-burgers/">
        </link>
        <updated>2020-07-23T14:49:57.000Z</updated>
        <content type="html"><![CDATA[<p>静态区间线性基</p>
<p>考虑chz菜者的做法:离线扫描线,然后从1~n维护一个后缀线性基,每次插入一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,就暴力从i到1全部更新一遍,更新不动了就停止,可以证明此复杂度均摊<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mn>6</mn><msup><mn>4</mn><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*64^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,荣获0pts的好成绩!</p>
<p>然后您发现我们复杂度主要在于插入时的更新,如果我们只更新<strong>1次</strong>就能起到n次的效果就好了...</p>
<p>于是我们有一个贪心的想法,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">pos[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示前i个数第j个基最靠右的位置,然后我们对于插入x的过程,可以贪心的只找最靠右的位置进行更新....</p>
<p>其实这个思想并不巧妙,早在区间数字种类的时候就用到过这样的扫描线贪心,但是对于线性基不太会所以没做出来QAQ</p>
<p>然后您发现有点细节,就是pos的更新,想想就好了,我们其实是在<strong>多个线性基上横跳的</strong>过程</p>
<p>所以一次可能会更新多个pos?</p>
<p>未完待续</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF613E Puzzle Lover]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf613e-puzzle-lover/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf613e-puzzle-lover/">
        </link>
        <updated>2020-07-21T14:38:33.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020国家集训队作业</p>
<p>重 操 旧 业 估计应该能做完part1,part2,part3都是AT题不太行啊</p>
<ul>
<li>给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2 \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的矩阵，每个位置上有一个小写字母。</li>
<li>有一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的小写字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，询问矩阵中有多少条有向路径满足以下条件：
<ul>
<li>路径上的字母连起来恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>。</li>
<li>不多次经过同一个位置。</li>
<li>只能向上下左右四个方向走。</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>≤</mo><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n,k \le 2 \times 10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，答案对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span> 取模。</li>
</ul>
<p>首先想少的我想DP,dp[i][j][k][l]表示前i列第j行,然后匹配了k个位置,前一个转折点在l的最多方案数是什么</p>
<p>显然是没法转移的,因为我们成环,而且可能像蛇一样弯曲前行...</p>
<p>但是转念一想这个环是不是太过basic了?好像不会复杂</p>
<p>就是说一个回头路一定是在字符串的开头或者结尾才有可能?</p>
<p>就例如下图,这是最复杂的路径情况了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1595342780332.png" alt="" loading="lazy"></figure>
<p>然后我们可以想办法搞定这个...中间部分?</p>
<p>你发现中间部分是蜿蜒曲折的,两边的回头路是简单的</p>
<p>所以我们可以只考虑中间设计dp,f[i][j][k]表示点i,j匹配了k的方案数并且<strong>下一步</strong>只能走同一行的点,g[i][j]表示点i,j匹配了k的方案数并且下一步只能走同一列的点转移</p>
<p>然后怎么算呢?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f_{i,j,k}=\sum{f_{i,j-1,k-1}[ch_{i,j+1}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">g_{3-i,j,k}=\sum{f_{i,j,k-1}[ch_{3-i,j}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mo>∑</mo><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>[</mo><mi>c</mi><msub><mi>h</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo>=</mo><msub><mi>t</mi><mi>k</mi></msub><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f_{i,j,k}=\sum{g_{i,j-1,k-1}[ch_{i,j+1}==t_k]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></span></p>
<p>第三个转移的意思是我们考虑转一个弯之后又向前走了一步,当然也是可以的qwq,3-i是第一二行之间切换</p>
<p>然后两边部分QAQ,你发现我们决定哪个为起点会影响中间这个DP过程啊</p>
<p>不过您又机智的发现这个是一个可以预处理然后特判能不能相等的部分,也就是说我们可以搞搞DP数组的初值来解决他?</p>
<p>具体的,对于如果从S走长度为大于1的x的回头路,我们可以看这个回头路能不能匹配串的前2x个字符,如果能,说明从S另一列的位置处<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>3</mn><mo>−</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>2</mn><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{3-i,j,2x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可以置为1</p>
<p>若长为等于1,说明就是从S向下走了一步,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可以置为1</p>
<p>同时,如果这个点本身就是能匹配的,说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>可置为1</p>
<p>为什么只用g数组初始化?因为f数组可以和g相互update,同时我们统计答案也是看g数组的</p>
<p>然后我们再考虑T的部分,也就是统计答案这部分QAQ</p>
<p>首先我们第三维小于m,<s>给T一点面子</s></p>
<p>然后如果T处一个长为x的后缀回头路可以匹配后2x个字符的话,我们就把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msub><mo>+</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>2</mn><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j-1,m-2x}+g_{i,j-1,m-2x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>统计入答案,相当于我们手动走这最后一步</p>
<p>然后我们发现我们没有处理从右往左走的情况,所以可以把串翻转之后再跑一遍上述过程....</p>
<p>然后您惊人的发现我们算重了,但是只算重了S和T在<strong>同一列</strong>的情况,所以这个很好用hash处理,就可以放在外面再加上!</p>
<p>然后我们就完成了一道国家集训队作业题....QAQ</p>
<p>未完code待续</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4310 绝世好题]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4310-jue-shi-hao-ti/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4310-jue-shi-hao-ti/">
        </link>
        <updated>2020-07-20T14:38:32.000Z</updated>
        <content type="html"><![CDATA[<p>这个DP妙啊</p>
<p>首先拿到题我们有dp[i][j]表示到i为止前一个数为j的最长and不为0序列是什么</p>
<p>然后转移时考虑枚举上一个哪个and起来不为0就好</p>
<p>但是这样你会发现没办法优化,问题是出在状态不够优秀上....</p>
<p>考虑二进制每一位都是独立的,那我们可不可以dp第二维记某一位为1的然后转移呢?</p>
<p>好像可以,但是转移的时候要小心了,对于数a,它能使所有二进制下a&amp;为1的状态都加一,<strong>也能使所有二进制为1的状态之间互相转移!</strong></p>
<p>举个例子,3可以使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>)</mo><mo>+</mo><mn>1....</mn></mrow><annotation encoding="application/x-tex">dp[2]=max(dp[1],dp[2])+1....</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>代码也就不难了</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN=1e5+7;

int n;
int a[MAXN],dp[MAXN],ans;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;a[i]);
	for(int i=1; i&lt;=n; ++i) {
		int qwq=0;
		for(int j=0; j&lt;=30; ++j) {
			if(a[i]&amp;(1&lt;&lt;j)) {
				qwq=max(dp[j],qwq);
			}
		}
		for(int j=0; j&lt;=30; ++j) {
			if(a[i]&amp;(1&lt;&lt;j)) {
				dp[j]=max(dp[j]+1,qwq+1);
			}
		}
	}
	for(int j=0; j&lt;=30; ++j) {
		ans=max(ans,dp[j]);
	}
	printf(&quot;%d\n&quot;,ans);
	return 0;

}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5894 [IOI2013]robots 机器人]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5894-ioi2013robots-ji-qi-ren/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5894-ioi2013robots-ji-qi-ren/">
        </link>
        <updated>2020-07-20T14:28:31.000Z</updated>
        <content type="html"><![CDATA[<p><code>&quot;当苦夏簌簌扑着扇，听过最后一声蝉&quot;</code></p>
<p>蛮不错的贪心,<s>不过灰题真的香</s></p>
<p>首先为啥具有二分性呢?因为如果我们k秒可以完成那么k+1秒也一定可以完成</p>
<p>然后我们就可以考虑二分一个ans,然后题目中的限制可以建图跑网络流,然后一看数据范围直接放弃</p>
<p>所以<s>网络流不过就是贪心</s>,因为只有两维我们能很简单的贪一下qwq</p>
<p>对于弱机器人,我们把玩具按照重量排序,然后每个机器人尽可能拿能拿的体积大的,并且机器人从小到大去选择,可以拿堆维护</p>
<p>剩下的玩具如果有小机器人拿不了的就完蛋</p>
<p>看上去很简单,但是要小心我们堆里存的东西一定是当前可以拿的...</p>
<p>吐槽一下神翻译小机器人和弱机器人让我笑好久</p>
<p>以及特判一些情况/xyx</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
const int MAXN = 1e6 + 7;
using namespace std;
int n, A, B, ans = -1;
int a[MAXN], b[MAXN];
struct rec {
	int w, s;
	bool operator&lt;(const rec &amp;x) {
		if(w == x.w)return s &lt; x.s;
		return w &lt; x.w;
	}
} t[MAXN];

priority_queue&lt;int&gt; heap;
inline int chk(int x) {
	int l = 1, j = 1;
	while(!heap.empty())heap.pop();
	for(int i = 1; i &lt;= n; ++i) {
		if(l &gt; A) {
			heap.push(t[i].s);
			continue;
		}
		if(a[l] &gt; t[i].w) {
			heap.push(t[i].s);
		} else {
			while(a[l] &lt;= t[i].w &amp;&amp; l &lt;= A) {
				j = 1;
				while(j &lt;= x &amp;&amp; !heap.empty()) {
					++j;
					heap.pop();
				}
				++l;
			}
			heap.push(t[i].s);
		}
	}
	for(int i = l; i &lt;= A; ++i) {
		j = 1;
		while(j &lt;= x &amp;&amp; !heap.empty()) {
			++j;
			heap.pop();
		}
	}
    //特判有的强机器人能拿光所有的
	for(int i = B; i &gt;= 1; --i) {
		j = 1;
		while(j &lt;= x &amp;&amp; !heap.empty()) {
			++j;
			l = heap.top();
			if(l &gt;= b[i])return 0;
			heap.pop();
		}
		if(heap.empty())break;
	}
	if(!heap.empty())return 0;
	//还有没空的
	return 1;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;n);
	for(int i = 1; i &lt;= A; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	sort(a + 1, a + A + 1);
	for(int i = 1; i &lt;= B; ++i)scanf(&quot;%d&quot;, &amp;b[i]);
	sort(b + 1, b + B + 1);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d%d&quot;, &amp;t[i].w, &amp;t[i].s);
	sort(t + 1, t + n + 1);
	int L = 1, R = n, mid;
	while(L &lt;= R) {
		mid = (L + R) &gt;&gt; 1;
		if(chk(mid)) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3177 [HAOI2015]树上染色]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3177-haoi2015shu-shang-ran-se/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3177-haoi2015shu-shang-ran-se/">
        </link>
        <updated>2020-07-20T14:19:26.000Z</updated>
        <content type="html"><![CDATA[<p><code>“将我大汉军旗插遍大漠草原！”</code></p>
<p><s>封面图小姐姐好色气啊</s></p>
<p>及树上DP的一些总结qwq</p>
<p>首先说说这个题,dp[i][j]表示点i的子树里选了j个黑点目前得到的最大贡献是什么</p>
<p>贡献是指i子树里所有边的贡献,转移时考虑i到v这条边的贡献,两侧共有多少个黑白点乘一下就好啦</p>
<p>然后这样子好像再套个树形背包就解决了!</p>
<p>下面说下树形DP的坑点</p>
<ol>
<li>
<p>转移时,我们枚举要从大到小枚举,第一重循环不这样做会导致完全背包,第二重循环不这样做如果循环内有0(比如这题0个黑点情况)就会导致先更新后又更新</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>z</mi><mo>[</mo><mi>v</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">siz[u]+=siz[v]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span></span></span></span>要之后加,否则一条链就卡掉了</p>
</li>
</ol>
<p>别的好像没啥了</p>
<p>再说下树的直径?</p>
<p>dp[u]表示点u最长链</p>
<p>当发现dp[v]+1&gt;dp[u]时,我们先把这两条链拼起来更新答案再update u</p>
<p>别的没了qwq<s>可能还有什么树上容斥?没做啊</s></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
#define int long long
const int MAXN = 3500;

int n, M, ccnt, N;
int dp[MAXN][MAXN], siz[MAXN];
int home[MAXN * 2], nxt[MAXN * 2], to[MAXN * 2], len[MAXN * 2];

inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	to[ccnt] = y;
	home[x] = ccnt;
	len[ccnt] = z;
}

inline void dfs(int u, int F) {
	siz[u] = 1;
	for(int i = home[u], val; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		for(int j = min(M, siz[u]); j &gt;= 0; --j) {
			for(int k = min(M, siz[v]); k &gt;= 0; --k) {
				val = len[i] * k * (M - k) + len[i] * (siz[v] - k) * (N - siz[v] + k);
				dp[u][j + k] = max(dp[u][j + k], dp[u][j] + dp[v][k] + val);
			}
		}
		siz[u] += siz[v];
	}
	return ;
}


signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;M);
	N = n - M;
	for(int i = 2, x, y, z; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;z);
		ct(x, y, z);
		ct(y, x, z);
	}
	dfs(1, 0);
	printf(&quot;%lld\n&quot;, dp[1][M]);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3523 [POI2011]DYN-Dynamite]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3523-poi2011dyn-dynamite/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3523-poi2011dyn-dynamite/">
        </link>
        <updated>2020-07-17T14:50:58.000Z</updated>
        <content type="html"><![CDATA[<p>读错题题</p>
<p>读错题的题面:</p>
<p>给一棵树,您要选择m个地方放点,满足两两之间最小值最大</p>
<p>相当于二分答案后,每个点之间都要相差x....</p>
<p>然后这个显然可以N^2,但是O(n)?</p>
<p>贪心的想,我们坑定要从深度大的开始选才能最多</p>
<p>好像我们可以放一个点就把一些点缩起来,然后这些点之后一定不能再被选,而其他点一定可选,但是这样我们虽然保证了每次缩的是一个连通块,却不能在合法的时间复杂度里解决....</p>
<p>比如一个大块,然后边上有很多小点,每次我们判断能不能再缩都是O(n)的....QAQ</p>
<p>不过跑不太满</p>
<p>给一棵树,树上有一些关键节点，要求你选m个点，使得关键节点到这些点中距离的最小值的最大值最小，求这个值</p>
<p>也是考虑二分+贪心,那么我们对于二分出的值,我们要满足key点到放置点的距离不能大于了</p>
<p>所以可以从底层开始贪心,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树中最远的key点距离,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树最近的choice点距离</p>
<p>那么如果f_i+g_i&lt;=mid,就可以凑齐,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>变为-inf</p>
<p>否则如果f_i==mid,就要把i设置为新点啦</p>
<p>你说莫名的TLE?我尼玛咋知道啊?</p>
<p>code</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf = 1e7 + 7;
const int MAXN = 6e5 + 7;

int is[MAXN / 2], f[MAXN / 2], g[MAXN / 2], Cnt, n, m, Mid;
int home[MAXN], nxt[MAXN], to[MAXN], ccnt;
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u, int F) {
	f[u] = -inf;
	g[u] = inf;
	if(is[u])f[u] = 0;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		f[u] = max(f[v] + 1, f[u]); //update f
		g[u] = min(g[u], g[v] + 1); //update g
	}
	if(f[u] + g[u] &lt;= Mid) {
		f[u] = -inf;
	}
	if(f[u] == Mid) { //furthst
		++Cnt;
		g[u] = 0;
		f[u] = -inf;
	}
	//	printf(&quot;%d %d %d\n&quot;,u,f[u],g[u]);
	return ;
}

inline int chk() {
	Cnt = 0;
	dfs(1, 0);
	if(f[1] &gt;= 0)Cnt++;
	if(Cnt &lt;= m)return 1;
	else return 0;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;is[i]);
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	int L = 0, R = n, ans;
	while(L &lt;= R) {
		Mid = (L + R) &gt;&gt; 1;
		if(chk()) {
			ans = Mid;
			R = Mid - 1;
		} else L = Mid + 1;
	}

	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3631 [APIO2011]方格染色]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3631-apio2011fang-ge-ran-se/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3631-apio2011fang-ge-ran-se/">
        </link>
        <updated>2020-07-15T14:58:45.000Z</updated>
        <content type="html"><![CDATA[<p>写这题解就离谱...</p>
<p>看上去就好神仙啊,考虑dp怎么解决?不太行,因为只有20pts</p>
<p>于是我们考虑找找规律,能发现相当于四个点如果为红色就是1,为蓝色就是0,那么异或起来值为1</p>
<p>然后这个结论由于异或显然有拓展性</p>
<p>XZU<br>
YWI</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Double superscript at position 4: X^Y^̲Z^W=Z^W^U^I=1
'>X^Y^Z^W=Z^W^U^I=1
</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Double superscript at position 4: X^Y^̲U^I=0!
'>X^Y^U^I=0!
</p>
<p>那么好像我们可以通过类似于平移一块2*2地毯的形式去不断的得到新的这样的关系</p>
<p>然后又找到了新结论:确定第一行第一列就确定了整个矩阵</p>
<p>证明显然吧,自己推一推?</p>
<p>然后相当于我们要计算第一行第一列的填色方案,于是考虑用这个东西找到规律</p>
<blockquote>
<p>如果对于矩阵1,1-&gt;x,y,x,y中有一个为偶数那么异或值为0,否则为1</p>
</blockquote>
<p>这个可以考虑这个矩阵中有多少个2*2得知</p>
<p>然后有了这个结论我们就可以考虑通过枚举1,1的取值来缩点得到几个连通块进而计算出答案</p>
<p>同一连通块的值确地一个就确定了整块,所以就为2^连通块数是答案</p>
<p>然后注意这样我们的给出的(x,y)是用于缩连通块的,而且他的取值决定了这一切是否合法</p>
<p>是否合法的部分可以用带权并查集去解决</p>
<p>你又会发现我们可以通过增加一行0来解决枚举1,1取值,不过没什么必要,只是更好写</p>
<p>而且我们之前结论还要变一下...</p>
<p>有一个坑点是模数是1e9不是质数...</p>
<p>code</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int P = 1e9;
const long long inv2 = (P) / 2;
const int MAXN = 1e6 + 7;
int f[MAXN], op[MAXN], val[MAXN];
inline int getf(int x) {
	return f[x] == x ? x : f[x] = getf(f[x]);
}
inline int merge(int x, int y, int z) {
	int f1 = getf(x);
	int f2 = getf(y);
	if(z) {
		if(f1 == f2)return 0;
		if(f1 == op[f2])return 1;
		f[f1] = op[f2];
		f[op[f1]] = f2;
	} else {
		if(f1 == op[f2])return 0;
		if(f1 == f2)return 1;

		f[f1] = f2;
		f[op[f1]] = op[f2];
	}
	return 1;
}
long long ksm(long long x, long long y) {
	long long ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
int n, m, k;
int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	int qwq = n + m;
	for(int i = 1; i &lt;= qwq; ++i) {
		f[i] = op[i + qwq] = i;
		f[i + qwq] = op[i] = i + qwq;
		//扩展域并查集
	}
	for(int i = 1, x, y, z; i &lt;= k; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
		if(((x + 1 &amp; 1) == 0) &amp;&amp; (y + 1 &amp; 1) == 0)z ^= 1;
		y += n;
		if(!merge(x, y, z)) {
			puts(&quot;0&quot;);
			return 0;
		}
	}
	// puts(&quot;qwq&quot;);
	long long ans = 0;
	int st = getf(1);
	val[op[st]] = 1;
	val[st] = 1;
	for(int i = 2; i &lt;= qwq; ++i) {
		int p = getf(i);
		if(!val[p]) {
			++ans;
			// printf(&quot;%d?\n&quot;, p);
		}
		val[p] = val[op[p]] = 1;
	}
	printf(&quot;%lld\n&quot;, ksm(2, ans));
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3119 [USACO15JAN]Grass Cownoisseur G]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3119-usaco15jangrass-cownoisseur-g/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3119-usaco15jangrass-cownoisseur-g/">
        </link>
        <updated>2020-07-15T14:23:32.000Z</updated>
        <content type="html"><![CDATA[<p>图论练习题</p>
<p>首先我们会发现可以缩下点,因为同一个连通分量里面就可以自由遍历所有的点,然后就可以得到一个拓扑图.....</p>
<p><s>注意是拓扑图不是树我也是服了自己</s></p>
<p>然后考虑在拓扑图上求这个答案,显然我们可以设计dp[i][0/1]表示点i是否已经走过反向边走到1的最长路径</p>
<p>然后显然这个东西要建反图才能处理每个点走到1的....</p>
<p>然后我们就这样建反图跑spfa就好了</p>
<p>显然,二维dp状态我们是可以用分层图的,所以可以再构造一个分层图,以更不错的常数解决此题</p>
<p>代码就用了这个</p>
<p><s>思维难度好小</s></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int MAXN=4e5+7;
int n,m;
int home[MAXN],to[MAXN],nxt[MAXN],ccnt,frm[MAXN];
inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
	frm[ccnt]=x;
}
int first[MAXN],cccnt;
struct rec {
	int to,nxt,vl;
} e[MAXN];
inline void ct2(int x,int y) {
	cccnt++;
	e[cccnt].nxt=first[x];
	first[x]=cccnt;
	e[cccnt].to=y;
}

int st[MAXN],tp,dfn[MAXN],dep,d[MAXN],low[MAXN],nw,num[MAXN],fl[MAXN];
inline void tarjan(int u) {
	fl[u]=1;
	dfn[u]=low[u]=++dep;
	st[++tp]=u;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		} else if(!fl[v])continue;
		low[u]=min(dfn[v],low[u]);
	}
	if(low[u]==dfn[u]) {
		++nw;
		while(1) {
			int v=st[tp];
			fl[v]=0;
			d[v]=nw;
			num[nw]++;
			--tp;
			if(v==u)break;
		}
	}
	return ;
}

int que[MAXN],head,tail,vis[MAXN],ans,dis[MAXN];
inline void spfa() {
	int s=d[1];
	head=tail=1;
	que[tail++]=s;
	while(head&lt;tail) {
		int u=que[head];
		++head;
		vis[u]=0;
//		printf(&quot;%d!%d\n&quot;,u,dis[u]);
		for(int i=first[u]; i; i=e[i].nxt) {
			int v=e[i].to;
//			printf(&quot;%d %d %d %d\n&quot;,v,dis[v],num[v],num[u]);
			if(dis[v]&lt;dis[u]+num[u]) {
				dis[v]=dis[u]+num[u];
				if(!vis[v]) {
					vis[v]=1;
					que[tail++]=v;
				}
			}
		}
//		puts(&quot;--------&quot;);
	}
	for(int i=1; i&lt;=2*nw+1; ++i)ans=max(ans,dis[i]);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;=m; ++i)
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y),ct(x,y);
	for(int i=1; i&lt;=n; ++i) {
		if(!dfn[i])tarjan(i);
	}
//	for(int i=1; i&lt;=n; ++i)printf(&quot;%d %d\n&quot;,i,d[i]);
	for(int i=1; i&lt;=nw; ++i)num[i+nw]=num[i];
	for(int i=1; i&lt;=m; ++i) {
		int u=frm[i];
		int v=to[i];
		if(d[u]==d[v])continue;
//		printf(&quot;%d %d %d %d\n&quot;,u,v,d[u],d[v]);
		ct2(d[v],d[u]);
		ct2(d[u],d[v]+nw);
		ct2(d[v]+nw,d[u]+nw);
	}
	spfa();
	printf(&quot;%d\n&quot;,dis[d[1]+nw]);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5665 划分]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5665-hua-fen/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5665-hua-fen/">
        </link>
        <updated>2020-07-12T14:46:14.000Z</updated>
        <content type="html"><![CDATA[<p><code>&quot;念念不忘,必有回响&quot;</code></p>
<p>CSP原题...</p>
<p>拿到题就很决策单调性优化?</p>
<p>首先我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示的是这一段为i上一段为j的最小代价是什么</p>
<p>转移时枚举之前的某个点,然后再枚举之前那个点上一段,再判断合不合法即可</p>
<p>你会发现这个东西是有决策单调性的,也就是说我们能多分就多分一定更优</p>
<p>所以我们可以考虑用一个一维...dp[i]表示考虑了前i个数的最优代价</p>
<p>那么显然我们可以记录某个状态的转移点啊,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">pre_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i是从哪个状态转移而来的</p>
<p>然后如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[j]-sum[pre[j]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>&lt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i]-sum[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>就可以,然后找到最大的j就是i的转移点...</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">sum_j-sum_{pre[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示单调队列值,我们就可以用单调队列来维护下,队头可以用这个判断</p>
<p>但是我们队尾怎么搞呢?单调队列的性质就是值小而且时间靠后就是更优的</p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">sum_j-sum_{pre[j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>就可以用单调队列来判断这个来删掉队尾QWQ</p>
<p>这样我们用这个就可以直接解决转移点了</p>
<p>之后就可以用__int128卡常了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=4e7+7;
const int MAXM=1e5+7;
const int P=(1&lt;&lt;30);
int n,typ,x,y,z,m;
int a[MAXN],b[MAXN],p[MAXM],l[MAXM],r[MAXM],q[MAXN],pre[MAXN];
ll sum[MAXN];
inline ll d(int x) {
	return sum[x]-sum[pre[x]];
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;typ);
	register int i,j;
	if(typ) {
		scanf(&quot;%d%d%d%d%d%d&quot;,&amp;x,&amp;y,&amp;z,&amp;b[1],&amp;b[2],&amp;m);
		for(i=1; i&lt;=m; ++i)scanf(&quot;%d%d%d&quot;,&amp;p[i],&amp;l[i],&amp;r[i]);
		for(i=3; i&lt;=n; ++i)b[i]=(0ll+1ll*b[i-1]*x+1ll*b[i-2]*y+z)%P;
		for(i=1; i&lt;=m; ++i) {
			for(j=p[i-1]+1; j&lt;=p[i]; ++j) {
				a[j]=(b[j]%(r[i]-l[i]+1))+l[i];
				sum[j]=sum[j-1]+a[j];
			}
		}
	} else {
		for(i=1; i&lt;=n; ++i)scanf(&quot;%d&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
	}
	int h,t;
	q[h=t=0]=0;
	for(i=1; i&lt;=n; ++i) {
		while(h&lt;t&amp;&amp;d(q[h+1])+sum[q[h+1]]&lt;=sum[i])++h;
		pre[i]=q[h];
		while(h&lt;t&amp;&amp;d(q[t])+sum[q[t]]&gt;=d(i)+sum[i])--t;
		q[++t]=i;
	}
	int nw=n;
	__int128 ans=0,tmp=1;
	while(nw) {
		tmp=d(nw);
		tmp*=d(nw);
		ans+=tmp;
		nw=pre[nw];
	}
	int st[50],tp=0;
	while(ans) {
		st[++tp]=ans%10;
		ans/=10;
	}
	while(tp)printf(&quot;%d&quot;,st[tp--]);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3206 [HNOI2010]城市建设]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3206-hnoi2010cheng-shi-jian-she/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3206-hnoi2010cheng-shi-jian-she/">
        </link>
        <updated>2020-07-11T14:47:19.000Z</updated>
        <content type="html"><![CDATA[<p>神仙题</p>
<p>动态带修最小生成树...</p>
<p>做法一</p>
<p>如果我们修改后的代价一定变劣,那么可以倒着做,你会发现如果我们把最小生成树上的边变优了就不会变,如果把其他边变优了就LCT维护一下</p>
<p>然后不能AC,有40QAQAQAQ</p>
<p>做法二</p>
<p>考虑线段树分治...</p>
<p>之前我们的线段树分治只用了个并查集,显得愚蠢,这里我们可以用LCT了.....</p>
<p>考虑回溯,我们只需要把这个线段树点带来的新边删掉,然后把由于这个点引入新边而删掉的边再搞回去,当然我们还是要Kruscal重构树啦</p>
<p>然后?回溯能解决那么线段树分治就做完了...复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的,会T</p>
<p>做法三</p>
<p>CDQ老大爷终于出来了</p>
<p>对时间分治,然而分治的核心在于减小问题规模,咋减小啊?</p>
<p>引入新概念,必选边和无用边</p>
<p>必选边是我们已知到这个时间点,无论再向下搜到哪个时间这些边都一定要加入的</p>
<p>也就是说,我们这些点是<strong>维护连通性</strong>而存在的...</p>
<p>所以我们除开分治区间内其他边全都标成负无穷,再做最小生成树,那么还有分治区间内的边就是必选边啦</p>
<p>那么显然我们就可以把必选边所连接的点缩点</p>
<blockquote>
<p><strong>必选边可以用来减少点数</strong></p>
</blockquote>
<p>而无用边就是在这个时间点里也都用不上了,今后一定也用不上的边</p>
<p>举个经典例子:重边(或自环),<s>当然没有这么简单...</s></p>
<p>那么无用边就是把分治区间内边标为负无穷之后再最小生成树也没有选上的边</p>
<blockquote>
<p><strong>无用边可以用来减少边数</strong></p>
</blockquote>
<p>满足了这两个做最小生成树的时间瓶颈的缩小,CDQ分治的正确性也就成立啦</p>
<p>时间复杂度是优美的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
const int MAXN = 1e5 + 7;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = nc();
		int x = 0, f = 1;
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;
int n, m, q, f[MAXN];
inline int getf(int x) {
	return f[x] == x ? x : getf(f[x]);
}
int siz[MAXN], *sz0;

struct rec {
	int u, v, w;
	inline int merge() {
		int fx = getf(u), fy = getf(v);
		if(fx == fy)return 0;
		if(sz0[fx] &lt; sz0[fy]) {
			f[fx] = fy;
			sz0[fy] += sz0[fx];
		} else {
			f[fy] = fx;
			sz0[fx] += sz0[fy];
		}
		return 1;
	}
} e[MAXN &lt;&lt; 1];

struct qry {
	int id, w;
} l[MAXN];


inline void bck(int x) {
	sz0[x] = siz[x];
	f[x] = x;
}
int in[MAXN], sz[MAXN], SIZ[20][MAXN], Q[20][MAXN], A[20][MAXN &lt;&lt; 1], *a, *p;

inline int cmp(int x, int y) {
	return e[x].w &lt; e[y].w;
}

inline void solve(int dep, int L, int R, int n, int m, int *a, int *p, ll ans) {
	register int i = 0;
	sz0 = SIZ[dep];
	for(i = 1; i &lt;= n; ++i) {
		siz[p[i]] = sz0[p[i]];
	}
	//定这些边一定先选上
	for(i = L; i &lt;= R; ++i) {
		e[l[i].id].merge();
	}
	for(i = 1; i &lt;= m; ++i) {
		if(e[a[i]].merge()) {
			ans += e[a[i]].w;
			a[i] = -a[i];
			//必须选边
		}
	}
	for(i = 1; i &lt;= n; ++i)bck(p[i]);
	int tp = 0;
	for(i = 1; i &lt;= m; ++i) {
		if(a[i] &lt; 0)e[-a[i]].merge();
		else a[++tp] = a[i];
	}
	m = tp;
	tp = 0;
	for(i = 1; i &lt;= n; ++i)
		if(f[p[i]] == p[i]) {
			p[++tp] = p[i];
			siz[p[i]] = sz0[p[i]];
			//必留点
		}
	n = tp;
	tp = 0;
	//钦定这些边一定不选
	for( i = L; i &lt;= R; ++i) {
		in[l[i].id] = 1;
	}
	for(i = 1; i &lt;= m; ++i) {
		if(!in[a[i]] &amp;&amp; !e[a[i]].merge())continue;
		a[++tp] = a[i];
	}
	m = tp;
	for(i = L; i &lt;= R; ++i)in[l[i].id] = 0;
	for(i = 1; i &lt;= n; ++i)bck(p[i]);
	if(n == 1) {
		for(i = L; i &lt;= R; ++i) {
			e[l[i].id].w = l[i].w;
			printf(&quot;%lld\n&quot;, ans);
		}
        //只剩下一个点啦,改掉之后就计算答案吧
		return ;
	}
	if(L == R) {
		int w = e[l[L].id].w = l[L].w;
		for(i = 1; i &lt;= m; ++i)w = min(e[a[i]].w, w);
        //显然这条边还可以康康能不能优化ans
		printf(&quot;%lld\n&quot;, ans + w);
		return ;
	}
	int mid = (L + R) &gt;&gt; 1;
	++dep;
	for( i = 1; i &lt;= n; ++i)SIZ[dep][Q[dep][i] = p[i]] = sz0[p[i]];
	for( i = 1; i &lt;= m; ++i)A[dep][i] = a[i];
	solve(dep, L, mid, n, m, A[dep], Q[dep], ans);
	--dep;
	for( i = 1; i &lt;= n; ++i)
		f[p[i]] = p[i];
	sort(a + 1, a + m + 1, cmp);
	solve(dep, mid + 1, R, n, m, a, p, ans);
    //dep用的少
	return ;
}

int main() {
	n = read();
	m = read();
	q = read();
	for(int i = 1; i &lt;= m; ++i) {
		e[i].u = read();
		e[i].v = read();
		e[i].w = read();
	}
	for(int i = 1; i &lt;= q; ++i) {
		l[i].id = read();
		l[i].w = read();
	}
	for(int i = 1; i &lt;= n; ++i)SIZ[1][i] = 1, Q[1][i] = f[i] = i;
	for(int i = 1; i &lt;= m; ++i)A[1][i] = i;
    //栈,因为比较复杂需要回溯
	sort(A[1] + 1, A[1] + m + 1, cmp);
	solve(1, 1, q, n, m, A[1], Q[1], 0);
	return 0;
}

</code></pre>
<p>最后不得不说,这个真的妙啊...</p>
]]></content>
    </entry>
</feed>