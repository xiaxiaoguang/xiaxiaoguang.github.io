<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-09-19T15:17:37.940Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[P5384 [Cnoi2019]雪松果树]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/">
        </link>
        <updated>2020-09-19T14:51:07.000Z</updated>
        <content type="html"><![CDATA[<p>单独腾一篇博客吧!</p>
<p>关于树上k级祖先和树上k级儿子的绝对快做法</p>
<p>首先枚举下各种做法吧!</p>
<h1 id="树上k级祖先">树上k级祖先</h1>
<h2 id="onlogn预处理"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>预处理</h2>
<ol>
<li>倍增求k级祖先</li>
</ol>
<p>显然,回答一组询问也是严格log的</p>
<p>访问空间太慢而且会被卡空间所以很屑</p>
<ol start="2">
<li>树剖求k级祖先</li>
</ol>
<p>当重链长度大于k,我们k级祖先就在这条链上,对于一个链都记录了直接访问即可...</p>
<p>这个显然不如:</p>
<ol start="3">
<li>长链剖分求k级祖先</li>
</ol>
<p>预处理每个长链数组还是要的</p>
<p>预处理倍增数组还是要的QAQ否则你可以尝试OnO1rmq!</p>
<p>然后你会发现我们如果一步跳到k最高二进制位的祖先后</p>
<p>由于k级祖先的长链长度一定大于这个数的</p>
<p>所以我们可以再从那个点向上或者向下沿着长链跳一步即可</p>
<p>时间复杂度回答起来是O1的</p>
<h2 id="on离线">O(n)离线</h2>
<p>开一个栈记录从根到x dfs经过的所有点</p>
<p>然后我们考虑dfs到x回答x的所有询问即可</p>
<h1 id="k级儿子个数和">k级儿子个数和</h1>
<p>hh</p>
<ol>
<li>线段树合并</li>
</ol>
<p>按照深度为下标建树然后每个位置记录有多少数</p>
<p>线段树合并</p>
<ol start="2">
<li>dsu on tree</li>
</ol>
<p><code>树上启发式合并</code></p>
<p>线段树合并另一种实现形式....</p>
<ol start="3">
<li>离线树状数组</li>
</ol>
<p>相当于数一个区间的某一个深度的个数</p>
<ol start="4">
<li>二分+vector</li>
</ol>
<p>每个深度的点开一个vector全部记录下来,然后在哪个vector处二分即可</p>
<p>当然可以压成所有的一个数组来优化空间</p>
<ol start="5">
<li>长链剖分</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">O(n)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
<p>出现了线性做法!</p>
<p>其实是利用了长链性质优化了dsu on tree</p>
<h1 id="finally">Finally</h1>
<p>my choice : (你谷最快)</p>
<p>可以离线求k级祖先</p>
<p>然后第二个数点我们可以树上差分</p>
<p>因为只求等于某个数的个数啊...</p>
<p>附上你谷rank 1代码</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e6+7;
const int MAXQ=3e6+7;
int n,m;
int ccnt,home[MAXN],id[MAXQ],nxt[MAXQ],to[MAXQ],fst[MAXN],sec[MAXN],dep[MAXN];
int ans[MAXN],st[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}

	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
	int _C=-1,_Z;
	char _sr[1&lt;&lt;21],_z[20];
	inline void Ot() {
		fwrite(_sr,1,_C+1,stdout),_C=-1;
	}
	inline void print(int x) {
		if(_C&gt;1&lt;&lt;20)Ot();
		while(_z[++_Z]=x%10+48,x/=10);
		while(_sr[++_C]=_z[_Z],--_Z);
		_sr[++_C]=' ';
	}
}
using namespace fastIO;

inline void ct(const int &amp;u,const int &amp;v) {
	ccnt++;
	nxt[ccnt]=home[u];
	home[u]=ccnt;
	to[ccnt]=v;
}

inline void ct2(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=fst[u];
	fst[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

inline void ct3(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=sec[u];
	sec[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

int tp,cnt[MAXN];
inline void dfs(int u) {
	st[++tp]=u;
	int v;
	for(int i=fst[u]; i; i=nxt[i]) {
		v=to[i];
		if(v&lt;tp) {
			ct3(st[tp-v],v,id[i]);
		}
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dep[v]=dep[u]+1;
		dfs(v);
	}
	--tp;
}

inline void dfs2(int u) {
	int v;
	cnt[dep[u]]++;
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]-=cnt[dep[u]+v];
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dfs2(v);
	}
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]+=cnt[dep[u]+v]-1;
	}
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	m=read();
	for(int i=2,x; i&lt;=n; ++i) {
		x=read();
		ct(x,i);
	}
	for(int i=1,x,y; i&lt;=m; ++i) {
		x=read();
		y=read();
		ct2(x,y,i);
	}
	dep[1]=1;
	dfs(1);
	dfs2(1);
	for(int i=1; i&lt;=m; ++i)print(ans[i]);
	Ot();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day2/">
        </link>
        <updated>2020-09-18T15:02:37.000Z</updated>
        <content type="html"><![CDATA[<p>哎...人总有写挂的一天吗?</p>
<p>A</p>
<p>傻逼题用map直接模拟即可</p>
<p>最后剩下的那个就是答案</p>
<p>卡双模hash</p>
<p>时间复杂度O(nlogn)</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int bas1 = 12344;
const int bas2 = 67891;
const int P1 = 1e9 + 9;
const int P2 = 1e9 + 3;
const int MAXS = 30;
const int MAXN = 1e5 + 7;
#define pii pair&lt;ll,ll&gt;
#define se second
#define fi first
#define mkp(x,y) make_pair(x,y)
int n;
string s;
map&lt;string, int&gt; mp;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 0; i &lt; n + n - 1; ++i) {
		cin &gt;&gt; s;
		mp[s]++;
	}
	for(auto v : mp) {
		if(v.se &amp; 1)
			cout &lt;&lt; v.fi &lt;&lt; endl;
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>就是base为2i的进制转换</p>
<p>直接模拟即可</p>
<p>这个可以看看代码</p>
<p>注意</p>
<ol>
<li>输出虚数部分的+时要小心,因为可能前面那个数是0啊</li>
<li>特判0</li>
</ol>
<p>而又没法对拍,只能手动....</p>
<p>code:</p>
<pre><code class="language-cpp">/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/
//orzEI!
#include&lt;bits/stdc++.h&gt;
#define ll __int128
using namespace std;
const int MAXN = 100;

ll t1, t2, p1, p2, q1, q2;
char s[MAXN];
int cnt;
ll qwq[MAXN];

namespace fastIO {
	int _C = -1, _Z;
	char _sr[1 &lt;&lt; 21], _z[20];
	inline void Ot() {
		fwrite(_sr, 1, _C + 1, stdout), _C = -1;
	}
	inline void print(ll x) {
		if(_C &gt; 1 &lt;&lt; 20)Ot();
		while(_z[++_Z] = x % 10 + 48, x /= 10);
		while(_sr[++_C] = _z[_Z], --_Z);
	}
	inline void print2(char s) {
		_sr[++_C] = s;
	}
}
using namespace fastIO;

inline void init() {
	qwq[0] = 1;
	for(int i = 1; i &lt; 80; ++i)qwq[i] = qwq[i - 1] * 2;
	return ;
}

inline ll ksm(int x) {
	return qwq[x];
}

inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

int main() {
	scanf(&quot;%s&quot;, s + 1);
	int a = strlen(s + 1);
	if(a == 1 &amp;&amp; s[1] == '0') {
		return puts(&quot;0&quot;), 0;
	}
	init();
	cnt = a + 1;
	for(int i = 1; i &lt;= a; ++i) {
		if(s[i] == '.') {
			cnt = i;
			break;
		}
	}
	//处理整数部分
	for(int i = 1; i &lt; cnt; ++i) {
		int t = (cnt - i) % 4;
		if(t == 1) { //正数
			t1 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if(t == 2) { //正数i
			t2 += ksm(cnt - i - 1) * (s[i] - '0');
		} else if (t == 3) { //负数
			t1 -= ksm(cnt - i - 1) * (s[i] - '0');
		} else {//负数i
			t2 -= ksm(cnt - i - 1) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',t1,t2,i);
	}
	//处理小数部分
	//使用最大的那一部分，然后除除gcd吧QAQ
	for(int i = a; i &gt; cnt; --i) {
		if(s[i] == '0')continue;
		int t = (i - cnt) % 4;
		//		printf(&quot;%d?%d\n&quot;,t,i);
		if((t == 1 || t == 3) &amp;&amp; !q2) {
			q2 = ksm(i - cnt);
		}
		if((t == 2 || t == 0) &amp;&amp; !q1) {
			q1 = ksm(i - cnt);
		}
	}
	if(!q1)q1 = 1;
	if(!q2)q2 = 1;
	//	printf(&quot;%lld %lld\n&quot;,q1,q2);
	for(int i = cnt + 1; i &lt;= a; ++i) {
		int t = (i - cnt) % 4;
		if(t == 1) { //负数i
			p2 -= q2 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 2) { //负数
			p1 -= q1 / ksm(i - cnt) * (s[i] - '0');
		} else if(t == 3) { //正数i
			p2 += q2 / ksm(i - cnt) * (s[i] - '0');
		} else {//正数
			p1 += q1 / ksm(i - cnt) * (s[i] - '0');
		}
		//		printf(&quot;%d %lld %lld %d\n&quot;,s[i]-'0',p1,p2,i);
	}
	//	printf(&quot;%lld %lld %lld %lld %lld %lld\n&quot;,p1,q1,t1,p2,q2,t2);
	p2 += q2 * t2;
	p1 += q1 * t1;
	ll qwq1 = gcd(p1, q1);
	ll qwq2 = gcd(p2, q2);
	p2 /= qwq2;
	q2 /= qwq2;
	p1 /= qwq1;
	q1 /= qwq1;
	if(q1 &lt; 0)p1 = -p1, q1 = -q1; //同时乘-1
	if(q2 &lt; 0)p2 = -p2, q2 = -q2;
	if(p1 != 0) {
		if(p1 &lt; 0) {
			print2('-');
			p1 = -p1;
		}
		if(q1 == 1) {
			print(p1);
		} else {
			print(p1);
			print2('/');
			print(q1);
		}
	}
	if(p2 != 0) {
		if(p2 &lt; 0) {
			print2('-');
			p2 = -p2;
		} else {
			if(p1 != 0)
				print2('+');//死因啊
		}
		if(q2 == 1) {
			if(p2 != 1)
				print(p2);
		} else {
			print(p2);
			print2('/');
			print(q2);
		}
		print2('i');
	}
	Ot();
	return 0;
}

/*

311111111.11111
11111111.11111
111111111111111111111111111111.11111111111111111111111111111111
11111111111111111111111111111111

*/



</code></pre>
<p>哎...这尼玛的都能卡</p>
<p>C</p>
<p>就差一步啊QAQTAT</p>
<p>首先把整个序列变成一个前1后-1的差分的形式后</p>
<p>我们可以发现相邻的1,-1可以用后面的一个1替代,然后相邻的-1,1 可以用后面的一个-1替代....</p>
<p>就做完了....最后数数序列中有数的位置有多少个即可</p>
<pre><code class="language-cpp">
/*
_/_/_/_/    _/_/_/_/_/  _/_/_/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/      _/
_/      _/      _/    _/  _/  _/
_/      _/  _/  _/    _/    _/_/
_/_/_/_/      _/_/     _/_/_/_/_/

_/_/_/_/    _/    _/  _/      _/
_/      _/   _/  _/   _/_/  _/_/
_/      _/    _/_/    _/ _/_/ _/
_/      _/     _/     _/  _/  _/
_/      _/    _/_/    _/      _/
_/      _/   _/  _/   _/      _/
_/_/_/_/    _/    _/  _/      _/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/

_/_/_/_/_/ _/_/_/_/_/ _/_/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/         _/     _/_/_/_/
    _/         _/     _/
    _/         _/     _/
    _/     _/_/_/_/_/ _/_/_/_/_/
*/

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int T;
char a[MAXN];
int b[MAXN];


// inline void solve() {
// 	int n = strlen(a + 1);
// 	int cnt = 0;
// 	ans = 0;
// 	bool flg = 1;
// 	memset(b, 0, sizeof(b));
// 	a[n + 1] = '0';
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(flg &amp;&amp; a[i] == '1') {
// 			//			ans++;
// 			b[i] = 1;
// 			continue;
// 		}
// 		if(flg &amp;&amp; a[i] == '0') {
// 			flg = 0;
// 		}
// 		cnt += a[i] - '0';
// 		if(cnt == 1 &amp;&amp; a[i + 1] == '0') {
// 			//			++ans;
// 			b[i] = 1;
// 			cnt = 0;
// 		} else if(a[i + 1] == '0' &amp;&amp; cnt &gt; 1) {
// 			b[i - cnt] = 1;
// 			b[i] = -1;
// 			cnt = 0;
// 			//			ans+=2;
// 		}
// 	}
// 	//	puts(&quot;qwq&quot;);
// 	for(int i = 1; i &lt;= n; ++i) {
// 		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
// 			b[i + 1] = -1;
// 			b[i] = 0;
// 		}
// 		ans += (b[i] != 0);
// 		//		printf(&quot;%d &quot;,b[i]);

// 	}
// 	//	puts(&quot;&quot;);
// 	//	printf(&quot;%d\n&quot;,ans);
// }

inline void solve2() {
	int n = strlen(a + 1);
	int cnt = 0;
	int ans = 0;
	bool flg = 1;
	memset(b, 0, sizeof(b));
	a[n + 1] = '0';
	for(int i = 1; i &lt;= n; ++i) {
		if(flg &amp;&amp; a[i] == '1') {
			//			ans++;
			b[i] = 1;
			continue;
		}
		if(flg &amp;&amp; a[i] == '0') {
			flg = 0;
		}
		cnt += a[i] - '0';
		if(a[i + 1] == '0' &amp;&amp; cnt &gt;= 1) {
			b[i - cnt] = 1;
			b[i] = -1;
			cnt = 0;
			//			ans+=2;
		}
	}
	//	puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(b[i] == 1 &amp;&amp; b[i + 1] == -1) {
			b[i + 1] = 1;
			b[i] = 0;
		}
		if(b[i] == -1 &amp;&amp; b[i + 1] == 1) {
			b[i + 1] = -1;
			b[i] = 0;
		}
		ans += (b[i] != 0);
		//		printf(&quot;%d &quot;,b[i]);

	}
	//	puts(&quot;&quot;);
	printf(&quot;%d\n&quot;, ans);
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, a + 1);
		// solve();
		solve2();
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>OEIS</p>
<p>i*(i+1)爆int了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 1e6 + 7;
inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}
ll f[MAXN];
int main() {
	int n;
	scanf(&quot;%d&quot;, &amp;n);
	f[1] = 6;
	f[2] = 30;
	for(int i = 3; i &lt;= n; ++i) {
		f[i] = (f[i - 1] * (7 * i - 4) % P * (i + 1) % P + f[i - 2] * 8 % P * (i - 2) % P * (i - 2) % P) % P * ksm(1ll * i * (i + 1) % P, P - 2) % P;
		f[i] %= P;
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR20秋季普转提day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day2/">
        </link>
        <updated>2020-09-15T14:41:19.000Z</updated>
        <content type="html"><![CDATA[<p>zzzz</p>
<p>孙笑川都干了那些坏事?</p>
<p>A</p>
<p>考虑他的转化问题:随机一个n个点的排列,从左往右删除每次删掉一个点之后我们把他的所有祖先都删除掉</p>
<p>那么答案就是这样一个排列的期望删除次数</p>
<p>不难发现可以变成每个数期望删除次数之和</p>
<p>然后就会发现概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>,也就是说我有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">1/siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>的几率在排列中比我儿子都靠前</p>
<p>对上述求和即可</p>
<p>复杂度O(n)</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
const int P = 998244353;
const int MAXN = 1e7 + 7;
int ccnt, home[MAXN], nxt[MAXN], to[MAXN], n, siz[MAXN];
ll ans, A[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;24)
	char buf[BUF_SIZE], *p1 = buf, *pend = buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		char s = nc();
		int x = 0;
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
};
using namespace fastIO;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		dfs(v);
		siz[u] += siz[v];
	}
	ans = (ans + A[siz[u]]) % P;
}

int main() {
	n = read();
	for(int i = 2, x; i &lt;= n; ++i) {
		x = read();
		ct(x, i);
	}
	A[0] = 1;
	A[1] = 1;
	for(int i = 2; i &lt;= n; ++i)		{
		A[i] = (P - (P / i)) * A[P % i] % P;
	}
	dfs(1);
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}



</code></pre>
<p>B</p>
<p>考场上用数据结构写了个很能卡的贪心hhh</p>
<p>但是出题人不一定想的到,数据也很水就过了</p>
<p>正确做法:</p>
<p>n为偶数,随便拿走一个变成奇数的情况</p>
<p>n为奇数,我们按照a排序,然后拿走第一个,</p>
<p>然后剩下的我们两组两组之间拿走b值较大的那个</p>
<p>可以证明我们拿走了最大的那个a就能保证我们剩下一定不会卡</p>
<p>也可以证明因为我们每次都拿了两两较大的b,rank最劣也是倒2,倒4,倒6.....一定大于倒1,倒3....即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">sum/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
int n;
ll S1, S2;
struct rec {
	int x, y, id;
	bool operator&lt;(const rec &amp;w)const {
		return x &gt; w.x;
	}
} a[MAXN];

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].x);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i].y);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1);
	int i = 0;
	printf(&quot;%d\n&quot;, n / 2 + 1);
	if(!(n &amp; 1)) {
		printf(&quot;%d %d &quot;, a[1].id, a[2].id);
		i = 3;
	} else {
		printf(&quot;%d &quot;, a[1].id);
		i = 2;
	}
	for(; i &lt;= n; i += 2) {
		if(a[i].y &gt;= a[i + 1].y) {
			printf(&quot;%d &quot;, a[i].id);
		} else {
			printf(&quot;%d &quot;, a[i + 1].id);
		}
	}
	puts(&quot;&quot;);
	return 0;
}


</code></pre>
<p>C</p>
<p>二分之后限制二变成了子树内至多有一些点能染色</p>
<p>然后我们按照这个range的性质dp去判断可不可行</p>
<p>细节有一堆</p>
<ol>
<li>上界更新的时候注意+1</li>
<li>不要阴间的重设上界范围</li>
<li>注意判断siz和down大小范围,all和up的范围</li>
</ol>
<p>坑死了,因为造不出很强的数据所以过拍不过题调了好久</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 3e5 + 7;
const int inf = 1e9 + 7;
int n, ccnt, home[MAXN], nxt[MAXN], to[MAXN];
int up[MAXN], down[MAXN], A, B, g[MAXN];
int f[MAXN], flg, siz[MAXN], all,rc[MAXN];
inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs1(int u, int F) {
	siz[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		siz[u] += siz[v];
	}
	if(n - siz[u] &lt; up[u]) {
		flg = 0;
	}
	return ;
}

inline void dfs(int u, int F) {
	bool tflg = 0;
	int tmp = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		f[u] += f[v];
		tmp += up[v];
	}
	up[u] = min(tmp, up[u]);
	if(f[u] &lt; down[u])
		f[u] = down[u];
	if(f[u] &gt; siz[u])flg = 0;
	if(f[u] &gt; up[u] || f[u] &gt; all)flg = 0;
	return;
}

inline int chk(int x) {
	all = x;
	for(int i = 1; i &lt;= n; ++i) {
		rc[i] = up[i];
		up[i] = x - up[i];
	}
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	flg = 1;
	dfs(1, 0);
	if(x &gt; up[1]) flg=0;
	for(int i = 1; i &lt;= n; ++i) {
		up[i] = rc[i];
	}
	return flg;
}

inline void solve() {
	int l = 0, r = n + 1, ans = -1, mid = 1;
	for(int i = 1; i &lt;= n; ++i) {
		l = max(l, down[i] + up[i]);
	}
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			ans = mid;
		} else {
			l = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return;
}

signed main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	scanf(&quot;%lld&quot;, &amp;A);
	for(int i = 1, x, y; i &lt;= A; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		down[x] = max(down[x], y);
	}
	scanf(&quot;%lld&quot;, &amp;B);
	for(int i = 1, x, y; i &lt;= B; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		up[x] = max(up[x], y);
	}
	flg = 1;
	dfs1(1, 0);
	if(!flg)return puts(&quot;-1&quot;), 0;
	solve();
	return 0;
}

/*

3
1 3
1 2
1 4
0
3
2 3
3 2
4 2


*/


</code></pre>
<p>D</p>
<p>博弈论+计数dp</p>
<p>非常烦啊</p>
<p>首先预处理两个数组g[0/1][x][i]表示alice/bob在x子树任意总方案(包括染色方案和重儿子选择方案)下保证权值小于等于i的方案数,这个方案可以不均衡</p>
<p>转移:,以alice层为例</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>+</mo><mi>g</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>a</mi><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[1][x][i]=g[1][ls][i]*a[rs]+g[1][rs][i]*a[ls]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p>
<p>a数组是任意选择的方案数(不限制权值)</p>
<p>表示我们Alice在转移的时候可以选择左子树走下去也可以选择右子树走下去</p>
<p>但是我们选择什么就是什么,所以另一颗子树随便选择</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>l</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>∗</mo><mi>g</mi><mo>[</mo><mn>2</mn><mo>]</mo><mo>[</mo><mi>r</mi><mi>s</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[2][x][i]=2*g[2][ls][i]*g[2][rs][i]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p>
<p>表示我们bob在转移时,左右子树必须都能够<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">&lt;=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>否则一切换可能会导致最后走下去权值变大</p>
<p>然后处理f数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{0/1,i,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示alice/bob从上到下走到点x,权值等于i的均衡方案数</p>
<p>转移的时候(假设我们在转移)我们会发现,如果这个正好是他的层,就直接从上面继承下来就好了</p>
<p>否则我们可能要面临对手切换子树的风险,所以要保证另一颗子树走下去权值不会超过i</p>
<p>也就是乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>r</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{0/1,i,rs}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>最后到叶子的时候,你会发现我们这个方案乘起来一定包括了整棵树的决策,所以只需要f数组求个和然后对应相乘了</p>
<p>因为我们再alice层只会让bob去计算另一颗子树的选择方案,而在bob层只会让alice算,那么和你的第二维没关系,之和你这条链长啥样有关</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 998244353;
const int MAXN = 5e3 + 7;
int n, K, ans;
int dep[MAXN], fa[MAXN], ls[MAXN], rs[MAXN];
int g[3][MAXN][MAXN], f[3][MAXN][MAXN], a[MAXN];

inline void add(int &amp;x, ll y) {
	x = x + y &gt; P ? (x + y - P) : (x + y);
}

inline void dfs(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = g[2][u][i] = 1ll * i * K % P;
		}
		a[u] = 1ll * K * K % P;
		return ;
	}
	dep[ls[u]] = dep[u] + 1;
	dep[rs[u]] = dep[u] + 1;
	if(ls[u])dfs(ls[u]);
	if(rs[u])dfs(rs[u]);
	a[u] = 2ll * a[ls[u]] % P * a[rs[u]] % P;
	if(dep[u] &amp; 1) {//奇数,bob
		for(int i = 1; i &lt;= K; ++i) {
			add(g[1][u][i], 1ll * g[1][ls[u]][i] * a[rs[u]] % P + 1ll * g[1][rs[u]][i] * a[ls[u]] % P);
			g[2][u][i] = 2ll * g[2][ls[u]][i] % P * g[2][rs[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			g[1][u][i] = 2ll * g[1][ls[u]][i] % P * g[1][rs[u]][i] % P;
			add(g[2][u][i], 1ll * g[2][ls[u]][i] * a[rs[u]] % P + 1ll * g[2][rs[u]][i] * a[ls[u]] % P);
		}
	}
	return ;
}

inline void dfs2(int u) {
	if(!ls[u] &amp;&amp; !rs[u]) {
		int suma = 0, sumb = 0;
		for(int i = 1; i &lt;= K; ++i) {
			add(suma, f[1][u][i]);
			add(sumb, f[2][u][i]);
		}
		add(ans, 1ll * suma * sumb % P);
		return ;
	}
	if(dep[u] &amp; 1) {
		for(int i = 1; i &lt;= K; ++i) {
			f[1][rs[u]][i] = f[1][ls[u]][i] = f[1][u][i];
			f[2][ls[u]][i] = 1ll * f[2][u][i] * g[2][rs[u]][i] % P;
			f[2][rs[u]][i] = 1ll * f[2][u][i] * g[2][ls[u]][i] % P;
		}
	} else {
		for(int i = 1; i &lt;= K; ++i) {
			f[2][rs[u]][i] = f[2][ls[u]][i] = f[2][u][i];
			f[1][ls[u]][i] = 1ll * f[1][u][i] * g[1][rs[u]][i] % P;
			f[1][rs[u]][i] = 1ll * f[1][u][i] * g[1][ls[u]][i] % P;
		}
	}
	if(ls[u])dfs2(ls[u]);
	if(rs[u])dfs2(rs[u]);
}


int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;K);
	for(int i = 2, x; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;x);
		if(!ls[x])ls[x] = i;
		else rs[x] = i;
	}
	dfs(1);
	for(int i = 1; i &lt;= K; ++i)f[1][1][i] = f[2][1][i] = 1;
	dfs2(1);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020提高组十连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-ti-gao-zu-shi-lian-ce-day3/">
        </link>
        <updated>2020-09-13T08:11:00.000Z</updated>
        <content type="html"><![CDATA[<p>锅是锅了,但是还是有本质很好的题目的...</p>
<p>出锅原因:</p>
<ol>
<li>数据和题面不符</li>
<li>二三题数据随机,导致暴力与正解一样</li>
</ol>
<p>A</p>
<p>有毒</p>
<p>我们会发现,本质上就是求一个图的染色方案,使得异色边数最大....大于m/2</p>
<p>做法很简单,直接dfs实现二分图染色即可,然后如果一遍不行我们randomshuffle存图顺序多dfs几遍</p>
<p>其实有个结论是如果我们二分图染色能做到每个奇环只有一条边是没有用的...</p>
<p>而奇环最小三个边</p>
<p>而且这样我们就有重复的边,如果选了一个包含了多个奇环就能变得很优....</p>
<p>当然这个最优化是NPh的</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
const int MAXM = 2e6 + 7;

int n, m, ccnt, ans;
int home[MAXN], nxt[MAXM], to[MAXM];
int eu[MAXM], ev[MAXM], col[MAXN];

struct rec {
	int u, v;
} e[MAXM];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

inline void dfs(int u) {
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(!col[v]) {
			col[v] = -col[u];
			dfs(v);
		}
	}
}

inline void solve() {
	ccnt = 0;
	memset(home, 0, sizeof(home));
	for(int i = 1; i &lt;= m; ++i) {
		ct(e[i].u, e[i].v);
		ct(e[i].v, e[i].u);
	}
	memset(col, 0, sizeof(col));
	for(int i = 1; i &lt;= n; ++i) {
		if(!col[i]) {
			col[i] = 1;
			dfs(i);
		}
	}
	int cnt = 0;
	for(int i = 1; i &lt;= m; ++i) {
		if(col[e[i].u] != col[e[i].v]) {
			cnt++;
		}
	}
	if(cnt &gt; m / 2) {
		// for(int i = 1; i &lt;= n; ++i) {
		// 	printf(&quot;%d %d\n&quot;, i, col[i]);
		// }
		ans = 1;
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(m == 0) {
		puts(&quot;No&quot;);
		return 0;
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].u, &amp;e[i].v);
	}
	for(int i = 1; i &lt;= 17; ++i) {
		random_shuffle(e + 1, e + m + 1);
		solve();
		if(ans)break;
	}
	if(ans)
		printf(&quot;Yes\n&quot;);
	else printf(&quot;No\n&quot;);
	return 0;
}



</code></pre>
<p>B</p>
<p>不需要构造方案不够妙啊!</p>
<p>但是本质上还是很妙的</p>
<p>我们观察一下,交换更简化的是什么</p>
<p>k=3</p>
<p>000101<br>
-&gt;<br>
101000</p>
<p>可以通过把错位k来把有些1搞过去,操作前提是我们有连续k个空格0</p>
<p>啊!你会发现这个相当于一个翻转操作啊</p>
<p>所以说我们一定可以把连续长为k的一段相同的和然后把一段长度小于等于k的随意位置搞到前面去</p>
<p>所以我们可以先把所有的空白段移动到最后然后看前面那些不是空白段的是不是完全匹配</p>
<p>因为如果不一样我们没法动就暴毙了</p>
<p>做法很简单,我们开一个栈然后把长度等于k的平移消除掉就好了,因为他们相当于没用了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
int T, n, k;
char s1[MAXN], s[MAXN], t1[MAXN], t[MAXN];

inline void init(char *str, char *res, int &amp;x) {
	static int len[MAXN], st[MAXN];
	x = 0;
	st[0] = -1;
	len[0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		++x;
		res[x] = str[i];
		if(str[i] - 'a' == st[x - 1]) {
			len[x] = len[x - 1] + 1;
			st[x] = st[x - 1];
		} else {
			len[x] = 1;
			st[x] = str[i] - 'a';
		}
		while(x &gt; 0 &amp;&amp; len[x] == k) {
			x -= k;
		}
	}
}

inline void solve() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s%s&quot;, s + 1, t + 1);
	int sl = 0, tl = 0;
	init(s, s1, sl);
	init(t, t1, tl);
	bool flg = sl == tl;
	for(int i = 1; i &lt;= tl; ++i) {
		flg &amp;= (s1[i] == t1[i]);
	}
	if(flg)puts(&quot;Yes&quot;);
	else puts(&quot;No&quot;);
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		solve();
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>考虑直接计数</p>
<p>你会发现只有两两之间的差一起取gcd,然后得到的d的所有的因数可能成为答案</p>
<p>然后要判断这个约数可不可以合法,就是能不能过被卡的位置</p>
<p>首先但凡中间的一定不行,因为我们就不能同时过开头和结尾了</p>
<p>判断条件是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>+</mo><mi>k</mi><mi>b</mi><mo>=</mo><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">st+kb==j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>=</mo><mo>=</mo><mi>j</mi><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">st==j(mod b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后两边的就有毒,他会限制我们合法序列的数量....</p>
<p>仔细思考一下应该可</p>
<p>如果两个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">%b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>同余就能限制</p>
<p>那么就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>s</mi><mi>t</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(st-x-1)/x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>暴力实现上面的</p>
<p>复杂度显然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(d(n)m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>std:</p>
<p>复杂度在两个方面,计算合法的序列,判断合法的约数</p>
<p>对于第一步,我们可以lowerbound!</p>
<p>对于第二步,我们可以压所有的质因数指数然后dp,因为一个不合法他的子集就都不合法....</p>
<p>具体的:我们可以用一个dfs类似的东西传导一下我们的限制和前后limit</p>
<p>std:</p>
<p>code:</p>
<pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
#define rep(i, a, b) for (int i = (a); i &lt;= int(b); i++)
#define per(i, a, b) for (int i = (a); i &gt;= int(b); i--)
#define fir first
#define sec second
#define tct template&lt;class type&gt;
using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; P;
const int maxn = 1e5, maxm = 2e6, mod = 1e9 + 7;
int m, c, q[maxn + 5], S[maxn + 5], T, C[maxm + 5];
ll N, K, p[maxn + 5], lst[maxn + 5], nxt[maxn + 5], A[maxm + 5], B[maxm + 5], Num[maxm + 5];

inline void red(int &amp;x) {
	x += x &gt;&gt; 31 &amp; mod;
}
tct inline void cmax(type &amp;x, type y) {
	x &lt; y ? x = y : 0;
}
tct inline void cmin(type &amp;x, type y) {
	x &gt; y ? x = y : 0;
}

struct event {
	int t; ll x;
	bool operator &lt; (const event &amp;o) const {
		return x &lt; o.x;
	}
} ev[maxn + 5];

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

void work(ll N) {
	for (ll i = 2; i * i &lt;= N; i++) if (N % i == 0) {
			p[++c] = i;
			while (N % i == 0) N /= i, q[c]++;
		}
	if (N &gt; 1) p[++c] = N, q[c] = 1;
}

map&lt;ll, int&gt; M;

void dfs(int x, ll y, int z) {
	if (x == c + 1) {//预处理所有约数
		M[y] = z;
		Num[z] = y;
		return;
	}
	z *= q[x] + 1;
	dfs(x + 1, y, z);
	rep(i, 1, q[x]) {
		y *= p[x];
		dfs(x + 1, y, z + i);
	}
}

void dfs0(int x, int z, int y) {
	if (x == c + 1) {//传导
		cmax(A[z], A[z + S[y]]);
		cmin(B[z], B[z + S[y]]);
		C[z] |= C[z + S[y]];
		return;
	}
	z *= q[x] + 1;
	per(i, q[x], 0) {
		if (i == q[x] &amp;&amp; x == y) continue;
		dfs0(x + 1, z + i, y);
	}
}

int main() {
	scanf(&quot;%lld %d&quot;, &amp;N, &amp;m);
	rep(i, 1, m) scanf(&quot;%d %lld&quot;, &amp;ev[i].t, &amp;ev[i].x);
	sort(ev + 1, ev + m + 1);
	ll x = 0, mx = 0, mn = N + 1;
	rep(i, 1, m) if (ev[i].t == 1) {
		if (x) K = gcd(K, ev[i].x - x);
		x = ev[i].x;
		cmax(mx, ev[i].x), cmin(mn, ev[i].x);
	}
	x = 0;
	rep(i, 1, m) {
		if (ev[i].t == 0) lst[i] = x;
		else x = ev[i].x;
	}
	x = N + 1;
	per(i, m, 1) {
		if (ev[i].t == 0) nxt[i] = x;
		else x = ev[i].x;
	}
	work(K);
	dfs(1, 1, 0);
	S[c] = 1;
	per(i, c, 1) S[i - 1] = S[i] * (q[i] + 1);
	T = S[0];
	fill(B, B + T, N + 1);
	rep(i, 1, m) if (ev[i].t == 0) {
		if (!lst[i]) {
			cmax(A[M[gcd(K, nxt[i] - ev[i].x)]], ev[i].x);
		} else if (nxt[i] == N + 1) {
			cmin(B[M[gcd(K, ev[i].x - lst[i])]], ev[i].x);
		} else {
			C[M[gcd(K, gcd(nxt[i] - ev[i].x, ev[i].x - lst[i]))]] = 1;
		}
	}
	rep(i, 1, c) dfs0(1, 0, i);
	int res = 0;
	rep(i, 0, T - 1) if (!C[i]) {
		ll x = (mn - A[i] - 1) / Num[i] + 1;
		ll y = (B[i] - 1 - mx) / Num[i] + 1;
		res = (res + x % mod * y % mod) % mod;
	}
	printf(&quot;%d\n&quot;, res);
	return 0;
}



</code></pre>
<p>数据太水了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
const int P = 1e9 + 7;
int m, T1, T2;
ll N, ans, tot, cnt[MAXN];
struct  rec {
	ll id, x;
	bool operator&lt;(const rec &amp;w)const {
		return x &lt; w.x;
	}
} a[MAXN], b[MAXN], c[MAXN];
int vis[MAXN];


inline ll gcd(ll x, ll y) {
	return y == 0 ? x : gcd(y, x % y);
}

inline void solve(ll x) {
	ll rc1 = 0, rc2 = 0;
	// for(int i = 0; i &lt;= x; ++i)vvis[i] = 0;
	ll tmp1 = 0;
	for(int i = 1; i &lt;= T1; ++i) {
		if(b[i].x &gt; c[1].x) {
			break;
		} else {
			if(b[i].x % x == c[1].x % x)
				tmp1 = b[i].x;
		}
	}
	// printf(&quot;c1 %lld\n&quot;, tmp1);
	rc1 = (c[1].x - tmp1 - 1) / x + 1;
	ll tmp2 = N + 1;
	for(int i = T1; i &gt;= 1; --i) {
		if(b[i].x &lt; c[T2].x) {
			break;
		} else {
			if(b[i].x % x == c[T2].x % x)
				tmp2 = b[i].x;
		}
	}
	// printf(&quot;c2 %lld\n&quot;, tmp2);
	rc2 = (tmp2 - c[T2].x - 1) / x + 1;
	if(tmp2 == N - N % x + c[1].x % x)rc2 += ((N - c[T2].x) % x == 0);
	// printf(&quot;QAQ%lld??%lld %lld %lld %lld\n&quot;, x, rc1, rc2, c[1].x / x + 1, ((N - c[T2].x) / x + 1));
	ans += rc1 * rc2 % P;
	ans %= P;
}

inline void build(ll x) {
	for(ll i = 1; i * i &lt;= x; ++i) {
		if(x % i == 0) {
			cnt[++tot] = i;
			if(i * i != x) {
				cnt[++tot] = x / i;
			}
		}
	}
	sort(cnt + 1, cnt + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		bool flg = 1;
		if(vis[i])continue;
		// printf(&quot;%lld??\n&quot;, cnt[i]);
		for(int k = 1; k &lt;= m; ++k) {
			if((a[k].id == 1) &amp;&amp; ((a[k].x % cnt[i] != c[1].x % cnt[i]) || (c[1].x &gt; a[k].x))) {
				// printf(&quot;%d?\n&quot;, k);
				flg = 0;
			}
			if((a[k].id == 0) &amp;&amp; (a[k].x % cnt[i] == c[1].x % cnt[i]) &amp;&amp; ((c[1].x &lt; a[k].x) &amp;&amp; (c[T2].x &gt; a[k].x))) {
				// printf(&quot;%d!%lld %lld\n&quot;, k, c[1].x, a[k].x);
				flg = 0;
			}
			if(!flg)break;
		}
		if(flg) {
			// printf(&quot;qwq\n&quot;);
			for(int j = i; j &lt;= tot; ++j) {
				if(cnt[j] % cnt[i] == 0 &amp;&amp; !vis[j]) {
					solve(cnt[j]);
					vis[j] = 1;
				}
			}
		}
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%lld%d&quot;, &amp;N, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].id, &amp;a[i].x);
		if(a[i].id == 0) {
			b[++T1] = a[i];
		} else {
			c[++T2] = a[i];
		}
	}
	sort(a + 1, a + m + 1);
	// for(int i = 1; i &lt;= m; ++i) {
	// 	printf(&quot;%lld %lld\n&quot;, a[i].id, a[i].x);
	// }
	sort(b + 1, b + T1 + 1);
	sort(c + 1, c + T2 + 1);
	ll tmp1 = 1;
	tmp1 = c[2].x - c[1].x;
	for(int i = 2; i &lt; T2; ++i) {
		// printf(&quot;%lld %lld\n&quot;, tmp1, c[i + 1].x - c[i].x);
		tmp1 = gcd(tmp1, c[i + 1].x - c[i].x);
		//预处理
	}
	// printf(&quot;%lld\n&quot;, tmp1);
	build(tmp1);//建图
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day1]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day1/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day1/">
        </link>
        <updated>2020-09-12T10:15:37.000Z</updated>
        <content type="html"><![CDATA[<p>水</p>
<p>A</p>
<p>首先按照题意写一个n!的做法</p>
<p>然后你会发现答案是斐波那契</p>
<p>然后矩阵加速递推即可</p>
<p>正确思考:</p>
<p>考虑第n个放什么</p>
<p>如果第n个放n-1,那么第n-1个只能放n</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_n+=f_{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>否则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>随便放</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_n+=f_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=6;
const int B=2;
const int P=998244353;
ll n;
inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
struct rec {
	ll a[MAXN][MAXN];
	inline void init() {
		for(int i=0; i&lt;B; ++i) {
			for(int j=0; j&lt;B; ++j) {
				a[i][j]=0;
			}
		}
	}

} w,tmp;
inline rec mul(rec &amp;x,rec &amp;y) {
	rec c;
	c.init();
	for(int i=0; i&lt;B; ++i) {
		for(int j=0; j&lt;B; ++j) {
			for(int k=0; k&lt;B; ++k) {
				add(c.a[i][j] ,1ll*x.a[k][j] * y.a[i][k]%P);
			}
		}
	}
	return c;
}
inline void ksm() {
	rec ans;
	n-=2;
	ans.init();
	for(int i=0; i&lt;B; ++i)ans.a[i][i]=1;
	while(n) {
		if(n&amp;1)ans=mul(tmp,ans);
		tmp=mul(tmp,tmp);
		n&gt;&gt;=1;
	}
	ans=mul(w,ans);
	printf(&quot;%lld\n&quot;,ans.a[0][0]);
	return ;
}

int main() {
	scanf(&quot;%lld&quot;,&amp;n);
	w.a[0][0]=2;
	w.a[1][0]=1;
	tmp.a[0][0]=1;
	tmp.a[1][0]=1;
	tmp.a[0][1]=1;
	if(n&lt;=2)printf(&quot;%lld\n&quot;,w.a[2-n][0]);
	else ksm();
	return 0;
}



</code></pre>
<p>B</p>
<p>考场写了假代码过了...</p>
<p>首先我们考虑路径可能长什么样子,第一想法</p>
<ol>
<li>两个子树全部走,中间的走一次</li>
</ol>
<p>然而这个可能是错的我们一个子树可能并不这样走</p>
<ol start="2">
<li>两个子树走部分中间走一次</li>
</ol>
<p>然后也是错的我们可能不止两个子树</p>
<ol start="3">
<li>一条链走一次挂了其他一些部分子树</li>
</ol>
<p>好像不能求</p>
<p>但是你会发现那条链只可能是从某个点到根的一部分</p>
<p>所以做完了</p>
<p>假在答案可能大于n,但是数据太水没卡</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=3e5+7;
int n,m;
int ccnt,home[MAXN],nxt[MAXN],to[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

int dep=0,ans;

inline void dfs(int u,int F) {
	if(m&gt;dep) {
		ans=max(ans,(m-dep)/2+dep + 1);
	} else {
		ans=max(ans,m + 1);
	}
	++dep;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dfs(v,u);
	}
	--dep;
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;n; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		ct(y,x);
	}
	if(m&gt;=2*(n-1)-1) {
		printf(&quot;%d\n&quot;,n);
		return 0;
	}
	dfs(1,0);
    ans=min(ans,n);//考场没有
	printf(&quot;%d\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>考虑每种颜色的贡献,然后容斥一下</p>
<p>正难则反的补集转换/cy</p>
<p>我们只需要求出有多少路径没有经过某种关键颜色即可</p>
<p>答案就是把某种颜色去掉之后所有连通块内部算答案</p>
<p>考虑枚举每个点,然后计算他当做连通块最高的那个点的父亲的答案</p>
<p>那么我们只需要这个点的某个儿子减去儿子子树中和他颜色相同的点</p>
<p>显然可以用一个栈维护</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=2e5+7;
const int MAXM=5e5+7;
int ccnt,home[MAXN],nxt[MAXM],to[MAXM],a[MAXN],n,vis[MAXN];
ll rc[MAXN],ans;

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

stack&lt;int&gt; v[MAXN];
int dfnn,dfn[MAXN],siz[MAXN];

inline void dfs(int u,int F) {
	dfn[u]=++dfnn;
	siz[u]=1;
	for(int i=home[u]; i; i=nxt[i]) {
		int T=to[i];
		if(T==F)continue;
		dfs(T,u);
		siz[u]+=siz[T];
		ll tmp=0;
		while(!v[a[u]].empty()) {
			int x=v[a[u]].top();
			if(dfn[x]&gt;=dfn[T] &amp;&amp; dfn[x]&lt;=dfn[T]+siz[T]-1) {
				tmp+=siz[x];
				v[a[u]].pop();
			} else break;
		}
		rc[a[u]]+=1ll*(siz[T]-tmp)*(siz[T]-tmp-1)/2;
	}
	v[a[u]].push(u);
	return ;
}

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		vis[a[i]]=1;
	}
	for(int i=1,x,y; i&lt;n; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		ct(y,x);
	}
	dfs(1,0);
	for(int i=1; i&lt;=n; ++i) {
		if(vis[i]) {
			ll tmp=0;
			while(!v[i].empty()) {
				tmp+=siz[v[i].top()];
				v[i].pop();
			}
			rc[i]+=(siz[1]-tmp)*(siz[1]-tmp-1)/2;
			ans=ans+1ll*n*(n-1)/2-rc[i];
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}



</code></pre>
<p>D</p>
<p>神仙计数题</p>
<p>不难发现我们就是要找到一种合法的区间方案然后分配给每个人</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个容器,有j个区间已经使用,然后有k个区间我们还在延伸</p>
<p>然后转移的时候枚举两维</p>
<p>第一维是考虑我们新开多少个区间,然后他们开始延伸</p>
<p>第二维是考虑我们终结多少个区间,然后把他们乘上一个组合数分配给每个人</p>
<p>这样做复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>难以接受</p>
<p>我们可以发现其实是有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的转移</p>
<p>如果我们能拆开两步,变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>O(n)转移给另一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的点,然后再O(n)转移复杂度就只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>了</p>
<p>做法很简单,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑了前i个容器用了j个区间然后这j个区间还没有确定是不是i为右端点,然后k个延续</p>
<p>那么这样转移的时候我们只需要枚举下f向g转移即可</p>
<ol>
<li>以i为左端点区间l个</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mi>l</mi><mo separator="true">,</mo><mi>k</mi><mo>+</mo><mi>l</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>∗</mo><mi>C</mi><mo>(</mo><mi>m</mi><mo>−</mo><mi>j</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g_{i,j+l,k+l}+=f_{i-1,j,k}*C(m-j,l)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p>
<ol start="2">
<li>以i为右端点区间l个</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mi>l</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>∗</mo><mi>C</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_{i,j,k-l}+=g_{i,j,k}*C(k,l)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751388em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span></span></p>
<p>答案是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{n,m,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>本题有标号的是人,无标号的是区间,所以只需要区间匹配人</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 105;
const int P = 998244353;
int c[MAXN][MAXN];
int f[MAXN][MAXN][MAXN], g[MAXN][MAXN][MAXN];
int n, m, t;

inline void add(int &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);
	c[0][0] = 1;
	for(int i = 1; i &lt;= m; ++i) {
		c[i][0] = 1;
		for(int j = 1; j &lt;= m; ++j) {
			add(c[i][j], c[i - 1][j - 1]);
			add(c[i][j], c[i - 1][j]);
		}
	}
	f[0][0][0] = 1;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 0; j &lt;= m; ++j) {
			for(int k = 0; k &lt;= min(j, t); ++k) {
				for(int l = 0; l &lt;= min(m - j, t); ++l)
					add(g[i][j + l][k + l], 1ll * f[i - 1][j][k] * c[m - j][l] % P);
				for(int l = 0; l &lt;= min(k, t); ++l)
					add(f[i][j][k - l], 1ll * g[i][j][k] * c[k][l] % P);
			}
		}
	}
	printf(&quot;%d\n&quot;, f[n][m][0]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR20秋季普转提day1]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day1/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr20-qiu-ji-pu-zhuan-ti-day1/">
        </link>
        <updated>2020-09-11T15:00:02.000Z</updated>
        <content type="html"><![CDATA[<p>毒瘤T4</p>
<p>A</p>
<p>按照题意进行模拟</p>
<p>但是你会发现我们最后朝向可能有点问题,就是他可能没有朝向一个和开头一样正确的方向</p>
<p>那么我们多做几遍把它转到开头一样,然后把这个当做循环节蹦跶就好了</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e6 + 7;
const ll dx[] = {0, 1, 0, -1};
const ll dy[] = {1, 0, -1, 0};
int n, T, a[MAXN];

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;T);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	ll nx = 0, ny = 0, nd = 0, qwq = 0;
	do {
		for(int i = 1; i &lt;= n; ++i) {
			nx += dx[nd] * a[i];
			ny += dy[nd] * a[i];
			(nd += a[i] % 4) %= 4;
		}
		++qwq;
	} while(nd != 0);
	nx *= T / qwq;
	ny *= T / qwq;
	for(int i = 1; i &lt;= T % qwq; ++i) {
		for(int i = 1; i &lt;= n; ++i) {
			nx += dx[nd] * a[i];
			ny += dy[nd] * a[i];
			(nd += a[i] % 4) %= 4;
		}
	}
	nx = nx &lt; 0 ? -nx : nx;
	ny = ny &lt; 0 ? -ny : ny;
	printf(&quot;%lld\n&quot;, nx + ny);
	return 0;
}



</code></pre>
<p>B</p>
<p>会发现我们可以找出他走的路径是什么样子的</p>
<p>那么就是走到某个餐馆停下然后之前进去过某些餐馆</p>
<p>所以我们枚举到哪个餐馆停下来,然后用一个线段树二分去解决前面最多可以选择多少可行的餐馆即可</p>
<h2 id="注意m是longlong">注意m是longlong!!!</h2>
<p>像m,n这样的数需要开ll我老是忘!</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e5 + 7;
const int MAXT = (1 &lt;&lt; 18) + 1;
int n, vis[MAXN], ans;
struct rec {
	ll x, t;
	int id;
	bool operator&lt;(const rec &amp;w)const {
		return x == w.x ? t &gt; w.t : x &lt; w.x;
	}
} a[MAXN], b[MAXN];
bool cmp(const rec &amp;x, const rec &amp;y) {
	return x.t &lt; y.t;
}
ll m;
struct BIT {
#define lowbit(x) (x&amp;(-x))
	ll tr[MAXT];
	inline void modify(int x, ll V) {
		for(; x &lt; MAXT; x += lowbit(x))tr[x] += V;
	}
	inline ll query2(int x) {
		ll ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
	inline ll query1(ll S) {
		int l = 0, r = MAXT - 1;
		while(l + 1 != r) {
			int mid = (l + r) &gt;&gt; 1;
			if(tr[mid] &gt; S)r = mid;
			else S -= tr[mid], l = mid;
		}
		return l;
	}
} t1, t2;

int main() {
	scanf(&quot;%d%lld&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].x, &amp;a[i].t);
		a[i].id = i;
		b[i] = a[i];
	}
	sort(a + 1, a + n + 1);//枚举数组
	sort(b + 1, b + n + 1, cmp);//下标数组
	for(int i = 1; i &lt;= n; ++i) {
		vis[b[i].id] = i;
	}
	ll S = 0;
	for(int i = 1; i &lt;= n; ++i) {
		S = m - a[i].t - a[i].x;
		if(S &lt; 0)continue;
		int pos = t1.query1(S);
		int res = t2.query2(pos);
		ans = max(res + 1, ans);
		t1.modify(vis[a[i].id], a[i].t);
		t2.modify(vis[a[i].id], 1);
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>结论:只要我们选择的数弹出次数总和少于n就一定可行</p>
<p>证明....好像很显然...</p>
<p>因为我们首先一定存在第一个可以弹出的,否则我们个数一定大于n</p>
<p>然后把第一个弹出,我们第一个之前的那个也一定能弹出,就这样把能弹的弹下去即可</p>
<p>问题变成背包</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
ll n, L[MAXN], D[MAXN], f[MAXN];

int main() {
	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;L[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;D[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = n; j &gt;= L[i]; --j) {
			f[j] = max(f[j], f[j - L[i]] + D[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}


</code></pre>
<p>D</p>
<p>唯一有质量的一道题/se</p>
<p>思想是我们只维护可能成为答案的,然后就能做到分离限制</p>
<p>首先我们第i个只能选i个的限制,可以考虑用一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">mulitiset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>维护前i大的,再用一个维护所有的,然后我们插入一个数分类讨论我们这个前i大的满没满,如果满了,我们看他能不能替代最小的那个,如果可以我们就把最小的那个弹出换成他</p>
<p>然后删除也是一样,如果我们能够删除的这个数在bst集合里,我们就看能不能从整体集合中拿出一个填入bst集合</p>
<p>具体分类讨论可以看看代码,非常非常的细节毒瘤</p>
<p>然后我们就能知道哪些元素是最优的了</p>
<p>问题变成了带修前k大的和,平衡树解决</p>
<p>当然好像也可以线段树二分实现这个qwq不过我喜欢显然</p>
<p><s>wyz的线段树二分还比我慢!</s></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 3e5 + 7;
const int MAXT = 6e5 + 7;
int siz[MAXT], rs[MAXT], ls[MAXT], rnd[MAXT];
ll val[MAXN], sum[MAXN];
int T, cnt, n, x, y, z, p, a, root;

inline int read() {
	int x = 0, f = 1;
	char c = getchar();
	for(; !isdigit(c); c = getchar())if(c == '-')f = -1;
	for(; isdigit(c); c = getchar())x = x * 10 + c - '0';
	return x * f;
}

inline void update(int x) {
	siz[x] = 1 + siz[ls[x]] + siz[rs[x]];
	sum[x] = sum[ls[x]] + sum[rs[x]] + val[x];
}

inline int nw_(int x) {
	siz[++cnt] = 1;
	val[cnt] = x;
	sum[cnt] = x;
	rnd[cnt] = rand();
	return cnt;
}

inline int merge(int A, int B) {
	if(!A || !B)return A + B;
	if(rnd[A] &lt; rnd[B]) {
		rs[A] = merge(rs[A], B);
		update(A);
		return A;
	} else {
		ls[B] = merge(A, ls[B]);
		update(B);
		return B;
	}
}

inline void split(int now, int k, int &amp;x, int &amp;y) {
	if(!now)x = y = 0;
	else {
		if(val[now] &lt;= k) {
			x = now;
			split(rs[now], k, rs[now], y);
		} else {
			y = now;
			split(ls[now], k, x, ls[now]);
		}
		update(now);
	}
}

inline ll ksum(int nw, int k) {
	ll ret = 0;
	if(k &gt;= siz[nw])return sum[nw];
	while(nw) {
		if(k &lt;= siz[rs[nw]]) {
			nw = rs[nw];
		} else if(k == siz[rs[nw]] + 1) {
			return ret + val[nw] + sum[rs[nw]];
		} else {
			k -= siz[rs[nw]] + 1;
			ret += sum[rs[nw]] + val[nw];
			nw = ls[nw];
		}
	}
	return ret;
}

char s[20];

inline void del(ll a) {
	split(root, a, x, z);
	split(x, a - 1, x, y);
	y = merge(ls[y], rs[y]);
	root = merge(merge(x, y), z);
}

inline void ins(ll a) {
	split(root, a, x, y);
	root = merge(merge(x, nw_(a)), y);
}

multiset&lt;int&gt; hve[MAXN], bst[MAXN];

int main() {
	srand((unsigned)time(NULL));
	n = read();
	T = read();
	int t, x;
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, s);
		scanf(&quot;%d%d&quot;, &amp;t, &amp;x);
		if(s[0] == 'B') {//借入
			//考虑我们顶替掉一个,然后对应点删
			if((int)bst[t].size() &lt; t) {
				bst[t].insert(x);
				ins(x);
			} else {
				auto u = (bst[t].begin());
				if(*u &lt; x) {
					del(*u);
					bst[t].erase(u);
					bst[t].insert(x);
					ins(x);
				}
			}
			hve[t].insert(x);
		} else {//删除QAQ
			auto u = hve[t].find(x);
			hve[t].erase(u);
			if((int)bst[t].size() &lt; t || (int)hve[t].size() == t - 1) {
				auto u = bst[t].find(x);
				del(*u);
				bst[t].erase(u);
			} else {
				auto y = (bst[t].begin());
				if(*y &lt;= x) {//x在bst里面
					auto z = *(--hve[t].lower_bound(*y));
					auto u = (bst[t].find(x));
					del(*u);
					bst[t].erase(u);
					bst[t].insert(z);
					ins(z);
				}
			}
		}
		printf(&quot;%lld\n&quot;, ksum(root, n));
	}
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3648 [APIO2014]序列分割]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3648-apio2014xu-lie-fen-ge/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3648-apio2014xu-lie-fen-ge/">
        </link>
        <updated>2020-09-09T14:45:37.000Z</updated>
        <content type="html"><![CDATA[<p>卡精度,你知道什么叫前人的经验的重要性吗?</p>
<p>首先我们考虑只砍第一刀,所以可以写出转移方程</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">f_i=min_{j&lt;i} {g_j + sum_j*(sum_i-sum_j)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p>
<p>然后我们能有:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi></mrow></msub><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">f_i=min_{j&lt;i} {g_j -sum_j*sum_j + sum_j*sum_i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>显然可以斜率优化</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>g</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo>∗</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y=g_j -sum_j*sum_j,x=sum_j,k_i=sum_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751388em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>最小化截距,所以维护的是上凸壳</p>
<p>然后你会发现这个y是小于0的,也就是说我们对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x&lt;y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>e</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>−</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>y</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">gety(x)-gety(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>大于0,但是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>x</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">sum_x-sum_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>小于0</p>
<p>那么我们可以把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">sum_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>*-1来去截取,也可以把斜率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">*-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>来适配</p>
<p>但是正确性就没法用凸包想象了</p>
<p>另外一种思路是直接像推决策单调性一样找出更优的条件,好像也很适配,可以试试</p>
<h1 id="细节">细节</h1>
<p>本题核心开始:</p>
<ol>
<li>卡精度,也就是说我们如果强制转换多了就人没了</li>
</ol>
<p>你可能会说叉积判</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是非负整数,我们可以存在x相同的两个点</li>
</ol>
<p>叉积判没了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
#define db double
using namespace std;
const int MAXN = 1e5 + 7;
int n, m, k;
int a[MAXN], bck[205][MAXN];
ll f[MAXN], sum[MAXN], g[MAXN];

inline ll gety(int x) {
	return 1ll * g[x] - sum[x] * sum[x];
}

inline ll getk(int x) {
	return sum[x];
}

inline ll getx(int x) {
	return sum[x];
}

int hd, tl, que[MAXN];

inline db getslope(int i, int j) {
	if(getx(j) == getx(i))return -1e19;
	return (gety(i) - gety(j)) / ((db)getx(j) - getx(i));
}

inline ll calc(int j, int i) {
	return gety(j) + sum[j] * sum[i];
}

inline void solve() {
	hd = 1;
	tl = 0;
	que[1] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		//		printf(&quot;%d %d %lf %lld\n&quot;,que[hd],que[hd+1],getslope(que[hd+1],que[hd]),getk(i));
		while(hd &lt; tl &amp;&amp; getslope(que[hd + 1], que[hd]) &lt;= getk(i)) {
			++hd;
		}
		//		printf(&quot;%d %d %d %d\n&quot;,i,que[hd],hd,tl);
		f[i] = calc(que[hd], i);
		bck[k][i] = que[hd];
		//		printf(&quot;%lld?\n&quot;,f[i]);
		while(hd &lt; tl &amp;&amp; getslope(que[tl - 1], que[tl]) &gt;= getslope(que[tl], i))
			tl--;
		que[++tl] = i;
	}
	return ;
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for(k = 1; k &lt;= m; ++k) {
		for(int i = 1; i &lt;= n; ++i) {
			f[i] = 0;
		}
		solve();
		//		puts(&quot;\nqwq\n&quot;);
		for(int i = 1; i &lt;= n; ++i) {
			g[i] = f[i];
		}
	}
	printf(&quot;%lld\n&quot;, g[n]);
	int nw = n;
	for(int i = m; i &gt;= 1; --i) {
		printf(&quot;%d &quot;, bck[i][nw]);
		nw = bck[i][nw];
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3336 [ZJOI2013]话旧]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3336-zjoi2013hua-jiu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3336-zjoi2013hua-jiu/">
        </link>
        <updated>2020-09-06T13:56:09.000Z</updated>
        <content type="html"><![CDATA[<p>牛逼啊</p>
<p>分类讨论神题</p>
<p>首先我们明白极小值是什么,人言就是比周围的取值都小的一个函数值</p>
<p>然后我们考虑图形,显然是几个起起伏伏的三角形,但是但凡降就一定能降到0</p>
<p>有个这个关键信息,我们把所有点按照x坐标排序后就可以开始dp了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0/1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mord mtight">/</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示到点i,点i之前的线段斜率是-1/1,</p>
<p>转移.....分类讨论大赛!</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1,y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为上一个点的坐标,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2,y_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为这个点的坐标</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mo>=</mo><mo>(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2-x_1)==(y_2-y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>说明我们一定是上升的两个点,而且中间全部都是上升段</p>
<p>那么我们只有一种连接方式,就是形成三角形的左侧上升段</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,1}+=f_{i-1,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为0,我们点i-1可以作为转折点,方案数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">+f_{i-1,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord">+</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo>)</mo><mo>=</mo><mo>=</mo><mo>(</mo><msub><mi>y</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(x_2-x_1)==(y_1-y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>说明我们一定是下降的两个点,而且中间全部都是下降段</p>
<p>那么我们有两种连接方式,就是第一种在i-1处达到极大值,第二种在i-1处处于右侧下降段</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}+=f_{i-1,1}+f_{i-1,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>接下来分类讨论比较鬼畜,为了方便设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>=</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">len=x_2-x_1-y_2-y_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>其实际意义就是如果我们能达到y=0,达到y=0最长的距离有多少</p>
<ol start="3">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">len&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ol>
<p>即我们达到不到0点,但是由于前两种情况都判过了,所以我们这个能够先下降后上升</p>
<p>中间可能有上转折点,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}+=f_{i-1,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y_1==0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,还是可能i-1为转折点,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}+=f_{i-1,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<ol start="4">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">len=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ol>
<p>即我们能达到0点,但是不能再多走没用的步了QAQ</p>
<p>上转折下转折点都有可能</p>
<p>下转折点则一定是上升的,但是前者可能上升也可能下降啊</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,1}+=f_{i-1,1}+f_{i-1,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>上转折点一定是下降的,且前者只能上升</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}+=f_{i-1,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<ol start="5">
<li>len&gt;0</li>
</ol>
<p>唯一有可能使答案变大的情况</p>
<p>首先我们把len用上下起伏的锯齿代替,即</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;_&#039; at position 1: _̲___ -&gt; &#039;.&#039;.&#039;.&#039;.…'>____ -&gt; &#039;.&#039;.&#039;.&#039;.&#039;.</span></p>
<p>然后里面的边缘有len/2-1个</p>
<p>但是两侧边缘还可能有,左侧能多出一个,右侧也多出一个</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>我们必须拉开右侧锯齿,否则一定会导致是上升段</p>
<p>左侧锯齿,当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i-1,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的时候,i-1可以成为转折点,则我们可以选择拉开左侧锯齿</p>
<p>否则我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i-1,0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>不可能拉开左侧锯齿,否则i-1处极小值不为0</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>....好像必须不能拉开右侧锯齿,然后当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mn>2</mn><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y2==0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时暴毙不能上升</p>
<p>最大值第二问随便解解方程就有了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int P = 19940417;
const int MAXN = 1e6 + 7;
int n, m, T, ans;
ll f[MAXN][2];
struct rec {
	int x, y;
	bool operator&lt;(const rec &amp;w)const {
		return x == w.x ? y &lt; w.y : x &lt; w.x;
	}
} a[MAXN], b[MAXN];

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	a[1].x = a[1].y = 0;
	a[m + 2].x = n;
	a[m + 2].y = 0;
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;a[i + 1].x, &amp;a[i + 1].y);
	}
	m += 2;
	int qwq = 0;
	sort(a + 1, a + m + 1);
	for(int i = 1; i &lt;= m; ++i) {
		if(i == 1 || a[i].x != a[i - 1].x || a[i].y != a[i - 1].y) {
			b[++qwq] = a[i];
		}
	}
	m = qwq;
	for(int i = 1; i &lt;= qwq; ++i) {
		a[i] = b[i];
	}
	f[1][0] = 1;//初始化,从1,0是1
	for(int i = 2; i &lt;= m; ++i) {
		int x2 = a[i].x;
		int x1 = a[i - 1].x;
		int y2 = a[i].y;
		int y1 = a[i - 1].y;
		int L = a[i].x - a[i - 1].x - a[i].y - a[i - 1].y;
		ans = max(ans, a[i].y);
		if(x2 - x1 == y2 - y1) {//f[i][1] update
			add(f[i][1], f[i - 1][1]);
			if(y1 == 0)add(f[i][1], f[i - 1][0]);//if 为0,说明我们可以起一个三角形
		} else if(x2 - x1 == y1 - y2) {//f[i][0] update
			add(f[i][0], f[i - 1][0]);
			add(f[i][0], f[i - 1][1]);
			//少讨论拐点为i-1的情况
		} else if(L &lt; 0) {//空中转折,我们发现不能从下面走,否则极小值不为0
			//那么我们从上面走,满足f[i][0],f[i-1][1]
			//但是=0的可能有意思
			add(f[i][0], f[i - 1][1]);
			if(y1 == 0)add(f[i][0], f[i - 1][0]);
		} else if(L == 0) {
			//第一种走法从下面走可以,从上面走也可以
			//对应0,1 ,1,1, 1,0
			//如果是0,我们考虑都不考虑qwq
			add(f[i][0], f[i - 1][1]);
			if(y1 == 0)add(f[i][0], f[i - 1][0]);
			add(f[i][1], f[i - 1][0]);
			add(f[i][1], f[i - 1][1]);
			//注意这个拐点为i-1的情况...少讨论了
		} else if(L &gt; 0) {//落地连接,我们在地面上可以起很多小三角形qwq
			//考虑拉平锯齿
			//如果我们上一个是上升的,则可以拉平的锯齿多一个
			//否则如果上一个是下降的,我们不能拉平边缘那个
			//如果我们这个是下升的,则我们必须拉平右边缘的锯齿?
			//否则我们这个是下降的,我们必须不拉平右边缘的锯齿
			ll a = ksm(2, L / 2 - 1);
			ll b = ksm(2, L / 2);
			add(f[i][0], f[i - 1][1] * b % P);
			add(f[i][0], f[i - 1][0] * a % P);
			if(y2 != 0) {
				add(f[i][1], f[i - 1][1] * b % P);
				add(f[i][1], f[i - 1][0] * a % P);
			}
		}
		if(f[i][0] || y2 == 0)
			ans = max(ans, y2 + (x2 - x1 - y2 + y1) / 2);
		//画画图即可
	}
	printf(&quot;%lld %d\n&quot;, f[m][0], ans);
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020提高组十连测day2]]></title>
        <id>https://xiaxiaoguang.github.io/post/2020-ti-gao-zu-shi-lian-ce-day2/</id>
        <link href="https://xiaxiaoguang.github.io/post/2020-ti-gao-zu-shi-lian-ce-day2/">
        </link>
        <updated>2020-09-06T07:53:53.000Z</updated>
        <content type="html"><![CDATA[<p>B</p>
<p>按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>&lt;</mo><mi>b</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a+b&lt;b+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>排序即可,时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>A</p>
<p>弱者做法:</p>
<p>直接贪心是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>的,然后我们分析下复杂度瓶颈在哪</p>
<ol>
<li>全局加数量</li>
<li>查询x要多少种才能凑齐</li>
</ol>
<p>解决这个的显然做法就是分块啊</p>
<p>把所有操作排序后分成根号m段</p>
<p>全局加变成打标记</p>
<p>然后考虑对于第i块,如果我们完全取走都无法凑齐这个月的,就全部取走</p>
<p>反之,我们重构这个块</p>
<p>需要维护的标记:</p>
<ol>
<li>加标记</li>
<li>清空标记</li>
</ol>
<p>额外数组</p>
<ol>
<li>每一块,每个月数量净收入</li>
<li>每一块,每个月价钱净收入</li>
</ol>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=2e5+7;
int n,m;
ll c[MAXN];
struct rec {
	ll x,y;
	bool operator&lt;(const rec &amp;w)const {
		return x&lt;w.x;
	}
} a[MAXN],b[MAXN];
ll sumn[MAXN],sumc[MAXN],addn[MAXN],sad[MAXN],sct[MAXN],qk[MAXN],hve[MAXN];
ll ans;
int sz,L[MAXN],R[MAXN],bel[MAXN],tot;
inline void init() {
	sz=sqrt(m);
	tot=1;
	L[tot]=1;
	for(int i=1; i&lt;=m; ++i) {
		if(i%sz==0) {
			R[tot]=i-1;
			++tot;
			L[tot]=i;
		}
		bel[i]=tot;
	}
	R[tot]=m;
	for(int i=1; i&lt;=m; ++i) {
		sad[bel[i]]+=a[i].y;
		sct[bel[i]]+=a[i].x * a[i].y;
	}

	return ;
}

inline void solve(int B,int q) {
	for(int i=L[B]; i&lt;=R[B]; ++i) { //下穿标记
		if(qk[B]!=-1) {
			hve[i]=0;
		}
		hve[i]+=addn[B] * a[i].y;
	}
	qk[B]=-1;
	addn[B]=0;
	for(int i=L[B]; i&lt;=R[B]; ++i) {
		if(hve[i]&lt;q) {
			q-=hve[i];
			ans+=hve[i]*a[i].x;
			hve[i]=0;
		} else {
			hve[i]-=q;
			ans+=q*a[i].x;
			break;
		}
	}
	sumn[B]=0;
	sumc[B]=0;
	for(int i=L[B]; i&lt;=R[B]; ++i) {
		sumn[B]+=hve[i];
		sumc[B]+=hve[i]*a[i].x;
	}
	return ;
}


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0,f=1;
		char s=nc();
		for(; !isdigit(s); s=nc())if(s=='-')f=-1;
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x*f;
	}
}
using namespace fastIO;

int main() {
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1; i&lt;=n; ++i) {
		c[i]=read();
	}
	for(int i=1; i&lt;=m; ++i) {
		a[i].x=read();
		a[i].y=read();
		if(a[i].y==-1)a[i].y=1e7;
	}
	sort(a+1,a+m+1);
	int qwq=0;
	for(int i=1; i&lt;=m; ++i) {
		if(a[i].x!=a[i-1].x) {
			b[++qwq]=a[i];
		} else {
			b[qwq].y+=a[i].y;
		}
	}
	m=qwq;
	for(int i=1; i&lt;=m; ++i) {
		a[i]=b[i];
	}
	init();
	//分根号段
	//然后直接跳
	for(int u=1; u&lt;=n; ++u) {
		for(int i=1; i&lt;=tot; ++i) {
			sumn[i]+=sad[i];
			sumc[i]+=sct[i];
			addn[i]++;//多一天
		}
		for(int i=1; i&lt;=tot; ++i) {
			if(sumn[i] &gt; c[u]) {
				solve(i,c[u]);//暴力改块内
				break;
			} else {
				c[u]-=sumn[i];
				ans+=sumc[i];
				sumn[i]=0;
				sumc[i]=0;
				addn[i]=0;
				qk[i]=u;
				//第u天这个块卖空了
			}
		}
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>好难难难难啊/kk</p>
<p>首先我们发现原题的眼睛,做过一个也是可以轮流开大招取走一些数然后nim游戏的题</p>
<p>这个是那个题的完全升级版,我们要把每个石子复制两堆,但是一次可以选择1或2个</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>−</mo><mi>n</mi><mi>i</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">3-nim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span></span></span></span>,也就是每个二进制位下<span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">%3==0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">x_1....x_n \in (0,1,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>b</mi><mi>i</mi><mi>t</mi></mrow></munder><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><mo>∗</mo><mi>a</mi><msub><mi>i</mi><mrow><mi>b</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>=</mo><mn>0</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\sum_{bit} \sum x_i*ai_{bit}=0 (mod 3)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3521180000000004em;vertical-align:-1.3021129999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000005em;"><span style="top:-1.847887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021129999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p>
<p>那么我们可以发现其实就是找到膜3意义下权值最大的线性无关组</p>
<p>这个和之前那个题就很相像了</p>
<p>可以考虑遍历线性基的每个位置,如果某个位置在线性基是空的,我们就直接加入</p>
<p>否则把当前向量和线性基中这个位置对应的向量中攻击力小的那个拿出来继续消元</p>
<p>显然是题解,我们想想怎么找QAQ</p>
<p>代码告诉我:我们对于每个二进制位维护一个是1还是2的b数组线性基</p>
<p>然后我们用一个三进制异或的东西,找到一个可行的答案</p>
<p>解释一下三进制异或吧:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>+</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2+2||1+0||0+1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>2</mn><mo>+</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1+1||2+0||0+2 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>然后QAQ....</p>
<p>好像本质上是我们考虑三进制的每一位他们都可以被两个二进制位表示一下</p>
<p>比如11-&gt;1,1,10-&gt;1,0</p>
<p>然后我们开两个二进制数,第一个表示我们第一位三进制位意义下,第二个表示我们第二个三进制位</p>
<p>然后显然一开始我们如果只用第一个三进制位就能得到纯二进制位的答案</p>
<p>然后自己抿了抿,完全不会了</p>
<p>update in 9/6/16:48</p>
<p>抓本质说话:我们本质上是维护一个三进制线性基</p>
<p>那么我们首先开一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_1,b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>数组,表示三进制下我哪些位是1哪些位是2</p>
<p>然后我们考虑正常的线性基过程:如果这一位有数我们就要异或一下</p>
<p>考虑三进制异或分开放在哪些位是1哪些位是2的数意义下面</p>
<p>对于二进制都是2的,我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>2</mn><mo>+</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1+1||2+0||0+2 = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>对于二进制都为1的,我们有<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>+</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2+2||1+0||0+1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>其实就是代码中两个长的位运算式子</p>
<p>这样我们就维护了整个三进制操作的线性基,就可以套用之前那个nim游戏题的思想结束整个题了</p>
<p>注意代码里有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>w</mi><mi>a</mi><mi>p</mi><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">swap(p,q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>你考虑我们线性操作包括取反向量(*-1)所以这个是可以的</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>思考本题+读代码时间 : <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>h</mi><mn>30</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">2h30min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">h</span><span class="mord">3</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span></p>
<p><s>浪费时间....</s></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
#define se second
#define fi first
#define ll long long
#define pii pair&lt;int,int&gt;
#define swap(x,y) (x^=y^=x^=y)
using namespace std;
const int P = 1e9 + 7;
int n;
ll b0[60], b1[60], b2[60], ans;

void ins(ll x, ll y, int z) {
	for(ll i = 59; i &gt;= 0; --i) {
		if(x &gt;&gt; i &amp; 1 || y &gt;&gt; i &amp; 1) {
			if(!b1[i] &amp;&amp; !b2[i]) {
				b1[i] = x;
				b2[i] = y;
				b0[i] = z;
				return ;
			}
			if(z &gt; b0[i])
				swap(x, b1[i]), swap(y, b2[i]), swap(z, b0[i]);
			ll p = b1[i], q = b2[i];
			if((y ^ q) &gt;&gt; i &amp; 1)swap(p, q);
            //对齐
			ll u = (x &amp; ~(p | q)) | (y &amp; p) | (~(x | y) &amp; q);
			ll v = (y &amp; ~(p | q)) | (~(x | y) &amp; p) | (x &amp; q);
			//得到三进制异或之后的b_1,b_2
			//然后新的u,v就是对应下一次的....
			x = u, y = v;
		}
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		ll x;
		int y;
		scanf(&quot;%lld %d&quot;, &amp;x, &amp;y);
		x ^= ans;
		ins(x, 0, y);
		ans = 0;
		for(int i = 0; i &lt; 60; ++i)
			ans += b0[i];
		printf(&quot;%lld\n&quot;, ans);
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2300 合并神犇]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2300-he-bing-shen-ben/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2300-he-bing-shen-ben/">
        </link>
        <updated>2020-09-05T15:01:50.000Z</updated>
        <content type="html"><![CDATA[<p>CSP D2T2</p>
<p>这...好神似啊QAQ?</p>
<p>我们要最少的操作次数使得合并后的序列单调不降</p>
<p>如果写出一个dp,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑前i个数最后一刀砍在j处的最小代价是什么,然后直接dp即可</p>
<p>所以可以发现这个东西具有决策单调性....等等是贪心吧?</p>
<p>你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数我们最小分割次数下最后一段最小是多少</p>
<p>然后f_i转移的时候只需要枚举到前面的一个j满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>j</mi></msub><mo>&lt;</mo><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">g_j&lt;=sum_i-sum_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>即可</p>
<p>所以就做完了,直接写break优化就能2e5飞快了!</p>
<p>期望复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,实际复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=3e5+7;
ll f[MAXN],sum[MAXN],pre[MAXN];
int a[MAXN],n;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
//		printf(&quot;%lld?\n&quot;,sum[i]);
	}
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0]=0;
	for(int i=1; i&lt;=n; ++i) {
		for(int j=i-1; j&gt;=0; --j) {
			if(pre[j]&lt;=sum[i]-sum[j] &amp;&amp; (f[j]+i-j-1&lt;f[i])) {
				f[i]=f[j]+i-j-1;
				pre[i]=sum[i]-sum[j];
				break;
			}
		}
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}


</code></pre>
<p>还有一题,一样的break剪枝,过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span><br>
P4954 [USACO09OPEN]Tower of Hay G</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=3e5+7;
ll f[MAXN],sum[MAXN],pre[MAXN];
int a[MAXN],n;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;a[i]);
//		printf(&quot;%lld?\n&quot;,sum[i]);
	}
	reverse(a+1,a+n+1);
	for(int i=1; i&lt;=n; ++i) {
		sum[i]=sum[i-1]+a[i];
	}
	memset(f,0,sizeof(f));
	f[0]=0;
	for(int i=1; i&lt;=n; ++i) {
		for(int j=i-1; j&gt;=0; --j) {
			if(pre[j]&lt;=sum[i]-sum[j] &amp;&amp; (f[j]+1&gt;f[i])) {
				f[i]=f[j]+1;
				pre[i]=sum[i]-sum[j];
//				printf(&quot;%lld %lld\n&quot;,pre[i],f[i]);
				break;
			}
		}
	}
	printf(&quot;%lld\n&quot;,f[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>