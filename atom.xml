<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-12-02T11:42:20.993Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[ARC杂题选讲P3]]></title>
        <id>https://xiaxiaoguang.github.io/post/arc-za-ti-xuan-jiang-p3/</id>
        <link href="https://xiaxiaoguang.github.io/post/arc-za-ti-xuan-jiang-p3/">
        </link>
        <updated>2020-12-02T06:06:59.000Z</updated>
        <content type="html"><![CDATA[<p>最后的狂欢</p>
<p>AT3978 [ARC093A] Traveling Plan</p>
<p>不去一个点...其实不会影响太多吧?</p>
<p>直接走即可吧...</p>
<p>AT3979 [ARC093B] Grid Components</p>
<p>给出一种构造方案</p>
<p>黑7白8</p>
<pre><code class="language-cpp">
$#$##
#$#$#
$#$##
#$#$#

</code></pre>
<p>黑6白7</p>
<pre><code class="language-cpp">
$#$#$#$
#$#$#$#
#$#$###
#$#$###
</code></pre>
<p>黑9白7</p>
<pre><code class="language-cpp">
#$#$#$#$#$#$#$#$###########
##########################
$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$#$#$#$#$#$#$

</code></pre>
<p>就是中间分割卡,然后两边直接暴力拼凑!</p>
<p>AT3981 [ARC093D] Dark Horse</p>
<p>毒瘤啊</p>
<p>DP....</p>
<p>看上去和剪刀石头布那个题很相近,但是我还是假啊</p>
<p>显然我们只需要求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_1=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的方案数再乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<p>做法是容斥,因为这个限制相当于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mo>=</mo><mo>{</mo><mi>s</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>G</mi><mi>i</mi></msub><mo>!</mo><mo>=</mo><msub><mi>A</mi><mi>x</mi></msub><mo>}</mo></mrow><annotation encoding="application/x-tex">G_i=\{sth||G_i|={2^i-1},minG_i!=A_x\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></p>
<p>每个集合的最小值??太难了,不如求每个集合的最小值都是A里面的容容斥</p>
<p>那么就是说我们要直接DP,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示从大到小考虑了前i个能打败的人,这N个集合有S已经选满了的方案数</p>
<p>然后转移相当于枚举一下下个人,然后看看他干满哪个集合</p>
<p>注意这里这个集合是放满,也就是说我们要用大于当前人i的所有人中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个,所以要乘一个组合数</p>
<p>然后最后里面的人还可以随便选择,乘上一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>c</mi><mo>[</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">fac[1&lt;&lt;k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>表示我们选入的那些人内部还可以随便排列</p>
<p>同样的,最后计数的时候外面的人可以随便选择,乘上一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>c</mi><mo>[</mo><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>n</mi><mo>−</mo><mi>S</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">fac[1&lt;&lt;n-S-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>即可,为啥是-S呢?因为你就算统计每个二进制位得到的也是-S.....qwq?</p>
<p>做完啦!!</p>
<p>注意我们千万不能减多了...我一开始把1剪掉了...还以为标号是从0~n-1....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 17;
const int MAXS = (1 &lt;&lt; 17);
int n, m, a[MAXN];
int f[MAXS], g[MAXS];//滚动数组/se
int fac[MAXS], ifac[MAXS];
inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline void sub(int &amp;x, int y) {
	x -= y;
	if(x &lt; 0)x += P;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline ll C(int x, int y) {
	if(y &gt; x)return 0;
	return 1ll * fac[x] * ifac[y] % P * ifac[x - y] % P;
}

inline void init() {
	fac[0] = ifac[0] = 1;
	int N = (1 &lt;&lt; n);
	for(int i = 1; i &lt;= N; ++i)fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[N] = ksm(fac[N], P - 2);
	for(int i = N - 1; i &gt;= 1; --i)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	return;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	sort(a + 1, a + m + 1);
	reverse(a + 1, a + m + 1);
	init();
	int mS = (1 &lt;&lt; n) - 1;
	f[0] = 1;
	for(int i = 1; i &lt;= m; ++i) {
		for(int S = 0; S &lt;= mS; ++S) {
			add(g[S], f[S]);//放弃这个人?
			for(int k = 0; k &lt; n; ++k) {
				if(S &gt;&gt; k &amp; 1)continue;
				add(g[S ^ (1 &lt;&lt; k)], 1ll * f[S] * fac[1 &lt;&lt; k] % P * C(mS - S - a[i] + 1, (1 &lt;&lt; k) - 1) % P);
			}
		}
		for(int S = 0; S &lt;= mS; ++S) {
			// printf(&quot;%d %d %d %d?\n&quot;, i, a[i], S, g[S]);
			f[S] = g[S];
			g[S] = 0;
		}
	}
	int ans = 0;
	for(int S = 0; S &lt;= mS; ++S) {
		int cnt = 0;
		for(int i = 0; i &lt; n; ++i)if(S &gt;&gt; i &amp; 1)++cnt;
		if(cnt &amp; 1)sub(ans, 1ll * f[S] * fac[mS - S] % P);
		else add(ans, 1ll * f[S] * fac[mS - S] % P);
	}
	printf(&quot;%lld\n&quot;, 1ll * ans * (1 &lt;&lt; n) % P);
	return 0;
}

</code></pre>
<p>AT3980 [ARC093C] Bichrome Spanning Tree</p>
<p>怎么计算?先找一个性质,就是图中的最小生成树</p>
<p>如果她是大于x的,显然此时再怎么染都是0</p>
<p>如果小于x</p>
<p>那T的颜色一定要染成一种颜色,否则T就成最小生成树了...</p>
<p>然后枚举一条边i,强制选上i后的最小生成树是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">tans_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">tans_i&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,则我们这个东西也要和之前的T同色,因为这个方案可以有之前的T删去一条边加上一条边构造而来</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">tans_i&gt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>那么这个边可以成为异色的,因为不管怎么染都不影响最小异色生成树</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">tans_i==x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>,这个生成树可以成为最小异色生成树......</p>
<p>依次枚举这些边然后强制选择某种颜色的边数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">tans_i=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>个数</p>
<p>首先强制枚举到边j为黑色,没有被强制染色的边随便染色,贡献为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>c</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{m-cnt-1-c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span></span></span></span>,然后cnt++,j变成白色</p>
<p>枚举下一条边</p>
<p>会发现这样最终方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mo>(</mo><msup><mn>2</mn><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow></msup><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>−</mo><mi>c</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2*(2^{cnt}-1)*2^{m-n-c}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043556em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span></span></span></span>,c为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">tans_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">tans_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>等于x的边数</p>
<p>(其实就是相当于按某种顺序计算所有的贡献!)</p>
<p>推导要等比数列求和:</p>
<p>首先T是黑白有2种</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>−</mo><mi>c</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n+1-1-c}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>−</mo><mi>c</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n-c}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">c</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>−</mo><mi>x</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n-x}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>−</mo><mi>x</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n+1-x}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>−</mo><mi>x</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n+2-x}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>公比为2,首相为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>−</mo><mi>x</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">2^{m-n-x}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow></msup></mrow><mrow><mn>1</mn><mo>−</mo><mn>2</mn></mrow></mfrac><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>−</mo><mi>x</mi></mrow></msup><mo>∗</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\frac {1-2^{cnt}} {1-2} 2^{m-n-x}*2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.406571em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.00324em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8703428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">t</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>显然cnt+x最后是c..qwq</p>
<p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">ans=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>那么我们先计算T为最小异色生成树的答案,(随便选,减去全一个颜色的)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>2</mn><mo>)</mo><mo>∗</mo><msup><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(2^{n-1}-2)*2^{m-n+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>强制T同色</p>
<p>计算上面的贡献转换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">ans&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span></p>
<p>接着套用上面的做法,但是注意到这个c要减去<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>哦...</p>
<p>AT3943 [ARC092B] Two Sequences</p>
<p>这个OJ不行啊这都没有题解?</p>
<p>P3760 [TJOI2017]异或和</p>
<p>这个题还是减法都能两只log/cy</p>
<p>就是枚举算这一位k的答案</p>
<p>变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">sum_i-sum_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,看看有多少j满足</p>
<p>然后分类讨论,如果小于j的位数构成的数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>&lt;</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">sum_i&lt;sum_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的时候因为进位所以k一定是1</p>
<p>那么对应的就是i这一位和j这一位都是0或者都是1</p>
<p>否则的话,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>i</mi></msub><mo>&gt;</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">sum_i&gt;sum_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>这一位都是0/1或者1/0</p>
<p>显然可以树状数组实现数点</p>
<p>对于这道题也是一样的,二进制运算加法也满足这个奇妙性质</p>
<p>两个数小于i的所有位和如果大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">1&lt;&lt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>,那么加和也一定这一位为1qwq,否则一定为0</p>
<p>剩下的就是个分类讨论,懒得我就不写了</p>
<p>AT3944 [ARC092C] Both Sides Merger</p>
<p>一开始我看到第三个样例傻掉了,让后才发现这个题是替换不是求和....</p>
<p>注意到如果我们两个数中间夹了奇数个数就一定能合二为一</p>
<p>eg:12213可以凑出4,操作方法是选择中间的那个2一直用</p>
<p>而这个性质其实告诉了我们可以dp(输出方案(雾))</p>
<p>但是我们又有可能存在一些毒瘤的端点删除操作</p>
<p>发现他还是不能改变奇偶性(转移这一回事,只能改变我们dp到最后统计答案时的操作</p>
<p>所以本题做完了</p>
<p>dp的时候要小心这个负数qaq.....</p>
<p>但是这个输出方案输出头的时候一定要只点1不能点其他的.....</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 1e3 + 7;
int a[MAXN], n, pre[MAXN], que[MAXN], tot;
ll  f[MAXN], ans, id;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&quot;%d&quot;, &amp;a[i]);
	memset(f, -0x3f, sizeof(f));
	f[0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		f[i] = a[i];
		for(int j = 0; j &lt; i; ++j) {
			if((i - j + 1) &amp; 1) {
				if(f[j] + a[i] &gt; f[i]) {
					f[i] = f[j] + a[i];
					pre[i] = j;
				}
			}
		}
	}
	ans = -1e9;
	for(int i = n; i &gt;= 1; --i) {
		if(f[i] &gt; ans) {
			ans = f[i];
			id = i;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	for(int i = n; i &gt;= id + 1; --i)que[++tot] = i;
	for(int i = id; i; i = pre[i]) {
		int u = pre[i];
		if(pre[i] == 0) {
			for(int j = 1; j &lt; i; ++j)que[++tot] = 1;
			break;
		}
		int x = i;
		while(x - u) {
			que[++tot] = (x + u) / 2;
			x -= 2;
		}
	}
	printf(&quot;%d\n&quot;, tot);
	for(int i = 1; i &lt;= tot; ++i)printf(&quot;%d\n&quot;, que[i]);
	return 0;
}


</code></pre>
<p>AT3937 [ARC091B] Remainder Reminder</p>
<p>对于这道题来说分类讨论是唯一的出路?</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>b</mi><mo>&gt;</mo><mo>=</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">a mod b &gt;= K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span></p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&lt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></li>
</ol>
<p>那么a&gt;k才行</p>
<p>这个方案数相当于在之后某段区间尺取,两端点不能相同</p>
<p>应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo>(</mo><mi>n</mi><mo>−</mo><mi>K</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac {(n-K)*(n-K-1)} 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>紧接着我们再看</p>
<ol start="2">
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a&gt;b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></li>
</ol>
<p>那么b&gt;k才行</p>
<p>并且对于一个给定的b,我们有一些A才能对应</p>
<p>eg:K=5,b=6,a=5,11,17</p>
<p>K=3,b=6,a=4,5,10,11,16,17都是可以的</p>
<p>也就是从一段开始向后跳一些步数,直到超过N为止...</p>
<p>枚举那个b,然后O(1)计数a吧?</p>
<pre><code class="language-cpp">
//Dawn Light
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
int n, k;
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	ll ans = 1ll * (n - k) * (n - k + 1) / 2; //eg : n=5,K=4,a=4,b=5
	if(k != 0)
		for(int i = k + 1; i &lt;= n; ++i) {
			ll tmp = n / i - 1;
			if(tmp &lt; 0)break;
			if(n % i &gt;= k)ans = ans + tmp * (i - k) + (n % i - k + 1);
			else ans = ans + tmp * (i - k);
		} else ans = 1ll * n * n;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}

</code></pre>
<p>AT3945 [ARC092D] Two Faced Edges</p>
<p>嗯嗯额!</p>
<p>首先我尝试加权,然后得到了一个神奇的数组g,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>表示从i到j的所有必须边异或和</p>
<p>然后发现我萎住了</p>
<p>我们再深入思考一下翻转这条边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>对于图的影响</p>
<ol>
<li>存在一条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>−</mo><mo>&gt;</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">v-&gt;u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>的路径</li>
<li>存在一条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>−</mo><mo>&gt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u-&gt;v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>但是没有经过这个边的路径</li>
</ol>
<p>发现如果二者<strong>有且仅有</strong>一个成立则成功了</p>
<p>因为说分类讨论</p>
<p>二者都不满足,那么一定u,v翻前翻后都是两个联通分量的</p>
<p>二者都满足,那么u,v一定满足翻前翻后都是一个连通分量的</p>
<p>满足1不满足2,之前我们u,v是一个连通分量的(v-&gt;u,而u-&gt;v),但是之后就不行了,u走不到v</p>
<p>满足2不满足1,之前我们u,v不是一个连通分量的,但是之后就行了,v走的到u</p>
<p>怎么维护条件2?</p>
<p>发现我们本质上就是判断(u,v)这条边是不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>−</mo><mo>&gt;</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u-&gt;v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>必经边</p>
<p>也就是说我们要判断删掉这条边后能否到达v</p>
<p>显然不太行QAQ</p>
<p>但是说我们对于每个点遍历一遍图的复杂度还是能承受的</p>
<p>所以说如果我们翻转u的所有出边顺序</p>
<p>然后再dfs一遍!</p>
<p>然后判断u的所有出点v到达的时候这个点的编号是否发生变化即可</p>
<p>如果是必经边,那么我们到达这个v的时候一定不会发生变化(不存在第二条不走这条边的路径)</p>
<p>时间复杂度不变吧,用bitset优化一下下</p>
<p>AT3936 [ARC091A] Flip,Flip, and Flip......</p>
<ol>
<li>四个顶点会被翻转偶数次</li>
<li>四个边界会被翻转偶数次</li>
<li>中间全是奇数次</li>
</ol>
<p>所以除掉这些点即可</p>
<p>答案为n<em>m-2</em>n-2*m+4</p>
<p>小心当n=1或者m=1的情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr提高组十连测day8]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day8/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day8/">
        </link>
        <updated>2020-12-01T12:28:47.000Z</updated>
        <content type="html"><![CDATA[<p>qwq重新整理啦</p>
<p>A. [2020提高组十连测day8]割韭菜</p>
<p>http://www.zhengruioi.com/contest/748/problem/1622</p>
<p>经典的技巧叫做行列无关</p>
<p>就是说我们每一行选多少每一列选多少本质上只有在拼起来的时候才会有影响</p>
<p>就是说我们能先选行再选列喽</p>
<p>那我们直接作出选前k次行的最大收益,前k次列的最大收益</p>
<p>然后计算一下因为行列重复覆盖而导致的收益减损即可</p>
<p>应该行数*列数个格子要少算</p>
<pre><code class="language-cpp">
//你要意识到一个最基本的事情是:行列单独无关
//那么我们可以处理行操作某些次数最大收益
//列操作某些次数最大收益
//然后组合一下下qwq
#include&lt;bits/stdc++.h&gt;
#define ll long long
#define pii pair&lt;ll,int&gt;
#define mkp(x,y) (make_pair(x,y))
#define se second
#define fi first
using namespace std;
const int MAXN = 1e3 + 7;
const int MAXK = 1e6 + 7;
priority_queue&lt;pii&gt; heap;
int n, m, k, v0;
int a[MAXN][MAXN];
ll f[MAXK], g[MAXK];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		int f = 1;
		char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test1.out&quot;, &quot;w&quot;, stdout);
	n = read();
	m = read();
	k = read();
	v0 = read();
	if(k == 0) {
		return puts(&quot;0&quot;), 0;
	}
	for(int i = 1; i &lt;= n; ++i) {//一行二列
		for(int j = 1; j &lt;= m; ++j) {
			a[i][j] = read();
		}
	}
	//行init
	for(int i = 1; i &lt;= n; ++i) {
		ll S = 0;
		for(int j = 1; j &lt;= m; ++j) {
			S += a[i][j];
		}
		heap.push(mkp(S, i));
	}
	//行k
	for(int i = 1; i &lt;= k; ++i) {
		int u = heap.top().se;
		ll v = heap.top().fi;
		heap.pop();
		f[i] = f[i - 1] + v;
		heap.push(mkp(v - 1ll * v0 * m, u)); //会每一列都减少QAQ
	}
	while(!heap.empty())heap.pop();
	for(int i = 1; i &lt;= m; ++i) {
		ll S = 0;
		for(int j = 1; j &lt;= n; ++j) {
			S += a[j][i];
		}
		heap.push(mkp(S, i));
	}
	for(int i = 1; i &lt;= k; ++i) {
		int u = heap.top().se;
		ll v = heap.top().fi;
		heap.pop();
		g[i] = g[i - 1] + v;
		heap.push(mkp(v - 1ll * v0 * n, u)); //每一列decQAQ
	}
	ll ans = -1e18;
	for(int i = 0; i &lt;= k; ++i) {
		ans = max(ans, f[i] + g[k - i] + 1ll * i * (i - k) * v0);//可能爆llQAQ
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}



</code></pre>
<p>B. [2020提高组十连测day8]智勇大闯关</p>
<p>http://www.zhengruioi.com/contest/748/problem/1623</p>
<p>咱不知道为啥要把这个题放在B....</p>
<p>发现最优一定是每个人都停在一个位置上,因为x能到y(结果更优),那我们z也可以按照同样的方式从<br>
x到y</p>
<p>这样就很简单了,可以二分人数...也可以发现随着人数的增多这个公共停下来的位置只能单调后移,所以说直接记录一下即可</p>
<p>这类结论题特容易fst,所以一定要拍拍拍</p>
<pre><code class="language-cpp">
//你考虑尺取推进...
//就是说人数越多,我们只可能单调向前冲啊
//然后你会发现,一个人能否到达某个点之和这个人的位置到某点位置之间的前缀最小值有关...
//也就是说,A能到x点,那么B也一定能到达,因为过程和A到达一样,而结果一定是更优了/....
//所以说我们可以考虑每次多出一个人QAQ
//然后我们会发现这个推进过程可以直接做....
//好像就线性了........我直接服了啊
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e6 + 7;
int T, n;
char s[MAXN];

inline void solve() {
	int cnt = 0;
	int pos = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(s[i] == '1')cnt++;
		else cnt--;
		pos = min(pos, cnt);
	}
	pos = -pos;
	int ans = 0;
	int ret = 0;
	int premax = 0;
	//先可怜一个人冲,然后挨个加人
	cnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(s[i] == '1')cnt++;
		else cnt--;
		while(cnt + ret &lt; 0) {
			ans++;
			ret += premax;
			if(ans &gt; n) {
				printf(&quot;-1\n&quot;);
				return ;
			}
		}
		if(ret &gt;= pos) {
			printf(&quot;%d\n&quot;, ans);
			return;
		}
		//转折...
		premax = max(premax, cnt);
		ret = max(ret, premax * ans);
	}
	return ;
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%s&quot;, s + 1);
		n = strlen(s + 1);
		solve();
	}
	return 0;
}


</code></pre>
<p>C. [2020提高组十连测day8]剪刀石头布</p>
<p>http://www.zhengruioi.com/contest/748/problem/1624</p>
<p>其实也不难/xk</p>
<p>首先我们有暴力跳区间的做法,因为能统计出每个人最后成为胜者的方案数即可</p>
<p>而你会发现他成为左/右区间的方案数是一样的.....也就是说其实本质不同的只有这些人向上爬时哪些时候成为左边,哪些时候成为右边</p>
<p>所以说我们暴力这样做,正解也一样肯定能O(n)推出一下每个手势作为左右胜者概率...1/3(右边)或者2/3(左边)</p>
<p>然后这个次数好像等价于转换为2进制数后0的个数,一个0就是一个右边...证明,其实可以通过观察每个数的每个二进制位发现(线段树本质)</p>
<p>那么假如有k个我们就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>=</mo><msup><mn>3</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">w_i=3^{-n}2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></p>
<p>答案就是求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></msubsup><msup><mn>2</mn><msub><mi>k</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">\sum_{l=1}^r 2^{k_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148818em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03148em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mn>3</mn><mi>n</mi></msup><msup><mo>)</mo><mrow><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(3^n)^{r-l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>直接提出</p>
<p>然后这个可以数位dp,直接记录卡没卡上界就好</p>
<p>最后的问题在于高精度十进制转二进制,这个可以转换成1e9进制再转换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mn>2</mn></mrow><annotation encoding="application/x-tex">2^32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">2</span></span></span></span>进制</p>
<p>相当于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>9</mn><mo>∗</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">n^2/9*32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>!</p>
<pre><code class="language-cpp">


#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;cstring&gt;
#include&lt;assert.h&gt;
using namespace std;
#define G getchar()
int read() {
	int x = 0; char ch = G;
	for (; !isdigit(ch); ch = G);
	for (; isdigit(ch); ch = G) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);
	return x;
}
#undef G
typedef long long ll;
const int INF = 1e9, mod = 998244353, inv3 = (mod + 1) / 3;
inline int upd(int x) {
	return x + (x &gt;&gt; 31 &amp; mod);
}
inline void add(int &amp;x, int y) {
	x = upd(x + y - mod);
}
inline void iadd(int &amp;x, int y) {
	x = upd(x - y);
}

int n;

int a[1 &lt;&lt; 15], b[1 &lt;&lt; 15];
int atot, btot;
int work() {
	int res = 0;
	for (int i = atot; i; i--) {
		ll t = (1LL * res * INF + a[i]);
		a[i] = t &gt;&gt; 30, res = t &amp; 1073741823;
	}
	while (atot &amp;&amp; !a[atot]) --atot;
	return res;
}
void bigint_minus() {
	int pos = 1;
	while (pos &lt;= btot &amp;&amp; !b[pos]) pos++;
	assert(pos &lt;= btot);
	--b[pos];
	for (int i = 1; i &lt; pos; i++) b[i] = 1073741823;
	while (btot &amp;&amp; !b[btot]) --btot;
}
int f[100010];
int g[100010];
int solve() {
	f[0] = 3;
	for (int i = 1; i &lt;= n; i++) f[i] = 1LL * f[i - 1] * f[i - 1] % mod;
	g[0] = 3;
	for (int i = 0, k = 1; i &lt; n; i += 30, k++) {
		for (int j = 0; j &lt; 30 &amp;&amp; i + j &lt; n; j++) {
			int id = i + j, v = b[k] &gt;&gt; j &amp; 1;
			if (!v) g[id + 1] = g[id] * 2LL * inv3 % mod * f[id] % mod;
			else g[id + 1] = (2LL * inv3 * f[id] % mod * f[id] + 1LL * inv3 * f[id] % mod * g[id]) % mod;
		}
	}
	return g[n];
}


char s[1 &lt;&lt; 15]; int len;
int ans;
int main() {
	n = read();

	scanf(&quot;%s&quot;, s); len = strlen(s);
	reverse(s, s + len);
	if (!(len == 1 &amp;&amp; s[0] == '1')) {
		for (int i = 0; i &lt; len; i += 9) {
			int x = 0;
			for (int j = min(len, i + 9) - 1; j &gt;= i; j--) {
				int v = s[j] ^ 48;
				x = x * 10 + v;
			}
			a[++atot] = x;
		}
		while (atot) b[++btot] = work();
		bigint_minus(); bigint_minus();
		iadd(ans, solve());
	}
	memset(a, 0, sizeof a);
	memset(b, 0, sizeof b);

	scanf(&quot;%s&quot;, s); len = strlen(s);
	reverse(s, s + len);
	atot = 0;
	for (int i = 0; i &lt; len; i += 9) {
		int x = 0;
		for (int j = min(len, i + 9) - 1; j &gt;= i; j--) {
			int v = s[j] ^ 48;
			x = x * 10 + v;
		}
		a[++atot] = x;
	}
	btot = 0;
	while (atot) b[++btot] = work();
	bigint_minus();
	add(ans, solve());

	printf(&quot;%d\n&quot;, ans);
	return 0;
}



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ARC杂题选讲P2]]></title>
        <id>https://xiaxiaoguang.github.io/post/arc-za-ti-xuan-jiang-p2/</id>
        <link href="https://xiaxiaoguang.github.io/post/arc-za-ti-xuan-jiang-p2/">
        </link>
        <updated>2020-12-01T00:44:27.000Z</updated>
        <content type="html"><![CDATA[<p>咋 做 啊</p>
<p>AT4120 [ARC096D] Sweet Alchemy</p>
<p>还是相当毒瘤的一道题</p>
<p>首先要一个经典的转换,就是变成树上问题</p>
<p>然后我们一个点选的次数不能超过他所有祖先d次,同时要小于他所有儿子,等价于我们树上差分之后每个点选择的次数小于等于d</p>
<p>也就是说我们选择一颗子树,代价为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \sumM at position 1: \̲s̲u̲m̲M̲_i'>\sumM_i</span>,权值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>,最多能进行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>次的最优权值和,但是1没有这个限制</p>
<p>显然这个东西是多重背包,但是不能直接上,因为代价太高,达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">1e9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span></span></span></span>级别</p>
<p>所以说我们可以考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示权值为i的最小代价是什么</p>
<p>然后我们还是能最多d次怎么办呢?就是说现在做了转换依然没法转移</p>
<p>我们有一个错误的贪心就是按照性价比排序能选就选</p>
<p>什么时候不错呢?当物品个数都足够多的时候,即可以选择大于n个的时候</p>
<p>此时你会发现无论如何那个性价比更劣的都已经比第一个劣了</p>
<p>比如</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>j</mi></msub><mi mathvariant="normal">/</mi><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><msub><mi>w</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_j/v_j &gt; w_i/v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><msub><mi>v</mi><mi>j</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n&gt;v_j,v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时,大于的部分显然满足贪心性质</p>
<p>实现的时候二进制分组,然后我们最后匹配的时候注意每个数最多在额外选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d-min(n,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>个</p>
<p>因为我们在之前已经完全背包了min个啊....</p>
<p>AT4111 [ARC095A] Many Medians</p>
<p>这个可以直接做吧?</p>
<p>把数列排序,然后第一个到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>l</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac l 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>删掉中位数都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>l</mi><mn>2</mn></mfrac><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac l 2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>然后之后的删掉都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>l</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac l 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>qwq</p>
<p>AT4112 [ARC095B] Binomial Coefficients</p>
<p>选出最大的作为第一个数</p>
<p>选出和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>差最小的作为第二个</p>
<p>AT4114 [ARC095D] Permutation Tree</p>
<p>显然树的形态只可能是毛毛虫</p>
<p>因为但凡存在一条侧链,满足u-&gt;v,而w-&gt;u</p>
<p>那有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>&lt;</mo><mi>u</mi><mo>&lt;</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v&lt;u&lt;w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>,同时v在u之后(因为是侧链)</p>
<p>所以说只能是毛毛虫</p>
<p>判断合法就是找出那条最长的链即可</p>
<p>构造合法解?找到直径的一个端点,然后在直径上走,每个点的权值为前面所有点的点数和</p>
<p>然后直径外的点就是加入点i周围的点,随便赋为点i的权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>AT2301 [ARC068D] Solitaire</p>
<p>这种题就不能直接计数啊,首先题目中的删除序列是指删除的数字构成的序列</p>
<p>所以说枚举1在单调队列哪个位置,以及剩下的怎么排列的形态都是不可的,会算重</p>
<p>我们考虑观察并设计dp,因为双端队列这东西保证序列的形态是从一开始向两端递增?..</p>
<p>所以说我们可以发现,删除的形态也是这样的</p>
<p>就是说是分三段</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1606790449525.png" alt="" loading="lazy"></figure>
<p>黑色的一段下降,且包括最低点1</p>
<p>黄色的一段下降,且满足最小值大于第三段红色</p>
<p>而且黄色+黑色的长度,红色段的长度为n-k</p>
<p>我们就不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数,第一个序列(黑色)的最小值为j的方案数</p>
<p>那么前i个数分成的两类,第一个(黑色)的最小值为j,另一个(h)的最小值为minx</p>
<p>我们要有minx大于剩下所有元素的最大值</p>
<p>然后我们要分入一个到A,B序列中</p>
<p>如果下一个数满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">x&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>,那么我们就插入A末尾,仍满足所有条件,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>−</mo><mo>&gt;</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mo>&lt;</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}-&gt;f_{i+1,&lt;j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>而如果大于等于j</p>
<p>加入A,A就不单调递减了</p>
<p>我们只能加入B,而且满足限制二这个值一定是另外的集合中最大的元素</p>
<p>同时,我们要保证这个值大于j,否则我们必然算重....</p>
<p>加入之后仍然满足条件,即向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i+1,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>而这个构造显然我们可以统计出所有黑色和黄色部分答案,剩下红色的长度为n-k-1,方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>qaq</p>
<p>从大到小dp即可,转移可以优化,就是下图类型优化</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1606791329399.png" alt="" loading="lazy"></figure>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN = 2e3 + 7;
const int P = 1e9 + 7;
int f[MAXN][MAXN];
int n, k;

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 2; i &lt;= n; ++i)f[1][i] = 1;//分入一个,另你一个为空
	for(int i = 1; i &lt; k - 1; ++i) {
		f[i + 1][n - i + 1] = f[i][n - i + 1];//放入直接转移的
		for(int j = n - i; j &gt;= 2; --j) {
			add(f[i + 1][j], f[i][j]);
			add(f[i + 1][j], f[i + 1][j + 1]);
		}
	}
	int ans = 0;
	for(int i = 2; i &lt;= n - k + 2; ++i) {
		add(ans, f[k - 1][i]);
	}
	if(k == 1)ans = 1;
	ans = 1ll * ans * ksm(2, n - k - 1) % P;
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>实现的时候要注意我们因为从大到小放入权值,所以第i个位置放入的是n-i+1,而且我们一开始的时候放入n,所以所有方案初值都为1</p>
<p>注意当k<mark>n的时候,我们相当于只需要满足之前的限制,红色那段么得了,最后不需要乘上2的次幂,k</mark>1的时候我们不需要DP</p>
<p>AT4113 [ARC095C] Symmetric Grid</p>
<p>你会发现行列无关,也就是操作顺序可以先行后列</p>
<p>那我们直接搜搜行的决策,之后列只能直接做匹配</p>
<p>能匹配我们就匹配,丢到一起</p>
<p>然后如果有一个没法匹配就自闭,重新下一个行搜索</p>
<p>看上去我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo><mo>∗</mo><mi>n</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n!*nm^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>巨量计算量</p>
<p>但是那个列匹配能删掉很多计算量</p>
<p>再优化一下做行的过程,就是说我们直接找每一行和那个匹配,就确定了行行的位置</p>
<p>可以优化掉一个没有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span>,剩下的状态数/计算量就很合法了!</p>
<p>AT4106 [ARC094B] Worst Case</p>
<p>用手画画几个pair就能找到一点点规律</p>
<p>我们选择的人的组合一定是如下样子:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mi>B</mi><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>A</mi><mi>B</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(1,AB),(AB,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mi>A</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>A</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2,AB/2),(AB/2,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mi>A</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>)</mo><mo separator="true">,</mo><mo>(</mo><mi>A</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(3,AB/3),(AB/3,3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p>
<p>....</p>
<p>其中所有除法都是下取整,总共AB开根号对pair</p>
<p>也就是说,我们一个粗略的答案上界是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><msqrt><mrow><mi>A</mi><mi>B</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">2*\sqrt {AB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span></p>
<p>然鹅,首先你会发现其中一定有一个是原来的人(A,B),答案-1</p>
<p>然后如果说这个AB是完全平方数的话,我们还会多算两遍,答案-2</p>
<p>同时如果说虽然不是完全平方数,但是开根后得到的数字x和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><mfrac><mi>A</mi><mi>B</mi></mfrac><mi>x</mi><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor \frac AB x \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.217331em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">x</span><span class="mclose">⌋</span></span></span></span>是一个数的话,我们直接乘2也会算重</p>
<p>eg:50 -&gt; 7*7&lt;50</p>
<p>满足上述三点后精细实现一下即可</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
int t, A, B;

signed  main() {
	scanf(&quot;%lld&quot;, &amp;t);
	while(t-- &gt; 0) {
		scanf(&quot;%lld%lld&quot;, &amp;A, &amp;B);
		int u = sqrt(1ll * A * B);
		int v = A * B / u;
		if(u * v == A * B &amp;&amp; v &gt; u)--v;
		if(A &gt; B)swap(A, B);
		int ans = 0;
		if(u == A &amp;&amp; v == B)
			ans--;
		else if(u * v == A * B)
			ans -= 2;
		else if(v == u)
			ans--;
		ans += u * 2 - 1;
		printf(&quot;%lld\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p>AT4107 [ARC094C] Tozan and Gezan</p>
<p>不难发现,如果A数组有位置i的值小于B数组位置j的值,那那个位置最后一定会被Tozan减成0</p>
<p>因为至少当大于0的时候,二者的差在一轮中可以不发生变化,T能进行一次,G在相同位置进行一次</p>
<p>答案至少加上所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>&lt;</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A&lt;B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>位置的值和</p>
<p>然后再来看看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>&gt;</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A&gt;B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>的位置</p>
<p>你会发现无论如何T都最后都能把他们消到只剩一个非0</p>
<p>因为只需要保留那个A&gt;B且大于0位置的数,然后其他位置的数排着消除即可,一定不会中途突然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A=B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,至少有一个位置不同</p>
<p>那之后,我们只需要判断留下哪个位置最优</p>
<p>发现其实就是对应位置A,B差最大的那个</p>
<p>因为G一定可以类似于截击T在操作最后非0位置时---操作其他位置而使其他位置都相同,非0位置不变</p>
<p>又因为两数组和相同,所以我们G也一定能做到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[省选模拟赛 7]]></title>
        <id>https://xiaxiaoguang.github.io/post/sheng-xuan-mo-ni-sai-7/</id>
        <link href="https://xiaxiaoguang.github.io/post/sheng-xuan-mo-ni-sai-7/">
        </link>
        <updated>2020-11-30T13:25:16.000Z</updated>
        <content type="html"><![CDATA[<p>被咕咕咕了的博客</p>
<p>A</p>
<p>幂等性相当强</p>
<p>根据群的定义,这玩意不可能是加法</p>
<p>不妨定义为max!</p>
<p>那么我们会发现查询相当于区间max</p>
<p>而这个东西.....要定义一些东西才行吧?</p>
<p>显然我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>个机会定义max....?</p>
<p>树上max?</p>
<p><s>直接输出1是一种合法的解</s></p>
<p>但是不能这样</p>
<p>我们每个点向上跳log步得到的最大值答案都搞出来,就是用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>搞出一个树上ST表</p>
<p>剩下还有3次机会给我们的q询问</p>
<p>也很简单,之前树上倍增不是跳log次吗?</p>
<p>但是这次我们左边用两个就能拼出一个最大值</p>
<p>然后右边用两个也能拼出一个最大值</p>
<p>二者之前再拼出一个值</p>
<p>正好用了3次,卡满了2e6....</p>
<p>B</p>
<p>插头dp!</p>
<p>这个形态....防止计重是相当难的唉</p>
<p>记录什么呢?</p>
<p>_____|-----</p>
<p>划分线上每个格子向哪个方向延伸?</p>
<p>不对,是是否向下延伸?</p>
<p>是的,你会发现我们能记录很多是否向下的0/1变量</p>
<p>如果向下为1,那我们这个位置下一刻只能放0,否则下个位置只能放1</p>
<p>设计这样一个状态,我们可能会转移出不太对劲的状态吧?就是计重了?</p>
<p>是的!因为你会发现这样我们没有考虑颜色,而直接将颜色计入转移系数显然会算重!</p>
<p>因为我们本质不同的方案数只和颜色相同,而一个染色方案是否有效却和我们的插头dp相同</p>
<p>所以说我们打算外层dp一下染色方案并状压内层插头形态</p>
<p>哼,怎么可能,状压的是内层所有可行的插头方案,就是比如有2^16个插头形态,就记录<span class='katex-error' title='ParseError: KaTeX parse error: Double superscript at position 4: 2^2^̲16'>2^2^16</span></p>
<p>这题n是6,所以是<span class='katex-error' title='ParseError: KaTeX parse error: Double superscript at position 4: 2^2^̲6'>2^2^6</span>=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mn>4</mn></mrow><annotation encoding="application/x-tex">2^64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mord">4</span></span></span></span></p>
<p>一个ll就能存下来</p>
<p>当然,这个东西显然要用map记录状态并转移,因为本质不同的染色方案可能对应了相同的边界颜色....</p>
<p>总而言之,dp套dp</p>
<p>code:</p>
<pre><code class="language-cpp">

#pragma G++ optimize(2)
#pragma G++ optimize(3)

#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;map&gt;
using std::map;
using std::pair;
using std::make_pair;
const int P = 998244353;
#define ull unsigned long long
#define ll long long
#define fi first
#define se second
#define mkp(x,y) make_pair(x,y)
map&lt;pair&lt;ll, ull&gt;, ll&gt; dp[3];
int n, m;
inline void update(int x, int y, ull Sc, ll vl, ull S, int t, int nc) {
	ull nS = 0;
	for(int plug = 0; plug &lt; (1 &lt;&lt; n); ++plug) {
		if(S &gt;&gt; plug &amp; 1) {//这个状态有了
			int upc = Sc &gt;&gt; y &amp; 1;//上方颜色
			int upplug = plug &gt;&gt; y &amp; 1;//上方插头
			int Lc = 0, Lplug = 0;

			if(y)Lc = Sc &gt;&gt; (y - 1) &amp; 1, Lplug = plug &gt;&gt; (y - 1) &amp; 1;//不是第一个,0是第一个
			if(upplug) {//有下插头
				if(nc != upc)//如果颜色不一样
					nS |= 1ull &lt;&lt; (plug ^ (1 &lt;&lt; y));//除掉下插头
			} else {//没有下插头
				if(y &amp;&amp; nc != Lc &amp;&amp; Lplug) { //有右插头
					nS |= 1ull &lt;&lt; (plug ^ (1 &lt;&lt; (y - 1)));//除掉右插头
				}
				nS |= 1ull &lt;&lt; (plug ^ (1 &lt;&lt; y)); //下插头
			}
		}
	}
	if(nS)(dp[t][mkp(Sc ^ ((Sc &gt;&gt; y &amp; 1) &lt;&lt; y) ^ (nc &lt;&lt; y), nS)] += vl) %= P;
}

int main() {
	// int n, m;
	int t = 0;

	dp[0][mkp(0, 1)] = 1;
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 0; j &lt; n; ++j) {
			t ^= 1;
			dp[t].clear();
			for(auto it : dp[t ^ 1]) {//C++11
				ll vl = it.se;
				ll col = it.fi.fi;
				ull S = it.fi.se;
				for(int k = 0; k &lt; 2; ++k) {
					update(i, j, col, vl, S, t, k);
				}
			}
		}
	}
	ll ans = 0;
	for(auto it : dp[t])
		if(it.fi.se &amp; 1)
			ans = (ans + it.se) % P;
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}



</code></pre>
<p>C</p>
<p>有一个结论:如果选择的长度为k的区间不包括两边子区间的最大值的话,一定无法更新答案</p>
<p>假设最大值为x次大值为y</p>
<p>而左边最次大值为A,a右边最次大值为B,b</p>
<p>显然x+y最大为a+b</p>
<p>而此时,若b&gt;A,B+b大于a+b</p>
<p>若a&gt;B,a+A大于a+b</p>
<p>除外则也显然不优</p>
<p>那么直接用线段树维护即可</p>
<p>finish</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NOIP2018 全国模拟赛 (完结!)]]></title>
        <id>https://xiaxiaoguang.github.io/post/noip2018-quan-guo-mo-ni-sai/</id>
        <link href="https://xiaxiaoguang.github.io/post/noip2018-quan-guo-mo-ni-sai/">
        </link>
        <updated>2020-11-30T08:07:53.000Z</updated>
        <content type="html"><![CDATA[<p>http://noi.ac/contest/10</p>
<p>挺毒瘤的,但是看完题解感觉还可以</p>
<p>A</p>
<p>不难发现好像糖果数量确定的代表花费确定</p>
<p>那么我们就是要满足一个愉悦度情况下选择最少的糖果</p>
<p>考虑枚举一下第一家糖果用了多少</p>
<p>然后我们相应的,要第二家糖果买的sum愉悦度比第一家多,所以说可以二分或者双指针</p>
<p>实现的时候最后两边同时尺取,就是说如果两个指针都大于1就交替?--</p>
<p>B</p>
<p>最小生成树计数??</p>
<p>其实挺惊艳的</p>
<p>每条边都有一个可能,然后会发现当最小生成树是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1~n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace nobreak"> </span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的时候就是直接把所有1~n-1形成一颗生成树后的结果</p>
<p>也就是说我们可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n^{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>得知形态,然后分配权值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>!</mo><mo>∗</mo><mo>(</mo><mi>n</mi><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">*(n-1)!*(n*(n-1)/2-n+1)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∗</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
<p>如果没有呢?</p>
<p>会发现我们要记录所有可能的连通块信息?</p>
<p>不需要,因为我们连边转移其实只和连通块的大小有关....因为转移系数如果是自连边要在任意连通块内部连接,否则是合并连通块,而任意连通块内部连边在已知多少连通块的情况下这个系数可以直接计算的</p>
<p>而又不难发现,连通块大小相当于一个整数划分....所以说我们要记录所有整数划分的状态</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>40</mn></msub></mrow><annotation encoding="application/x-tex">P_{40}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?也是很可的37338</p>
<p>有个优化转移的好方法,就是观察到大小不同的连通块最多根号个,也就是说我们可以把&quot;有多少个大小为i&quot;的这个信息写入转移里,然后就能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><msqrt><mi>n</mi></msqrt><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O((\sqrt n)^2 + nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault" style="padding-left:0.833em;">n</span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>完成一个转移啦</p>
<pre><code class="language-cpp">
//离散化这个整数划分方案
//具体的,我们可以搜索,用map映射
#include&lt;bits/stdc++.h&gt;
#define vi vector&lt;int&gt;
#define pb push_back
using namespace std;
const int MAXN = 50;
const int MAXP = 5e4 + 7;
const int P = 1e9 + 7;
int n, a[MAXN], tot;
int rcx[MAXP], vis[MAXP], rcs[MAXP][MAXN];
map&lt;vi, int&gt; mp1;
map&lt;int, vi&gt; mp2;
vi b;
bool cmp(int x, int y) {
	return x &gt; y;
}
inline void dfs(int x, int rs, int lst) {
	if(rs == 0) {
		if(mp1.find(b) == mp1.end()) {
			sort(b.begin(), b.end(), cmp);
			mp1[b] = ++tot;
			mp2[tot] = b;
			for(int j = 0; j &lt; x; ++j) {
				rcx[tot] += b[j] * (b[j] - 1) / 2;//每个连通块内部完全图
			}
			for(int j = 0; j &lt; x; ++j) {
				rcs[tot][b[j]]++;//统计有多少个
			}
		}
		return;
	}
	for(int i = lst; i &gt;= 1; --i) {
		b[x] = i;
		if(rs - i &lt; 0)continue;
		dfs(x + 1, rs - i, i);
		b[x] = 0;
	}
	return ;
}

int f[MAXP], g[MAXP];

inline void init() {
	b.resize(n);
	for(int i = 0; i &lt; n; ++i)b[i] = 0;
	//注意每个v的大小都是n+1
	dfs(0, n, n);
	return;
}

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}
//转移我们同样大小连通块枚举一个即可
int tmp[MAXN][MAXN], q1[MAXN], q2[MAXN];
inline void solve() {
	int m = n * (n - 1) / 2;
	f[tot] = 1;//所有都没有
	for(int i = 1; i &lt;= m; ++i) {
		if(vis[i]) {
			for(int S = 1; S &lt;= tot; ++S) {
				vi v = mp2[S];
				if(f[S]) {
					int t = 0;
					for(int k = 0; k &lt; n; ++k) {
						if(!v[k])break;
						for(int j = k + 1; j &lt; n; ++j) {
							if(!v[j])break;
							if(!tmp[v[k]][v[j]]) {
								tmp[v[k]][v[j]] = 1;
								q1[++t] = v[k];
								q2[t] = v[j];
								vi q = v;
								q.pb(v[k] + v[j]);
								int qwq = v[k] * v[j];
								if(v[k] == v[j])qwq = qwq * rcs[S][v[k]] * (rcs[S][v[k]] - 1) / 2;
								else qwq = qwq * rcs[S][v[k]] * rcs[S][v[j]];
								q[k] = 0;
								q[j] = 0;
								sort(q.begin(), q.end(), cmp);
								q.resize(n);
								int T = mp1[q];
								add(g[T], 1ll * f[S] * qwq % P);
							}
						}
					}
					for(int k = 1; k &lt;= t; ++k) {
						tmp[q1[k]][q2[k]] = 0;
					}
				}
			}
		} else {
			for(int S = 1; S &lt;= tot; ++S) {
				add(g[S], 1ll * f[S] * (rcx[S] - i + 1) % P);
			}
		}
		for(int S = 1; S &lt;= tot; ++S) {
			f[S] = g[S], g[S] = 0;
		}
	}
	printf(&quot;%d\n&quot;, f[1]);
	return;
}
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]] = 1;
	}
	init();//预处理
	solve();//dp
	return 0;
}


</code></pre>
<p>C</p>
<p>其实题解做法是对应了三种不同的排序方式呢</p>
<ol>
<li>插入排序</li>
</ol>
<p>选择最小的旋转到最前</p>
<ol start="2">
<li>归并排序</li>
</ol>
<p>对于0/1序列可以这样做,因为我们合并的时候直接reverse左半边的1和右半边的0即可</p>
<p>前面都是0后面都是1就排好序了,实现的时候要一次,就是类似于000[1111 0 0000]11</p>
<p>变为000[0000 0 1111]11</p>
<p>qwq就是使得多的一边有一个回文中心,并且左边都是1即可</p>
<ol start="3">
<li>快速排序</li>
</ol>
<p>实现原理就是选取一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pivot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>然后小于这个值的分到左边,大于的分到右边,紧接着递归左右区间</p>
<p>小于的记为0,大于的记为1</p>
<p>排序一个0/1序列?调用归并排序</p>
<p>这样你就有一个最优才<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的乐色排序算法了!</p>
<p>D2</p>
<p>A</p>
<p>bst...我顺序开题!</p>
<p>考虑操作一本质上顺序不会影响</p>
<p>就是说我们对于一个节点,先交换他和他兄弟还是他父亲和他父亲的兄弟是一样的</p>
<p>而第一个区间操作,会发现其实就是对应了几层全部修改和两层区间修改(前后缀)</p>
<p>而因为n很小,那我们也可以把修改压入一个int内,第i位为0/1表示有没有进行这一位的翻转</p>
<p>那就变成了一个很多次全局加和几个区间加了!</p>
<p>所以说我们直接树状数组维护即可</p>
<p>然后全局加在外层打标记</p>
<p>查询的时候,先查查这个点的标记,然后再跳跳跳即可</p>
<p>B</p>
<p>显然是贪心匹配最优....</p>
<p>也就是说我们维护一个L1,R1,L2,R2表示前面的一段L1<sub>R1和后面的一段L2</sub>R2能否匹配</p>
<p>然后每次用哈希判断,子串哈希值即可,如果能匹配就直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mn>1</mn><mo>=</mo><mi>R</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1=R1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mn>2</mn><mo>=</mo><mi>R</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2=R2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mo>+</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">tot+=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn><mo>&gt;</mo><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">R1&gt;L2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span>就结束了</p>
<p>注意因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mn>1</mn><mo>−</mo><mi>L</mi><mn>1</mn><mo>=</mo><mi>R</mi><mn>2</mn><mo>−</mo><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">R1-L1=R2-L2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span>所以说本质不同的其实只有O(n)个</p>
<p>直接枚举</p>
<p>C</p>
<p>显然的是我们有第一类操作使得每个字符串顺序无意义</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示i个A,j个B,k个C的点</p>
<p>而魔法也相当于有x个A....能转换成y个A....</p>
<p>于是我们就可以...建图啦!注意这里我们只需要一个字符串使用一个魔法即可!</p>
<p>因为我们没有DP的必要,每个节点都代表了n!种本质不同的字符串,所以说直接做即可</p>
<p>所以说求出最长这个拓扑图上路径即可</p>
<p>D3</p>
<p>A</p>
<p>随便统计一下都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的....就可以知道所以人在行列的排名,就可以用类似map的东西计数</p>
<p>B</p>
<p>艹...一开始傻逼了</p>
<p>就是直接dp,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数,然后最后有j个数本质不同的方案数</p>
<p>钦点我们不转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>即可......</p>
<p>额鹅鹅鹅这个比ARC原题弱100倍我还是sb了</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 5005;
int n, m, P;
int f[MAXN][MAXN], sum[MAXN][MAXN];

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;P);
	f[0][0] = 1;//没意思
	sum[0][0] = 1;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt; m; ++j) {
			if(j)
				add(f[i][j], 1ll * f[i - 1][j - 1] * (m - j + 1) % P); //接
			add(f[i][j], sum[i - 1][j]); //长度大于j的直接做
		}
		for(int j = m - 1; j &gt;= 1; --j) {
			sum[i][j] = sum[i][j + 1];
			add(sum[i][j], f[i][j]);
		}
	}
	printf(&quot;%d\n&quot;, sum[n][1]);
	return 0;
}


</code></pre>
<p>C</p>
<p>这什么超级弱化版啊</p>
<p>线段树</p>
<p>对于操作1,我们记录区间距离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>最近的值(+-)</p>
<p>然后我们修改如果能够改掉就向下递归即可</p>
<p>操作2显然只能影响一个数,带来的额外代价也就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>没有什么....TLE的可能呢</p>
<p>咕咕咕</p>
<p>D4</p>
<p>A</p>
<p>真的....很傻啊</p>
<p>一个子图只能是几个森林</p>
<p>但凡存在非森林(环)部分,我们把那个环提出来,然后那个又不合法了</p>
<p>所以说我们只需要求出一个最大生成树,然后之外的全部删掉即可</p>
<p>B</p>
<p>猜到了结论,没有做法</p>
<p>显然我们一定最多只会选择两个....</p>
<p>因为但凡选择第三个,游戏结束后,我们可以删除掉<strong>不包括第一次重复元素</strong>的集合,就变成两个了</p>
<p>然后我们就能发现可以直接计数了</p>
<p>因为我们第一个集合选择了元素i之后</p>
<p>我们一定会在某个另一个集合选择qwq,直到那个数出现,这个次数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>(包含i的集合中本质不同的数字种类数)</p>
<p>那么这个就直接预处理,排序!</p>
<p>但是要小心二者是一个集合的情况</p>
<p>只在一个集合选择,答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,前提是有多个元素</p>
<p>C</p>
<p>差不许多</p>
<p>会发现我们可以树链剖分维护一下树上路径区间线性基?</p>
<p>怎么实现复杂度都很自闭,三个log?</p>
<p>完蛋完蛋</p>
<p>我们可以考虑分治?</p>
<p>就是处理所有经过mid的询问</p>
<p>预处理一个从mid开始前缀的线性基,一个mid开始后缀线性基</p>
<p>然后两个线性基可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>加(合并)</p>
<p>那么把两边加起来即可</p>
<p>好像复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nloglogMax)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>因为我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mlog^2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>根本算不上号!</p>
<p>rqy的实现方法</p>
<p>本质不同的线性基只有logMax个,我们记录左边的,左边全部处理出来,挂到log个地方</p>
<p>然后我们扫描线一个r,从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>,插入一个元素就暴力插入之前所有线性基位置,插不动就停下</p>
<p>因为这些线性基本质相同(相互包含),所以l从大到小考虑每次都能用上一次结果-&gt;?</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logMax)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>就能完成答案了!</p>
<p>? : 类似于之前区间线性基,就是维护[l,mid]每个基最靠右的位置,这样我们插入的时候就能很开心的只更新log个位置(因为看上去只有一个基)</p>
<p>D5</p>
<p>长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的序列A，其中的每个数都是不大于n的正整数，且n以内每个正整数至少出现一次。</p>
<p>对于每一个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1,..,n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，求出的本质不同的长度为k的子序列(不一定要连续)的数量。对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模。</p>
<p>直接计数.....</p>
<p>首先选出子序列方案数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{i}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.255674em;vertical-align:-0.35001em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span></p>
<p>然后发现算重了一个,就是前面某个位置k和后面某个相同位置j,在k前和j后选择从而凑齐了k的方案数</p>
<p>减去即可,时间复杂度O(n)</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int P = 1e9 + 7;
using namespace std;
const int MAXN = 3e5 + 7;
int n, rc1, rc2;
int a[MAXN], vis[MAXN];
int fac[MAXN], ifac[MAXN];

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void init() {
	fac[0] = 1;
	ifac[0] = 1;
	for(int i = 1; i &lt;= n; ++i)fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[n] = ksm(fac[n], P - 2);
	for(int i = n - 1; i &gt;= 1; --i)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	return ;
}

inline ll C(int n, int m) {
	if(n &lt; m)return 0;
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	++n;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		if(vis[a[i]]) {
			rc1 = vis[a[i]];
			rc2 = i;
		}
		vis[a[i]] = i;
	}
	init();
	for(int i = 1; i &lt;= n; ++i) {
		ll ans = C(n, i);
		ans = ans - C(rc1 - 1 + n - rc2, i - 1) + P; //这个会算重
		ans = ans % P;
		printf(&quot;%lld\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<p>B</p>
<p>首先转化每一个数为下标和权值的差,这个小于0就别想了</p>
<p>那么一个数能放的位置是固定的....</p>
<p>而且我们有这个数前面要删掉多少数才能凑齐的一个要求</p>
<p>感觉上就是一个上升子序列了的...</p>
<p>这个看上去就是吧?</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数,而且满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">A_i==i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>最长子序列</p>
<p>转移?我们可以发现,一个数i能转移到j当且仅当</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><msub><mi>a</mi><mi>j</mi></msub><mo>&lt;</mo><mi>i</mi><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">a_i-a_j&lt;i-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>就是说这个满足条件..相当于我们有足够多的空位删掉</p>
<p>那么这个转移优化很显然了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>−</mo><mi>i</mi><mo>&lt;</mo><msub><mi>a</mi><mi>j</mi></msub><mo>−</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">a_i-i&lt;a_j-j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></p>
<p>那么我们就可以二维数点啦!!</p>
<p>C</p>
<p>一开始假假假了</p>
<p>就是想枚举一些编号,然后看这些点能否形成连通块这样子</p>
<p>显然我们可以花费额外的代价选点使他们连通</p>
<p>那我们换个思路,改为枚举一下区间后,包括这些点的最小连通块大小</p>
<p>有一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>做法,就是每次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>判断</p>
<p>判断方法也很简单,我们从每一个点开始dfs,找到一个点就把这个点到那个点路径全染上色继续dfs</p>
<p>直到染色的为一个连通块</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>发现我们有单调性</p>
<p>就是说随着左端点向右移,右端点也只能单调向右移动</p>
<p>因为我们一定是上次连通块变大才可能行啊,我们删掉点了嘛...</p>
<p>那么我们直接双指针即可</p>
<p>而优化这个,就是在判断上下功夫</p>
<p>结论:一个点集连通所需必要点数为,按照dfs序排序后每个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_i{dis(i,i+1)}+dis(1,n)/2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497100000000001em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>这个包括点集内部已经选上的点啊</p>
<p>所以说我们如果能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>w</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">twopointer</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>时快速维护这个式子就做完了</p>
<p>发现是前驱/后继信息查询,还真能set,做完了</p>
<p>D6</p>
<p>A</p>
<p>发现可以做</p>
<p>就是说我们暴力枚举的复杂度是允许的,因为均摊是O(m)的</p>
<ol>
<li>枚举每一行的点</li>
<li>枚举每一列的点</li>
<li>枚举每一个左上-右下对角线的点</li>
<li>枚举每一个左下-右上对角线的点</li>
</ol>
<p>然后就做完啦</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>B</p>
<p>直接dp不太行吗?嗯,会计重</p>
<p>就是说我们第一个梯子成为目标的同时第二个梯子也可能成为了目标</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑了前i层,然后距离最近的为了满足条件的梯子为j,以及现在选择的是哪个去满足</p>
<p>不行,就是这样计重啦</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k,l,m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示考虑前i个层,j,k,l,m为最近的横木距离多少</p>
<p>然后转移放在哪里即可</p>
<p>但是最后答案呢?</p>
<p>发现我们可以用额外的0/1?不不不,如果这一维为h就不变(h-&gt;h),否则我们才想(x-&gt;x+1)</p>
<p>最后答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>h</mi></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f_{n,x,h,h,h}+f_{n,h,x,h,h}+f_{n,h,h,x,h}.....</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>正解?</p>
<p>我们再压掉一维就好了....</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j,k,l,m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i层,然后在这一层放横木的梯子<strong>能否爬到这一行</strong>,k,l,m还是和之前相同</p>
<p>转移靠....</p>
<p>考虑我们怎么转移??</p>
<p>如果放在相同位置,直接变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">{i+1,j+1,k+1,l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></span></p>
<p>如果放在不同位置,如果为0(可以爬到这一行),相当于我们已经要计算下一个能否爬过来,也就是说只有当这个第一个状态为h的时候才不行</p>
<p>变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo separator="true">,</mo><mi>i</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mn>3</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mn>1</mn><mo>=</mo><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">{h,i2+1,i3+1,i1==h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">h</span></span></span></span></span>(为1是爬不到了)</p>
<p>其他三个也同理</p>
<p>然后如果为0,相当于我们这一层爬的他如果要放给其他的,距离只能是距离1,同时其他的也一样,要么平移要么直接给第三维</p>
<p>虽然我们已知dynamic状态,还是不会计重</p>
<p>最后统计所有可行状态方案数之和即可</p>
<p>写的时候注意有一个亡命状态叫做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{h,h,h,1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span></span></span>,就是说我四个梯子都挂了....千万不能算上他.....</p>
<p>代码中钦点第一维大于=第二维大于=第三维,,而且第四维为1代表不能....qwq</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 32;
const int P = 1e9 + 9;
int n, f[MAXN][MAXN][MAXN][2], g[MAXN][MAXN][MAXN][2], h;

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;h);
	f[0][0][0][0] = 1;
	for(int i = 0; i &lt; n; ++i) {
		for(int j = h; j &gt;= 0; --j) {
			for(int k = j; k &gt;= 0; --k) {
				for(int l = k; l &gt;= 0; --l) {
					for(int m = 0; m &lt; 2; ++m) {
						if(m == 1 &amp;&amp; j == h &amp;&amp; k == h &amp;&amp; l == h)continue;
						add(g[min(j + 1, h)][min(k + 1, h)][min(l + 1, h)][m], f[j][k][l][m]);
						if(m) {//如果没有
							add(g[h][min(k + 1, h)][min(l + 1, h)][j == h], f[j][k][l][m]);
							add(g[h][min(j + 1, h)][min(l + 1, h)][k == h], f[j][k][l][m]);
							add(g[h][min(j + 1, h)][min(k + 1, h)][l == h], f[j][k][l][m]);
						} else {
							add(g[min(k + 1, h)][min(l + 1, h)][1][j == h], f[j][k][l][m]);
							add(g[min(j + 1, h)][min(l + 1, h)][1][k == h], f[j][k][l][m]);
							add(g[min(j + 1, h)][min(k + 1, h)][1][l == h], f[j][k][l][m]);
						}
					}
				}
			}
		}
		for(int j = h; j &gt;= 0; --j) {
			for(int k = j; k &gt;= 0; --k) {
				for(int l = k; l &gt;= 0; --l) {
					for(int m = 0; m &lt; 2; ++m) {
						f[j][k][l][m] = g[j][k][l][m];
						g[j][k][l][m] = 0;
					}
				}
			}
		}
	}
	int ans = 0;
	for(int j = h; j &gt;= 0; --j) {
		for(int k = j; k &gt;= 0; --k) {
			for(int l = k; l &gt;= 0; --l) {
				for(int m = 0; m &lt; 2; ++m) {
					if(m == 1 &amp;&amp; j == h &amp;&amp; k == h &amp;&amp; l == h)continue;
					add(ans, f[j][k][l][m]);
				}
			}
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>C</p>
<p>显然可以扫描线,先预处理每个颜色向前跳一步是哪个位置</p>
<p>然后我们动态维护一个向前跳T步跳到的位置,....静态维护也行</p>
<p>回答所有右端点在j的答案,显然线段树维护所有左端点在某个区间的询问的答案</p>
<p>然后我们有对于一个颜色相当于向前跳T步位置+1,向前跳T+1步的位置-1</p>
<p>查询答案就是一个区间和查询,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[L,R]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">]</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span></p>
<p>六场完结,有机会会更新六场热身赛的题解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[qbxt D10 && NOIP提高组考前刷题冲刺班（第十场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/qbxt-d10-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-shi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/qbxt-d10-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-shi-chang/">
        </link>
        <updated>2020-11-29T06:32:08.000Z</updated>
        <content type="html"><![CDATA[<p>全场最佳 A</p>
<p>A</p>
<p>显然操作顺序和最后结果无关</p>
<p>因为我们最后都是从两边移走1</p>
<p>具体的我们可以枚举一下哪个是1哪个是0,以及两边的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_1,a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><mn>2</mn><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">a_1-2x_1+x_2=0/1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是操作多少次,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是位置1的值,对二取模</p>
<p>第二个</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>2</mn><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><mo>=</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">a_2+x_1-2x_2+x_3=0/1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span></span></span></span></p>
<p>我们对于这些方程高斯消元....</p>
<p>然鹅只有一组整数解</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2</mn><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mi>b</mi><mo>+</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">-2x_1+x_2=b+0/1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span></span></span></span></p>
<p>第二个</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><mn>2</mn><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>x</mi><mn>3</mn></msub><mo>=</mo><mi>c</mi><mo>+</mo><mn>0</mn><mi mathvariant="normal">/</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x_1-2x_2+x_3=c+0/1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span></span></span></span></p>
<p>然后我们有n个方程....</p>
<p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>操作了k次,那么换序之后还是操作了k次,消完之后会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的系数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>那么就是n+1倍<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>b</mi><mo>+</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x_1=b+[0,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></p>
<p>所以只能有一个整数解(不可能两倍...)</p>
<p>接着第二个到最后一个也这样做</p>
<p>就可以递归证明</p>
<p>具体实现,你会发现操作一次相当于前面的一个0向后移动一位</p>
<p>然后我们就能用一个栈模拟一下了...</p>
<pre><code class="language-cpp">
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
int n, st[20000005], tp, a[20000005];
char s[20000005];
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%s&quot;, s + 1);
	n = strlen(s + 1);
	for(int i = 1; i &lt;= n; i++)
		a[i] = s[i] - '0';
	for(int i = 1; i &lt;= n; i++) {
		if(a[i] == 0) {
			st[++tp] = i;
			continue;
		}
		if(a[i] == 1) continue;
		st[++tp] = i;
		while(tp &amp;&amp; i - st[tp] + 1 &lt;= a[i]) {
			int nw = i - st[tp] + 1;
			a[i] -= nw;
			a[i + 1] += nw - 1;
			tp--;
		}
		//	printf(&quot;a=%d\n&quot;,a[i]);
		if(tp) {
			int nw = a[i];
			a[i + 1] += nw;
			st[tp] += nw;
		} else {
			a[i + 1] += a[i] - a[i] / (i + 1);
			int q = a[i] % (i + 1);
			if(q) st[++tp] = q;
		}
		/*	printf(&quot;i=%d,tp=%d\n&quot;,i,tp);
			for(int j=1;j&lt;=tp;j++)
				printf(&quot;%d &quot;,st[j]);
			printf(&quot;\n&quot;);*/
	}
	for(int i = 1; i &lt;= n; i++)
		s[i] = '1';
	for(int i = 1; i &lt;= tp; i++)
		s[st[i]] = '0';
	s[n + 1] = 0;
	printf(&quot;%s&quot;, s + 1);
	return 0;
}





</code></pre>
<p>B</p>
<p>怎么不重啊??</p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>,会发现这个区间有一些数i是满足的,当且仅当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mfrac><mi>i</mi><mi>l</mi></mfrac><mo>⌉</mo><mo>!</mo><mo>=</mo><mo>⌊</mo><mfrac><mi>i</mi><mi>r</mi></mfrac><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lceil \frac i l \rceil!=\lfloor \frac i r \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.200664em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.855664em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span></p>
<p>那么会发现这两个只有根号个区间,然后区间差分加法即可....</p>
<p>做法2</p>
<p>对于第i步,小于i的区间一定最多只会计算1次</p>
<p>然鹅大于等于i的区间一定都计入....</p>
<p>所以说我们第一个直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlnnlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>统计</p>
<p>后一个直接双指针</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 6e5 + 7;
int n, m, l[MAXN], r[MAXN];
struct qwq {
	int l, r;
	bool operator&lt;(const qwq &amp;x) {
		return r - l + 1 &lt; x.r - x.l + 1;
	}
} e[MAXN];
struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN];
	inline void add(int x, int v) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += v;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tr;
int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d%d&quot;, &amp;e[i].l, &amp;e[i].r);
	sort(e + 1, e + m + 1);
	int L = 1;
	for(int i = 1; i &lt;= n; ++i) {
		for(; L &lt;= m &amp;&amp; e[L].r - e[L].l + 1 &lt; i; ++L) {
			tr.add(e[L].l, 1);
			tr.add(e[L].r + 1, -1);
			// printf(&quot;%d %d\n&quot;, i, L);
		}
		int ans = 0;
		for(int j = i; j &lt;= n; j += i) {
			ans += tr.qry(j);
		}
		ans += m - L + 1;
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>所有相邻的波峰-波谷</p>
<p>然鹅不需要维护峰,直接维护这个差分数组</p>
<p>区间加也变成sb了!甚至不需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">pushdown</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span></span></span></span></p>
<p>就能轻松过第一问</p>
<p>然后第二问,我们要维护一下开头和结尾的差分值,以及每个位置向后第一个大于0的值是啥</p>
<p>看看实现吧!</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int MAXN = 5e5 + 7;
int T, n, q;
ll a[MAXN], b[MAXN];
struct rec {
	ll st, ed, cnt, stf, edf;
	ll ans;
	//开头,结尾的权值
	//一共的答案
	//cnt的记录
	//合并的时候,如果能拼起来,我们就拼,开头大于等于结尾
	//查询某个数前面第一个数&lt;=0?
	//嗯嗯额!
	//stf是除去0的第一个数
} tr[MAXN];
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE, IOerror;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		if(p1 == pend)IOerror = -1;
		if(IOerror == -1)return IOerror;
		return *p1++;
	}
	inline int read() {
		int x = 0, f = 1;
		char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;
#define mid ((l+r)&gt;&gt;1)

inline void pushup(int k) {
	tr[k].stf = tr[k &lt;&lt; 1].stf;
	tr[k].edf = tr[k &lt;&lt; 1 | 1].edf;
	if(tr[k].stf == 0) {
		tr[k].stf = tr[k &lt;&lt; 1 | 1].stf;
	}
	if(tr[k].edf == 0) {
		tr[k].edf = tr[k &lt;&lt; 1].edf;
	}
	tr[k].st = tr[k &lt;&lt; 1].st;
	tr[k].ed = tr[k &lt;&lt; 1 | 1].ed;
	tr[k].ans = tr[k &lt;&lt; 1].ans + tr[k &lt;&lt; 1 | 1].ans;
	tr[k].cnt = tr[k &lt;&lt; 1].cnt + tr[k &lt;&lt; 1 | 1].cnt;
	if(tr[k &lt;&lt; 1].edf &gt; 0 &amp;&amp; tr[k &lt;&lt; 1 | 1].stf &gt; 0 &amp;&amp; tr[k &lt;&lt; 1 | 1].st &gt;= 0)--tr[k].cnt;
	// printf(&quot;%d %lld %d qwq\n&quot;, k, tr[k].ans, tr[k].cnt);
	//开头大于等于0,且两端第一个数都是大于0的,那么我们就可以拼起来
}

inline void build(int k, int l, int r) {
	if(l == r) {
		tr[k].st = tr[k].ed = tr[k].stf = tr[k].edf = b[l];
		if(tr[k].st &gt; 0) {
			tr[k].ans = tr[k].st;
			tr[k].cnt = 1;
		} else {
			tr[k].ans = 0;
			tr[k].cnt = 0;
		}
		return;
	}
	// printf(&quot;build : %d %d %d ?? \n&quot;, k, l, r);
	build(k &lt;&lt; 1, l, mid);
	build(k &lt;&lt; 1 | 1, mid + 1, r);
	pushup(k);
}

inline void mdf(int k, int l, int r, int P, int v) {
	// printf(&quot;mdf : %d %d %d %d %d %d %d %d %d\n&quot;, k, l, r, P, v, tr[k].st, tr[k].ed, tr[k].edf, tr[k].stf);
	if(l == r) {
		tr[k].st += v;
		tr[k].ed = tr[k].stf = tr[k].edf = tr[k].st;
		if(tr[k].st &gt; 0) {
			tr[k].ans = tr[k].st;
			tr[k].cnt = 1;
		} else {
			tr[k].ans = 0, tr[k].cnt = 0;
		}
		return ;
	}
	if(P &lt;= mid)mdf(k &lt;&lt; 1, l, mid, P, v);
	else mdf(k &lt;&lt; 1 | 1, mid + 1, r, P, v);
	pushup(k);
	return ;
}

int main() {
	// freopen(&quot;test2.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test3.out&quot;, &quot;w&quot;, stdout);
	T = read();
	while(T-- &gt; 0) {
		n = read();
		q = read();
		for(int i = 1; i &lt;= n; ++i)a[i] = read();
		for(int i = 2; i &lt;= n; ++i)b[i] = a[i] - a[i - 1];
		b[1] = -1e16;//来来
		build(1, 1, n);
		for(int i = 1, x, y, z; i &lt;= q; ++i) {
			x = read();
			if(x == 1)printf(&quot;%lld %lld\n&quot;, tr[1].ans, tr[1].cnt * 2);
			else {
				x = read();
				y = read();
				z = read();
				if(x &gt; 1)
					mdf(1, 1, n, x, z);
				if(y + 1 &lt;= n)
					mdf(1, 1, n, y + 1, -z);
			}
		}
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>第一问n&lt;=300,直接枚举那一列跳下去</p>
<p>因为我们显然会选择一列走下去而不会多列</p>
<p>subtask 3</p>
<p>所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都相同?</p>
<p>那么我们可以考虑发现这个东西从哪拐下去对于最大的那个y,之后的y这个选择都是单调递减的</p>
<p>所以说我们可以发现这个东西有决策单调性,也就是说我们决策单调递增....</p>
<p>所以说我们走到第i个点花费为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>y</mi></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><mo>(</mo><mi>x</mi><mo>−</mo><mi>y</mi><mo>+</mo><mi>i</mi><mo>)</mo><mo>∗</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_y-s_i+(x-y+i)*a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是对于i的决策点</p>
<p>那每一列对于后面的贡献是一次函数</p>
<p>每次加入一个新的决策(列)y,我们可以弹掉最后一段决策....</p>
<p>然后我们就能分治决策单调性?!</p>
<p>首先最优方案不会劣于我们的当前决策点</p>
<p>而对于一个点,他的最优决策向下,那之后状态他的最优决策也是向下</p>
<p>对于同一行也是一样的</p>
<p>你会发现从k到k+1列,他同行决策点只能单调向右上移动</p>
<p>所以说新的一列,我们会发现他只存在从y轴下到上的一群决策点他们是变为向下走的!</p>
<p>那也就是说我们可以把所有询问离线挂到一列上</p>
<p>然后一下改一群决策点的答案,于是我们就可以一下回答一群</p>
<p>tyy:</p>
<p>设(x,y),然后发现这个东西转移很斜率优化</p>
<p>而这个东西不是很能斜率优化....因为我们会走到小于y的,不能做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>的凸包斜率优化</p>
<p>但是提前n个点都知道,可以线段树建立凸包</p>
<p>排序要归并排序</p>
<p>然后会发现询问要定位到logn个节点,然后每次都二分又是两个log</p>
<p>所以说我们可以按照斜率排序所有询问,然后每个节点记录一下当前匹配到那个位置,然后从那个位置向后跳....</p>
<p>E</p>
<p>有些数是随便的,然后我们要向其中填入数,使得序列逆序对个数最小</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>4</mn><mo separator="true">,</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e4,k&lt;=100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p>dp,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数,最后一个数放j的逆序对数</p>
<p>会发现这个j单调递增,所以直接转移即可</p>
<p>然鹅小心这个东西T了,可以前缀和优化或者内部转移</p>
<p>F</p>
<p>Bzoj4361:isn</p>
<p>容斥?</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数长度为j的递增子序列方案数</p>
<p>然后转移直接枚举树状数组优化</p>
<p>统计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">g_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示长度为i递增子序列方案数</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mn>1</mn><mo>=</mo><msub><mi>g</mi><mi>i</mi></msub><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ans1=g_i*(n-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.6597200000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>这样算重了,因为可能在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>已经删成递增了....</p>
<p>然后容斥....你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msub><mi>g</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><mi>f</mi><mi>a</mi><mi>c</mi><mo>[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mo>(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">-g_{i+1}*fac[n-i-1]*(i+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>即可容斥</p>
<p>G</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>50</mn></mrow><annotation encoding="application/x-tex">n&lt;=50</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span></span></span></span></p>
<p>划分成两个集合,满足两个集合and起来为一个数</p>
<p>那么显然枚举一个数大小,钦点这个集合内的数都选上,然后容斥即可</p>
<p>H</p>
<ol>
<li>
<p>所有x-&gt;y</p>
</li>
<li>
<p>查询两两颜色相邻最小距离</p>
</li>
</ol>
<p>分块</p>
<p>预处理每个大颜色和所有小颜色距离</p>
<p>预处理一个要并进去的答案,然后如果并进去的大小大于根号就暴力重构</p>
<p>I</p>
<p>三个相同颜色的卡死一个集合</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[qbxt D9 && NOIP提高组考前刷题冲刺班（第九场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/qbxt-d9-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-jiu-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/qbxt-d9-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-jiu-chang/">
        </link>
        <updated>2020-11-28T10:36:41.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>不用讲了</p>
<p>B</p>
<p>不用讲了</p>
<p>倍增DP是可以的!</p>
<p>可以组合计数!</p>
<p>C</p>
<p>不用讲了</p>
<p>容斥,注意乘上每个组内部排序(3!的次方)的方案数</p>
<pre><code class="language-cpp">

//容斥
#include&lt;bits/stdc++.h&gt;
const int MAXN = 4e6 + 7;
#define ll long long
using namespace std;
const int P = 998244353;//摸错人
int n, N;
int fac[MAXN], ifac[MAXN];
ll cf6[MAXN];
inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

inline void add(ll &amp;x, ll y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline void sub(ll &amp;x, ll y) {
	x -= y;
	if(x &lt; 0)x += P;
}

inline void init() {
	fac[0] = 1;
	ifac[0] = 1;
	for(int i = 1; i &lt;= N; ++i)fac[i] = 1ll * fac[i - 1] * i % P;
	ifac[N] = ksm(fac[N], P - 2);
	for(int i = N - 1; i &gt;= 1; --i)ifac[i] = 1ll * ifac[i + 1] * (i + 1) % P;
	cf6[0] = 1;
	for(int i = 1; i &lt;= n; ++i)cf6[i] = cf6[i - 1] * 6 % P;
	return;
}

inline ll C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % P * ifac[n - m] % P;
}

inline void solve() {
	ll ans = fac[N];
	for(int i = 1; i &lt;= n; ++i) {
		if(i &amp; 1)sub(ans, cf6[i] * C(n, i) % P * fac[N - 2 * i]  % P);
		else add(ans, cf6[i] * C(n, i) % P * fac[N - 2 * i]  % P);
	}
	printf(&quot;%lld\n&quot;, ans);
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	N = 3 * n;
	init();
	solve();
	return 0;
}

</code></pre>
<p>D</p>
<p>直接树套树剖竟然三个log过5e5</p>
<p>一个点在这个路径上,和其中某几个端点查LCA一定是这个路径本身,或者这个dis和等于两点距离</p>
<p>那么我们能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>预处理然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>查询!</p>
<p>OnO1rmq....其实写n^2暴力没有这么复杂吧.....</p>
<p>最小值可以二分一下?假设答案至少为x</p>
<p>相当于小于x的路径和节点都有交集</p>
<p>树链求交</p>
<p>四个端点两两LCA(一条路径上的除外)</p>
<p>然后LCA排序一下重复的和不在路径上的点去掉后选后两个</p>
<p>大概分类讨论一下</p>
<p>我们能维护这个交集</p>
<p>把链按照权值排序,求一个前缀交集和后缀交集</p>
<p>二分这个点的答案</p>
<p>大概可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>这样不带删除或者修改操作就解决了</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>D</mi><mi>Q</mi></mrow><annotation encoding="application/x-tex">CDQ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">Q</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">离</mi><mi mathvariant="normal">线</mi></mrow><annotation encoding="application/x-tex">离线</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">线</span></span></span></span></li>
</ol>
<p>线段树分治吧?</p>
<p>就是考虑单点修改直接改,然后回溯回复整个序列</p>
<p>线段树直接做?</p>
<p>就是离线,把所有可能的边情况拿出来</p>
<p>然后排序,建立线段树,之后就是一个区间路径交的维护</p>
<p>然后我们就能做了?</p>
<p>卢卡斯</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;EOF&#039; at end of input: …/p}*C_{n%P,m%P}'>C_{n,m}=C_{n/p,m/p}*C_{n%P,m%P}</span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{n,m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> %P</p>
<p>模合数?</p>
<p>可以质因数分解为每个,然后再做下面的阶乘</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>!</mo><mo>=</mo><msup><mi>p</mi><mi>a</mi></msup><mi>N</mi></mrow><annotation encoding="application/x-tex">n!=p^aN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>,然后觳觫的部分直接做(互素)</p>
<p>P=1e9+7</p>
<p>第k小子集和</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">n&lt;=30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></p>
<p>二分一下</p>
<p>然后mit in middle即可判断这个的rank</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[qbxtD8 && NOIP提高组考前刷题冲刺班（第八场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/qbxtd8-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-ba-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/qbxtd8-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-ba-chang/">
        </link>
        <updated>2020-11-28T00:47:37.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>直接做</p>
<p>注意答案和0取max</p>
<p>B</p>
<p>从最后一个区间向前考虑,每个区间和前面区间有交集则要向前延伸</p>
<p>然后每个区间一开始左端点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>d</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>−</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">ddl time-t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></p>
<p>C</p>
<p>直接暴力dp的话</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个数,最后一个数以j结尾的权值之和</p>
<p>这个转移的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>n</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlnn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">n</span></span></span></span>,并不优秀</p>
<p>如果j和k互质,那么我们有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>∗</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}*f_{i,k}=f_{i,j*k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">∗</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>然后你会发现我们就能线性筛了QAQ.....</p>
<p>本质上相当于我们把两个数写成质因数乘积</p>
<p>然后对于一个长度为n的序列,每个指数是单调不降的</p>
<p>乘起来相当于每个序列延长一下</p>
<p>然后我们就会发现这个东西可以线性筛了.....</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>如果我们预处理所有质数对于n的单独贡献,可以做到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>n</mi><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m+nm/lnm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int N = 1e7 + 5;
const int P = 1e9 + 7;
const int MAXN = 24;
const int MAXP = 664591;
bool vis[N];
int prim[N], num[N], mx[N], cnt, n, m;
int fst1[MAXP][MAXN], rc[MAXP];
int f[MAXP][MAXN], g[MAXP][MAXN], sum[MAXN], dp[N];
//我们只需要知道最小质因子
inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}
void init1() {
	cnt = 0;
	for (int i = 2 ; i &lt;= m; ++i) {
		if (!vis[i]) {
			prim[++cnt] = i;
			num[i] = 1;
			mx[i] = cnt;
		}
		for (int j = 1 ; j &lt;= cnt &amp;&amp; i * prim[j] &lt;= m; ++j) {
			vis[i * prim[j]] = 1;
			mx[i * prim[j]] = j;
			if (!(i % prim[j])) {
				num[i * prim[j]] = num[i] + 1;
				break;
			}
			num[i * prim[j]] = 1;
		}
	}
	ll V;
	for(int i = 1; i &lt;= cnt; ++i) {
		V = 1;
		for(int j = 0; V &lt;= m; ++j) {
			fst1[i][j] = V;
			rc[i] = j;
			V = V * prim[i];
		}
	}
}
inline void init2() {
	for(int q = 1; q &lt;= cnt; ++q) {
		for(int i = 0; i &lt;= rc[q]; ++i)sum[i] = 1;
		f[q][0] = 1;
		for(int i = 1; i &lt;= n; ++i) {
			for(int j = 0; j &lt;= rc[q]; ++j) {
				add(g[q][j], 1ll * sum[j] * fst1[q][j] % P);
			}
			f[q][0] = g[q][0];
			g[q][0] = 0;
			sum[0] = f[q][0];
			for(int j = 1; j &lt;= rc[q]; ++j) {
				f[q][j] = g[q][j];
				sum[j] = sum[j - 1];
				add(sum[j], f[q][j]);
				g[q][j] = 0;
			}
		}
		for(int j = 1; j &lt;= rc[q]; ++j)
			dp[fst1[q][j]] = f[q][j];
	}
	return ;
}

//题目加强了
inline void solve() {
	int ans = 1;
	dp[1] = 1;
	for(int i = 2; i &lt;= m; ++i) {
		dp[i] = 1ll * dp[fst1[mx[i]][num[i]]] * dp[i / fst1[mx[i]][num[i]]] % P;
		add(ans, dp[i]);
	}
	printf(&quot;%d\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	init1();
	init2();
	solve();
	return 0;
}

</code></pre>
<p>李队的杜教筛</p>
<p>很慢!</p>
<p>code:</p>
<pre><code class="language-cpp">
#pragma GCC optimize(3)
#include&lt;bits/stdc++.h&gt;
#define R register
#define ll long long
using namespace std;
const ll P = 1e9 + 7;
const ll MAXP = 4e5 + 7;
const ll mP = 4e5;
const ll N = 1e7 + 7;
ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1) ans *= x, ans %= P;
		x *= x, x %= P, y &gt;&gt;= 1;
	}
	return ans;
}
ll f[12][MAXP];
int m, n;
int q[N][10];
map&lt;ll, ll&gt; dp[11];
ll solve(ll x, ll y) {
	if(y == 1) return q[x][n - 1]; //sigma(x)
	if(x &lt;= mP) return f[y][x];
	if(dp[y][x]) return dp[y][x];
	R ll X = 0, i, j, t, p;
	for(i = 1; i &lt;= x; i = j + 1) {
		t = x / i;
		j = x / t;
		p = q[j][n - y] - q[i - 1][n - y];
		X += p * solve(t, y - 1) % P;
		X %= P;
	}
	X += P, X %= P;
	dp[y][x] = X;
	return X;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	ll tp = mP;
	R ll i, j, k, o, p;
	f[0][1] = 1;
	for(i = 1; i &lt;= m; ++i) {
		q[i][0] = i;
		for(j = 1; j &lt; n; ++j) q[i][j] = 1ll * q[i][j - 1] * i % P;
	}
	for(i = 1; i &lt;= n; ++i) {
		for(j = 1; j &lt;= tp; ++j) {
			p = tp / j;
			for(k = 1; k &lt;= p; ++k) {
				o = k * j;
				f[i][o] += f[i - 1][j] * q[k][n - i] % P;
				f[i][o] %= P;
			}
		}
	}
	for(i = 1; i &lt;= n; ++i) {
		for(j = 1; j &lt;= tp; ++j) {
			f[i][j] += f[i][j - 1];
			f[i][j] %= P;
		}
	}
	for(i = 0; i &lt; n; ++i)
		for(j = 1; j &lt;= m; ++j) {
			q[j][i] += q[j - 1][i];
			q[j][i] -= q[j][i] &gt;= P ? P : 0;
		}
	ll ans = solve(m, n);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}



</code></pre>
<p>D</p>
<p>删一条边 : 割边</p>
<p>删两条边</p>
<ol>
<li>
<p>G不连通</p>
</li>
<li>
<p>G连通</p>
</li>
</ol>
<p>先枚举一条边干掉</p>
<p>拉出生成树(dfs树)T</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">e1,e2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord">2</span></span></span></span>被完全相同的非树边覆盖了</p>
<p>a树边+非树边</p>
<p>e1不被覆盖</p>
<p>e1只被e2覆盖</p>
<p>b树边加树边</p>
<p>e1,e2被一样的覆盖</p>
<p>e1,e2不被一样的覆盖</p>
<p>给每条非树边一个随机权值,然后让树边的到一个所有的覆盖的非树边异或值</p>
<p>那么我们会发现第一种情况case1</p>
<p>树上一条边权值直接是0</p>
<p>case 2</p>
<p>树上一条边和其他的边权值相同</p>
<p>第二种情况case 3</p>
<p>树上两条边权值相同</p>
<p>此时删掉之后我们至少有一个点留出来?</p>
<p>case 4</p>
<p>树上两条边权值不同</p>
<p>删掉之后不会有影响</p>
<p>所以说我们只需要树上差分之后开个map统计一下即可</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^2logm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>py乘</p>
<p>$ (A<em>1e4+B)</em>(C<em>1e4+D)=AC</em>1e8+(AD+BC)*1e4+BD $</p>
<p>$ AD+BC=(A+B)(C+D)-AC-BD $</p>
<p>只需要三次乘法</p>
<p>T(n)=3T(n/2)+O(n)</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>1.58</mn></msup></mrow><annotation encoding="application/x-tex">n^{1.58}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>阿狸和桃子的游戏</p>
<p>....考...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[qbxtD7 && NOIP提高组考前刷题冲刺班（第七场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/qbxtd7-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-qi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/qbxtd7-and-noip-ti-gao-zu-kao-qian-shua-ti-chong-ci-ban-di-qi-chang/">
        </link>
        <updated>2020-11-27T06:42:57.000Z</updated>
        <content type="html"><![CDATA[<p>A</p>
<p>n^15</p>
<p>写的搜索</p>
<p>n<sup>2</sup>m那种</p>
<p>B</p>
<p>容斥</p>
<p>ljh:</p>
<p>是7的倍数,减去是2/3/5的倍数,+是6/10/15的倍数,-是30的倍数</p>
<p>my:</p>
<p>至少是2,3,5,7的倍数-至少是2,3,5的倍数</p>
<p>于是我们就可以写一个ljh的容斥,然后相减</p>
<p>C</p>
<p>最小化?/yun</p>
<p>我们可以维护一个矩阵,行表示a选什么列表示b选什么</p>
<p>然后我们就有某一个数是a,b都选之后这个矩阵只有一个矩阵下三角是满足的</p>
<p>然后相当于我们一个边就代表这里面一个点</p>
<p>把这个[ab]矩阵变成一个点,边变成一个矩阵</p>
<p>那么我们相当于给一个矩阵加1</p>
<p>然后要找一个点使得被最小的矩阵覆盖</p>
<p>可以进行扫描线</p>
<p>my:</p>
<p>额没有那么妙</p>
<p>就是考虑增量,对于一个右端点,用线段树维护所有左端点处答案</p>
<p>然后一路增量过去即可.....就是枚举新点的所有边然后区间修改</p>
<p>注意我们一条边再被经过时要改两次,就是左边被改一次右边被改一次....</p>
<p>时间复杂度都是O(nlogn)</p>
<p>code:</p>
<pre><code class="language-cpp">
//tsx线段树
//关门弟子
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 4e5 + 7;
int n, m, ccnt;
int home[MAXN], nxt[MAXN], to[MAXN];

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

struct rec {
	int adt;
	ll Mx;
	rec(int ADT = 0, ll Mix = 0): adt(ADT), Mx(Mix) {};
} tr[MAXN];

rec operator+(const rec &amp;x, const rec &amp;y) {
	rec nw = rec();
	nw.adt = x.adt + y.adt;
	nw.Mx = x.Mx + y.adt;
	return nw;
}

inline void calc(int k, int v) {
	tr[k].Mx += v;
	tr[k].adt += v;
	return;
}

inline void update(int k) {
	tr[k].Mx = min(tr[k &lt;&lt; 1].Mx, tr[k &lt;&lt; 1 | 1].Mx);
	return;
}

inline void pushdown(int k) {
	if(tr[k].adt) {
		calc(k &lt;&lt; 1, tr[k].adt);
		calc(k &lt;&lt; 1 | 1, tr[k].adt);
		tr[k].adt = 0;
	}
}

///jk
inline void add(int k, int l, int r, int L, int R, rec jk) {
	// printf(&quot;add : %d %d %d %d %d %lld V is %d\n&quot;, k, l, r, L, R, tr[k].Mx, jk.adt);
	if(L &lt;= l &amp;&amp; r &lt;= R) {
		calc(k, jk.adt);
		return ;
	}
	pushdown(k);
	int mid = (l + r) &gt;&gt; 1;
	if(L &lt;= mid)add(k &lt;&lt; 1, l, mid, L, R, jk);
	if(R &gt; mid)add(k &lt;&lt; 1 | 1, mid + 1, r, L, R, jk);
	update(k);
	return;
}

inline int qry(int k, int l, int r, int L, int R) {
	if(L &lt;= l &amp;&amp; r &lt;= R) {
		// printf(&quot;qry  : %d %d %lld\n&quot;, l, r, tr[k].Mx);
		return tr[k].Mx;
	}
	pushdown(k);
	int mid = (l + r) &gt;&gt; 1;
	if(R &lt;= mid)return qry(k &lt;&lt; 1, l, mid, L, R);
	else if(L &gt; mid)return qry(k &lt;&lt; 1 | 1, mid + 1, r, L, R);
	else return min(qry(k &lt;&lt; 1, l, mid, L, R), qry(k &lt;&lt; 1 | 1, mid + 1, r, L, R));
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1, x, y; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	int ans = 1e9;
	for(int u = 2; u &lt; n; ++u) {
		// printf(&quot;now is :%lld \n&quot;, u);
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			// printf(&quot;vis is %d\n&quot;, v);
			if(v &gt; u || v == 1) {
				add(1, 1, n, 2, u, rec(1, 0));
			} else {
				add(1, 1, n, v + 1, u, rec(1, 0));
				add(1, 1, n, 2, v, rec(-1, 0));
			}//如果包括了他们俩,就-1
			//显然左端点1不能成为答案吧
		}
		// printf(&quot;%d ?\n&quot;, qry(1, 1, n, 2, u));
		ans = min(ans, qry(1, 1, n, 2, u));//查询区间答案???
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
<p>D</p>
<p>首先直接dp要记录这个轮数</p>
<p>妈的不要</p>
<p>所以说我们发现这个转移矩阵是个循环矩阵</p>
<p>所以说我们就可以循环矩阵快速幂(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2log)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>,qc的做法)</p>
<p>但是写出转移式子就发现可以倍增做这个事情</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示2^i步,走j步的方案数</p>
<p>然后,,,,,我们就能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>了...</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑f_{i,j}表示前2^i轮,最后0号在j的方案数(走了j步)
//转移考虑两个拼起来的时候,对于位置x,我们有一个类似卷积的东西
//就是类似于走了y步,再去走k步,满足(x+k)%(n-1)==x
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 2000;
const int MAXlog = 40;
int n, m, t, d;
int a[MAXN];
int f[MAXlog][MAXN], g[MAXN], dp[MAXN];

inline void add(int &amp;x, int y) {
	x += y;
	if(x &gt;= P)x -= P;
}

inline void solve() {
	for(int i = 1; i &lt;= m; ++i)f[0][a[i]] = 1;
	for(int i = 1; i &lt;= 30; ++i) {
		for(int j = 0; j &lt; n; ++j) {
			for(int k = 0; k &lt; n; ++k) {
				add(f[i][(j + k) % n], 1ll * f[i - 1][k]*f[i - 1][j] % P);
			}
		}
	}
	//走0步,一步都不算
	g[0] = 1;
	for(int i = 0; i &lt;= 30; ++i) {
		if(t &gt;&gt; i &amp; 1) {
			// printf(&quot;%d ?\n&quot;, i);
			for(int j = 0; j &lt; n; ++j) {
				for(int k = 0; k &lt; n; ++k) {
					// printf(&quot;%d %d %d %d\n&quot;, j, k, f[i][k], g[j]);
					add(dp[(j + k) % n], 1ll * g[j]*f[i][k] % P);
				}
			}
			for(int j = 0; j &lt; n; ++j)g[j] = dp[j], dp[j] = 0;
		}
	}
	int ans = 0;
	// for(int i = 0; i &lt; n; ++i)printf(&quot;%d &quot;, g[i]);
	for(int i = 0; i &lt; n; i += d)add(ans, g[i]);
	printf(&quot;%d\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;t, &amp;d);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	solve();
	return 0;
}
/*

9 10 96318817 5
29086
14551
3546
12089
18582
10244
23380
4102
31676
31273


*/

</code></pre>
<p>全局最小割</p>
<p>钦定一个s,t</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是随便一个</p>
<p>然后选一个点i,然后使得i和前面的所有点连的边数最大</p>
<p>然后会发现这样能构造出一个序列</p>
<p>最后删掉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所有连边即可</p>
<p>但是还没有考虑两个点是合并的</p>
<p>也很简单,我们把两个点merge成一个点,然后再做上述过程</p>
<p>随后我们接着随便选,把剩下n-1个点合乘一个,所有过程答案求最小值即可</p>
<p>对于一个图,随机logn棵生成树,这log棵生成树不能有共同的边</p>
<p>随机G'有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>2</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">nlog^2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>条边</p>
<p>然后这些生成树中有一个生成树</p>
<p>最小的分割方案是会分成三份</p>
<p>所以说我们可以选两条边断掉,然后枚举其中一条用数据结构优化另一条的枚举</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>l</mi><mi>o</mi><msup><mi>g</mi><mn>3</mn></msup><mi>n</mi></mrow><annotation encoding="application/x-tex">mlog^3n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span></p>
<p>区间的代价为这一段的出现数字种类的平方</p>
<p>然后问总划分方案使得划分代价最小</p>
<p>首先都分成一段是可能优的答案为n</p>
<p>然后你会发现这个东西啊naive</p>
<p>因为平方上升,所以说我们直接枚举i前根号个不同的数字即可.....<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>c</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=f_j+cst(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p>这个预处理可以动脑子</p>
<p>平面最近点对</p>
<p>随便按横坐标劈开</p>
<p>然后分治左右得到答案d</p>
<p>然后中间合并的话.....</p>
<p>你会发现答案一定在x-d和x+d之间的范围内</p>
<p>然后把那些点找出来,按照纵坐标排序</p>
<p>考虑其中某一个点,向前后枚举几个点纵坐标距离差就已经超过d了...就停止</p>
<p>会发现这里我们只需要枚举几次就能超越d</p>
<p>然后又会发现这个三角形咋办啊</p>
<p>枚举一个,剩下的都在附近??</p>
<p>从中间分开,算左右答案</p>
<p>现在我们只需要看x-d和x+d的</p>
<p>纵坐标排序</p>
<p>剩下两个点只能在y+d范围</p>
<p>然后感觉一下,这个点不会很多</p>
<p>我们先枚举第一个,再枚举第二个并用第一个第二个距离再减第三个的纵坐标范围</p>
<p>n个点,m条边的有向图</p>
<p>然后在i点选操作j有得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>下一秒所在的点可能在这个点指出去的某个点</p>
<p>有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">p_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示i这个点做操作j到点k的概率</p>
<p>保证和为1</p>
<p>最小化t=0时的得分期望</p>
<p>1e-6误差</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示t=0在i的最小得分</p>
<p>初始化....f=0,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">f^{(k)}_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.27686399999999994em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.27686399999999994em;"><span></span></span></span></span></span></span></span></span></span>表示第k次计算是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值</p>
<p>每一步</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mrow><mo>(</mo><mi>k</mi><mo>)</mo></mrow></msubsup><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>a</mi></msub><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>a</mi></mrow></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>∗</mo><munder><mo>∑</mo><mi>j</mi></munder><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msubsup><mi>f</mi><mi>j</mi><mrow><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow></msubsup></mrow></mrow></mrow><annotation encoding="application/x-tex">f^{(k)}_{i}=min_a{C_{i,a}+\frac 1 2*\sum_j {p_{i,a,j}*f^{(k-1)}_j}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.321664em;vertical-align:-0.276864em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.276864em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.735217em;vertical-align:-1.413777em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后多算几轮,知道快超时就输出,使得误差很小</p>
<p>(差不多三四十次就好了....)</p>
<p>然后这里老师数学分析了一下,证明这个误差确实不会很大</p>
<p>牛顿迭代</p>
<p>找到某个点,然后搞一个直线(导数)</p>
<p>从直线出发求交点横坐标然后带入再求导</p>
<p>再求那个导数的交点横坐标......</p>
<p>一直迭代直到找到0点</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">loglogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span></p>
<p>P4055 [JSOI2009]游戏</p>
<p>显然是二分图染色后跑最大匹配,非必须点就是可行的答案</p>
<p>然后我们可以从不在最大匹配的(一定是非匹配点)点集中向最大匹配点走沿着匹配边,和i同一侧的点都是非必须的</p>
<p>因为至少有一种方案是选上i</p>
<p>SP11469 SUBSET - Balanced Cow Subsets</p>
<p>先除半,然后左边有10个点,右边有10个</p>
<p>我们左边的和为a,右边的和为b,左边另一堆数和为c,右边另一堆数和为d</p>
<p>a+b=c+d</p>
<p>a-c=d-b</p>
<p>相当于我们左边枚举子集得到所有可能的差</p>
<p>然后右边也一样做做</p>
<p>利用map来匹配一下!</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>3</mn><mfrac><mi>n</mi><mn>2</mn></mfrac></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(3^{\frac n 2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.09708em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.84708em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915428571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4049 [JSOI2007]合金]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4049-jsoi2007he-jin/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4049-jsoi2007he-jin/">
        </link>
        <updated>2020-11-27T04:26:53.000Z</updated>
        <content type="html"><![CDATA[<p>啊啊啊唐爷爷强</p>
<p>这个和之前那个很相近啊,就是钟神出的b题</p>
<p>首先把一个三元的是没用的,知道前两个就知道第三个了</p>
<p>拿前两个元素作为坐标,每个点拍到平面上</p>
<p>我们就会发现,这个操作类似于一个加权平均数,也就是类似于表示出一些向量围成的面积</p>
<p>三个点就是三角形内的点都能表示</p>
<p>n个点就是凸包内的点都能表示</p>
<p>现在我们想选出最少的边使得所有目标点被圈在中间</p>
<p>首先你会发现这些边一定是包括了所有目标点凸包</p>
<p>也就是所有点都在这个边的一侧</p>
<p>用叉积,叉积大于0在左侧,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mn>1</mn><mi>y</mi><mn>2</mn><mo>−</mo><mi>x</mi><mn>2</mn><mi>y</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1y2-x2y1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span></span></span></span></p>
<p>然后我们就能<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>∗</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^2*n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>找到所有合法边了</p>
<h2 id="找到以后呢按照传统oi点到为止的规则这个题已经切了">找到以后呢?按照传统OI点到为止的规则,这个题已经切了</h2>
<p>但是他不讲武德,还是要求一个最小环</p>
<h2 id="最小环我防出去了防出去了啊">最小环我防出去了,防出去了啊</h2>
<p>然后它来了个点在线段/直线上</p>
<h2 id="我反手一个点积大于0判掉所有在直线上的">我反手一个点积大于0判掉所有在直线上的</h2>
<p>然后此时他竟然来一个点就能成为答案的</p>
<h2 id="我大意了啊没有闪">我大意了啊,没有闪</h2>
<p>于是90好几发</p>
<p>code:</p>
<pre><code class="language-cpp">
//考虑怎么做?
//凸包
//一条边在另外所有点的一侧就加入
//然后找最小环
//叉积判断?
//del x * del y
#include&lt;bits/stdc++.h&gt;
#define db double
using namespace std;
const db eps = 1e-8;
const int MAXN = 507;
struct  ND {
	db x, y, z;
} e[MAXN], d[MAXN];
//xy-xy
inline db cross(ND xx, ND yy, ND zz) {
	return (xx.x - zz.x) * (yy.y - zz.y) - (xx.y - zz.y) * (yy.x - zz.x);
}
//xx+yy
inline db dot(ND xx, ND yy, ND zz) {
	return (xx.x - zz.x) * (yy.x - zz.x) + (xx.y - zz.y) * (yy.y - zz.y);
}

int n, m;
int g[MAXN][MAXN];

int main() {
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	for(int i = 1; i &lt;= m; ++i)scanf(&quot;%lf%lf%lf&quot;, &amp;e[i].x, &amp;e[i].y, &amp;e[i].z);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%lf%lf%lf&quot;, &amp;d[i].x, &amp;d[i].y, &amp;d[i].z);
	memset(g, 0x3f3f3f3f, sizeof(g));
	for(int i = 1; i &lt;= m; ++i) {
		int flg = 1;
		for(int j = 1; j &lt;= n; ++j) {
			if(fabs(e[i].x - d[j].x) &gt; eps || fabs(e[i].y - d[j].y) &gt; eps) {
				flg = 0;
				break;
			}
		}
		if(flg) {
			puts(&quot;1&quot;);
			return 0;
		}
	}
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			if(i != j) {//看看这线段是否牛逼
				int flg = 1;
				for(int k = 1; k &lt;= n; ++k) {
					if(fabs(cross(e[i], e[j], d[k])) &lt; eps &amp;&amp; dot(e[i], e[j], d[k]) &gt; eps) {
						//共线不在线段
						flg = -1;
						break;
					}
					if(cross(e[i], e[j], d[k]) &gt; eps) {
						flg = -1;
						break;
					}
				}
				if(flg == -1)continue;
				g[i][j] = 1;
			}
		}
	}
	for(int k = 1; k &lt;= m; ++k) {
		for(int i = 1; i &lt;= m; ++i) {
			for(int j = 1; j &lt;= m; ++j) {
				g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
			}
		}
	}
	int ans = 1e9;
	for(int i = 1; i &lt;= m; ++i)ans = min(ans, g[i][i]);
	if(ans == 1e9)puts(&quot;-1&quot;);
	else printf(&quot;%d\n&quot;, ans);
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>