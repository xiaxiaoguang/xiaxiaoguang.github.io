<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-08-28T06:11:20.214Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[P3724 [AHOI2017/HNOI2017]大佬]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3724-ahoi2017hnoi2017da-lao/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3724-ahoi2017hnoi2017da-lao/">
        </link>
        <updated>2020-08-28T05:27:06.000Z</updated>
        <content type="html"><![CDATA[<p>好难啊</p>
<p>首先我们应该能观察到我刷水题和我怼大佬两件事是可以分开的,也就是说我们可以先写一个dp处理我前i天刷水题的最少次数(也就是留给其他操作的最多次数),再写一个dp处理之后操作?</p>
<p>会发现我们不太行,因为我们有两次怼大佬,如果只有一次的话我们就可以搜索出来所有的最少操作打出的伤害了</p>
<p>就是说写一个类似于bfs的东西,然后把(使用天数,造成伤害)所有的这样的pair搞出来,这样我们就能得知只使用一次怼大佬操作的答案,就是使用一个pair,搜索的状态....这个不用说了吧?</p>
<p>把上述pair按照嘲讽值排序,由于这样的pair可能高达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mn>0</mn></mrow><annotation encoding="application/x-tex">2^20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">0</span></span></span></span>个,我们只好思考能不能用双指针类似的思想来快速找到两个合并得到两次操作的答案</p>
<p>怎么合并呢?</p>
<p>首先我们有使用天数要合并,显然使用的天数不能超过第一个DP得出的怼大佬次数的最大值,其次我们造成的伤害由于题目的要求不能超过大佬的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>如果超过就会导致一击打成负数然后被暴虐了.....</p>
<p>紧接着,我们要有机会把大佬的自信打成0,所以我们剩下的天数(maxd-d1-d2)还要大于大佬剩下的(C_i-f1-f2),这样我们才能打爆他</p>
<p>综上,我们天数和一定,所以一维单增同时另一维单减,再每次减少的同时判断能不能打死即可,双指针了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define fi first
#define se second
#define mkp(x,y) (make_pair(x,y))
const int MAXN = 120;
const int MAXT = 1e6 + 7;
int n, m, mc, T, mx;
int a[MAXN], w[MAXN], c[MAXN];
int dp[MAXN][MAXN];
int maxd;
inline int chkmax(int &amp;x, int y) {
	x = max(x, y);
	return x;
}

map&lt;pair&lt;int, int&gt;, int&gt; mp;
struct nod {
	int i, F, L;
	nod(int x = 0, int y = 0, int z = 0): i(x), F(y), L(z) {};
};
pair&lt;int, int&gt; zt[MAXT];

queue&lt;nod&gt; Q;
inline void search() {
	queue&lt;nod&gt; Q;
	Q.push((nod) {
		1, 1, 0
	});
	while(!Q.empty()) {
		nod u = Q.front();
		Q.pop();
		if(u.i == maxd)continue;
		// printf(&quot;node:%d %d %d\n&quot;, u.i, u.F, u.L);
		Q.push((nod) {
			u.i + 1, u.F, u.L + 1
		});
		if(u.L &gt; 1 &amp;&amp; 1ll * u.F * u.L &lt;= 1ll * mx &amp;&amp;
				(mp.find(mkp(u.F * u.L, u.i + 1)) == mp.end())) {
			Q.push((nod) {
				u.i + 1, u.F *u.L, u.L
			});
			zt[++T] = mkp(u.L * u.F, u.i + 1);
			mp[mkp(u.F * u.L, u.i + 1)] = 1;
		}
	}
	return ;
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;mc);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;w[i]);
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;c[i]);
		mx = max(mx, c[i]);
	}
	// for(int p = 1; p &lt;= m; ++p) {
	memset(dp, -0x3f, sizeof(dp));
	dp[0][mc] = 0;//初始状态?
	for(int i = 0; i &lt; n; ++i) {
		for(int k = 0; k &lt;= mc; ++k) {
			if(k &gt;= a[i + 1]) {
				chkmax(dp[i + 1][min(k - a[i + 1] + w[i + 1], mc)], dp[i][k]); //刷题
				chkmax(dp[i + 1][k - a[i + 1]], dp[i][k] + 1);//不刷题
			}
			// printf(&quot;%d %d %d?%d %d \n&quot;, i, k, dp[i][k], dp[i + 1][k - a[i + 1] + w[i + 1]], dp[i + 1][k - a[i + 1]]);
		}
	}
	for(int i = 1; i &lt;= n; ++i)
		for(int k = 0; k &lt;= mc; ++k) {
			chkmax(maxd, dp[i][k]);
		}
	search();
	// printf(&quot;%d %d\n&quot;, p, maxd[p]);
	// }
	sort(zt + 1, zt + T + 1);
	for(int i = 1; i &lt;= m; ++i) {
		if(c[i] &lt;= maxd) {//如果小于最大天数直接反死
			puts(&quot;1&quot;);
			continue;
		}
		bool fl = 0;
		int mm = 1e9;
		for(int j = T, k = 1; j; --j) {
			while(k &lt; T &amp;&amp; zt[k].fi + zt[j].fi &lt;= c[i])//伤害和小于
				mm = min(mm, zt[k].se - zt[k].fi),//最小化这个才能满足下面的式子
				++k;
			if(mm + c[i] - zt[j].fi &lt;= maxd - zt[j].se) {//拆开mm可以得到c_i-fj-fi&lt;=maxd-di-dj
				fl = 1;
				break;
			}
			if(zt[j].fi &lt;= c[i] &amp;&amp; c[i] - zt[j].fi &lt;= maxd - zt[j].se) {//如果我们一击就能打死
				fl = 1;
				break;
			}
		}
		fl ? puts(&quot;1&quot;) : puts(&quot;0&quot;);
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2900 [USACO08MAR]Land Acquisition G]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2900-usaco08marland-acquisition-g/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2900-usaco08marland-acquisition-g/">
        </link>
        <updated>2020-08-27T14:44:02.000Z</updated>
        <content type="html"><![CDATA[<p>斜率优化好题</p>
<p>首先我们那道题写出状态转移方程后感到了一丝丝不对劲,因为这个式子好像不能直接斜率优化啊?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub><mo>+</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>a</mi><mi>k</mi></msub><mo>)</mo><mo>∗</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>b</mi><mi>k</mi></msub><mo>)</mo><mo separator="true">,</mo><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">f_i=f_j+max(a_k)*max(b_k),j&lt;i,j&lt;=k&lt;=i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></span></p>
<p>但是我们要斜率优化!!!所以如果我们a和b之和i,j有关就好了</p>
<p>脑袋里浮现出了一个经典的交叉直线:</p>
<p>在矩形的宽递减的同时长递增</p>
<p>如果我们能把序列转换成这样的东西,就能很好去维护转移了!</p>
<p>然后你会敏锐的发现其他长宽严格小于某矩形的矩形一定没用了,因为可以分给这一组然后不产生贡献</p>
<p>所以我们就预处理一下搞出这样的符合的矩形序列</p>
<p>紧接着我们斜率优化走起</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>∗</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">f_j=f_i+a_{i+1}*b_j
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.673611em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">k=b_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x=a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x=f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>f</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y=f_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>直接套板子??不行,想想我们维护的凸包是什么</p>
<p>要解决的是最小化问题,所以我们维护下凸包,然后卡的直线斜率应该刚好大于其中某条</p>
<p>同时呢我们新加入形成的凸包要满足后面的斜率大于前面的,所以如果小于就删掉</p>
<p>写的时候要注意宽是递减的,也就是说求斜率的时候我们应该把分母那个东西改一改...</p>
<p>代码里面为了显得getslope函数正常直接维护了一个负数域的上凸包,以后请不要这样</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define db double
const int MAXN = 1e5 + 7;
int n, que[MAXN];
struct rec {
	int x, y;
	bool operator&lt;(const rec &amp;w)const {
		return x == w.x ? y &gt; w.y : x &gt; w.x;
	}
} e[MAXN];
ll f[MAXN];
inline int getx(int x) {
	return e[x + 1].x;
}

inline ll gety(int x) {
	return f[x];
}

inline int getk(int x) {
	return e[x].y;
}

inline ll calc(int x, int y) {
	return f[y] + 1ll * e[x].y * e[y + 1].x;
}

inline db getslope(int x, int y) {
	return (1.0 * gety(x) - gety(y)) / (1.0 * getx(x) - getx(y));
}

int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].x, &amp;e[i].y);
	}
	sort(e + 1, e + n + 1);
	int m = 0;
	for(int i = 1; i &lt;= n; ++i)
		if(e[i].y &gt; e[m].y)
			e[++m] = e[i];
	n = m;
	// for(int i = 1; i &lt;= n; ++i) {
	// 	printf(&quot;%d %d\n&quot;, e[i].x, e[i].y);
	// }
	int h = 1, t = 1;
	que[h] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		// printf(&quot;%d %d %d %lf %d\n&quot;, que[h], que[h + 1], t, getslope(que[h], que[h + 1]), e[i].y);
		while(h &lt; t &amp;&amp; getslope(que[h], que[h + 1]) &gt; -e[i].y) {
			// printf(&quot;%lf %d\n&quot;, getslope(que[h], que[h + 1]), e[i].y);
			++h;
		}
		// printf(&quot;calc:%d %d?\n&quot;, i, que[h]);
		f[i] = calc(i, que[h]); 
		// printf(&quot;%lld???\n&quot;, f[i]);
		while(h &lt; t &amp;&amp; getslope(que[t - 1], que[t]) &lt; getslope(que[t], i)) {
			// printf(&quot;%lf %lf\n&quot;, getslope(que[t], que[t - 1]), getslope(que[t], i));
			--t;
		}
		que[++t] = i;
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4072 [SDOI2016]征途]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4072-sdoi2016zheng-tu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4072-sdoi2016zheng-tu/">
        </link>
        <updated>2020-08-27T08:48:30.000Z</updated>
        <content type="html"><![CDATA[<p>额...很难想象这题我调了好长时间....</p>
<p>首先我们不难得出答案就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>m</mi><mo>∗</mo><mo>∑</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mo>(</mo><mo>∑</mo><mi>x</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">min{m*\sum{x^2}-(\sum{x})^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>最小化中间那个平方</p>
<p>做法一是斜率优化</p>
<p>细节有:</p>
<ol>
<li>斜率不要带负数单调递减......</li>
<li>注意double的用法</li>
<li>直接使用滚动数组即可,除了求值完全基于上个数组</li>
</ol>
<p>做法二再加上wqs二分凑齐凸优化</p>
<p>细节:判断的时候别用你妈的eps</p>
<p>f[n].se&gt;=m的时候就统计答案</p>
<p>还用longlong</p>
<p>斜率优化<br>
code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
#define ll long long
using namespace std;
const int MAXN = 3e3 + 7;
int n, m;
int a[MAXN], sum[MAXN];
int que[MAXN];
ll f[MAXN], g[MAXN];

inline ll calc(int x, int y) {
	return g[y] + 1ll * (sum[x] - sum[y]) * (sum[x] - sum[y]);
}

inline db k(int x) {
	return 2.0 * sum[x];
}

//y f_x+sum_x^2
inline ll gety(int b) {
	return g[b] + 1ll * sum[b] * sum[b];
}
//x sum_x
//k 2*sum_k
//b f_y-sum_y^2
inline db getslope(int x, int y) {
	return (gety(y) - gety(x)) / (sum[y] - sum[x]);//del(y)/del(x);
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
		g[i] = sum[i] * sum[i];
		// printf(&quot;%d?\n&quot;, sum[i]);
	}
	int h = 1, t = 1;
	for(int j = 2; j &lt;= m; ++j) {
		h = 1, t = 1;
		que[h] = j - 1;
		for(int i = 1; i &lt;= n; ++i) {
			f[i] = 0;
		}
		for(int i = j; i &lt;= n; ++i) {
			while(h &lt; t &amp;&amp; getslope(que[h], que[h + 1]) &lt; k(i)) {
				// printf(&quot;%d %d %d %lf %lf\n&quot;, i, que[h], que[h + 1], getslope(que[h], que[h + 1]), k(i));
				++h;
			}
			// printf(&quot;%d %d %d %lf %lf\n&quot;, i, que[h], que[h + 1], getslope(que[h], que[h + 1]), k(i));
			// printf(&quot;in-&gt;%d %d?%d %d\n&quot;, i, que[h], h, t);
			f[i] = calc(i, que[h]);
			// printf(&quot;dedaole :%d?%d %d?\n&quot;, f[i], g[que[h]], sum[i] - sum[que[h]]);
			// if(h &lt; t)
			// 	printf(&quot;now tb is :%lf?%lf\n&quot;, getslope(que[h], que[h + 1]), k(i));
			while(h &lt; t &amp;&amp; getslope(que[t], que[t - 1]) &gt; getslope(que[t], i))
				--t;
			que[++t] = i;
		}
		for(int i = 1; i &lt;= n; ++i) {
			g[i] = f[i];
		}
	}
	printf(&quot;%lld\n&quot;, 1ll * m * f[n] - 1ll * sum[n] * sum[n]);
	return 0;
}


</code></pre>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
#define ll long long
#define fi first
#define se second
#define pii pair&lt;ll,int&gt;
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int MAXN = 3e3 + 7;
const db eps = 1e-7;
int n, m;
int a[MAXN];
ll sum[MAXN];
int que[MAXN];
pii f[MAXN];

inline pii calc(int x, int y) {
	return mkp(f[y].fi + 1ll * (sum[x] - sum[y]) * (sum[x] - sum[y]), 1 + f[y].se);
}

inline db k(int x) {
	return 2.0 * sum[x];
}

//y f_x+sum_x^2
inline ll gety(int b) {
	return f[b].fi + 1ll * sum[b] * sum[b];
}
//x sum_x
//k 2*sum_k
//b f_y-sum_y^2
inline db getslope(int x, int y) {
	return (db)(gety(y) - gety(x)) / (db)(sum[y] - sum[x]);//del(y)/del(x);
}

inline pii solve(int x) {
	int h = 1, t = 1;
	for(int i = 1; i &lt;= n; ++i) {
		f[i].fi = 0;
		f[i].se = 0;
	}
	que[h] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; getslope(que[h], que[h + 1])  &lt; k(i)) {
			// printf(&quot;%d %d %d %lf %lf\n&quot;, i, que[h], que[h + 1], getslope(que[h], que[h + 1]), k(i));
			++h;
		}
		// printf(&quot;%d %d %d %lf %lf\n&quot;, i, que[h], que[h + 1], getslope(que[h], que[h + 1]), k(i));
		// printf(&quot;in-&gt;%d %d?%d %d\n&quot;, i, que[h], h, t);
		f[i] = calc(i, que[h]);
		f[i].fi += x;
		// printf(&quot;dedaole :%d?%d %d?\n&quot;, f[i], f[que[h]], sum[i] - sum[que[h]]);
		// if(h &lt; t)
		// 	printf(&quot;now tb is :%lf?%lf\n&quot;, getslope(que[h], que[h + 1]), k(i));
		while(h &lt; t &amp;&amp; getslope(que[t], que[t - 1])  &gt; getslope(que[t], i))
			--t;
		que[++t] = i;
	}
	return f[n];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
		// g[i] = sum[i] * sum[i];
		// printf(&quot;%d?\n&quot;, sum[i]);
	}
	int l = -1e9, r = 1e9, mid, Ans = 0;
	for(int i = 1; i &lt;= 36; ++i) {
		mid = (l + r) &gt;&gt; 1;
		// printf(&quot;%d %d %d\n&quot;, l, r, mid);
		solve(mid);
		if(f[n].se &gt; m) {
			l = mid;
		} else {
			Ans = f[n].fi - m * mid;
			r = mid;
		}
	}
	printf(&quot;%lld\n&quot;, 1ll * m * Ans - 1ll * sum[n]*sum[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1973 [NOI2011]NOI 嘉年华]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1973-noi2011noi-jia-nian-hua/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1973-noi2011noi-jia-nian-hua/">
        </link>
        <updated>2020-08-27T05:54:38.000Z</updated>
        <content type="html"><![CDATA[<p>init</p>
<p>首先预处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">tot_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9011879999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示l,r时间段中的活动有哪些....</p>
<p>然后这个可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>的时间预处理</p>
<p>接下来我们再预处理两个数组</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pre_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示1~i时间我们第一个选了x的前提下,第二个选了活动个数的最大值</p>
<p>然后怎么求呢?dp一下</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mrow><mi>k</mi><mo>&lt;</mo><mi>i</mi></mrow></munder><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">pre_{i,j}=\max_{k&lt;i}{pre_{k,j}+tot_{i,k},pre_{k,j-tot_{i,k}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.394558em;vertical-align:-0.7794779999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7794779999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>你没看错,要么分给第一个会场要么分给第二个,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>然后我们还能再处理出一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">suf_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,就是后缀的选择</p>
<p>很易得出转移方程:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow></munder><mrow><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo separator="true">,</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">suf_{i,j}=\max_{k&gt;i}{suf_{k,j}+tot_{j,k},suf_{k,j-tot_{i,k}}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4739179999999998em;vertical-align:-0.7794779999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">&gt;</span><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7794779999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35307999999999995em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样就做完预处理啦qwq</p>
<p>我们还要计算一个求解的数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>区间的活动全部被一边选走,两边最优的最小值</p>
<p>然后我们还有枚举<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之前和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后有多少活动给了这一边,所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x+y+sum_{l,r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>就是第一边选的个数!</p>
<p>而另一边呢?你会发现我们的pre和suf就有用了,可以开眼了!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>r</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow><annotation encoding="application/x-tex">pre_{l,x}+suf_{r,y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>就是答案</p>
<p>两部分结合起来,转移方程就是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo>=</mo><munder><mi>max</mi><mo>⁡</mo><mi>x</mi></munder><munder><mi>max</mi><mo>⁡</mo><mi>y</mi></munder><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>t</mi><mi>o</mi><msub><mi>t</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow></msub><mo separator="true">,</mo><mi>p</mi><mi>r</mi><msub><mi>e</mi><mrow><mi>l</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub><mo>+</mo><mi>s</mi><mi>u</mi><msub><mi>f</mi><mrow><mi>r</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">f_{l,r}=\max_{x}\max_{y}{x+y+tot_{l,r},pre_{l,x}+suf_{r,y}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.530548em;vertical-align:-0.8361080000000001em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43056em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4305599999999999em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8361080000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>还没完.....答案并不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>i</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">f_{s_i,t_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.28055599999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为这个pre和suf只是局部最优,仅用他们并不能推出全局最优解,也就是说我们<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mo>?</mo><mo separator="true">,</mo><mo>?</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{?,?}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">?</span><span class="mpunct mtight">,</span><span class="mclose mtight">?</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>才可能是全局最优解,而我们无法知道这个?</p>
<p>解决方法也很简单<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>max</mi><mo>⁡</mo><mrow><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>l</mi></mrow></msub><msub><mi>max</mi><mo>⁡</mo><mrow><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\max_{i&lt;=l}\max_{j&gt;=r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999985em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">&lt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17737em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&gt;</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>一定是答案,因为我们虽然每个状态并不一定是全局最优解,但最优解一定在这个数组中</p>
<p>这样我们就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>4</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求解f然后TLE了!</p>
<p>用脑袋仔细想想,pre数组随着第二维的增大,他的数组值只有可能变小,没有说我第一个会场活动多第二个会场跟着变多的道理</p>
<p>也就是说,随着x的增大,y如果随着增大, min前面那个只能越来越大,后面那个越来越小</p>
<p>所以对于x增加我们的y只能从大到小的变换....</p>
<p>然后x一增大y变小挨着找最优决策点就做完了....因为一定min在取到后面那个数之后一定不会再取回之前了.....只会越来越劣</p>
<p>这样决策单调性优化我们就可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>了...</p>
<p>但是还有一个问题,由于tot是记录了所有完全包含的,所以会导致如果有两个完全相同的区间,我们的f数组步长为1就会更新出错,而且这个hack在讨论区也给出了</p>
<p>要么更改求f数组的过程,要么使得没有两个相同区间,由于这样其实本质上我们只是缺少了只选择其中几个区间的决策,所以我们最后把相同的区间右端点扰动一下就好了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define db double
using namespace std;
#define mkp(x,y) (make_pair(x,y))
const int MAXN = 500;
map&lt;pair&lt;db, db&gt;, int&gt; mp;
vector&lt;db&gt; v;
int n, m;
struct rec {
	db s, t;
	bool operator&lt;(const rec &amp;x)const {
		return s + t &lt; x.s + x.t;
	}
} a[MAXN];
int pre[MAXN][MAXN], suf[MAXN][MAXN], f[MAXN][MAXN], tot[MAXN][MAXN];
int s[MAXN], t[MAXN]; //强卡区间重复....

inline int getid(db x) {
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

inline void init() {
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for(int i = 1; i &lt;= n; ++i) {
		s[i] = getid(a[i].s);
		t[i] = getid(a[i].t);
		// printf(&quot;activity %d st in : %d ed in :%d \n&quot;, i, s[i], t[i]);
	}
	m = v.size();
	return;
}

inline void init2() {
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			pre[i][j] = suf[i][j] = -0x3f3f3f3f;
		}
	}
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 0; j &lt;= n; ++j) {
			for(int k = 1; k &lt; i; ++k) {
				pre[i][j] = max(pre[i][j], tot[k][i] + pre[k][j]);
				if(j &gt;= tot[k][i]) {
					pre[i][j] = max(pre[i][j], pre[k][j - tot[k][i]]);
				}
			}
			// printf(&quot;pre:!%d %d %d?\n&quot;, i, j, pre[i][j]);
		}
	}
	for(int i = m; i &gt;= 1; --i) {
		for(int j = 0; j &lt;= n; ++j) {
			for(int k = i + 1; k &lt;= m; ++k) {
				suf[i][j] = max(suf[i][j], tot[i][k] + suf[k][j]);
				if(j &gt;= tot[i][k]) {
					suf[i][j] = max(suf[i][j], suf[k][j - tot[i][k]]);
				}
			}
			// printf(&quot;suf:!%d %d %d?\n&quot;, i, j, suf[i][j]);
		}
	}
	return ;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lf%lf&quot;, &amp;a[i].s, &amp;a[i].t);
		a[i].t = a[i].s + a[i].t;
		if(mp.find(mkp(a[i].s, a[i].t)) != mp.end())
			a[i].t = a[i].t - mp[mkp(a[i].s, a[i].t)] * 0.001;
		mp[mkp(a[i].s, a[i].t)]++;
		v.push_back(a[i].s);
		v.push_back(a[i].t);
	}
	init();
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = i + 1; j &lt;= m; ++j) {
			for(int k = 1; k &lt;= n; ++k) {
				if(s[k] &gt;= i &amp;&amp; t[k] &lt;= j)
					tot[i][j]++;
			}
			// printf(&quot;%d %d %d\n&quot;, i, j, tot[i][j]);
		}
	}
	init2();
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = i + 1; j &lt;= m; ++j) {
			int p0, p1;
			for(int y = n, x = 0; x &lt;= n; ++x) {
				p0 = min(x + y + tot[i][j], pre[i][x] + suf[j][y]);
				while(y &amp;&amp; p0 &lt;= (p1 = min(x + y - 1 + tot[i][j], pre[i][x] + suf[j][y - 1])))
					p0 = p1, --y;
				f[i][j] = max(f[i][j], min(x + y + tot[i][j], pre[i][x] + suf[j][y]));
			}
		}
	}
	int ans = 0;
	for(int j = 1; j &lt;= n; ++j) {
		ans = max(ans, min(pre[m][j], j));
		// printf(&quot;?%d?%d?\n&quot;, j, pre[m][j]);
	}
	printf(&quot;%d\n&quot;, ans);
	for(int i = 1; i &lt;= n; ++i) {
		ans = 0;
		for(int j = 1; j &lt;= s[i]; ++j) {
			for(int k = t[i]; k &lt;= m; ++k) {
				ans = max(ans, f[j][k]);
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}



</code></pre>
<p>七海死了</p>
<p>在弹丸论破扯几把蛋的世界观里她的珍贵才能体现出来吧</p>
<p>但是弹丸论破世界观还是真tm的太扯淡了</p>
<p>绝望篇按理应该很好看的,但是太你妈扯淡了!!!!!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CF1391D 505]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf1391d-505/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf1391d-505/">
        </link>
        <updated>2020-08-27T03:11:16.000Z</updated>
        <content type="html"><![CDATA[<p>做个D题还这么慢QAQ</p>
<p>首先我们必须猜出一个结论,n&gt;=4时无解</p>
<p>因为n&gt;=4的时候一定存在一个4*4的矩阵</p>
<p>而这个矩阵可以被分成4个2*2的小矩阵</p>
<p>同时每个矩阵都要是奇数个,那么4*4的那个矩阵就一定不能是奇数个了</p>
<p>这个还是很妙的</p>
<p>然后剩下我们就可以状压了...</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{i,S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i行第i行的状态是S的最少次数</p>
<p>转移的时候预处理相邻状态合法的是那些以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cnt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示i的二进制位</p>
<p>然后直接做就好了....QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 15;
const int MAXM = 1e6 + 7;
int n, m;
char s[MAXM];
int vis[MAXN][MAXN];
int a[MAXN][MAXM], tmp[MAXM], dp[MAXM][MAXN], cnt[MAXN];

inline void init() {
	// printf(&quot;%d %d\n&quot;, n, m);
	for(int S1 = 0; S1 &lt; (1 &lt;&lt; n); ++S1) {
		for(int S2 = 0; S2 &lt; (1 &lt;&lt; n); ++S2) {
			int tmp1 = 0, tmp2 = 0;
			vis[S1][S2] = 1;
			for(int k = 0; k &lt; n; ++k) {
				tmp2 = (S1 &gt;&gt; k &amp; 1) + (S2 &gt;&gt; k &amp; 1);
				// printf(&quot;%d?%d\n&quot;, tmp2, tmp1);
				if(k != 0 &amp;&amp; ((tmp1 + tmp2) &amp; 1) == 0)
					vis[S1][S2] = 0;
				tmp1 = tmp2;
				tmp2 = 0;
			}
			// printf(&quot;%d %d %d?\n&quot;, S1, S2, vis[S1][S2]);
		}
	}
	// printf(&quot;%d %d\n&quot;, n, m);
	for(int S = 0; S &lt; (1 &lt;&lt; n); ++S) {
		for(int i = 0; i &lt; n; ++i) {
			if(S &amp; (1 &lt;&lt; i))cnt[S]++;
		}
		// printf(&quot;%d %d\n&quot;, S, cnt[S]);
	}
	memset(dp, 0x3f3f3f3f, sizeof(dp));
	for(int i = 1; i &lt;= m; ++i) {
		// printf(&quot;in - &gt;%d?\n&quot;, i);
		for(int j = 1; j &lt;= n; ++j) {
			// printf(&quot;%d?a :%d\n&quot;, j, a[j][i]);
			tmp[i] |= (a[j][i] &lt;&lt; (j - 1));
		}
		// printf(&quot;%d %d\n&quot;, i, tmp[i]);
		// dp[i][tmp[i]] = 0;
	}
	int MAXS = (1 &lt;&lt; n) - 1;
	for(int S = MAXS, qwq = 1; S || qwq; S = (S - 1)&amp;MAXS) {
		if(!S)qwq = 0;
		dp[1][S] = cnt[S ^ tmp[1]];
	}
	return;
}

inline void solve() {
	int MAXS = (1 &lt;&lt; n) - 1;
	for(int i = 2; i &lt;= m; ++i) {
		for(int S1 = MAXS, qwq = 1; S1 || qwq; S1 = (S1 - 1)&amp;MAXS) {
			if(!S1)qwq = 0;
			for(int S2 = MAXS, qaq = 1; S2 || qaq; S2 = (S2 - 1)&amp;MAXS) {
				if(!S2)qaq = 0;
				// printf(&quot;%d?%d?\n&quot;, S1, S2);
				if(!vis[S1][S2])continue;
				int qwq = cnt[S1 ^ tmp[i]];
				// printf(&quot;we are in-&gt;%d? %d? %d\n&quot;, S1, S2, i);
				dp[i][S1] = min(dp[i][S1], dp[i - 1][S2] + qwq);
				// printf(&quot;qwq is %d dp value is%d and %d\n&quot;, qwq, dp[i][S1], dp[i - 1][S2]);
			}
		}
	}
	int ans = 1e9;
	for(int S = 0; S &lt;= MAXS; ++S) {
		ans = min(ans, dp[m][S]);
	}
	if(ans != 1e9)
		printf(&quot;%d\n&quot;, ans);
	else puts(&quot;-1&quot;);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(n &gt;= 4 &amp;&amp; m &gt;= 4)return puts(&quot;-1&quot;), 0;
	if(n &lt;= m) {
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, s + 1);
			for(int j = 1; j &lt;= m; ++j) {
				a[i][j] = s[j] - '0';
			}
		}
	} else {
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, s + 1);
			for(int j = 1; j &lt;= m; ++j) {
				a[j][i] = s[j] - '0';
			}
		}
		n ^= m ^= n ^= m;
		// for(int i = 1; i &lt;= n; ++i) {
		// 	for(int j = 1; j &lt;= m; ++j) {
		// 		printf(&quot;shuchu a:%d %d %d\n&quot;, i, j, a[i][j]);
		// 	}
		// }
	}
	init();
	solve();
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P1263 宫廷守卫]]></title>
        <id>https://xiaxiaoguang.github.io/post/p1263-gong-ting-shou-wei/</id>
        <link href="https://xiaxiaoguang.github.io/post/p1263-gong-ting-shou-wei/">
        </link>
        <updated>2020-08-27T03:06:19.000Z</updated>
        <content type="html"><![CDATA[<p>标准网络流建模</p>
<p>对于每一行,每一堵墙相当于把这行分成了很多部分</p>
<p>而每一列也是一样的qwq</p>
<p>然后我们发现一个空地代表了对应行的部分和对应列的部分只能放下一个兵</p>
<p>所以把对应行和列连边,表示如果这条边有流量这行和这列都不能有流量了</p>
<p>陷阱就相当于没有空地也不会增加新行划分列划分</p>
<p>所以最后建图就是行一排列一排s到行列到t类型的</p>
<p>输出方案的时候我们找这个二分图中间那些边即可qwq</p>
<p>做完了,其实建图和输出方案还是有一点难度的,但是没有细节啊</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
#define mkp(x,y) (make_pair(x,y))
using namespace std;
const int MAXN = 500;
const int inf = 1e9 + 7;
const int MAXM = 2e5 + 7;
int m, n, ccnt, a[MAXN][MAXN], T, s, t, maxflow;
int nxt[MAXM], to[MAXM], home[MAXM], flw[MAXM], cur[MAXM];
int vis[MAXN][MAXN][2];
map&lt;pair&lt;int, int&gt;, int&gt; mp;

inline void cuntu(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	flw[ccnt] = z;
}

inline void ct(int x, int y, int z) {
	cuntu(x, y, z);
	cuntu(y, x, 0);
}

inline int GET(int x, int y, int p) {
	if(!vis[x][y][p])
		vis[x][y][p] = ++T;
	return vis[x][y][p];
}

int queh[MAXN], quel[MAXN];
inline void build() {
	ccnt = 1;
	for(int i = 1; i &lt;= m; ++i) {
		// printf(&quot;H :%d\n&quot;, i);
		for(int j = 1; j &lt;= n; ++j) {
			// printf(&quot;in L-&gt;%d &quot;, j);
			if(a[i][j] == 2) {
				quel[j]++;//这一列点数+1
				queh[i]++;//这一行点数+1
				// printf(&quot;%d %d?\n&quot;, quel[j], queh[i]);
			} else if(a[i][j] == 0) {
				// printf(&quot;node :%d ct-&gt;node: %d?\n&quot;, GET(i, queh[i], 1), GET(j, quel[j], 0));
				ct(GET(i, queh[i], 1), GET(j, quel[j], 0), 1);
			}
		}
		// puts(&quot;&quot;);
	}
	++T;
	s = T;
	++T;
	t = T;
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 0; j &lt;= queh[i]; ++j) {
			// printf(&quot;s - &gt;%d\n&quot;, GET(i, j, 1));
			ct(s, GET(i, j, 1), 1);
		}
	}
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 0 ; j &lt;= quel[i]; ++j) {
			// printf(&quot;t - &gt; %d\n&quot;, GET(i, j, 0));
			ct(GET(i, j, 0), t, 1);
		}
	}
	return ;
}

inline void solve() {
	for(int u = 1; u &lt;= T; ++u) {
		if(u == s || u == t)continue;
		bool flg = 0;
		for(int i = home[u]; i; i = nxt[i]) {
			int  v = to[i];
			if(v == s &amp;&amp; flw[i] == 1)flg = 1;
			if(v == t &amp;&amp; flw[i] == 0)flg = 2;//统计有没有流量
		}
		if(flg == 1) {//s出发有流量,说明这个点在匹配里
			for(int i = home[u]; i; i = nxt[i]) {
				int v = to[i];
				if(v != s &amp;&amp; flw[i] == 0) {
					mp[mkp(min(u, v), max(u, v))] = 1; //这个点有了
					break;
				}
			}
		} else if(flg == 2) {
			for(int i = home[u]; i; i = nxt[i]) {
				int v = to[i];
				if(v != t &amp;&amp; flw[i] == 1) {
					mp[mkp(min(u, v), max(u, v))] = 1;
					break;
				}
			}
		}
	}
	memset(quel, 0, sizeof(quel));
	memset(queh, 0, sizeof(queh));
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			if(a[i][j] == 2) {
				quel[j]++;
				queh[i]++;
			} else if(a[i][j] == 0) {
				int tmp1 = GET(i, queh[i], 1);
				int tmp2 = GET(j, quel[j], 0);
				if(tmp1 &gt; tmp2)
					tmp1 ^= tmp2 ^= tmp1 ^= tmp2;
				if(mp.find(mkp(tmp1, tmp2)) != mp.end())
					printf(&quot;%d %d\n&quot;, i, j);
			}
		}
	}
	return ;
}

int h[MAXM];
int que[MAXM];
inline int bfs() {
	memset(h, 0, sizeof(h));
	int hd = 1, tl = 1;
	que[hd] = s;
	h[s] = 1;
	while(hd &lt;= tl) {
		int u = que[hd];
		++hd;
		for(int i = home[u]; i; i = nxt[i]) {
			int v = to[i];
			if(!h[v] &amp;&amp; flw[i] &gt; 0) {
				h[v] = h[u] + 1;
				que[++tl] = v;
			}
		}
		if(h[t])return 1;
	}
	return h[t];
}

inline int dfs(int u, int nflw) {
	if(u == t || nflw == 0)return nflw;
	int ret = nflw, a = 0;
	for(int &amp;i = cur[u]; i; i = nxt[i]) {
		int v = to[i];
		if(h[v] == h[u] + 1 &amp;&amp; (a = dfs(v, min(ret, flw[i])))) {
			flw[i] -= a;
			flw[i ^ 1] += a;
			ret -= a;
			if(!ret)break;
		}
	}
	if(nflw == ret)h[u] = -1;
	return (nflw - ret);
}

inline void Dinic() {
	maxflow = 0;
	while(bfs()) {
		memcpy(cur, home, sizeof(cur));
		maxflow += dfs(s, inf);
	}
	printf(&quot;%d\n&quot;, maxflow);
	solve();
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
	for(int i = 1; i &lt;= m; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			scanf(&quot;%d&quot;, &amp;a[i][j]);
		}
	}
	build();//建图
	Dinic();
	return 0;
}

</code></pre>
<p>别看长其实和昨天的DP比起来可好写了差老多了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4099 [HEOI2013]SAO ]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4099-heoi2013sao/">
        </link>
        <updated>2020-08-26T11:21:51.000Z</updated>
        <content type="html"><![CDATA[<p>n-1条边有向弱联通图拓扑序计数</p>
<p>咋做啊?</p>
<p>首先我们应该注意到是树,而不是那个阴间的npc问题</p>
<p>类似于一坨坨的序列合并...我们就要想是整个一坨合并还是插入合并?</p>
<p>这个题显然拓扑序列是可以两个子树之间穿插的,所以我们转移的时候就要用穿插的方式转移</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 8: f_{i,j}$̲$表示点i在拓扑序的j号位置的…'>f_{i,j}$$表示点i在拓扑序的j号位置的方案数是什么

转移时,对于一条连向儿子的边,u要么能放在v前,要么能放在v后

也就是说.......u.....v......,或者...v.....u......

这个其实限制了状态的转移,也就是那些状态能够转移过来

然后我们要分配儿子,因为我们还有兼具合并v的重任所以上组合数把!

钦定$v&lt;u$硬点u在拓扑序原来的排名为l,而合并之后的排名为k,所以前面的总可能是$\binom{k-1}{l-1}$,就是l-1个点分在原子树里

紧接着会发现我们有$siz[u]+siz[v]-k$个数还没用呢....因为我们枚举了原来的排名为l,所以$siz[u]-l$就是原来放在另外拓扑序后面的数数量,所以我们再$*\binom{siz[u]+siz[v]-k}{siz[u]-l}$表示我们把后面部分选好

$$f_{u,j}=\sum_{l&lt;siz[v]}\sum_{k&lt;l}f_{u,l}*f_{v,k}*\binom{j-1}{l-1}\binom{siz[u]+siz[v]-k}{siz[u]-l}</p>
<p>就是这个转移方程了</p>
<p>钦定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>&gt;</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">v&gt;u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span></p>
<p>其实很对称啊,我们会发现之前组合数的部分都不用变,改变的是转移的范围</p>
<p>假设第一维枚举原来的点数,第二维枚举v向前给出多少个点的贡献(就是u新的排名会后移啊.....),因为此时v可能不会再影响u原来的排名后移了</p>
<p>第三维枚举的就是我们实际的比u多的rank,这里一开始自闭了一下,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">dp_{v,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>其实也可以表示v比u大k的方案..</p>
<p>总的来说,这个转移共有两个细节</p>
<ol>
<li>计算新排名时要组合新排名前面的数和新排名之后的数</li>
<li>计算新排名的时候要仔细想想枚举什么,以及对应乘上的dp状态</li>
</ol>
<p>按理说应该直接枚举新u的排名的,代码没有这样写</p>
<p>最后对了还有一个前缀和优化,仔细看看代码就会感觉是临时加上去的.....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e9 + 7;
const int MAXN = 1e3 + 7;
const int MAXM = 2e3 + 7;
int n, ccnt, T, home[MAXN], nxt[MAXM], to[MAXM], flg[MAXM];

inline void ct(int x, int y, int z) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	flg[ccnt] = z;
}

inline ll ksm(ll x, ll y) {
	ll ans = 1;
	while(y) {
		if(y &amp; 1)ans = ans * x % P;
		x = x * x % P;
		y &gt;&gt;= 1;
	}
	return ans;
}

int dp[MAXN][MAXN], siz[MAXN], f[MAXN][MAXN], C[MAXN][MAXN], sum[MAXN][MAXN];
// ll fac[MAXN], ifac[MAXN];
inline void INIT() {
	C[0][0] = 1;
	for(int i = 1; i &lt; MAXN; ++i) {
		C[i][0] = 1;
		for(int j = 1; j &lt;= i; ++j) {
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;
		}
	}
	return ;
}

inline void init() {
	memset(home, 0, sizeof(home));
	ccnt = 0;
	memset(dp, 0, sizeof(dp));
}

inline void add(int &amp;x, ll y) {
	x += y;
	// printf(&quot;?%d?%d?\n&quot;, x, y);
	if(x &gt; P)
		x -= P;
}

inline void dfs(int u, int F) {
	siz[u] = 1;
	dp[u][1] = 1;
	// printf(&quot;u is :%d?\n&quot;, u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs(v, u);
		// printf(&quot;u %d and back v %d?\n&quot;, u, v);
		for(int k = 1; k &lt;= n; ++k)
			f[u][k] = 0;
		if(flg[i] == 1) {//之前边,u在v之前
			// printf(&quot;u is v front front is :%d back is :%d\n&quot;, u, v);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举u原来点数
				for(int k = 0; k &lt;=  siz[v]; ++k) { //枚举v给出的贡献
					// for(int l = k + 1; l &lt;= siz[v]; ++l) {
					int del = ((sum[v][siz[v]] - sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[j + k - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][ siz[u] - j] % P);
					// printf(&quot;but each size is%d %dget ans:%d\n&quot;, siz[u], siz[v], f[u][j + k]);
					// }
				}
			}
		} else {//u在v之后
			// printf(&quot;u is v back front is :%d back is :%d\n&quot;, v, u);
			for(int j = 1; j &lt;= siz[u]; ++j) { //枚举新u的点数
				for(int k = 1; k &lt;= siz[v]; ++k) {
					// for(int l = 1; l &lt;= k; ++l) {
					int del = ((sum[v][k]) + P) % P;
					// printf(&quot;now we in:%d %d %dhad dp array u:%d v:%d\n&quot;, j, k, l, dp[u][j], dp[v][l]);
					add(f[u][j + k],
						1ll * del * dp[u][j] % P
						* C[k + j - 1][j - 1] % P
						* C[siz[u] + siz[v] - j - k][siz[u] - j] % P) ;
					// printf(&quot;but each size is%d %d\n&quot;, siz[u], siz[v]);
					// }
				}
			}
		}
		siz[u] += siz[v];
		for(int k = 1; k &lt;= n; ++k)
			dp[u][k] = f[u][k];
	}
	// printf(&quot;%d?\n&quot;, u);
	for(int i = 1; i &lt;= n; ++i) {
		sum[u][i] = (sum[u][i - 1] + dp[u][i]) % P;
		// add(sum[u][i], sum[u][i - 1]);
		// add(sum[u][i], dp[u][i]);
		// printf(&quot;!%d??%d %d\n&quot;, sum[u][i], sum[u][i - 1], dp[u][i]);
	}
	return ;

}
char s[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;T);
	INIT();//大预处理
	// printf(&quot;%d %d %d\n&quot;, C[10][2], C[5][3], C[6][4]);
	while(T-- &gt; 0) {
		init();
		scanf(&quot;%d&quot;, &amp;n);
		for(int i = 1, x, y; i &lt; n; ++i) {
			scanf(&quot;%d&quot;, &amp;x);
			cin &gt;&gt; s;
			scanf(&quot;%d&quot;, &amp;y);
			++x;
			++y;
			// printf(&quot;%d %d\n&quot;, x, y);
			//&lt;说明x在y之前打
			if(s[0] == '&lt;') {
				// puts(&quot;Y&quot;);
				ct(x, y, 1);
				ct(y, x, 0);
				//变向说明y在x之后
			} else {
				// puts(&quot;N&quot;);
				//x在y之后打
				ct(x, y, 0);
				ct(y, x, 1);
				//说明y在x之前打
			}
		}
		dfs(1, 0);
		int ans = 0;
		for(int i = 1; i &lt;= n; ++i)
			add(ans, dp[1][i]);
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}

</code></pre>
<p>zzz</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P3515 [POI2011]Lightning Conductor]]></title>
        <id>https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/</id>
        <link href="https://xiaxiaoguang.github.io/post/p3515-poi2011lightning-conductor/">
        </link>
        <updated>2020-08-26T10:30:21.000Z</updated>
        <content type="html"><![CDATA[<p>唉...二分是又一个细节吧.....</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub><mo>+</mo><msqrt><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo>−</mo><mi>j</mi><mi mathvariant="normal">∣</mi></mrow></msqrt><mo>&lt;</mo><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">a_j+\sqrt{|i-j|}&lt;=a_i+p
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.25612499999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.983875em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">∣</span></span></span><span style="top:-2.9438750000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25612499999999994em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p>
<p>拿到题我们就应该想到找每个数上述式子最大的j</p>
<p>观察后面根号函数,你会发现他的导函数单调递减!有决策单调性了</p>
<p>而与此同时我们要求的是最大值,所以可以用单调队列来优化</p>
<p>就是单调队列优化决策单调性的板子.....</p>
<p>直接上就好了,正着做一遍反着来一遍</p>
<p>然后最后处理答案随便搞一下就好</p>
<p><strong>但是nmd卡细节</strong></p>
<p>记得我们决策单调性有一个二分的步骤吗?</p>
<p>里面我们的l,r一定要限制好范围!!!!</p>
<p>对于r,如果k[r]存在(即有右端点的限制)我们就设置右端点为r</p>
<p>对于l,我们输入了x,y两个决策点想要找一个不错的,所以我们左端点应该在y之后!</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><msub><mi>k</mi><mi>y</mi></msub><mo>?</mo><msub><mi>k</mi><mi>y</mi></msub><mo>+</mo><mn>1</mn><mo>:</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=k_y?k_y+1:n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">?</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>但是这样诗人小G又不能过,(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>y</mi></msub></mrow><annotation encoding="application/x-tex">k_y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>一看就很扯吗...),所以我暴力改改参数得到了普适应的一组参数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mi>y</mi><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">l=y,r=n+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>以后就用这组</p>
<p>二分用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l&lt;r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>锁定答案形式</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define db double
const int MAXN = 5e5 + 7;
int n, a[MAXN], que[MAXN], k[MAXN];
db sq[MAXN], f[MAXN];

inline db calc(int x, int y) {
	return a[y] + sq[x - y];
}

inline int bound(int x, int y) {
	int l = y, r = k[y] ? k[y] + 1 : n + 1, mid;
	while(l &lt; r) {
		mid = (l + r) &gt;&gt; 1;
		calc(mid, x) &gt; calc(mid, y) ? l = mid + 1 : r = mid;
	}
	return r;
}	 

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	for(int i = 0; i &lt;= n; ++i)
		sq[i] = sqrt(i);
	int h = 1, t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;calc in -&gt;%d by%d\n&quot;, i, que[h]);
		f[i] = calc(i, que[h]);
		// printf(&quot;we get :%lf?\n&quot;, f[i]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;she controlled :%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	reverse(a + 1, a + n + 1);
	reverse(f + 1, f + n + 1);
	h = 1, t = 0;
	memset(k, 0, sizeof(k));
	for(int i = 1; i &lt;= n; ++i) {
		while(h &lt; t &amp;&amp; k[h] &lt;= i)++h;//管束右端点太窄
		// printf(&quot;qwq-&gt;:%d %d %lf\n&quot;, i, que[h], f[n - i + 1]);
		f[i] = max(f[i], calc(i, que[h]));
		// printf(&quot;we get :%lf?\n&quot;, f[n - i + 1]);
		while(h &lt; t &amp;&amp; k[t - 1] &gt;= bound(que[t], i))
			--t;
		k[t] = bound(que[t], i);
		// printf(&quot;%d?\n&quot;, k[t]);
		que[++t] = i;
	}
	// reverse(a + 1, a + n + 1);
	for(int i = n; i &gt;= 1; --i) {
		// printf(&quot;%lf %d\n&quot;, f[i], a[i]);
		printf(&quot;%d\n&quot;, max((int)ceil(f[i] - a[i]), 0));
	}
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P2511 [HAOI2008]木棍分割]]></title>
        <id>https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/</id>
        <link href="https://xiaxiaoguang.github.io/post/p2511-haoi2008mu-gun-fen-ge/">
        </link>
        <updated>2020-08-26T08:17:13.000Z</updated>
        <content type="html"><![CDATA[<p>nmd细节</p>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示前i个棍分成j组的方案数</p>
<p>转移式子很简单f_{i,j}=\sum_{k&lt;i,sum[i]-sum[k]&lt;=Max}f_{k,j-1}</p>
<p>然后j这维可以滚动,同时可以前缀和优化...</p>
<p>不过这个有个你妈的细节,就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>t</mi><mi>p</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=sum_{i-1,j-1}-sum_{tp-1,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">p</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>这个是不能转移到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的....毕竟<strong>没有空组</strong>!!</p>
<p>唉...但是只WA了一个点,让人麻木</p>
<p>写的时候多想了好多强加了好多限制使得看上去繁琐了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P = 1e4 + 7;
const int MAXN = 1e5 + 7;
int n, m, S;
int a[MAXN], pre[MAXN];
int Max, MM;

inline int chk(int x) {
	int tmp = 0;
	int ccnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(tmp + a[i] &gt; x) {
			ccnt++;
			tmp = a[i];
		} else tmp += a[i];
	}
	return (m &gt;= ccnt);
}

inline void solve1() {
	int l = MM, r = S, mid;
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(chk(mid)) {
			r = mid - 1;
			Max = mid;
		} else l = mid + 1;
	}
}

ll f[2][MAXN], sum[2][MAXN], ans;
inline void solve2() {
	int tp = 0;
	int t = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(pre[i] &lt;= Max)
			f[1][i] = 1;
		sum[1][i] = sum[1][i - 1] + f[1][i];
	}
	for(int j = 2; j &lt;= m + 1; ++j) {
		tp = 0;
		// puts(&quot;qwq&quot;);
		for(int i = j; i &lt;= n; ++i) {
			while(tp &lt;= i &amp;&amp; pre[i] - pre[tp] &gt; Max)++tp;
			sum[t][i] = sum[t][i - 1];
			// printf(&quot;%d %din-&gt;%lld %lld\n&quot;, i, tp, sum[t ^ 1][i], sum[t ^ 1][tp - 1]);
			if(tp != 0)
				f[t][i] = sum[t ^ 1][i - 1] - sum[t ^ 1][tp - 1];
			else
				f[t][i] = sum[t ^ 1][i - 1];
			// printf(&quot;%lld??\n&quot;, f[t][i]);
			f[t][i] = (f[t][i] + P) % P;
			sum[t][i] = (sum[t][i] + f[t][i]) % P;
		}
		ans = (ans + f[t][n]) % P;
		t ^= 1;
		for(int i = 0; i &lt;= n; ++i)
			f[t][i] = sum[t][i] = 0;
	}
	printf(&quot;%lld\n&quot;, ans);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		pre[i] = pre[i - 1] + a[i];
		S += a[i];
		MM = max(MM, a[i]);
	}
	solve1();//解决第一问
	printf(&quot;%d &quot;, Max);
	solve2();//缀和优化第二维
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5504 [JSOI2011]柠檬]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5504-jsoi2011ning-meng/">
        </link>
        <updated>2020-08-26T03:29:35.000Z</updated>
        <content type="html"><![CDATA[<p>决策单调性优化2</p>
<p>我爱</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>j</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>(</mo><mi>i</mi><mo>)</mo><mo>∗</mo><mo>(</mo><msub><mi>s</mi><mi>j</mi></msub><mo>−</mo><msub><mi>s</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow></mrow><annotation encoding="application/x-tex">f_j=max{f_{i-1}+col(i)*(s_{j}-s_{i}+1)^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><mi>c</mi><mi>o</mi><msub><mi>l</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">col_i==col_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>,这个是满足的才行</p>
<p>观察后面函数导函数是单调递增的,而要最大化,由上一篇博客可知要决策单调性优化单调栈形式了....</p>
<p>具体怎么说呢?</p>
<p>不难发现,正是因为我们要<strong>最大化</strong>,对于一个颜色j,越靠前后面那个转移的值越大!</p>
<p>也就是说对于一个决策点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,j当前不是最优的,j可能会在某个时间点之后成为了最优点</p>
<p>也就是说我们一个单调栈内决策点的最优时间是<strong>递减</strong>的.....而最优时间可以反映到颜色数上,因为相当于颜色数越多我们最优时间越靠后</p>
<p>辣么我们就可以想出一些方法去维护这个单调栈了....</p>
<ol>
<li>如果栈顶的两个元素的最优时间早于新决策点i和栈顶的最优时间我们就弹出栈顶</li>
</ol>
<p>显然i是最优的,但是栈顶的最优时间还在i之前,所以说明他无论如何都不会成为最优时间了,所以我们可以弹出栈顶....</p>
<ol start="2">
<li>如果栈顶的两个元素的最优时间小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>即i颜色数就弹出栈顶</li>
</ol>
<p>也就是说他已经不再能成为那个决策点了,也就是最优时间已经过了...</p>
<p>做完这两个操作我们再去更新i即可</p>
<p>而怎么求出两个决策点的最优时间比较呢?</p>
<p>可以二分,因为两个决策点一定是某段时间之前一个更优,之后另一个更优,直接二分那个颜色数然后类似的转移一下就好了</p>
<p>所以最后整个算法流程也就是这样了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
#define ll long long
int n, a[MAXN], s[MAXN], vis[MAXN];
vector&lt;int&gt; st[MAXN], rc[MAXN];
ll f[MAXN];

inline ll calc(int x, int y) {
	// if(x == y)return f[y] + a[x];
	return f[x - 1] + 1ll * y * y * a[x];
}

inline int bound(int x, int y) {//在x,y中update
	int l = 1, r = n, mid, ret = n + 1;
	// printf(&quot;%d %d?%d %d\n&quot;, l, r, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		// printf(&quot;in-&gt;%lld %lld?\n&quot;, calc(x, mid - s[x] + 1), calc(y, mid - s[y] + 1));
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			ret = mid;
			r = mid - 1; 
		} else l = mid + 1;
	}
	// printf(&quot;!!!%d\n&quot;, ret);
	return ret;
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	//直接用st维护
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// printf(&quot;%d?\n&quot;, st[t].size());
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1])
				&lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;%d %d?\n&quot;, bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]), bound(st[t][st[t].size() - 1], i));
			st[t].pop_back();//只要结尾一段的决策点i最优就一直...
		} st[t].push_back(i);
		// printf(&quot;st:%d st2:%d low:%d \n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2], bound(st[t][st[t].size() - 1], i));
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// printf(&quot;%d\n&quot;, st[t][st[t].size() - 1]);
			st[t].pop_back();
		}
		// printf(&quot;i:%d best choic: %d!\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finial:%lld\n&quot;, f[i]);
	}
	printf(&quot;%lld\n&quot;, f[n]);
	return 0;
}

</code></pre>
<p>还有noi.ac的一道抄袭这个题的决策单调性优化</p>
<p><strong>有一个至关重要的细节就是如果我们的二分二分不出时间</strong></p>
<p>说明前面的决策点永远都不可能成为最优决策点了....</p>
<p>那么这个时候我们只需要压住栈即可,因为珍贵的栈顶是最优的</p>
<p>即bound函数返回n+1</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long double
const int MAXN = 1e6 + 7;

int n, k;
int a[MAXN], vis[MAXN], s[MAXN];
vector&lt;int&gt; st[MAXN];
ll f[MAXN], qwq[MAXN];

inline ll calc(int x, int y) {
	return f[x - 1] + qwq[y];
}

inline int bound(int x, int y) {
	int l = 1, r = n, ret = n + 1, mid;
	// printf(&quot;in-&gt;%d %d?\n&quot;, x, y);
	while(l &lt;= r) {
		mid = (l + r) &gt;&gt; 1;
		if(calc(x, mid - s[x] + 1) &gt;= calc(y, mid - s[y] + 1)) {
			// printf(&quot;this mid is ok%d\n&quot;, mid);
			ret = mid;
			r = mid - 1;//这个决策点x更优,再靠前
		} else l = mid + 1;
	}
	// printf(&quot;end with %d\n&quot;, ret);
	return ret;
}

inline void init() {
	if(k == 2) {
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i;
		}
	} else if(k == 3)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = pow(i, 1.5);
			// printf(&quot;%d %Lf\n&quot;, i, qwq[i]);
		} else if(k == 4)
		for(int i = 1; i &lt;= n; ++i) {
			qwq[i] = 1ll * i * i;
		}
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;k, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		vis[a[i]]++;
		s[i] = vis[a[i]];
	}
	init();
	for(int i = 1; i &lt;= n; ++i) {
		int t = a[i];
		// puts(&quot;Ha1&quot;);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= bound(st[t][st[t].size() - 1], i)) {
			// printf(&quot;out..-&gt;%d?%d?\n&quot;, st[t][st[t].size() - 1], st[t][st[t].size() - 2]);
			st[t].pop_back();
		}
		// puts(&quot;Ha2&quot;);
		st[t].push_back(i);
		while(st[t].size() &gt;= 2 &amp;&amp;
				bound(st[t][st[t].size() - 2], st[t][st[t].size() - 1]) &lt;= s[i]) {
			// puts(&quot;qwq&quot;);
			st[t].pop_back();
		}
		// printf(&quot;wei shen me?%d %d?\n&quot;, i, st[t][st[t].size() - 1]);
		f[i] = calc(st[t][st[t].size() - 1], s[i] - s[st[t][st[t].size() - 1]] + 1);
		// printf(&quot;finish:%Lf\n&quot;, f[i]);
	}
	printf(&quot;%.6Lf\n&quot;, f[n]);
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>