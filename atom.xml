<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-04-17T12:44:04.362Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CF576D Flights for Regular Customers]]></title>
        <id>https://xiaxiaoguang.github.io/post/cf576d-flights-for-regular-customers/</id>
        <link href="https://xiaxiaoguang.github.io/post/cf576d-flights-for-regular-customers/">
        </link>
        <updated>2020-04-17T12:29:51.000Z</updated>
        <content type="html"><![CDATA[<p>IOI2020集训队作业</p>
<p>小清新的一道题,因为不需要灵机一动</p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></p>
<p>题意翻译</p>
<ul>
<li>给定一张 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 条边的有向图。</li>
<li>一开始你在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 号节点，你要走到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 号节点去。</li>
<li>只有当你已经走过了至少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi mathvariant="normal">​</mi></msub><mi>i</mi></mrow><annotation encoding="application/x-tex">d_​i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.15em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">​</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span></span></span></span> 条边时，你才能走第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 条边。</li>
<li>问最少要走多少步，或判断无法到达。</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>150</mn></mrow><annotation encoding="application/x-tex">n,m \le 150</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">d_i \le 10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>。</li>
</ul>
<p>看完题我们一定会对n,m比较小感到诧异</p>
<p>因为这样子至少走过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>条边这个限制就会变得鸡肋,我们可以矩阵快速幂啊!</p>
<p>那么做法也就呼之欲出了</p>
<p>我们把原来的边按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>拍下序,然后从小到大处理</p>
<p>然后考虑枚举每条边,然后把它加入原来的矩阵中,然后用快速幂让这个矩阵自己乘自己乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_{i+1}-d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>次</p>
<p>再依次这样做,可以判断能否到达</p>
<p>如果要看最少走多少条边我们可以考虑如果两个相邻的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>值小于n就暴力做一下,否则就先做n次看能不能到达,之后再快速幂做<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>−</mo><msub><mi>d</mi><mi>i</mi></msub><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">d_i+1-d_i-n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次,因为剩下的一定也不会使他们到达了</p>
<p>发现每个点要么是0要么是1,就可以用bitset来写矩阵乘法,复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">/\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>,否则过不去</p>
<p>code:</p>
<pre><code class="language-cpp">//From Dawn light
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;bitset&gt;
using std::sort;
using std::bitset;
int n, m;
bitset&lt;160&gt;a[160], b[160], T[160];
struct rec {
	int from, to, w;
	bool operator&lt;(const rec &amp;x)const {
		return w &lt; x.w;
	}
} edge[160];

void times(bitset&lt;160&gt; *a, bitset&lt;160&gt; *b) {
	bitset&lt;160&gt; res[160];
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= n; ++j) {
			if(a[i][j])res[i] |= b[j];
		}
	}
	for(int i = 1; i &lt;= n; ++i)a[i] = res[i];
}

inline void ksm(bitset&lt;160&gt; *a, int b) {
	bitset&lt;160&gt; res[160];
	for(int i = 1; i &lt;= n; ++i)res[i][i] = 1;
	while(b) {
		if(b &amp; 1)times(res, a);
		times(a, a);
		b &gt;&gt;= 1;
	}
	for(int i = 1; i &lt;= n; ++i)a[i] = res[i];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d&quot;, &amp;edge[i].from, &amp;edge[i].to, &amp;edge[i].w);
	}
	sort(edge + 1, edge + m + 1);
	for(int i = 1; i &lt;= n; ++i) {
		a[i][i] = 1;
	}
	int now = 0;
	if(edge[1].w &gt; 0)return puts(&quot;Impossible&quot;), 0;

	// puts(&quot;QWQ&quot;);
	for(int i = 1; i &lt; m; ++i) {
		T[edge[i].from][edge[i].to] = 1;
		// printf(&quot;%d?\n&quot;, i);
		if(edge[i].w == edge[i + 1].w)continue;
		// printf(&quot;??&quot;);
		for(int j = 1; j &lt;= n + 1 &amp;&amp; now &lt; edge[i + 1].w; ++j, ++now) {
			// printf(&quot;%d &quot;, j);
			times(a, T);
			if(a[1][n] == 1)return printf(&quot;%d\n&quot;, now + 1), 0;
		}
		// puts(&quot;&quot;);
		for(int j = 1; j &lt;= n; ++j) {
			b[j] = T[j];
		}
		ksm(b, edge[i + 1].w - now);
		times(a, b);
		now = edge[i + 1].w;
	}
	// puts(&quot;QWQW&quot;);
	T[edge[m].from][edge[m].to] = 1;
	for(int j = 1; j &lt;= n + 1; ++j, now++) {
		times(a, T);
		if(a[1][n] == 1)return printf(&quot;%d\n&quot;, now + 1), 0;
	}
	return puts(&quot;Impossible&quot;), 0;
}


</code></pre>
<p>是不是很模板啊</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4363 [九省联考2018]一双木棋chess]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4363-jiu-sheng-lian-kao-2018yi-shuang-mu-qi-chess/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4363-jiu-sheng-lian-kao-2018yi-shuang-mu-qi-chess/">
        </link>
        <updated>2020-04-15T06:49:34.000Z</updated>
        <content type="html"><![CDATA[<p>九省联考D1T1</p>
<p>哇偶,状压DP我果然还是不会的,要多做些才行呢</p>
<p>如果考场考了是不是就TAT了啊</p>
<p>简要题意没有了</p>
<p>上去直接考虑n=2m=2,发现可以手算所有决策</p>
<p>以及还有n=10m=1,会发现我们只能从左到右放</p>
<p>然后没了,正解吧</p>
<p>轮廓线DP</p>
<p>一种挺奇妙的DP状态设计方式啊!</p>
<p>我们把n+m-1个行和列压起来,然后这一位为0表示轮廓线是横着的边,如果为1就表示轮廓线为竖着的边</p>
<p>被轮廓线围住的三角形就是放棋子的格子</p>
<p>然后你会发现这个状态的设计很不错,因为他充分利用了每个信息------这个棋盘一定满足放置是一个从右上到左下的三角形</p>
<p>而且我们可以通过0/1来定位棋子具体在哪一个格子,从而实现转移qwq</p>
<p>eg:</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1586936687539.png" alt="" loading="lazy"></figure>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0, f = 1;
		register char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;
const int MAXN = 10;
const int P = 1e9 + 7;

int a[MAXN][MAXN], b[MAXN][MAXN];

int f[1 &lt;&lt; (MAXN &lt;&lt; 1)];

int dfs(int sta, bool who, int n, int m) {
	if(~f[sta])return f[sta];
	f[sta] = who ? -P : P;
	int x = n, y = 0;
	for(int i = 0; i &lt; n + m - 1; ++i) {
		if(sta &gt;&gt; i &amp; 1)x--;
		else y++;
		if((sta &gt;&gt; i &amp; 3) != 1)
			continue;
		int nxt = sta ^ (3 &lt;&lt; i);
		if(who)
			f[sta] = max(f[sta], dfs(nxt, who ^ 1, n, m) + a[x][y]);
		else
			f[sta] = min(f[sta], dfs(nxt, who ^ 1, n, m) - b[x][y]);
	}
	return f[sta];
}


int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	int n = read(), m = read();
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; m; ++j) {
			a[i][j] = read();
		}
	}
	for(int i = 0; i &lt; n; ++i) {
		for(int j = 0; j &lt; m; ++j) {
			b[i][j] = read();
		}
	}
	memset(f, -1, sizeof(f));
	f[((1 &lt;&lt; n) - 1) &lt;&lt; m] = 0;
	printf(&quot;%d\n&quot;, dfs((1 &lt;&lt; n) - 1, 1, n, m));
}

</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>l</mi><mi>j</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">Orzljh
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">h</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4364 [九省联考2018]IIIDX]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4364-jiu-sheng-lian-kao-2018iiidx/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4364-jiu-sheng-lian-kao-2018iiidx/">
        </link>
        <updated>2020-04-14T09:26:06.000Z</updated>
        <content type="html"><![CDATA[<p>九省联考D1T2</p>
<p>吐槽这样的<img src="https://xiaxiaoguang.github.io/post-images/1586856430229.png" alt="" loading="lazy">弱者只会弄水题</p>
<p>另外![](/.......)....本来这里应该有张p站的图的</p>
<ul>
<li>给你一颗树和一些权值,要求你给这个树分权值,满足父亲的权值小于儿子而且按照bfs序越靠前的点权值越大,输出方案</li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">n&lt;=1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span></p>
<p>首先我们有个一眼的做法就是考虑直接贪心,就是给编号最小的儿子最大的siz个去组方案</p>
<p>先把权值按照从大到小排序能快一点</p>
<p>然而如果出现权值相等的情况就命没了,eg 4 2.0 1 1 2 1</p>
<p>你会这样划分<img src="https://xiaxiaoguang.github.io/post-images/1586856792627.png" alt="" loading="lazy"></p>
<p>然后命没了</p>
<p>所以我们要改改这个做法</p>
<p>为什么不对?因为我们是按照dfs序去划分,而题面中都提示你按照bfs序去做了</p>
<p>所以我们再想直接按照bfs序去做要怎么搞</p>
<p>也就是说我们要同时维护父亲预留大小和查询这个点的最大可能性</p>
<p>线段树</p>
<ul>
<li>1.维护前缀有多少个点可以选</li>
</ul>
<p>没了</p>
<p>然后你会发现一个之前贪心不用搞的事情,就是我们相等的权值一定要尽可能右边的,因为线段树上相等的一列按照这个方法做是右边更优左边更劣的...当然这是在同一层的视角下</p>
<p>update:将完课后被神仙队友爆锤,一堆锅....还现场模拟代码/xk/xk/xk</p>
<p>你会发现我们可能会出现选完一个点预留好了然后又去选了左边使得预留不够吗?</p>
<p>不可能,因为我们二分<strong>只看右边啊</strong></p>
<p>你会发现如果我们出现一个点为0的情况而我们二分到了这个点吗?</p>
<p>此时看代码会自动+1,这个+1也是为了处理这个而来的</p>
<p>消极.</p>
<p>谁知道呢?</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
const int MAXN = 5e5 + 7;
const int inf = 1e9;
using namespace std;
struct rec {
    int mn, del;
} tr[MAXN &lt;&lt; 2];
int n, N;
double k;
int a[MAXN], b[MAXN], ans[MAXN], siz[MAXN], fa[MAXN], cnt[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
    static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
    inline char nc() {
        if(p1 == pend) {
            p1 = buf;
            pend = buf + fread(buf, 1, BUF_SIZE, stdin);
        }
        return *p1++;
    }
    inline int read() {
        int x = 0, f = 1;
        char s = nc();
        for(; !isdigit(s); s = nc())if(s == '-')f = -1;
        for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
        return x * f;
    }
}
using namespace fastIO;

inline bool cmp(int a, int b) {
    return a &gt; b;
}

inline void add(int x, int delta) {
    tr[x].del += delta;
    tr[x].mn += delta;
}

inline void up(int x) {
    tr[x].mn = min(tr[x &lt;&lt; 1].mn, tr[x &lt;&lt; 1 | 1].mn);
}

inline void down(int x) {
    add(x &lt;&lt; 1, tr[x].del);
    add(x &lt;&lt; 1 | 1, tr[x].del);
    tr[x].del = 0;
}

inline void build(int k, int l, int r) {
    if(l == r) {
        tr[k].mn = l;
        return ;
    }
    int mid = (l + r) &gt;&gt; 1;
    build(k &lt;&lt; 1, l, mid);
    build(k &lt;&lt; 1 | 1, mid + 1, r);
    up(k);
}

inline int query(int k, int l, int r, int qwq) {
    if(l == r) {
        return (tr[k].mn &gt;= qwq ? l : l + 1);
    }
    down(k);
    int mid = (l + r) &gt;&gt; 1;
    if(qwq &lt;= tr[k &lt;&lt; 1 | 1].mn)return query(k &lt;&lt; 1, l, mid, qwq);
    else return query(k &lt;&lt; 1 | 1, mid + 1, r, qwq);
}

inline void update(int k, int l, int r, int L, int R, int D) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        tr[k].mn += D;
        tr[k].del += D;
        return ;
    }
    down(k);
    int mid = (l + r) &gt;&gt; 1;
    if(L &lt;= mid)update(k &lt;&lt; 1, l, mid, L, R, D);
    if(R &gt; mid)update(k &lt;&lt; 1 | 1, mid + 1, r, L, R, D);
    up(k);
}

int main() {
    // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d&quot;, &amp;n);
    scanf(&quot;%lf&quot;, &amp;k);
    for(int i = 1; i &lt;= n; ++i)a[i] = read();// printf(&quot;%d?\n&quot;, a[i]);
    sort(a + 1, a + n + 1, cmp);
    for(int i = n - 1; i; i--) {
        // printf(&quot;%d %d\n&quot;, a[i], a[i + 1]);
        if(a[i] == a[i + 1])cnt[i] = cnt[i + 1] + 1;
        else cnt[i] = 0;
    }
    for(int i = 1; i &lt;= n; ++i) {
        fa[i] = (int)floor(i / k);
        // printf(&quot;%d \n&quot;, fa[i]);
        siz[i] = 1;
    }
    for(int i = n; i; --i) {
        siz[fa[i]] += siz[i];
        // printf(&quot;%d?\n &quot;, siz[i]);
        //统计子树和
        //SAM基操
    }
    build(1, 1, n);
    for(int i = 1; i &lt;= n; ++i) {
        // printf(&quot;%d %d?\n&quot;, fa[i], siz[fa[i]] - 1);
        if(fa[i] &amp;&amp; fa[i] != fa[i - 1])
            update(1, 1, n, ans[fa[i]], n, siz[fa[i]] - 1);
        int x = query(1, 1, n, siz[i]);
        // printf(&quot;%d %d\n&quot;, x, cnt[x]);

        x += cnt[x];
        // printf(&quot;%d ?&quot;, x);
        cnt[x]++;
        // printf(&quot;%d \n&quot;, cnt[x]);

        ans[i] = x;
        update(1, 1, n, x, n, -siz[i]);
    }
    for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, a[ans[i]]);
    return 0;
}
</code></pre>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>r</mi><mi>z</mi><mi>h</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">Orzhq
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6381 『MdOI R2』Odyssey]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6381-mdoi-r2-odyssey/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6381-mdoi-r2-odyssey/">
        </link>
        <updated>2020-04-13T14:52:12.000Z</updated>
        <content type="html"><![CDATA[<p>洛谷四月月赛Div1T1</p>
<p>哇偶,看来我T1就不会做qwq</p>
<p>然后一个30暴力就把自己带走了</p>
<p>若正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 满足：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的积是一个正整数的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 次方，即存在正整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><msup><mi>c</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">ab=c^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>那么我们称 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 为一组完美数对。</p>
<p>有一个包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个结点和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 条边的有向无环图，这张图中的每条边都有权值和长度两个属性。</p>
<p>如果一条路径 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 满足以下条件之一，则称其为一条完美路径：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 中仅包含一条边。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 从其起点开始依次为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>3</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>e</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">e_1, e_2, e_3, \ldots e_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 这 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mtext> </mtext><mo>(</mo><mi>p</mi><mo>≥</mo><mn>2</mn><mo>)</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">p\ (p\ge 2)p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord mathdefault">p</span></span></span></span> 条边，对于任意的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>p</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\leq i\leq p-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的权值和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">e_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>​ 的权值组成完美数对。</p>
<p>你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。</p>
<p>先不用说k=1或者n&lt;=10了</p>
<p>k&lt;=2?</p>
<p>我们发现有这样一个不难发现的规律,就是直接对于每个边的权值每个质因数因子%2,那么要求乘起来等于2?,然后你会发现如果要从一条边走向另一条边就一定这两条边权值相等</p>
<p>所以我们枚举每个权值,然后拿权值等于我们枚举的边去跑拓扑排序就好了</p>
<p>k&lt;=10?</p>
<p>之前的结论其实还是有用的,进行之前那个取模之后,你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a+b==k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>k</mi><mo separator="true">,</mo><mi>b</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a&lt;k,b&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>,所以你会发现对于一个a只有一个唯一的b对吧</p>
<p>那么我们就可以和之前一样枚举一个权值,然后拿所有权值等于a和b的边去跑一个0/1状态的拓扑排序,这个很简单,因为毕竟只有两个状态</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
const int MAXN = 3e5 + 7;
struct rec {
	rec(int a = 0, int b = 0, int c = 0, int d = 0) {
		x = a, y = b, w = c, l = d;
	}
	int x, y, w, l;
};
int n, m, k, ans, ccnt, x, y, w, l, cnt;
int home[MAXN], to[MAXN], nxt[MAXN], in[MAXN];
int r[MAXN], vis[MAXN], dp[MAXN][2], f[MAXN];
queue&lt;int&gt; q;
vector&lt;rec&gt; v[MAXN];

bool cmp(rec a, rec b) {
	return r[a.x] &lt; r[b.x];
}

void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
	in[y]++;
}

pair&lt;int, int&gt; proc (int a) {
	ll res1 = 1, res2 = 1;
	for(int i = 2; i * i &lt;= a; ++i) {
		int tmp = 0;
		while(a % i == 0) {
			tmp++, a /= i;
		}
		if(tmp % k) {
			for(int j = 1; j &lt;= tmp % k; ++j) {
				res1 = (res1 * i);
			}
			for(int j = 1; j &lt;= k - tmp % k; ++j) {
				res2 = (res2 * i &gt; 100000 ? 0 : res2 * i);
			}
		}
	}
	if(k != 1)res1 *= a;
	for(int j = 2; j &lt;= k; ++j) {
		res2 = (res2 * a &gt; 100000 ? 0 : res2 * a);
	}
	return make_pair((int)res1, (int)res2);
}

void topo() {
	for(int i = 1; i &lt;= n; ++i) {
		if(!in[i]) {
			q.push(i);
			r[i] = ++cnt;
		}
	}
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i = home[u]; i; i = nxt[i]) {
			if(--in[to[i]] == 0) {

				q.push(to[i]);
				r[to[i]] = ++cnt;
			}
		}
	}
	return;
}


int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d%d%d&quot;, &amp;x, &amp;y, &amp;w, &amp;l);
		pair&lt;int, int&gt; tmp = proc(w);
		if(tmp.second) {
			v[min(tmp.first, tmp.second)].push_back(rec(x, y, tmp.first, l));
			f[min(tmp.first, tmp.second)] = max(tmp.first, tmp.second);
		} else {
			ans = max(ans, l);
		}
		ct(x, y);
	}
	topo();
	for(int i = 1; i &lt;= 100000; ++i) {
		int len = v[i].size();
		if(len == 0)continue;
		sort(v[i].begin(), v[i].end(), cmp);
		for(int j = 0; j &lt; len; ++j) {
			if(vis[v[i][j].x] != i) {
				dp[v[i][j].x][0] = dp[v[i][j].x][1] = 0, vis[v[i][j].x] = i;
			}
			if(vis[v[i][j].y] != i) {
				dp[v[i][j].y][0] = dp[v[i][j].y][1] = 0, vis[v[i][j].y] = i;
			}
			if(v[i][j].w == i) {
				dp[v[i][j].y][0] = max(dp[v[i][j].y][0], dp[v[i][j].x][1] + v[i][j].l);
			}
			if(v[i][j].w == f[i]) {
				dp[v[i][j].y][1] = max(dp[v[i][j].y][1], dp[v[i][j].x][0] + v[i][j].l);
			}
			ans = max(ans, max(dp[v[i][j].y][0], dp[v[i][j].y][1]));
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P6383 『MdOI R2』Resurrection]]></title>
        <id>https://xiaxiaoguang.github.io/post/p6383-mdoi-r2-resurrection/</id>
        <link href="https://xiaxiaoguang.github.io/post/p6383-mdoi-r2-resurrection/">
        </link>
        <updated>2020-04-13T08:54:51.000Z</updated>
        <content type="html"><![CDATA[<p>洛谷4月月赛Div1T2</p>
<p>这道题确实真思维题</p>
<p>突然想起NOIP出的树上的数...辣么一道毒瘤思维题....我好怕啊</p>
<p>所以还是要善良</p>
<p>显然的东西:</p>
<p>根,肯定要定在n号点,要不然题目中给出的奇特性质就用不上了</p>
<p><s>之后你会发现从每个点到根他的祖先编号递增?</s></p>
<p>不显然的东西:</p>
<p>上去直接猜结论:</p>
<blockquote>
<p>任意两条新树中的边放在原树中不会相交</p>
</blockquote>
<p>即:<img src="https://xiaxiaoguang.github.io/post-images/1586768771730.png" alt="" loading="lazy">不会出现</p>
<p>考虑证明这个结论是充要的</p>
<p>必要性...显然吧,如果图中第1,3个点想要连边,那么在1上的那条边被断开的时候1<sub>3不能有边断开,而且3</sub>父亲的边一定要断开,所以和2~4矛盾啊</p>
<p>再考虑怎么构造出一种合法方案,这样就充分了</p>
<p>然后我们把根放入一个堆里,做一下流程</p>
<ul>
<li>从堆中取出编号最小的节点,断开原树中与父亲连边,再把他新树中的儿子节点加入集合</li>
</ul>
<p>这样构造的一定合法</p>
<p>所以每个点都会向他的祖先连边,而且如果向x级祖先连边那么1~x-1级祖先他的子树中点就都不能连</p>
<p>考虑f[i][j]表示i向上有j个可以连边的祖先,子树里连边的方案数,那么我们枚举一下x,然后i-&gt;x连一条边,这样子树里的点就都不能向1~x-1连</p>
<p>方程就是这样的</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></munderover><munder><mo>∏</mo><mrow><mi>v</mi><mo>∈</mo><mi>s</mi><mi>o</mi><mi>n</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow></munder><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f[i][j]=\sum_{x=1}^{j}\prod_{v\in son(u)}f_{v,j-(x-1)+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.3747820000000006em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8587770000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.347113em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>转移可以前缀和优化</p>
<p>没了</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define CT const int&amp;
#define ll long long
const int P = 998244353;
const int MAXN = 3456;
int n, u, v, f[MAXN][MAXN], p[MAXN], ccnt;
int home[MAXN*2], to[MAXN*2], nxt[MAXN*2];

inline void ct(CT x, CT y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

void dfs(int u, int fa) {
	// printf(&quot;%d?\n&quot;, u);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v != fa)
			dfs(v, u);
	}
	for(int j = 0; j &lt;= n; ++j)p[j] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == fa)continue;
		for(int j = 0; j &lt;= n; ++j) {
			p[j] = 1ll * p[j] * f[v][j] % P;
		}
	}
	for(int i = 1; i &lt;= n; ++i)
		p[i] = (p[i] + p[i - 1]) % P;
	//求一个前缀和
	for(int i = 0; i &lt;= n; ++i)
		f[u][i] = (p[i + 1] - (u == n ? p[0] : p[1]) + P) % P;
	//因为是前缀和所以要减掉p_1
}

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt; n; ++i) {
		scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
		ct(u, v);
		ct(v, u);
	}
	dfs(n, 0);
	printf(&quot;%d\n&quot;, f[n][0]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P4428 [BJOI2018]二进制]]></title>
        <id>https://xiaxiaoguang.github.io/post/p4428-bjoi2018er-jin-zhi/</id>
        <link href="https://xiaxiaoguang.github.io/post/p4428-bjoi2018er-jin-zhi/">
        </link>
        <updated>2020-04-13T03:44:54.000Z</updated>
        <content type="html"><![CDATA[<p>BJOI2018D1T2</p>
<p>不得不说人家BJOI的题一个个都是神仙,给人全新的做题体验---暴力出奇迹???</p>
<p>简要题意:</p>
<ul>
<li>查询一段另一区间有多少个子区间满足重排之后能构成一个%3=0的二进制数</li>
</ul>
<p>一看就不可做,20pts跑路,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span></p>
<p>50pts...可能是每个询问我们都DP一次吗?然后DP可以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>??</p>
<p>好吧直接开正解</p>
<blockquote>
<p>&quot;传说中的动态dp？反正极其毒瘤就是了&quot;</p>
</blockquote>
<p>肯定先要推结论的,我一开始想直接找出0/1串的规律,挂了....</p>
<p>所以我们缩小到每个元素的性质而不是直接找整体的</p>
<ul>
<li>对于1个1,如果他在奇数位置,那他会对答案贡献2,如果在偶数位置则会对答案贡献1,最后要求贡献%3=0</li>
</ul>
<p>这个结论很显然对吧,因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">偶</mi><mi mathvariant="normal">数</mi></mrow></msup><mo>≡</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2^{偶数}\equiv 1(mod 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">偶</span><span class="mord cjk_fallback mtight">数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant="normal">奇</mi><mi mathvariant="normal">数</mi></mrow></msup><mo>≡</mo><mn>2</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">2^{奇数} \equiv 2(mod 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">奇</span><span class="mord cjk_fallback mtight">数</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></p>
<p>那么我们考虑下合法的情况?....如果1的个数是偶数,那么一定可以,因为我们可以奇偶平分啊</p>
<p>如果1的个数是奇数?必须满足奇数的个数是偶数个数多至少3,为什么呢?否则我们奇偶配对后一定%3=1/2对吧</p>
<p>而大于3?如果是5,那么显然我们可以给偶数放个1,就又变成多3的情况,如果是4?你不觉得1的个数是偶数了吗?</p>
<p>所以综上所述,这个不太行,我们要补集转化</p>
<p>我们先想1的个数一定是奇数对吧,而且我们要满足能够构造出奇数比偶数多3?</p>
<ul>
<li>1.只有1个1</li>
<li>2.奇数个1,而且0的个数小于等于1</li>
</ul>
<p>否则我们有2个零?就一定可以构造出奇数比偶数多的假象</p>
<p>eg: 3个1,2个0 10101,7个1,2个0,101011111</p>
<p>这样我们就来快速找到一个区间的答案吧!动态DP啊!或者说DP过程分治化并记录?线段树!</p>
<p>我们要记录什么信息呢?包含不包含左右端点,4中情况第一维,有奇数个1还是偶数个,有0/1还是1/1,有0/1还是1/0,共四维,怎么转移啊?</p>
<p>所以我们把两个问题分开计数,然后最后减去算重的 部分就好</p>
<p>第一个线段树上存这样的dp数组<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Dp_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>其中i的定义和一开始的定义一样</p>
<p>j表示这个区间有奇数个1或者偶数个1</p>
<p>k表示这个区间有0个0或1个0</p>
<p>另一个线段树存这样的dp数组</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mi mathvariant="normal">​</mi></mrow><annotation encoding="application/x-tex">Dp_{i,j}​</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">​</span></span></span></span></p>
<p>i的定义还是和开始的定义一样，</p>
<p>j表示这个区间有0个1或者1个1</p>
<p>考虑第一个条件的转移我们需要对于每个节点维护:</p>
<ul>
<li>前缀零的个数,后缀零的个数</li>
<li>包括了1个1的前缀和后缀的个数</li>
</ul>
<p>那你会发现因为我们要计算跨过中间点的答案,所以就是左边0后缀0*右边前驱只有1个1的前缀+右边同理就是答案</p>
<p>然后再考虑第二种情况</p>
<p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">R_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 为线段后缀中满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mn>2</mn><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\bmod 2 = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的数量。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> 统计前缀，对称地是类似的。</p>
<p>那么你枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi mathvariant="normal">.</mi><msub><mi>R</mi><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo separator="true">,</mo><mi>B</mi><mi mathvariant="normal">.</mi><msub><mi>L</mi><mrow><mi>c</mi><mo separator="true">,</mo><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A.R_{a, b}, B.L_{c, d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>​ 考虑能否产生贡献：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a+c \le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">b + d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 为奇数，那么则可以产生对答案有他们俩乘积的贡献。</li>
</ul>
<p>还有一个重复的就是1的个数和10/01的个数会被减重复对吧,这个直接用一个树状数组就能维护</p>
<p>然后没什么了,其他细节也不会,学个大概qwq</p>
<p>真的太难了</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5 + 10;
typedef long long ll;
int n, mk, m;
int a[MAXN];

struct linetree1 {
	ll v[4 * MAXN][4][2][2];
	inline void merge(int p, int p1, int p2) { //非常恶心的merge函数
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++) //加法转移们
				v[p][0][i][k] = v[p1][0][i][k] + v[p2][0][i][k] + v[p1][2][i][k] + v[p2][1][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][1][i][k] = v[p1][3][i][k] + v[p1][1][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][2][i][k] = v[p2][3][i][k] + v[p2][2][i][k];
		for(int i = 0; i &lt;= 1; i++)for(int k = 0; k &lt;= 1; k++)v[p][3][i][k] = 0;
		for(int i = 0; i &lt;= 1; i++) //乘法转移,这里for枚举p1,p2各选多少个0
			for(int j = 0; i + j &lt;= 1; j++) //手动枚举了奇偶性的转移
				v[p][0][0][i + j] += v[p1][2][0][i] * v[p2][1][0][j] + v[p1][2][1][i] * v[p2][1][1][j],
									 v[p][0][1][i + j] += v[p1][2][0][i] * v[p2][1][1][j] + v[p1][2][1][i] * v[p2][1][0][j],
											 v[p][1][0][i + j] += v[p1][3][0][i] * v[p2][1][0][j] + v[p1][3][1][i] * v[p2][1][1][j],
													 v[p][1][1][i + j] += v[p1][3][0][i] * v[p2][1][1][j] + v[p1][3][1][i] * v[p2][1][0][j],
															 v[p][2][0][i + j] += v[p1][2][0][i] * v[p2][3][0][j] + v[p1][2][1][i] * v[p2][3][1][j],
																	 v[p][2][1][i + j] += v[p1][2][0][i] * v[p2][3][1][j] + v[p1][2][1][i] * v[p2][3][0][j],
																			 v[p][3][0][i + j] += v[p1][3][0][i] * v[p2][3][0][j] + v[p1][3][1][i] * v[p2][3][1][j],
																					 v[p][3][1][i + j] += v[p1][3][0][i] * v[p2][3][1][j] + v[p1][3][1][i] * v[p2][3][0][j];
	}
	inline void modify(int p, int l, int r, int pos) {
		if(r - l == 1) {
			if(a[r]) {
				v[p][3][1][0] = 1;
				v[p][3][0][1] = 0;
			} else {
				v[p][3][0][1] = 1;
				v[p][3][1][0] = 0;
			}
			return ;
		}
		int mid = (l + r) / 2;
		if(pos &lt;= mid) {
			modify(p &lt;&lt; 1, l, mid, pos);
		} else {
			modify(p &lt;&lt; 1 | 1, mid, r, pos);
		}
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
	}
	inline void query(int p, int l, int r, int dl, int dr) {
		if(dl == l &amp;&amp; dr == r) {
			if(mk == 0) {
				for(int i = 0; i &lt;= 3; ++i) {
					for(int j = 0; j &lt;= 1; ++j) {
						for(int k = 0; k &lt;= 1; ++k) {
							v[0][i][j][k] = v[p][i][j][k];
						}
					}
				}
				mk = 1;
			} else {
				for(int i = 0; i &lt;= 3; ++i) {
					for(int j = 0; j &lt;= 1; ++j) {
						for(int k = 0; k &lt;= 1; ++k) {
							v[4 * n + 1][i][j][k] = v[0][i][j][k];
						}
					}
				}
				merge(0, 4 * n + 1, p);
			}
			return ;
		}
		int mid = (l + r) / 2;
		if(dl &lt; mid) {
			query(p &lt;&lt; 1, l, mid, dl, min(dr, mid));
		}
		if(mid &lt; dr) {
			query(p &lt;&lt; 1 | 1, mid, r, max(dl, mid), dr);
		}
	}
	inline ll cquery(int l, int r) {
		for(int i = 0; i &lt;= 3; ++i) {
			for(int j = 0; j &lt;= 1; ++j) {
				for(int k = 0; k &lt;= 1; ++k) {
					v[0][i][j][k] = 0;
				}
			}
		}
		mk = 0;
		query(1, 0, n, l, r);
		ll ret = 0;
		for(int i = 0; i &lt;= 3; ++i)ret += v[0][i][1][0] + v[0][i][1][1];
		return ret;
	}
	inline void build(int p, int l, int r) {
		if(r - l == 1) {
			// printf(&quot;%d %d %d %d\n&quot;, p, l, r, a[r]);
			if(a[r]) {
				v[p][3][1][0] = 1;
			} else {
				v[p][3][0][1] = 1;
			}
			return;
		}
		int mid = (l + r) / 2;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid, r);
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
	}
} lt1;

struct linetree2 {
	ll v[4 * MAXN][4][2];
	inline void merge(int p, int p1, int p2) {
		for(int i = 0; i &lt;= 1; ++i)v[p][0][i] = v[p1][0][i] + v[p2][0][i] + v[p1][2][i] + v[p2][1][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][1][i] = v[p1][3][i] + v[p1][1][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][2][i] = v[p2][3][i] + v[p2][2][i];
		for(int i = 0; i &lt;= 1; ++i)v[p][3][i] = 0;

		for(int i = 0; i &lt;= 1; i++)
			for(int j = 0; i + j &lt;= 1; j++) {
				v[p][0][i + j] += v[p1][2][i] * v[p2][1][j];

				v[p][1][i + j] += v[p1][3][i] * v[p2][1][j];

				v[p][2][i + j] += v[p1][2][i] * v[p2][3][j];

				v[p][3][i + j] += v[p1][3][i] * v[p2][3][j];
			}
	}
	inline void modify(int p, int l, int r, int pos) {
		if(r - l == 1) {
			if(a[r]) {
				v[p][3][1] = 1;
				v[p][3][0] = 0;
			} else {
				v[p][3][0] = 1;
				v[p][3][1] = 0;
			}
			return ;
		}
		int mid = (l + r) &gt;&gt; 1;
		if(pos &lt;= mid) {
			modify(p &lt;&lt; 1, l, mid, pos);
		} else {
			modify(p &lt;&lt; 1 | 1, mid, r, pos);
		}
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);
		return ;
	}

	inline void query(int p, int l, int r, int dl, int dr) {
		if(dl == l &amp;&amp; dr == r) {
			if(mk == 0) {
				for(int i = 0; i &lt;= 3; ++i)
					for(int j = 0; j &lt;= 1; ++j) {
						v[0][i][j] = v[p][i][j];
					}
				mk = 1;
			} else {
				for(int i = 0; i &lt;= 3; ++i)
					for(int j = 0; j &lt;= 1; ++j) {
						v[4 * n + 1][i][j] = v[0][i][j];
					}
				merge(0, 4 * n + 1, p);
			}
			return ;
		}
		int mid = (l + r) &gt;&gt; 1;
		if(dl &lt; mid) {
			query(p &lt;&lt; 1, l, mid, dl, min(dr, mid));
		}
		if(mid &lt; dr) {
			query(p &lt;&lt; 1 | 1, mid, r, max(dl, mid), dr);
		}
	}
	inline ll cquery(int l, int r) {
		for(int i = 0; i &lt;= 3; ++i) {
			for(int j = 0; j &lt;= 1; ++j) {
				v[0][i][j] = 0;
			}
		}
		mk = 0;
		query(1, 0, n, l, r);
		ll ret = 0;
		for(int i = 0; i &lt;= 3; ++i)ret += v[0][i][1];
		return ret;
	}
	inline void build(int p, int l, int r) {
		if(r - l == 1) {
			// printf(&quot;%d %d %d %d\n&quot;, p, l, r, a[r]);
			if(a[r]) {
				v[p][3][1] = 1;
			} else {
				v[p][3][0] = 1;
			}
			return ;
		}
		int mid = (l + r) / 2;
		build(p &lt;&lt; 1, l, mid);
		build(p &lt;&lt; 1 | 1, mid, r);
		merge(p, p &lt;&lt; 1, p &lt;&lt; 1 | 1);

	}
} lt2;

struct treearray {
	int ta[MAXN];
	inline void c(int x, int t) {
		for(; x &lt;= n; x += x &amp; (-x))ta[x] += t;
	}
	inline int d(int x) {
		int r = 0;
		for(; x &gt; 0; x -= x &amp; (-x))r += ta[x];
		return r;
	}
	inline ll q(int l, int r) {
		return d(r) - d(l);
	}
} tr1, tr2;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;a[i]);
	}
	lt1.build(1, 0, n);
	lt2.build(1, 0, n);
	for(int i = 1; i &lt;= n; ++i) {
		if(a[i]) {
			tr1.c(i, 1);
		}
		if(a[i]^a[i + 1] &amp;&amp; i != n) {
			tr2.c(i, 1);
		}
	}
	scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1, t, l, r; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;t);
		// printf(&quot;%d?\n&quot;, i);
		//puts(&quot;QWQ&quot;);
		if(t == 1) {
			scanf(&quot;%d&quot;, &amp;l);
			a[l] ^= 1;
			lt1.modify(1, 0, n, l);
			// puts(&quot;QAQ&quot;);

			lt2.modify(1, 0, n, l);
			// puts(&quot;QAQ&quot;);
			tr1.c(l, (a[l]) ? 1 : -1);
			if(l != n) {
				tr2.c(l, (a[l]^a[l + 1]) ? 1 : -1);
			}
			if(l != 1) {
				tr2.c(l - 1, (a[l - 1]^a[l]) ? 1 : -1);
			}
		} else {
			scanf(&quot;%d%d&quot;, &amp;l, &amp;r);
			ll len = r - l + 1;
			printf(&quot;%lld\n&quot;, len * (len + 1) / 2 - lt1.cquery(l - 1, r) - lt2.cquery(l - 1, r) + tr1.q(l - 1, r) + tr2.q(l - 1, r - 1));
			// printf(&quot;%d &quot;, lt1.cquery(l - 1, r));
			// printf(&quot;%d &quot;, lt2.cquery(l - 1, r));
			// printf(&quot;%d &quot;, tr1.q(l - 1, r));
			// printf(&quot;%d &quot;, tr2.q(l - 1, r - 1));
			// puts(&quot;QAQ&quot;);

		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5468 [NOI2019]回家路线]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5468-noi2019hui-jia-lu-xian/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5468-noi2019hui-jia-lu-xian/">
        </link>
        <updated>2020-04-10T14:38:41.000Z</updated>
        <content type="html"><![CDATA[<p>NOI2019D1T1</p>
<p>NOI中的送分题难度?</p>
<p>俗话说得好,一日不更博,一日不吃饭</p>
<p>然后吃完一天饭的我来更博了/kk</p>
<p>题目大意：</p>
<p>现在有n个城市，城市之间有m条火车可以到达。</p>
<p>第i条火车是从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">x_ix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span>出发并到达<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>​，是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时间出发，并在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">q_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时间到达。</p>
<p>火车只能够在前一辆到达后才能乘坐。</p>
<p>设共乘坐了k辆火车，那么他的代价是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>q</mi><msub><mi>s</mi><mi>k</mi></msub></msub><mo>+</mo><mrow><mo fence="true">(</mo><mi>A</mi><mo>×</mo><msubsup><mi>p</mi><msub><mi>s</mi><mn>1</mn></msub><mn>2</mn></msubsup><mo>+</mo><mi>B</mi><mo>×</mo><msub><mi>p</mi><msub><mi>s</mi><mn>1</mn></msub></msub><mo>+</mo><mi>C</mi><mo fence="true">)</mo></mrow><mo>+</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mrow><mo fence="true">(</mo><mi>A</mi><msup><mrow><mo fence="true">(</mo><msub><mi>p</mi><mrow><mi>s</mi><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>q</mi><msub><mi>s</mi><mi>j</mi></msub></msub><mo fence="true">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>B</mi><mrow><mo fence="true">(</mo><msub><mi>p</mi><msub><mi>s</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></msub><mo>−</mo><msub><mi>q</mi><msub><mi>s</mi><mi>j</mi></msub></msub><mo fence="true">)</mo></mrow><mo>+</mo><mi>C</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">(q_{s_{k}}+\left(A \times p_{s_{1}}^{2}+B \times p_{s_{1}}+C\right)+\sum_{j=1}^{k-1}\left(A\left(p_{s j+1}-q_{s_{j}}\right)^{2}+B\left(p_{s_{j+1}}-q_{s_{j}}\right)+C\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00586em;vertical-align:-0.25586em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.55em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34709999999999996em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.80002em;vertical-align:-0.65002em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.054008em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span></span></span></span></p>
<p>求最小代价。</p>
<p>这个上去第一眼就能想到DP吧,dp[i][j]表示i时刻在j的最小时间花费,考虑转移时如果这个时候有车就用车转移一下,否则就等待,从dp[k][j]转移过来,随意算下等待代价就好</p>
<p>然后这个东西显然复杂度还挺不行,怎么都是个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msup><mi>t</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nt^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>,想办法优化一个转移?</p>
<p>你会发现一个基本的决策单调性,也就是说如果时刻<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>k</mi><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">l&lt;k&lt;i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>满足了k对于i更优,那么对于i之后的j,j到l的代价只会比j到k的更大,所以一定不会再次启用决策l</p>
<p>这样就可以决策单调性干掉一个t,O(nt)了</p>
<p>这个做法可以通过本题,不过还不是最优秀的</p>
<p>考虑再优化,因为我们坐车决策一共m个,所以只要把m个打出来按照某某个方式排序DP就好</p>
<p>咋排序?当然是按照时间啦!出发时间越小坑定越靠前啦,所以这样排序之后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示考虑到第i个决策,第i个必选,目前人处在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,所花最小时间</p>
<p>转移O(m)枚举之前一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">y_j==x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,然后算一下等的代价进行转移</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><munder><mi>min</mi><mo>⁡</mo><mrow><mi>j</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><mo>=</mo><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>q</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>&lt;</mo><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></munder><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>A</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>−</mo><msub><mi>q</mi><mi>j</mi></msub><msup><mo>)</mo><mn>2</mn></msup><mo>+</mo><mi>B</mi><mo>(</mo><msub><mi>p</mi><mi>i</mi></msub><mo>−</mo><msub><mi>q</mi><mi>j</mi></msub><mo>)</mo><mo>+</mo><mi>C</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i]= \min_{j&lt;i,y_j==x_i,q[j]&lt;p[i]}(dp[j]+A(p_i-q_j)^2+B(p_i-q_j)+C) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7383199999999999em;vertical-align:-0.9883199999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.66786em;"><span style="top:-2.0090000000000003em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mrel mtight">=</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">]</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">p</span><span class="mopen mtight">[</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">]</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9883199999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.150216em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mo>(</mo><mi>A</mi><msubsup><mi>p</mi><mi>i</mi><mn>2</mn></msubsup><mo>)</mo><mo>+</mo><mo>(</mo><mi>A</mi><msubsup><mi>q</mi><mi>j</mi><mn>2</mn></msubsup><mo>)</mo><mo>−</mo><mn>2</mn><mi>A</mi><msub><mi>p</mi><mi>i</mi></msub><msub><mi>q</mi><mi>j</mi></msub><mo>+</mo><mi>B</mi><msub><mi>q</mi><mi>j</mi></msub><mo>+</mo><mi>B</mi><msub><mi>p</mi><mi>i</mi></msub><mo>+</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">dp[i]=dp[j]+(Ap_i^2)+(Aq_j^2)-2Ap_iq_j+Bq_j+Bp_i+C
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2472159999999999em;vertical-align:-0.383108em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord">2</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p>你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有单调性,而且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2</mn><mi>A</mi><msub><mi>q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">-2Aq_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>也有单调性,分别x,k</p>
<p>所以y,b是啥就不用了我说了吧</p>
<p>时间复杂度仅有O(m)</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int MAXN = 2e5 + 7;
#define ll long long
#define db double

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0, f = 1;
		char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
#undef BUF_SIZE
}
using namespace fastIO;


inline int ymax(register int a, register int b) {
	return a &gt; b ? a : b;
}

inline ll ymin(register ll a, register ll b) {
	return a &lt; b ? a : b;
}

struct node {
	ll x, y;

	int id;
};

int n, m, A, B, C, maxT = 0;

int x[MAXN], y[MAXN], p[MAXN], q[MAXN], home[MAXN];
ll ans = 0x3f3f3f3f3f3f3f, dp[MAXN];
vector&lt;int&gt; d[1005];
vector&lt;node&gt; que[MAXN];
queue&lt;int&gt; res[1005];


inline db gslope(register node a, register node b) {
	return 1.0 * (a.y - b.y) / (1.0 * (a.x - b.x));
}

inline void ins(register int id) {
	int pos = y[id];
	node now = (node) {
		q[id], dp[id] + A *q[id]*q[id] - B *q[id], id
	};
	while(que[pos].size() - home[pos] &gt;= 2) {
		int len = que[pos].size();

		if(gslope(que[pos][len - 1], que[pos][len - 2]) &lt;
				gslope(que[pos][len - 2], now))
			break;
		que[pos].pop_back();
		// printf(&quot;%d %d\n&quot;, len, home[pos]);
	}
	que[pos].push_back(now);
}

inline void del(register db slpe, register int pos) {
	while(que[pos].size() - home[pos] &gt;= 2) {
		// printf(&quot;%lf %d?! &quot;, gslope(que[pos][home[pos]], que[pos][home[pos] + 1]), home[pos]);

		if(gslope(que[pos][home[pos]], que[pos][home[pos] + 1]) &gt;
				slpe)
			return ;
		++home[pos];
	}
	// puts(&quot;&quot;);
}


int main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	n = read();
	m = read();
	A = read();
	B = read();
	C = read();
	for(register int i = 1; i &lt;= m; ++i) {
		x[i] = read();
		y[i] = read();
		p[i] = read();
		q[i] = read();
		// printf(&quot;%d %d %d %d\n&quot;, x[i], y[i], p[i], q[i]);
		maxT = ymax(maxT, q[i]);
	}
	for(register int i = 1; i &lt;= m; ++i) {
		d[p[i]].push_back(i);
	}
	que[1].push_back((node) {
		0, 0, 0
	});
	for(register int t = 0; t &lt;= maxT; ++t) {
		while(!res[t].empty()) {
			ins(res[t].front());
			res[t].pop();
		}
		int len = d[t].size();
		// printf(&quot;%d %d\n&quot;, t, d[t].size());
		for(register int k = 0; k &lt; len; ++k) {
			int id = d[t][k];
			int pos = x[id];
			// printf(&quot;%d %d &quot;, id, pos);
			if(que[pos].size() == home[pos]) {
				continue;
			}
			db slpe = 2.0 * A * p[id];
			// printf(&quot;%lf? &quot;, slpe);

			del(slpe, pos);
			int j = que[pos][home[pos]].id;
			// printf(&quot;%d!! \n&quot;, j);

			dp[id] = dp[j] + 1ll * A * (p[id] - q[j]) * (p[id] - q[j]) + 1ll * B * (p[id] - q[j]) + C;
			// /printf(&quot;%d *\n&quot;, dp[id]);

			res[q[id]].push(id);
			if(y[id] == n)
				ans = ymin(ans, dp[id] + q[id]);

		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5473 [NOI2019]I 君的探险]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5473-noi2019i-jun-de-tan-xian/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5473-noi2019i-jun-de-tan-xian/">
        </link>
        <updated>2020-04-07T14:58:59.000Z</updated>
        <content type="html"><![CDATA[<p>NOI2019D2T3</p>
<p>交互题,<s>你谷第一篇题解?</s></p>
<p>首先解释交互题是什么,通俗一点,就是** 出题人把答案放在了输入数据里面! **但是你不能知道实际的全部输入信息,你只能根据他给出的几个信息和调用提前实现好的函数猜出这个输入数据</p>
<p><s>这个解释可能不太对,但对这个题是有用的</s></p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1586271869766.png" alt="" loading="lazy"></figure>
<p>交互题不能没有这个啊</p>
<h2 id="部分分1">部分分1</h2>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1586271907001.png" alt="" loading="lazy"></figure>
<p>照此过程模拟即可,只要你能成功实现交互!</p>
<p>4pts</p>
<h2 id="部分分2~5">部分分2~5</h2>
<p>只要有一点点暴力的想法,你会发现,如果我们想找一个点周围的边,那么只需要把这个点modify一次,然后把所有点全部query一遍,其中是亮的我们就record他们之间的一条边,再把这个点modify回去就好</p>
<p>然而直接这样是不行的,我们只需要稍稍优化下暴力,查询只查询和亮暗情况之前有变化的点,就可以省去最后改回来的一次,然后每次只query所有编号大于当前点的点,就可以让总查询数变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n^2/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">2</span></span></span></span>,过掉第5个点</p>
<p>16pts</p>
<h2 id="部分分-6~9">部分分 6~9</h2>
<p>满足图由许多两个点的块组成,也就是我们要确定每个点是另外哪个点连着的</p>
<p>这部分也不难想,因为我们仔细观察数据范围可以得出算法的消耗应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span></p>
<p>而logn的算法...而且是交互题....比较泛用的好像有<code>二进制</code>啊?</p>
<p>做法也就同样有了,我们按照点的编号第x位二进制是1/0把所有点分成两组,然后把所有是1的点提出来点亮,然后花费n的代价查一遍全局,我们得到一个亮暗集合...那么观察不难的出</p>
<blockquote>
<p>如果一个点和他的相连点这一位相同,那一定处于暗集合,这一位不同一定处于亮集合</p>
</blockquote>
<p>这样我们把所有位都做一遍,再处理一下每个点就能得到每个点对应的点了!</p>
<p>复杂度...全都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>16pts</p>
<h2 id="部分分10~11">部分分10~11</h2>
<p><s>这一部分是最为关键的??</s></p>
<p>满足编号大的只向编号小的连一条边</p>
<p>乍一想和之前的做法好像没有任何关系....除了复杂度....</p>
<p>所以我们还是要想一个log做法?好像还有二分也是log的</p>
<p>那这个题我们对于一个点可以找到他二分范围和性质吗?</p>
<p>很容易发现:<strong>二分范围就是这个点编号到1,性质就是点亮一个前缀看他亮不亮,在某个位置之后一定全都亮</strong></p>
<p>有这个性质我们就可以对于单个点二分了....而我们有n个点?整体二分就好啦</p>
<p>代价还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>8pts</p>
<h2 id="部分分12~14">部分分12~14</h2>
<p>满足图是一条链</p>
<p>这一部分可能比较需要灵机一动?qwq</p>
<p>因为做法很简单....每个点只会受到两个点的影响...如果我们先花掉O(n)的时间找到一个<code>初始点</code>,然后从初始点向两侧扩展...好像就满足每个点只受到一个点的影响了!因为另一个点已知,完全可以计算出那个点的影响</p>
<p>只受到一个点的影响?回到第三档部分分</p>
<p>12pts</p>
<h2 id="部分分15~17">部分分15~17</h2>
<p><s>被迫营业树的部分QAQ</s></p>
<p>之前一部分已经提示我们可以通过一次次扩展点来消掉周围点异或值是一些点的异或和的做法...</p>
<p>那么树,他没有环,我们应该也是可以通过以这个扩展消掉异或和的</p>
<ul>
<li>我们只需要求出每个点u周围点的编号的异或和,然后如果修改这个和表示的点导致u发生改变那么他们之间就有一条边</li>
</ul>
<p>为啥正确呢?首先你会发现叶子这个性质一定成立</p>
<p>而非叶子我们只需要把叶子从这个树上<code>剥离</code>,也就是消掉他的影响,也总有一天会变成叶子就成立了</p>
<p>12pts</p>
<p>至此所有非正解做法都讲完了,其实这道<strong>NOID2T3</strong>的题对于真正NOI选手68pts都不难呢</p>
<h2 id="正解">正解</h2>
<p>你会发现我们现在都还没有用过这个check,所以正解一定很坑</p>
<p>没错,正解需要一点随机化/xyx</p>
<p>同时,我们可能还需要一个复杂度带log的做法...如果我们把之前的两个做法融合一下,我们可以想到能不能<strong>划分出一个集合,然后在集合里整体二分呢?</strong></p>
<p>这看上去完全是硬凑,但是想一下和之前的区别,之前是知道一定只有一条边在前面,所以我们一定能满足单调性</p>
<p>但如果我们限制一下二分的过程,然后把奇偶性作为判断的标准呢?你会发现我们一定可以对于前面是奇数条边的点连出边,而前面是偶数的由于整体二分可能判断不了有没有边,因为点亮前缀后他状态没变</p>
<p>所以我们直接按照这个方法去做,就可以连好某个排列里面满足前面边是奇数的那些边</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1586398957313.png" alt="" loading="lazy"></figure>
<p>但是显然连得不够啊....所以我们只需要random_shuffle一个新的排列,然后再在这个排列上做这个事情,就又能够连出去一些边了!</p>
<p>其中check可以用来减少运算量的,如果一个点的周围的边都被标记了下次整体二分就不要把这个点加进去了</p>
<p>然后你肯定要问这样怎么保证复杂度啊</p>
<p>题解有一个结论:rand的一个排列里面有差不多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">n/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">3</span></span></span></span>个点向前连边是奇数个</p>
<p>不会证,但这道题做完了,完结散花!!</p>
<p><a href="https://loj.ac/submission/783398">你谷交不了呢QAQ</a></p>
<p><s>写的还不错吧留个赞再走呗</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AT2383 [AGC015E] Mr.Aoki Incubator]]></title>
        <id>https://xiaxiaoguang.github.io/post/at2383-agc015e-mraoki-incubator/</id>
        <link href="https://xiaxiaoguang.github.io/post/at2383-agc015e-mraoki-incubator/">
        </link>
        <updated>2020-04-07T07:57:36.000Z</updated>
        <content type="html"><![CDATA[<p>UOJ推荐题</p>
<p>OrzEI</p>
<p>题目大意</p>
<p>数轴上有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个点，每个点初始时在位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">V_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的速度向数轴正方向前进</p>
<p>初始时刻，你可以选择一些点为其染色，之后的行走过程中，染色的点会将其碰到的所有点都染上色，之后被染上色的点亦是如此</p>
<p>在所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">2^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span>种初始染色方案中，问有多少种初始染色方案，能使得最终所有的点都被染色？答案对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>取模</p>
<p>首先不难发现到世界末日的时候所有点一定是按照v排布的,而且不会再相交</p>
<p>那么我们把按照v排序的相对顺序和一开始x的相对顺序对于一个点拉成一条线段</p>
<p>问题就变成了选择一些的线段让他们覆盖整个数轴的总方案数</p>
<p>这个东西显然可以dp,先按照右端点排一下序啊,我们每个线段右端点就递增了</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>表示前i条线段第i条线段强制选,覆盖了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,r[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>这个范围的总方案数</p>
<p>转移的时候枚举之前的一个l,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>∈</mo><mo>[</mo><mi>l</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">l \in [l[i],r[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span>,,然后就可以</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi></mrow><mi>i</mi></munderover><mo>[</mo><mi>r</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>r</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">f[i]=\sum_{j=pre}^{i}[r[j]&lt;=r[i]]{f[j]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2254460000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></span></p>
<p>因为重复不重复这个不重要我们只需要满足全覆盖就好了</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
#define ll long long
typedef pair&lt;int, int&gt; par;

struct {
	inline operator int() {
		int x;
		return scanf(&quot;%lld&quot;, &amp;x), x;
	}
	inline operator ll() {
		ll x;
		return scanf(&quot;%lld&quot;, &amp;x), x;
	}
	template&lt;class T&gt; inline void operator ()(T &amp;x) {
		x = *this;
	}
	template&lt;class T, class ...A &gt;inline void operator () (T &amp;x, A &amp;...a) {
		x = *this;
		this-&gt;operator ()(a...);
	}
} read;

const int MAXN = 2e5 + 5, P = 1e9 + 7;
int l[MAXN], r[MAXN];
int p[MAXN];
int tmp[MAXN];
par pr[MAXN];
ll f[MAXN], s[MAXN];

int main() {
	int n = read;
	for(int i = 1; i &lt;= n; ++i) {
		read(pr[i].second, pr[i].first);
		//注意先按照v排序
	}
	std::sort(pr + 1, pr + n + 1);
	for(int i = 1; i &lt;= n; ++i) {
		tmp[i] = pr[i].second;
		//离散化部分
	}
	std::sort(tmp + 1, tmp + n + 1);
	//x数组
	for(int i = 1; i &lt;= n; ++i) {
		pr[i].second = int(std::lower_bound(tmp + 1, tmp + n + 1, pr[i].second) - tmp);
		//离散化
		p[pr[i].second] = i;
		//p数组记录了新位置
	}
	for(int i = 1; i &lt;= n; ++i) {
		r[i] = std::max(r[i - 1], p[i]);
		//这里是求出每段实际区间的右端点是哪个值
	}
	l[n] = p[n];
	for(int i = n - 1; i; --i) {
		l[i] = std::min(l[i + 1], p[i]);
		//同理左端点
	}
	int L = 0;
	f[0] = s[0] = 1;
	for(int i = 1; i &lt;= n; ++i) {
		while(r[L] &lt; l[i] - 1) {
			++L;
			//这句话其实限制了转移方程里面的[]
			//满足区间和是其中任何一个元素都合法
		}
		f[i] = (s[i - 1] - s[L - 1] + P) % P;
		s[i] = (s[i - 1] + f[i]) % P;
	}
	while(r[L] &lt; n) {
		++L;
	}
	printf(&quot;%lld\n&quot;, (s[n] - s[L - 1] + P) % P);
	return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5361 [SDOI2019]热闹的聚会与尴尬的聚会]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5361-sdoi2019re-nao-de-ju-hui-yu-gan-ga-de-ju-hui/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5361-sdoi2019re-nao-de-ju-hui-yu-gan-ga-de-ju-hui/">
        </link>
        <updated>2020-04-06T08:36:32.000Z</updated>
        <content type="html"><![CDATA[<p>SDOI2019D2T1..吗?</p>
<p>唔母,他D几T几不重要,重要的是咕咕咕咕咕咕</p>
<p>这当然是假的了,我怎么可能咕,强力推荐&lt;&lt;这就是僵尸啊&gt;&gt;两季</p>
<p>他的联系薄上有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 位好友，他们两两之间或者互相认识，或者互相不认识。小 Q 希望在周六办一个热闹的聚会，再在周日办一个尴尬的聚会。</p>
<ul>
<li>一场热闹度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 的聚会请来了任意多位好友，对于每一位到场的好友来说都有至少 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 位他认识的好友也参加了聚会，且至少对于一位到场的好友来说现场恰好有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 位他认识的好友；</li>
<li>一场尴尬度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 的聚会请来了恰好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 位好友，且他们两两互不认识。</li>
</ul>
<p>两场聚会可能有重复的参与者，联系薄上也有可能有某些好友同时缺席了两场聚会。</p>
<p>小 Q 喜欢周六聚会的热闹度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 与周日聚会的尴尬度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 之间满足：$\left\lfloor \frac{n}{p+1} \right\rfloor! \le $ 且 $\left\lfloor \frac{n}{q+1} \right\rfloor! \le $</p>
<p>请帮助小 Q 找出一个可行的邀请方案。</p>
<p>这个题意其实并不需要简化,因为很容易读懂</p>
<p>首先,看到这个尴尬的聚会,一眼就知道是求一个独立集,这好像是NPC问题啊,看看有没有什么丢掉的条件?</p>
<p>好像只有一个人数的限制QAQ,最大独立集肯定求不了,所以我们要尽可能的求个小的独立集,由于人数的限制可以变成乘起来大于n,所以我们第一问的p要尽可能的大</p>
<p>首先我们按照相识关系建立一个图,那么第一问就是要保留一个最小度数至少为p的子图,显然最后一个限制没啥意义,因为既然最小度数都有了.....</p>
<p>这个显然可以二分一个最小度数,然后把原图中度数小于最小的度数的点删除,再看剩下的点最小的度数是否大于p.不大于就是继续删</p>
<p>最后要么存在一些点,要么删光,就对应成立不成立...</p>
<p>还有一个是链表的做法,你会发现我们最后的答案图一定满足所有点的最小度数作为答案对吧,如果我们想要答案变大首先要把那些最小度数的点全部删掉,然后再对应的减一下相邻点的度数,得到新的答案,重复这个过程直到没有点,那么过程中所有答案得到最大值就是答案了</p>
<p>正确性显然吧</p>
<p>有了操作1的p,操作2最小q直接枚举得到,然后我们随机一个序列,按这个序列的顺序去保存独立集,这样一个玄学随机算法就可以过掉此题,毕竟他出的题复杂度和数据范围不严格一致,所以我们也概率正确</p>
<p>code:</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;ctime&gt;
#define add(x,y) (ct(x,y),ct(y,x))
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE], *p1 = BUF_SIZE + buf, *pend = buf + BUF_SIZE;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0, f = 1;
		register char s = nc();
		for(; !isdigit(s); s = nc())if(s == '-')f = -1;
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x * f;
	}
}
using namespace fastIO;
const int MAXN = 3e5;
int T, n, m;
int to[MAXN], nxt[MAXN], home[MAXN], tot, ccnt, deg[MAXN], cnt[MAXN], ansp, ansq;
int ans1[MAXN], ans2[MAXN], ans3[MAXN];
inline void ct(int x, int y) {
	//printf(&quot;%d %d\n&quot;, x, y);
	++deg[x];
	++ccnt;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}
int Q[MAXN], ql, qr;
inline int check(int v) {
	int siz = n, i, x, y, p;
	ql = 1, qr = 0;
	for(i = 1; i &lt;= n; ++i) {
		if(deg[i] &lt; v)ans3[i] = 0, Q[++qr] = i, --siz;
		else ans3[i] = 1;

	}
	while(ql &lt;= qr &amp;&amp; siz &gt; v) {
		x = Q[ql], ++ql;
		//printf(&quot;%dQWE\n&quot;, x);
		for(p = home[x]; p; p = nxt[p]) {
			if(ans3[y = to[p]]) {
				--deg[y];
				if(deg[y] &lt; v) {
					ans3[y] = 0;
					Q[++qr] = y;
					--siz;
				}
			}
		}
	}
	memcpy(deg, cnt, (n + 2) *sizeof(int));
	if(siz &gt; v) {
		memcpy(ans1, ans3, (n + 2) *sizeof(int));
		return 1;
	}
	return 0;
}
int id[MAXN], vis[MAXN];
int main() {
	//freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	srand(time(NULL));
	int i, j, x, y, tot, p;
	T = read();
	while(T -- &gt; 0) {
		n = read();
		m = read();
		ccnt = 0;
		memset(home, 0, (n + 2) *sizeof(int));
		memset(deg, 0, (n + 2) *sizeof(int));
		//任何时间复杂度都不能放过
		while(m-- &gt; 0)x = read(), y = read(), add(x, y);
		memcpy(cnt, deg, (n + 2) *sizeof(int));
		//for(int i = 1; i &lt;= n; ++i) {
		//	printf(&quot;%d\n&quot;, deg[i]);
		//}
		int l = 1, r = n - 1, mid;
		ansp = 0;
		while(l &lt;= r) {
			mid = (l + r) &gt;&gt; 1;
			if(check(mid)) {
				ansp = mid;
				l = mid + 1;
			} else {
				r = mid - 1;
			}
		}
		tot = 0;
		for(i = 1; i &lt;= n; ++i) {
			if(ans1[i])
				++tot;
			//printf(&quot;%d %d?\n&quot;, i, ans1[i]);
		}
		printf(&quot;%d &quot;, tot);
		for(i = 1; i &lt;= n; ++i)
			if(ans1[i])
				printf(&quot;%d &quot;, i);
		puts(&quot;&quot;);
		//printf(&quot;%d\n&quot;, ansq);
		for(i = 1; i &lt;= n; ++i) {
			if(n / (ansp + 1) &lt;= i &amp;&amp; n / (i + 1) &lt;= ansp) {
				ansq = i;
				break;
			}
		}
		if(ansq == 1) {
			printf(&quot;1 1\n&quot;);
			continue;
		}
		if(ansq == n) {
			printf(&quot;%d &quot;, n);
			for(i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, i);
			puts(&quot;&quot;);
		} else {
			for(i = 1; i &lt;= n; ++i)id[i] = i;
			while(1) {
				tot = 0;
				random_shuffle(id + 1, id + n + 1);
				memset(vis, 0, (n + 2) *sizeof(int));
				memset(ans2, 0, (n + 2) *sizeof(int));
				for(i = 1; i &lt;= n &amp;&amp; tot &lt; ansq; ++i) {
					if(!vis[x = id[i]]) {
						ans2[x] = 1;
						++tot;
						for(p = home[x]; p; p = nxt[p])vis[to[p]] = 1;
					}
				}
				if(tot == ansq) {
					printf(&quot;%d &quot;, tot);
					for(i = 1; i &lt;= n; ++i)if(ans2[i])printf(&quot;%d &quot;, i);
					puts(&quot;&quot;);
					break;
				}
			}
		}
	}
	return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>