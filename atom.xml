<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiaxiaoguang.github.io</id>
    <title>夏晓光(loveJY)的博客</title>
    <updated>2020-10-02T14:26:18.873Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiaxiaoguang.github.io"/>
    <link rel="self" href="https://xiaxiaoguang.github.io/atom.xml"/>
    <subtitle>仍要向下扎根,向上结果</subtitle>
    <logo>https://xiaxiaoguang.github.io/images/avatar.png</logo>
    <icon>https://xiaxiaoguang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 夏晓光(loveJY)的博客</rights>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第二场）]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-er-chang/">
        </link>
        <updated>2020-10-02T06:27:49.000Z</updated>
        <content type="html"><![CDATA[<p>QAQ</p>
<p>T2被降智</p>
<p>A</p>
<p>二分答案</p>
<p>判断的时候我们先让之前(如果有灯)就放光放过去,照亮一些路灯</p>
<p>然后再找到第一个照不亮的我们从哪个点向后找第二个要照亮的路灯就好了</p>
<p>时间复杂度O(nlogn)</p>
<p>考场空间开小?成为全场唯一90</p>
<h1 id="以后15倍空间一定要开">以后1.5倍空间一定要开!!!</h1>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int MAXN = 2e5 + 7;

int n, k, a[MAXN];

inline int chk(int x) {
	int lstl = 0;
	int lstu = 1;
	lstu = 1;
	lstl = 1;
	while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
		++lstl;
	}
	lstu = lstl + 1;
	for(int i = 2; i &lt;= k; ++i) {
		while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n) {
			++lstu;
		}
		lstl = lstu;
		while(fabs(a[lstl + 1] - a[lstu]) &lt;= x &amp;&amp; lstl &lt;= n) {
			++lstl;
		}
		lstu = lstl + 1;
	}
	while(fabs(a[lstu] - a[lstl]) &lt;= x &amp;&amp; lstu &lt;= n)
		++lstu;
	return lstu &gt; n;
}

signed main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);
	a[n + 1] = 2e9;
	a[0] = -2e9;
	int	L = 0, R = 2e9, ans = 0;
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	while(L &lt;= R) {
		int mid = (L + R) &gt;&gt; 1;
		if(chk(mid)) {
			ans = mid;
			R = mid - 1;
		} else {
			L = mid + 1;
		}
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;

}


</code></pre>
<p>B</p>
<p>惨</p>
<p>首先n^2很easy</p>
<p>然后考虑怎么观察来优化</p>
<p>你会发现我们就算交换很鬼畜也会有很多不动的位置</p>
<p>比如12345对于2交换一次</p>
<p>21435</p>
<p>1,3,5都没有变</p>
<p>但是数组整个下标其实向后平移了一位,然后有一些特殊位置要暴力修改....</p>
<p>做法就很显然了...开个2n的数组就行了</p>
<p>然后每次我们交换交换特殊位置...QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 3e6 + 7;
int n, p[MAXN];
int main() {
	scanf(&quot;%d&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)p[i] = i;
	for(int i = 2; i &lt;= n; ++i) {
		int nw = 0;
		for(int j = 1; j &lt;= n; j += i) {
			swap(nw, p[j + i - 2]);
		}
		p[i + n - 1] = nw;

	}
	for(int i = n; i &lt; 2 * n; ++i) {
		printf(&quot;%d &quot;, p[i]);
	}
	puts(&quot;&quot;);
	return 0;
}

</code></pre>
<p>C</p>
<p>随便dp即可</p>
<p>单指针计数可以实现快速判断最近的是哪个</p>
<p>同时计算一段贡献也很basic</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 205;
const int MAXK = 32;
ll a[MAXN], sum[MAXN], b[MAXN], suf[MAXN];
int n, k;
ll f[MAXN][MAXK][2];
inline ll cst1(int l, int r) {//l light -&gt;r
	return sum[r] - sum[l - 1] - 1ll * (r - l + 1) * a[l];
}

inline ll cst2(int l, int r) {//r light -&gt; l
	return suf[l] - suf[r + 1] - 1ll * (r - l + 1) * b[r];
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for(int i = 1; i &lt;= n; ++i) {
		b[i] = a[n] - a[i];
	}
	for(int i = n; i &gt;= 1; --i) {
		suf[i] = suf[i + 1] + b[i];
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= min(i, k); ++j) {
			if(j != 1) {
				int lstu = i;
				for(int k = i - 1; k &gt;= 1; --k) {
					while(a[i] - a[lstu - 1] &lt; a[lstu - 1] - a[k]) --lstu;
					f[i][j][1] = min(f[i][j][1], f[k][j - 1][1] + cst1(k, lstu - 1) + cst2(lstu, i));
				}
			} else {
				f[i][j][1] = min(f[i][j][1], cst2(1, i));
			}
			for(int k = i - 1; k &gt;= 1; --k)
				f[i][j][0] = min(f[i][j][0], f[k][j][1] + cst1(k, i));
		}
	}
	printf(&quot;%lld\n&quot;, min(f[n][k][0], f[n][k][1]));
	return 0;
}


</code></pre>
<p>D</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树到i距离为j的点数有多少个</p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示点i子树中满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>(</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>i</mi><mo>)</mo><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">dis(LCA(x,y),x)=dis(LCA(x,y),y)=dis(LCA(x,y),i)+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><br>
的有多少个</p>
<p>你会发现g数组更新其实很简单</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>g</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j}+=g_{v,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mo>=</mo><msub><mi>f</mi><mrow><mi>v</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">g_{i,j+1}+=f_{v,j}*f_{i,j+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>第二行相当于加入了新的三元组</p>
<p>f转移一样简单</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define int long long
#define ll long long
using namespace std;
const int MAXN = 1e5 + 7;
const int MAXM = 2e5 + 7;
int home[MAXN], nxt[MAXM], to[MAXM], ccnt, n;
ll a[MAXN], ans;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int fa[MAXN];
ll sum1[MAXN][5], sum2[MAXN][5];

inline void dfs1(int u, int F) {
	fa[u] = F;
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		dfs1(v, u);
		sum1[u][1] += a[v];
		sum1[u][3] += sum1[u][2] * sum1[v][1];
		sum1[u][2] += sum1[v][1] * sum2[u][2];
		sum2[u][2] += sum1[v][1];
	}
	return;
}

signed main() {
	// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);
	// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);

	scanf(&quot;%lld&quot;, &amp;n);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
	}
	for(int i = 1, x, y; i &lt; n; ++i) {
		scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);
		ct(x, y);
		ct(y, x);
	}
	dfs1(1, 0);
	//case 1
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[fa[u]];
		if(v == 0)continue;
		ans += a[v] * sum1[u][2];
	}
	//case 2
	for(int u = 1; u &lt;= n; ++u) {
		ans += sum1[u][3];
	}
	//case 3
	for(int u = 1; u &lt;= n; ++u) {
		int v = fa[u];
		if(v == 0)continue;
		ll tp = sum1[v][1] - a[u];
		ans += tp * sum1[u][2];
	}
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化听课(Day 1+2)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-ting-ke-day-1/">
        </link>
        <updated>2020-10-01T10:36:57.000Z</updated>
        <content type="html"><![CDATA[<p>枚举</p>
<p>for,或者while,或者do_while?/se</p>
<p>基本所有代码都要包括....</p>
<p>水仙花数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n*log_{10}n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p>
<p>搜索</p>
<p>显然</p>
<p>坐等例题</p>
<p>NOI1999</p>
<p>n很小唉</p>
<p>可以考虑搜索出蛋糕最小表面积</p>
<p>用了多少总体积,到了第几层,半径和高</p>
<p>那么我们来剪枝!</p>
<p>可行性剪枝</p>
<ol>
<li>半径和高递减</li>
<li>如果这一层用最优的方法去放都不能满足总体积就return</li>
</ol>
<p>也就是半径1高度1-&gt;半径2高度2......</p>
<ol start="3">
<li>如果这一层用最劣的方法都能放下就不搜</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>1...</mn><mi>R</mi><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mi>H</mi><mo>−</mo><mn>2...</mn></mrow><annotation encoding="application/x-tex">R-1,H-1...R-2,H-2...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></p>
<p>说明我们之前的决策sb了</p>
<p>最优性剪枝</p>
<ol start="4">
<li>当前表面积和+剩下的最小表面积都不能凑齐超过答案就return</li>
</ol>
<p>你会发现当体积一定的时候剩下最小表面积应该能搞出来?</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>=</mo><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup><mi>h</mi></mrow><annotation encoding="application/x-tex">V=\pi r^2 h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>2</mn><mi>π</mi><mi>r</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">S=2\pi r h
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">h</span></span></span></span></span></p>
<p>r最大为.....</p>
<p>然后能算出对应的h,就可以找到最小表面积了</p>
<p>相当于估价函数吧</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601623513084.png" alt="" loading="lazy"></figure>
<p>显然可以暴力吧...<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mn>13</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,a[13]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">a</span><span class="mopen mtight">[</span><span class="mord mtight">1</span><span class="mord mtight">3</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后面值为i的有多少张</p>
<p>不过状态有点多,会发现我们无论如何只看面值是否相同</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mo>[</mo><mn>5</mn><mo>]</mo></mrow></msub></mrow><annotation encoding="application/x-tex">f_{lst,b[5]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04964em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">t</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mopen mtight">[</span><span class="mord mtight">5</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span>表示上一个是什么,然后重复i次的有多少面值</p>
<p>转移的时候选下一个是什么...?</p>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601623817582.png" alt="" loading="lazy"></figure>
<p>枚举下最多多少个数k</p>
<p>搜搜当前最小的分母</p>
<p>你会发现如果我们最小分母的k倍小于剩下的数和就一定不可能可以剪一刀</p>
<p>就能跑出来了</p>
<p>k短路可以A*,能MLE呢</p>
<p>咕咕咕函数</p>
<figure data-type="image" tabindex="3"><img src="https://xiaxiaoguang.github.io/post-images/1601624926960.png" alt="" loading="lazy"></figure>
<p>A*是8-最多的格子个数</p>
<p>状态无限所以要ID</p>
<figure data-type="image" tabindex="4"><img src="https://xiaxiaoguang.github.io/post-images/1601624963620.png" alt="" loading="lazy"></figure>
<p>我们又有无限个状态</p>
<p>估价函数是有多少位置不同-1</p>
<p>然后这个东西是因为最后一步可以还原两个棋子</p>
<p>题目告诉我们要枚举答案QAQ</p>
<figure data-type="image" tabindex="5"><img src="https://xiaxiaoguang.github.io/post-images/1601625355953.png" alt="" loading="lazy"></figure>
<p>不显然可以折半</p>
<p>把方案折半,前12种的有一些,前13种的有一些</p>
<p>然后考虑三个人的数如何快速判断相等</p>
<p>第一个搜索中三个人的和我们可以两个做差,然后得到一个大小为2的差分数组</p>
<p>然后考虑拼在一起的时候是要第二个从右向左差分去查</p>
<p>显然可以手写哈希表来查存</p>
<figure data-type="image" tabindex="6"><img src="https://xiaxiaoguang.github.io/post-images/1601626675300.png" alt="" loading="lazy"></figure>
<p>爬山即可</p>
<p>每次向所有方向中能降低权值最小的走</p>
<p>可以考虑一个呜噜呜噜的判断方向做法</p>
<p>就是所有向量求和?的和向量方向</p>
<p>模拟退火</p>
<p>设置一个棒棒的估价函数</p>
<p>然后一个降温温度</p>
<p>然后一个可能跳出去的判断方法</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>l</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>T</mi><mo>)</mo><mo>&gt;</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">/</mi><mi>R</mi><mi>A</mi><mi>N</mi><msub><mi>D</mi><mi>M</mi></msub><mi>A</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">exp(delta/T)&gt;rand()/RAND_MAX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span>T值越小这个里面的值绝对值越大,而del显然是负数,那么del越小越容易交换</p>
<p>同样的,如果我们最大化,只需要变一下符号即可</p>
<p>整数划分</p>
<p>钦定前面大于后面</p>
<p>屑</p>
<p>背包问题</p>
<figure data-type="image" tabindex="7"><img src="https://xiaxiaoguang.github.io/post-images/1601627563786.png" alt="" loading="lazy"></figure>
<p>可以考虑按照性价比排序进行搜索,这样容易剪枝</p>
<p>因为性价比是递减的,如果当前性价比下(买小数个)凑出的答案都不够优秀就return</p>
<p>货郎担</p>
<p>状压可以解决20了</p>
<p>直接搜还是蛮难的...</p>
<figure data-type="image" tabindex="8"><img src="https://xiaxiaoguang.github.io/post-images/1601628286924.png" alt="" loading="lazy"></figure>
<p>背包问题</p>
<p>所以下一个面额是什么可以搜索出来</p>
<p>然后我们拼一拼的时候可以背包来做.....看不能延伸</p>
<figure data-type="image" tabindex="9"><img src="https://xiaxiaoguang.github.io/post-images/1601628498620.png" alt="" loading="lazy"></figure>
<p>奇偶最短路的实现方法就是每个点拆成奇数点和偶数点然后连边随便连一连</p>
<p>最后只有一个源点出发跑一跑bfs最短路就行了</p>
<figure data-type="image" tabindex="10"><img src="https://xiaxiaoguang.github.io/post-images/1601628939205.png" alt="" loading="lazy"></figure>
<p>整除</p>
<p>奇数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>+</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">a+b|(a^n+b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>偶数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mi mathvariant="normal">∣</mi><mo>(</mo><msup><mi>a</mi><mi>n</mi></msup><mo>−</mo><msup><mi>b</mi><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)|(a^n-b^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<figure data-type="image" tabindex="11"><img src="https://xiaxiaoguang.github.io/post-images/1601633671957.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://xiaxiaoguang.github.io/post-images/1601633621961.png" alt="" loading="lazy"></figure>
<p>总-不合法</p>
<figure data-type="image" tabindex="13"><img src="https://xiaxiaoguang.github.io/post-images/1601633767276.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://xiaxiaoguang.github.io/post-images/1601635787049.png" alt="" loading="lazy"></figure>
<p>推推石子得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi>i</mi><mi mathvariant="normal">/</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n {i/gcd(i,n)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mrow><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow></mrow><annotation encoding="application/x-tex">\sum_{d|n} \sum_{k=1}^{n/d} {k*[gcd(k,n/d)==1]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.47701em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.961005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>k</mi><mo>∗</mo><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>k</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}\sum_{k=1}^{n}k*[gcd(k,n)=1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p>后面这个式子显然是phi函数可以做到的</p>
<p>显然i与n互质,n-i与n互质</p>
<p>所以所有和n互质的数的和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo><mo>∗</mo><mi>d</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\phi(d)*d/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord">2</span></span></span></span></p>
<p>做完了,可以预处理最小质因数做到log</p>
<figure data-type="image" tabindex="15"><img src="https://xiaxiaoguang.github.io/post-images/1601637832702.png" alt="" loading="lazy"></figure>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mo>=</mo><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^n[gcd(i,n)==d]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∑</mo><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></munder><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi></mrow></munderover><mo>[</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>d</mi><mo>)</mo><mo>=</mo><mo>=</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{d|n}n/d\sum_{i=1}^{n/d}[gcd(i,n/d)==1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.4770100000000004em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>d</mi><mi mathvariant="normal">∣</mi><mi>n</mi></mrow></msub><mi>d</mi><mi>ϕ</mi><mo>(</mo><mi>d</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum_{d|n}d\phi(d)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p>
<p>卢卡斯定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C(n,m)%P=C(n%P,m%P)*C(n/P,m/P)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p>
<p>n用m进制分解,然后各位的数对应求组合数然后相乘???</p>
<p>gcd,lcm</p>
<p>gcd二除法</p>
<p>b=0,gcd=a</p>
<ol>
<li>两数都为偶数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mn>2</mn><mo>∗</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">=2*gcd(a/2,b/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span></p>
<ol start="2">
<li>二数都为奇数</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a-b,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<ol start="3">
<li>一奇一偶</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">=gcd(a/2,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>多元一次方程输出方案</p>
<figure data-type="image" tabindex="16"><img src="https://xiaxiaoguang.github.io/post-images/1601641712364.png" alt="" loading="lazy"></figure>
<p>显然我们考虑如果能前n-1个构造出和第n个数剩余系下所有数就能表示M</p>
<p>然后这个条件就是互质</p>
<p>显然因为我们所有数和最后那个数互质也就是说我们n-1的情况还可以继续变小</p>
<figure data-type="image" tabindex="17"><img src="https://xiaxiaoguang.github.io/post-images/1601641834634.png" alt="" loading="lazy"></figure>
<p>具体构造起来可能是O(nlogn)的....</p>
<p>中国剩余定理</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><munder><mo>∏</mo><mi>i</mi></munder><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">N=\prod_{i} m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i=N/m_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>(</mo><mi>m</mi><mi>o</mi><mi>d</mi><msub><mi>m</mi><mi>i</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">K_i*c_i=1 (mod m_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>a</mi><mi>i</mi></msub><msub><mi>c</mi><mi>i</mi></msub><msub><mi>K</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x=\sum_{i=1}^n a_ic_iK_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>正确性显然</p>
<figure data-type="image" tabindex="18"><img src="https://xiaxiaoguang.github.io/post-images/1601644946874.png" alt="" loading="lazy"></figure>
<p>有人想生成函数?</p>
<p>考虑插板法可以计算没有n限制下的解</p>
<p>有限制可以容斥</p>
<p>那么我们考虑至少一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">x_i&gt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>很好算,只需要k-n即可</p>
<p>然后我们钦定有多少大于n,k就减去多少个n</p>
<figure data-type="image" tabindex="19"><img src="https://xiaxiaoguang.github.io/post-images/1601646314122.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://xiaxiaoguang.github.io/post-images/1601646334844.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://xiaxiaoguang.github.io/post-images/1601646665421.png" alt="" loading="lazy"></figure>
<p>设i维的j维面有f个,然后转移会发现一条线能成为一个面,而一个面能成为两个面</p>
<p>即i-1维的j维元素*2,j-1维元素成为j维元素...</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>∗</mo><mn>2</mn><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j}*2+f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<figure data-type="image" tabindex="22"><img src="https://xiaxiaoguang.github.io/post-images/1601646591718.png" alt="" loading="lazy"></figure>
<p>规律不好找/jk</p>
<figure data-type="image" tabindex="23"><img src="https://xiaxiaoguang.github.io/post-images/1601647626994.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1568. [2020提高组十连测day5]白银御行]]></title>
        <id>https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/</id>
        <link href="https://xiaxiaoguang.github.io/post/1568-2020-ti-gao-zu-shi-lian-ce-day5bai-yin-yu-xing/">
        </link>
        <updated>2020-10-01T07:26:24.000Z</updated>
        <content type="html"><![CDATA[<p>哇偶...</p>
<p>畸形第k大-&gt;</p>
<p>二分答案</p>
<p>多次询问-&gt;</p>
<p>整体二分</p>
<p>然后考虑怎么把矩阵相交变成数点问题</p>
<p>两个矩阵相交的条件可以是在两维都要区间相交</p>
<p>而转换...最好用的消除条件的方法就是容斥</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1601537501647.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://xiaxiaoguang.github.io/post-images/1601537631151.png" alt="" loading="lazy"></figure>
<p>所以也就是说我们按照这个条件去处理每一层的整体二分过程就好了</p>
<p>问题在于代码有好多好多细节QAQ</p>
<p>堪比接水果</p>
<p>注意 :</p>
<ol>
<li>
<p>多开几个数组处理每一层询问和修改的分开</p>
</li>
<li>
<p>注意最后值域收缩到一个点那些点的答案就是这个值</p>
</li>
<li>
<p>注意最小化所以&lt;=分左边</p>
</li>
</ol>
<p>code:</p>
<pre><code class="language-cpp">
//Finished by dawn light
//as difficult as frute
//qwq orzmyh!
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7 + 1e4;
using namespace std;

int n, m;
struct mat {
	int r1, c1, r2, c2, z, id;
	bool operator&lt;(const mat &amp;x)const {
		return c1 == x.c1 ? z &lt; x.z : c1 &lt; x.c1;
	}
} e[MAXN], ask[MAXN], mdq[MAXN * 2], a[MAXN], b[MAXN];

struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXN * 2];
	inline void mdf(int x, int V) {
		for(; x &lt;= n; x += lowbit(x))tr[x] += V;
	}
	inline int qry(int x) {
		int ret = 0;
		for(; x; x -= lowbit(x))ret += tr[x];
		return ret;
	}
} tr;
int tp[MAXN];

inline void pd1(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, -1);
		}
}

inline void pd2(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c1;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c2;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd3(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r1;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r2;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			tp[mdq[i].id] -= tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void pd4(int L, int R, int l, int r, int P) {
	int tot = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= P) {
			mdq[++tot] = e[i];
			mdq[tot].r1 = e[i].r2;
			mdq[tot].c1 = e[i].c2;
			mdq[tot].z = -2;
		}
	}
	for(int i = l; i &lt;= r; ++i) {
		mdq[++tot] = ask[i];
		mdq[tot].r1 = ask[i].r1 - 1;
		mdq[tot].c1 = ask[i].c1 - 1;
	}
	sort(mdq + 1, mdq + tot + 1);
	for(int i = 1; i &lt;= tot; ++i) {
		if(mdq[i].z == -2) {
			tr.mdf(mdq[i].r1, 1);
		} else {
			if(mdq[i].r1 == 0)continue;
			tp[mdq[i].id] += tr.qry(mdq[i].r1);
		}
	}
	for(int i = 1; i &lt;= tot; ++i)if(mdq[i].z == -2)tr.mdf(mdq[i].r1, -1);
}

inline void fz(int vL, int vR, int L, int R, int l, int r) {
	if(vL == vR) {
		for(int i = l; i &lt;= r; ++i) {
			tp[ask[i].id] = vL;
		}
		return;
	}
	int M = (vL + vR) &gt;&gt; 1;
	for(int i = l; i &lt;= r; ++i)tp[ask[i].id] = 0;
	pd1(L, R, l, r, M);
	pd2(L, R, l, r, M);
	pd3(L, R, l, r, M);
	pd4(L, R, l, r, M);
	int T1 = 0;
	int T2 = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(tp[ask[i].id] &gt;= ask[i].z) {
			a[++T1] = ask[i];
		} else {
			b[++T2] = ask[i];
			b[T2].z -= tp[ask[i].id];
		}
	}
	int tmp1 = l + T1 - 1;
	for(int i = l; i &lt;= tmp1; ++i) {
		ask[i] = a[i - l + 1];
	}
	for(int i = tmp1 + 1; i &lt;= r; ++i) {
		ask[i] = b[i - tmp1];
	}
	T1 = 0;
	T2 = 0;
	for(int i = L; i &lt;= R; ++i) {
		if(e[i].id &lt;= M) {
			a[++T1] = e[i];
		} else {
			b[++T2] = e[i];
		}
	}
	int tmp2 = L + T1 - 1;
	for(int i = L; i &lt;= tmp2; ++i) {
		e[i] = a[i - L + 1];
	}
	for(int i = tmp2 + 1; i &lt;= R; ++i) {
		e[i] = b[i - tmp2];
	}
	if(l &lt;= tmp1)fz(vL, M, L, tmp2, l, tmp1);
	if(r &gt;= tmp1 + 1)fz(M + 1, vR, tmp2 + 1, R, tmp1 + 1, r);
	return ;
}

inline void solve2() {
	fz(1, n + 1, 1, n, 1, m);
	for(int i = 1; i &lt;= m; ++i) {
		if(tp[i] &gt; n)puts(&quot;-1&quot;);
		else printf(&quot;%d\n&quot;, tp[i]);
	}
	return ;
}
namespace fastIO {
#define BUF_SIZE (1&lt;&lt;22)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;
int main() {
	n = read();
	m = read();
	for(int i = 1; i &lt;= n; ++i) {
		e[i].r1 = read();
		e[i].c1 = read();
		e[i].r2 = read();
		e[i].c2 = read();
		e[i].id = i;
	}
	for(int i = 1; i &lt;= m; ++i) {
		ask[i].r1 = read();
		ask[i].c1 = read();
		ask[i].r2 = read();
		ask[i].c2 = read();
		ask[i].z = read();
		ask[i].id = i;
	}
	solve2();
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP-S2考前综合强化刷题（第一场)]]></title>
        <id>https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/</id>
        <link href="https://xiaxiaoguang.github.io/post/csp-s2-kao-qian-zong-he-qiang-hua-shua-ti-di-yi-chang/">
        </link>
        <updated>2020-10-01T06:55:47.000Z</updated>
        <content type="html"><![CDATA[<p>屑</p>
<p>A</p>
<p>考虑必胜策略的构造</p>
<p>假设我有最后一张牌</p>
<p>如果对方选取i,我就选择i+1</p>
<p>然后考虑我们这样做一定能有一个牌权</p>
<p>如果对方先手而且我的牌不比他多就能靠这个牌权取胜</p>
<p>所以:</p>
<p>奇数+奇先手必胜</p>
<p>奇数+偶先手必胜</p>
<p>偶数 偶必胜</p>
<p>n=2先手必胜</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
string s;
int T;
int main() {
	scanf(&quot;%d&quot;,&amp;T);
	while(T--&gt;0) {
		int op;
		cin&gt;&gt;s;
		scanf(&quot;%d&quot;,&amp;op);
		if(s.size()==1 &amp;&amp; s[s.size()-1]=='2') {
			printf(&quot;%d\n&quot;,op);
		} else if((s[s.size()-1]-'0')%2==0)puts(&quot;1&quot;);
		else {
			if(op==0)puts(&quot;0&quot;);
			else puts(&quot;1&quot;);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>发现我们可以在线/se</p>
<p>举个例子:</p>
<p>染色一行,那么我们如果染蓝色,看看这一行最近一次染得是蓝色还是红色</p>
<p>如果染的蓝色,那么我们查询这个上次到这次时间区域染列红色的个数,那些会变蓝,对应加上</p>
<p>如果染的是红色,那么我们查询这次到上次时域染的行蓝色的个数,那些会不变,加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">m-cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>直接暴力分类讨论要8中,所以我在代码中压缩了行列的区别</p>
<p>考场心态炸裂QAQ</p>
<p>不该打grakn forces2020</p>
<p>齐神的O(n)做法</p>
<p>每一行每一列按照染色的最后时间排序</p>
<p>然后就会发现上述过程可以排序双指针了....</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
const int MAXN=1e6+7;
using namespace std;
int n,m,k;
ll ans;
int col[2][MAXN],tim[2][MAXN];
//color time
const int MAXT=2e6+7;
struct rec {
#define lowbit(x) (x&amp;(-x))
	int tr[MAXT];
	inline void mdf(int x,int v) {
		for(; x&lt;=k; x+=lowbit(x))tr[x]+=v;
	}
	inline ll qry(int x) {
		ll ret=0;
		for(; x; x-=lowbit(x))ret+=tr[x];
		return ret;
	}
} tr[2][2];//first h,l second r,b

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = BUF_SIZE + buf;
	inline char nc() {
		if(p1 == pend) {
			p1 = buf;
			pend = buf + fread(buf, 1, BUF_SIZE, stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x = 0;
		char s = nc();
		for(; !isdigit(s); s = nc());
		for(; isdigit(s); s = nc())x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + s - '0';
		return x;
	}
}
using namespace fastIO;

int main() {
	n=read();
	m=read();
	k=read();
	ans=1ll*n*m;
	for(int i=1,x,y,z; i&lt;=k; ++i) {
		x=read();
		z=read();
		y=read();
		if(y==0) {//红色
			if(col[x][z]==0) {//base red paint red
				ans += tr[x^1][1].qry(i)-tr[x^1][1].qry(tim[x][z]);
			} else {//base blue paint ret
				if(x==1) {
					ans += (n-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
				} else ans += (m-tr[x^1][0].qry(i)+tr[x^1][0].qry(tim[x][z]));
			}
            		} else {//蓝色
			if(col[x][z]==1) {
				ans -= tr[x^1][0].qry(i)-tr[x^1][0].qry(tim[x][z]);
			} else {//红色？？
				if(x==0)
					ans -= (m-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
				else ans -= (n-tr[x^1][1].qry(i)+tr[x^1][1].qry(tim[x][z]));
			}
		}
		if(tim[x][z]!=0) {
			tr[x][col[x][z]].mdf(tim[x][z],-1);
		}
		tr[x][y].mdf(i,1);
		col[x][z]=y;
		tim[x][z]=i;
	}
	ans=1ll*n*m-ans;
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
<p>C</p>
<p>nth_element</p>
<p>QAQ降智了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int MAXN=12345;
int n,Q,a[MAXN],v[MAXN];

struct rec {
	ll W;
	int id;
	bool operator&lt;(const rec &amp;x)const {
		return W==x.W?id&lt;x.id:W&gt;x.W;
	}
} p[MAXN];

int t,k;

int main() {
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=0; i&lt;n; ++i)scanf(&quot;%d%d&quot;,&amp;v[i],&amp;a[i]);
	scanf(&quot;%d&quot;,&amp;Q);
	for(int i=1; i&lt;=Q; ++i) {
		scanf(&quot;%d%d&quot;,&amp;t,&amp;k);
		for(int i=0; i&lt;n; ++i) {
			p[i].W=1ll*a[i]+1ll*v[i]*t;
			p[i].id=i+1;
		}
		nth_element(p,p+k-1,p+n);
		printf(&quot;%d\n&quot;,p[k-1].id);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>考虑DP,设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示看了前i个A数前j个B数能够得到的最小划分代价</p>
<p>然后转移是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的,因为要枚举上一行上一列是什么</p>
<p>然后转移能优化吗QAQ?</p>
<p>你会发现:</p>
<blockquote>
<p>结论：存在一个最优解的每次删数，至少有一段长度是1</p>
</blockquote>
<p>因为我们有一段都大于1的</p>
<p>我们可以拆成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x+y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>然后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mi>a</mi><mo>+</mo><mi>y</mi><mi>b</mi><mo>&lt;</mo><mo>=</mo><mo>(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">xa+yb&lt;=(x+y)*(a+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p>
<p>所以整完了,转移式子变得可以优化</p>
<p>实现的时候有一维可以直接前缀最小值</p>
<p>另一维...好像按理说也是可以的,不过我的实现是使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>数组</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int MAXN = 2005;
int n, m;
int A[MAXN], B[MAXN];
ll f[MAXN][MAXN], suma[MAXN], sumb[MAXN];
ll minxa[MAXN][MAXN], minxb[MAXN];
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= n; ++i) {
		scanf(&quot;%d&quot;, &amp;A[i]);
		A[i]--;
		suma[i] = suma[i - 1] + A[i];
	}
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d&quot;, &amp;B[i]);
		B[i]--;
		sumb[i] = sumb[i - 1] + B[i];
	}
	if(n &lt; m) {
		swap(n, m);
		swap(A, B);
		swap(suma, sumb);
	}
	memset(f, 0x3f3f3f3f, sizeof(f));
	memset(minxa, 0x3f3f3f3f, sizeof(minxa));
	memset(minxb, 0x3f3f3f3f, sizeof(minxb));
	minxa[0][0] = 0;
	for(int i = 1; i &lt;= m; ++i)minxa[0][i] = 0;
	minxb[0] = 0;
	f[0][0] = 0;
	for(int i = 1; i &lt;= n; ++i) {
		for(int j = 1; j &lt;= m; ++j) {
			f[i][j] = min(f[i][j], minxa[i - 1][j - 1] + A[i] * sumb[j]);
			f[i][j] = min(f[i][j], minxb[j - 1] + B[j] * suma[i]);
		}
		for(int j = 1; j &lt;= m; ++j) {
			minxa[i][j] = min(minxa[i][j - 1], f[i][j] - A[i + 1] * sumb[j]);
			minxb[j] = min(minxb[j], f[i][j] - B[j + 1] * suma[i]);
		}
	}
	printf(&quot;%lld\n&quot;, f[n][m]);
	return 0;
}
/*
3 4
2 4 3
2 6 6 4
*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#1567. [2020提高组十连测day5]藤原千花]]></title>
        <id>https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/</id>
        <link href="https://xiaxiaoguang.github.io/post/1567-2020-ti-gao-zu-shi-lian-ce-day5teng-yuan-qian-hua/">
        </link>
        <updated>2020-09-27T15:01:31.000Z</updated>
        <content type="html"><![CDATA[<p>马耀华的比赛题A</p>
<p>太重要了所以这场比赛题我将拆成三篇博客讲述</p>
<p>http://www.zhengruioi.com/problem/1567</p>
<p>线图....QAQ他的点数是按照组合数级别上涨的...</p>
<p>真的来说是图中多少条长为k的路径...</p>
<p>详情请见zjoi 线图那道题</p>
<p>考场时没有判断一个点然后挂掉了QAQ</p>
<p>现在来看是什么我都没有判断就挂掉了....</p>
<h1 id="暴力">暴力</h1>
<p>k=0,判断是否连通&amp;&amp;是否是每个点度数都为偶数</p>
<p>k=1,你会发现新图中一个点是原图中两个点的度数和-2</p>
<p>那么我们就可以把所有新图中的点度数算出来然后和k=0一样了</p>
<p>然鹅...不严谨的我没有想到这样一个可爱的情况:</p>
<p>1孤零零的站在那里,第一次线图他消失了</p>
<p>所以要特殊判断一个点...</p>
<h1 id="正解">正解:</h1>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></p>
<p>首先k=0的判据:所有点度数为偶数一定还成立</p>
<p>然后根据k=1我们可以发现:如果所有点度数奇偶性相同也可以</p>
<p>那....所有点度数都为奇数的图能否由线图导出?</p>
<p>你会发现可以,此时只需要所有边两侧的点度数奇偶性不同</p>
<p>那...这样好像可以递归下去,这样的图又能否由线图导出?</p>
<p>然后你又会发现这样的图好像一定是一个二分图...</p>
<p>也就是说我们不存在奇环,至少三元环</p>
<p>再一想,一旦一个图中某个点度数为3就会出现这样一个三元环!就暴毙了</p>
<p>不过好像左边一个点右边两个点的完全二分图也满足这个性质而且能够导出??.....QAQ</p>
<p><strong>但是至少这种情况是特殊的</strong></p>
<p>即,它属于那种能够越变越小的特殊线图:链</p>
<p>每进行一次,链的长度会缩短1</p>
<h2 id="判no判据">判No判据</h2>
<h3 id="存在长度大于k的链">存在长度大于k的链</h3>
<p>缩不完</p>
<h3 id="存在长度等于k的链而且有其他剩下的连通块">存在长度等于k的链,而且有其他剩下的连通块</h3>
<p>长度等于k的链会变成一个点</p>
<p>至少剩下两个连通块</p>
<h3 id="存在多个长度等于k的链">存在多个长度等于k的链</h3>
<p>QAQ这个其实和上面一样</p>
<p>但是判断起来可不一样啊</p>
<h3 id="不存在点">不存在点</h3>
<p>QAQ这个卡了我一会..</p>
<p>题目定义</p>
<h3 id="存在不止一个连通块">存在不止一个连通块</h3>
<p>QAQ这个又卡了我一会....</p>
<p>注意有些链可能缩没了</p>
<h3 id="上面都没触犯结果三个图性质都没满足">上面都没触犯,结果三个图性质都没满足</h3>
<p>这个最好判断qwq</p>
<h2 id="判yes判据">判Yes判据</h2>
<h3 id="最后只剩下存在长为k的链">最后只剩下存在长为k的链</h3>
<p>一个点也行</p>
<h3 id="满足一个图性质">满足一个图性质</h3>
<p>显然</p>
<p>于是我们大胆实践</p>
<p>就用2h完成了这道题!!!</p>
<p>附赠第一发AC的代码/se</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 2e6 + 7;
int n, m, k;
struct rec {
	int x, y;
} e[MAXN];
int f[MAXN], in[MAXN];
inline int getf(int x) {
	return f[x] == x ? x : f[x] = getf(f[x]);
}

inline void pd1() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		if(getf(i) != getf(1))return (void)puts(&quot;No&quot;);
	}
	for(int i = 1; i &lt;= n; ++i) {
		//		printf(&quot;%d %d?\n&quot;,i,in[i]);
		if(in[i] &amp; 1)return (void)puts(&quot;No&quot;);
	}
	return (void)puts(&quot;Yes&quot;);
}//k equal 0

//one node
inline void pd2() {
	static int siz[MAXN];
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
	}
	for(int i = 1; i &lt;= n; ++i) {
		siz[getf(i)]++;
	}
	int cnt = 0;
	for(int i = 1; i &lt;= n; ++i) {
		if(siz[i] &gt; 1) {
			++cnt;
		}
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	if(cnt == 0)return (void)puts(&quot;No&quot;);
	for(int i = 1; i &lt;= m; ++i) {
		if((in[e[i].x] + in[e[i].y]) &amp; 1)return (void)puts(&quot;No&quot;);
	}
	puts(&quot;Yes&quot;);
	return ;
}

int home[MAXN], nxt[MAXN], to[MAXN], ccnt;

inline void ct(int x, int y) {
	ccnt++;
	nxt[ccnt] = home[x];
	home[x] = ccnt;
	to[ccnt] = y;
}

int flg, mx;
int dep[MAXN], vis[MAXN];
//du shu is 2
//with out circle
//lian tong kuai!
inline void dfs(int u, int F) {
	if(!flg)return ;
	vis[u] = 1;
	mx = max(mx, dep[u]);
	for(int i = home[u]; i; i = nxt[i]) {
		int v = to[i];
		if(v == F)continue;
		//		printf(&quot;%d-&gt; %d %d in? %d\n&quot;,u,v,vis[v],in[v]);
		if(vis[v])flg = 0;
		else {
			if(in[v] != 1 &amp;&amp; in[v] != 2)flg = 0;
			dep[v] = dep[u] + 1;
			dfs(v, u);
		}
	}
}

int visp[MAXN];
inline void dfs2(int u, int F) {
	visp[u] = 1;
	for(int i = home[u]; i; i = nxt[i]) {
		if(to[i] == F)continue;
		dfs2(to[i], u);
	}
}

//if k &gt; maxlen lian ,can1
//if graph is jishu or graph is jioutu,can2
inline void pd3() {
	for(int i = 1; i &lt;= n; ++i)f[i] = i;
	for(int i = 1; i &lt;= m; ++i) {
		in[e[i].x]++;
		in[e[i].y]++;
		f[getf(e[i].x)] = getf(e[i].y);
		ct(e[i].x, e[i].y);
		ct(e[i].y, e[i].x);
	}
	int cnt = 0;
	int flg2 = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(in[i] == 0) {
			visp[i] = 1;
			continue;
		}
		if(!vis[getf(i)] &amp;&amp; in[i] == 1) { //is himself
			// printf(&quot;%d?%d\n&quot;, i, in[i]);
			flg = 1;
			mx = 0;
			dfs(i, 0);
			if(!flg) continue;
			if(mx &gt; k)return (void)puts(&quot;No&quot;);
			else if(mx == k) {
				if(!flg2)return (void)puts(&quot;No&quot;);
				flg2 = 0; //cunzai!
				dfs2(i, 0);
			} else dfs2(i, 0);
		}
	}
	// puts(&quot;qwq&quot;);
	for(int i = 1; i &lt;= n; ++i) {
		if(!visp[i] &amp;&amp; i == getf(i)) {
			cnt++;
			//				printf(&quot;%d \n&quot;,i);
		}
	}
	// printf(&quot;%d %d\n&quot;, cnt, flg2);

	if(flg2 &amp;&amp; cnt == 0)return (void)puts(&quot;No&quot;);
	// printf(&quot;%d %d\n&quot;, flg2, cnt);
	if(!flg2 &amp;&amp; cnt == 0) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qwq&quot;);
		return (void)puts(&quot;Yes&quot;);
	} else if(!flg2) {//too....
		return (void)puts(&quot;No&quot;);
	}
	if(cnt &gt; 1)return (void)puts(&quot;No&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if(!(in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg)return (void)puts(&quot;Yes&quot;);
	flg = 1;
	for(int i = 1; i &lt;= n; ++i) {
		if(visp[i])continue;
		if((in[i] &amp; 1)) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;QAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	flg = 1;
	for(int i = 1; i &lt;= m; ++i) {
		if(visp[e[i].x] || visp[e[i].y])continue;
		if(!((in[e[i].x] &amp; 1) ^ (in[e[i].y] &amp; 1))) {
			flg = 0;
			break;
		}
	}
	if(flg) {
		// if(n == 890000 &amp;&amp; m == 269874)puts(&quot;qAq&quot;);
		return (void)puts(&quot;Yes&quot;);
	}
	return (void)puts(&quot;No&quot;);
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i = 1; i &lt;= m; ++i) {
		scanf(&quot;%d%d&quot;, &amp;e[i].x, &amp;e[i].y);
	}
	if(k == 0) {
		return pd1(), 0;
	}//qaq
	if(k == 1) {
		return pd2(), 0;
	}//qwq
	pd3();//QAQAQAQ
	return 0;
}

/*

12 10 2
1 2
3 4

5 6
6 7
7 8
8 5

9 10
10 11
11 12
12 9

*/


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr普及组五连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-pu-ji-zu-wu-lian-ce-day3/">
        </link>
        <updated>2020-09-25T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>浪费生命的3h30min...</p>
<p>A</p>
<p>map</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>比较巧妙</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
//const int MAXN=1e5+7;
int n,m;
map&lt;int,int&gt; mp;
int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test.out&quot;,&quot;w&quot;,stdout);
	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
	for(int i=1,x,y,opt; i&lt;=n; ++i) {
		scanf(&quot;%d&quot;,&amp;opt);
		if(opt==1) {
			scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
			mp[x]=y;
		} else {
			scanf(&quot;%d&quot;,&amp;x);
			if(mp.find(x)==mp.end()) {
				puts(&quot;0&quot;);
			} else printf(&quot;%d\n&quot;,mp[x]);
		}
	}
	return 0;
}


</code></pre>
<p>B</p>
<p>每个点记录状压2^k的状态</p>
<p>然后发现边长为1</p>
<p>可以广度优先搜索</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define pii pair&lt;int,int&gt;
#define se second
#define fi first
#define mkp(x,y) (make_pair(x,y))
const int MAXS=1100;
const int MAXN=5007;
const int MAXM=6007;
using namespace std;

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

int n,ccnt,m,k,hd,tl;
int home[MAXN],nxt[MAXM],to[MAXM],w[MAXM],hve[MAXN];

int f[MAXN][MAXS],vis[MAXN][MAXS];//f_uS表示点u在已经有了S之后能不能走过去。。。
pii que[MAXS*MAXN];//不能炸吧。。。

inline void ct(int x,int y,int z) {
	++ccnt;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
	w[ccnt]=z;
}

inline void solve() {
	memset(f,0x3f3f3f3f,sizeof(f));
	f[1][hve[1]]=0;
	vis[1][hve[1]]=1;
	hd=tl=1;
	que[hd]=mkp(1,hve[1]);
	while(hd&lt;=tl) {
		int u=que[hd].fi,S=que[hd].se;
		hd++;
		if(u==n)break;
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i],q=w[i];
			int nS=S|hve[v];
			if(!vis[v][nS] &amp;&amp; ((q&amp;S)==q)) {
				vis[v][nS]=1;
				que[++tl]=mkp(v,nS);
				f[v][nS]=f[u][S]+1;
			}
		}
	}
	int ans=1e9;
	for(int i=0; i&lt;MAXS; ++i)ans=min(ans,f[n][i]);
	if(ans==1e9)printf(&quot;No Solution&quot;);
	else printf(&quot;%d\n&quot;,ans);
	return;
}

int main() {
//	freopen(&quot;test1.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);

	n=read();
	m=read();
	k=read();
	for(int i=1,x; i&lt;=n; ++i) {
		for(int j=0; j&lt;k; ++j) {
			x=read();
			hve[i]|=(x&lt;&lt;j);
		}
	}
	for(int i=1,x,y,z; i&lt;=m; ++i) {
		x=read();
		y=read();
		z=0;
		for(int j=0,p; j&lt;k; ++j) {
			p=read();
			z|=(p&lt;&lt;j);
		}
		ct(x,y,z);//qaq
	}
	solve();//bfs
	return 0;
}


</code></pre>
<p>C</p>
<p>一个质数能被分解成两个质数的乘积</p>
<p>当且仅当质因数指数和为2</p>
<p>问题变得显然,线性筛每个数最小质因子即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+Q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e7+7;
int q;
int sum[MAXN];
int pri[MAXN],isp[MAXN],mpr[MAXN];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void init() {
	int tot=0;
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			pri[++tot]=i;
			mpr[i]=i;
		}
		for(int j=1; j&lt;=tot &amp;&amp; i * pri[j] &lt; MAXN; ++j) {
			isp[i*pri[j]]=1;
			mpr[i*pri[j]]=min(pri[j],mpr[i]);
			if(i%pri[j]==0) {
				mpr[i*pri[j]]=pri[j];
				continue;
			}
		}
	}
	for(int i=2; i&lt;MAXN; ++i) {
		if(!isp[i]) {
			sum[i]=sum[i-1]+1;
		} else {
			int x=i;
			x/=mpr[x];
			x/=mpr[x];
			if(x==1) {
				sum[i]=sum[i-1]+1;
			} else sum[i]=sum[i-1];
		}
	}
	return;
}

int main() {
//	freopen(&quot;test2.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	init();
	q=read();
	for(int i=1,l,r; i&lt;=q; ++i) {
		l=read();
		r=read();
		printf(&quot;%d\n&quot;,sum[r]-sum[l-1]);
	}
	return 0;
}


</code></pre>
<p>D</p>
<p>树上链交!</p>
<p>首先判断有没有空集,就是看两者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span>的深度哪个更浅</p>
<p>然后把浅的那个LCA和另外两个端点再做LCA,如果有一个等于本身就说明LCA在另外的链上</p>
<p>然后链交大小?</p>
<p>设两条路径为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>u</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>u</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo separator="true">,</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">LCA(x,u),LCA(x,v),LCA(u,y),LCA(v,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>四个点按照dfs序排下序,然后选取最后两个求dis即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=4e5+7;
int n,q,qwq,depp,ccnt;
int siz[MAXN],dfn[MAXN],dep[MAXN],fa[MAXN],son[MAXN],top[MAXN];
int home[MAXN],nxt[MAXN],to[MAXN];
int a[10];


namespace fastIO {
#define BUF_SIZE (1&lt;&lt;20)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void dfs1(int u,int F) {
	siz[u]=1;
	dfn[u]=++depp;
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==F)continue;
		dep[v]=dep[u]+1;
		fa[v]=u;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]&gt;siz[son[u]])son[u]=v;
	}
	return ;
}

inline void dfs2(int u,int topf) {
	top[u]=topf;
	if(!son[u])return ;
	dfs2(son[u],topf);
	for(int i=home[u]; i; i=nxt[i]) {
		int v=to[i];
		if(v==fa[u] || v==son[u])continue;
		dfs2(v,v);
	}
}

inline int LCA(int x,int y) {
	while(top[x]!=top[y]) {
		if(dep[top[x]]&lt;dep[top[y]])
			x^=y^=x^=y;
		x=fa[top[x]];
	}
	if(dep[x]&gt;dep[y])x^=y^=x^=y;
	return x;
}

inline bool cmp(const int &amp;x,const int &amp;y) {
	return dfn[x]&lt;dfn[y];
}

inline int DIS(int x,int y) {
	return dep[x]+dep[y]-2*dep[LCA(x,y)];
}

//this is a completely 链交大小
inline void solve(int u,int v,int x,int y) {
	a[1]=LCA(u,x);
	a[2]=LCA(u,y);
	a[3]=LCA(v,x);
	a[4]=LCA(v,y);
	sort(a+1,a+5,cmp);
	printf(&quot;%d\n&quot;,DIS(a[3],a[4])+1);
	return;
}

int main() {
//	freopen(&quot;test3.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;test1.out&quot;,&quot;w&quot;,stdout);
	n=read();
	q=read();
	qwq=read();
	for(int i=1,x,y; i&lt;n; ++i) {
		x=read();
		y=read();
		ct(x,y);
		ct(y,x);
	}
	dep[1]=1;
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1,x,y,z; i&lt;=q; ++i) {
		x=read();
		y=read();
		z=read();
		solve(x,y,z,y);//直接链交走人了。。。
	}
	return 0;
}




</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 【LGR-076】洛谷 ⑨ 月月赛 I & Cnoi2020 ]]></title>
        <id>https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/</id>
        <link href="https://xiaxiaoguang.github.io/post/lgr-076-luo-gu-yue-yue-sai-i-and-cnoi2020/">
        </link>
        <updated>2020-09-24T14:55:05.000Z</updated>
        <content type="html"><![CDATA[<p>呃呃呃本来想打的然后因为数学物理考试咕咕咕了...</p>
<p>说实话都是纸老虎仔细想想就切掉了....</p>
<p>P6832 [Cnoi2020]子弦</p>
<p>可以冲sam吗?.....1e7不太能啊</p>
<p>答案显然就是每个最短的串的出现次数</p>
<p>即统计a~z出现次数</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e7 + 8;
char s[MAXN];
int cnt[50], ans;
int main() {
	scanf(&quot;%s&quot;, s);
	int n = strlen(s);
	for(int i = 0; i &lt; n; ++i) {
		cnt[s[i] - 'a']++;
	}
	for(int i = 0; i &lt; 26; ++i)ans = max(ans, cnt[i]);
	printf(&quot;%d\n&quot;, ans);
	return 0;
}


</code></pre>
<p>P6833 [Cnoi2020]雷雨</p>
<p>一开始就发现了正解然后心里暗示自己是错误的/cy</p>
<p>显然可以做三遍最短路:第一遍是从最上层任意一个点出发到剩下所有点的,第二遍是从红魔馆,第三遍是迷途竹林</p>
<p>然后枚举中间点三者求和即可</p>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>n</mi><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nmlog(nm))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>因为点数和边数同阶所以dijkstra可过</p>
<p>spfa???老哥这是<strong>网格图</strong>啊</p>
<p>code:</p>
<p>咕咕咕</p>
<p>P6834 [Cnoi2020]梦原</p>
<p>纸老虎1</p>
<p>先想想给出一个树的形态咋做吧....</p>
<p>显然一定每次选极大连通块??</p>
<p>然后如果是链上好像就是积木大赛???</p>
<p>差分数组所有正值加起来???</p>
<p>啊啊啊这好像树上是一样的....</p>
<p>然后树形态不固定好像也会了....</p>
<p>因为显然一个值会在1/k个区间出现啊,他的贡献就是value*1/k</p>
<p>用一个二维数点,求区间比一个数大的数的和/数的出现次数</p>
<p>离线+树状数组即可</p>
<p>注意特判<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">k&gt;i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>此时概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac 1 {i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>讲述写代码的时候一个sb错误:树状数组的add和取模优化的add重了QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
#define int long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int n,k;
ll fac[MAXN],ifac[MAXN],inv[MAXN];
struct rec {
	int x,id;
	bool operator&lt;(const rec &amp;w) const {
		return x&lt;w.x;
	}
} a[MAXN];

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}
const int MAXT=2e6+7;
struct BIT {
#define lowbit(x) (x&amp;-x)
	ll tr[MAXT];
	inline ll qry(int x) {
		ll ret=0;
		if(x==0)return 0;
		for(; x; x-=lowbit(x)) {
			add(ret,tr[x]);
		}
		return ret;
	}
	inline void mdf(int x,ll V) {
		for(; x&lt;=n; x+=lowbit(x))add(tr[x],V);
	}
} tr1,tr2;

inline ll ksm(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&amp;1)ans=ans*x%P;
		x=x*x%P;
		y&gt;&gt;=1;
	}
	return ans;
}

inline void init() {
	fac[0]=1;
	for(int i=1; i&lt;=k; ++i)fac[i]=1ll*fac[i-1]*i%P;
	ifac[k]=ksm(fac[k],P-2);
	ifac[0]=ifac[1]=1;
	for(int i=k-1; i&gt;=2; --i)ifac[i]=1ll*ifac[i+1]*(i+1)%P;
	for(int i=1; i&lt;=k; ++i) {
		inv[i]=1ll*fac[i-1]*ifac[i]%P;
	}
	return ;
}

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;19)
	static char buf[BUF_SIZE],*p1=buf,*pend=buf;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}
	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
}
using namespace fastIO;

signed main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	k=read();
	for(int i=1; i&lt;=n; ++i) {
		a[i].x=read();
		a[i].id=i;
	}
	sort(a+1,a+n+1);
	init();
	ll ans=0;
	for(int i=1; i&lt;=n; ++i) {
		if(a[i].id==1) {
			add(ans,a[i].x);
			tr1.mdf(a[i].id,a[i].x);
			tr2.mdf(a[i].id,1);
			continue;
		}
		int L=max(1ll,a[i].id-k);
		int sum=tr1.qry(a[i].id-1)-tr1.qry(L-1);
		int num=tr2.qry(a[i].id-1)-tr2.qry(L-1);
		add(ans,1ll*(num*a[i].x%P-sum+P)%P*inv[a[i].id-L]%P);
		tr1.mdf(a[i].id,a[i].x);
		tr2.mdf(a[i].id,1);
		//一个统计个数一个统计sum
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}

/*

5 4
1 2 3 4 5

*/


</code></pre>
<p>P6835 [Cnoi2020]线形生物</p>
<p>哇偶!</p>
<p>我:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示点i走到n的期望值</p>
<p>ljh:太棒了你可以高斯消元!</p>
<p>我:QAQ!</p>
<p>ljh随手在黑板上写了几个式子,然后切掉了!</p>
<p>我:!!!!</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>走到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的期望步数</p>
<p>由期望的线性性质我们可以得到答案就是求个和</p>
<p>怎么求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>?</p>
<p>sum表示f数组前缀和</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></mfrac><mo>∗</mo><mo>(</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">f_i=\frac 1 {in[i]}*(\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+f_i+1)+1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>然后我们随便化简一下</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]==1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>!</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">in[i]!=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∑</mo><mrow><mi>v</mi><mo>!</mo><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></munder><mo>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>−</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_i=\sum_{v!=i+1}(sum_{i-1}-sum_{v-1}+1)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.410449em;vertical-align:-1.360444em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">!</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.360444em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>做完了</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;
const int P=998244353;
const int MAXN=1e6+7;
int id,n,m;
ll f[MAXN],sum[MAXN];

int home[MAXN],nxt[MAXN],to[MAXN],ccnt,in[MAXN];

inline void ct(int x,int y) {
	ccnt++;
	nxt[ccnt]=home[x];
	home[x]=ccnt;
	to[ccnt]=y;
}

inline void add(ll &amp;x,ll y) {
	x+=y;
	if(x&gt;=P)x-=P;
}

int main() {
	scanf(&quot;%d%d%d&quot;,&amp;n,&amp;n,&amp;m);
	for(int i=1,x,y; i&lt;=m; ++i) {
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		ct(x,y);
		in[x]++;
	}
	for(int i=1; i&lt;=n; ++i) {
		in[i]++;
	}
	//dp！
	ll ans=0;
	for(int u=1; u&lt;=n; ++u) {
		f[u]=1;
		sum[u]=sum[u-1];
		if(in[u]==1) { //只有一步QAQ
			add(ans,1);
			add(sum[u],f[u]);
			continue;
		}
		for(int i=home[u]; i; i=nxt[i]) {
			int v=to[i];
			add(f[u],(sum[u]-sum[v-1]+1+P)%P);
		}
		add(sum[u],f[u]);
		add(ans,f[u]);
	}
	printf(&quot;%lld\n&quot;,ans);
	return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[20zr提高组十连测day4]]></title>
        <id>https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/</id>
        <link href="https://xiaxiaoguang.github.io/post/20zr-ti-gao-zu-shi-lian-ce-day4/">
        </link>
        <updated>2020-09-22T15:05:50.000Z</updated>
        <content type="html"><![CDATA[<p>阴间的dmy</p>
<p>http://www.zhengruioi.com/contest/703</p>
<p>A</p>
<p>提高组D2T1送分题</p>
<p>但是题面不够长所以qwq</p>
<p>做法:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示第一个串匹配到i第二个串匹配到j的最小代价</p>
<p>然后转移:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>!</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i!=b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_{i,j}=min(f_{i-1,j-1},min(f_{i-1,j},f_{i,j-1}))+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>=</mo><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_i==b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,j}=f_{i-1,j-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>优化:因为答案不会超过50,所以第二维有用的只有100个状态</p>
<p>直接用这些dp即可</p>
<p>其实本题造数据很难把</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+7;
int n;
int f[MAXN][105];
char s[MAXN],t[MAXN];
int main() {
	scanf(&quot;%s&quot;,s+1);
	scanf(&quot;%s&quot;,t+1);
	int n1=strlen(s+1);
	int n2=strlen(t+1);
	if(n1&lt;n2) {
		swap(n1,n2);
		swap(s,t);
	}
	if(n1-n2&gt;50)return printf(&quot;-1&quot;),0;
	memset(f,0x3f3f3f3f,sizeof(f));
	f[0][50]=0;
	for(int i=1; i&lt;=n1; ++i) {
		for(int j=50; j&gt;=-50; --j) {
			int p=i-j;
			if(p&lt;0 || p&gt;n2)continue;
			if(s[i]==t[p]) {
				f[i][j+50]=f[i-1][j+50];
			} else {
				f[i][j+50]=min(f[i][j+1+50],min(f[i-1][j-1+50],f[i-1][j+50]))+1;
			}
		}
	}
	if(f[n1][n1-n2+50]&gt;50)return printf(&quot;-1&quot;),0;
	printf(&quot;%d\n&quot;,f[n1][n1-n2+50]);
	return 0;
}


</code></pre>
<p>B</p>
<p>神仙数学题</p>
<p>你考虑维护两个L,R是2的幂次,同时满足形式:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111111</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111111(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11111112</mn><mo>(</mo><mi>k</mi><mi mathvariant="normal">个</mi><mo>)</mo><mn>00000000....</mn></mrow><annotation encoding="application/x-tex">11111112(k个)00000000....
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>然后考虑合法成为答案的数x一定在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo separator="true">,</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l,r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>之间</p>
<p>那么这个数字的幂次要尽可能的小于是想到再维护两个和这个差不多的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span></p>
<p>Lx表示把前200位拿出来的前缀幂次最小值,<strong>如果不够两百位我们后面用0补齐两百位</strong></p>
<p>Rx表示把前两百位拿出来的前缀幂次最大值<strong>不够两百位也是用零补齐</strong></p>
<p>然后每次用x*Lx,如果正好大于L就是答案,否则我们如果小于Rx就留下更新然后不乘了</p>
<p>否则然后更新一次后我们把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo>∗</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx*Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>这个值去考虑更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mo separator="true">,</mo><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Lx,Rx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>如果大于Rx更新Rx否则更新Lx</p>
<h2 id="因为我们lxrx的性质他一定满足大于或小于">因为我们Lx,Rx的性质他一定满足大于或小于!</h2>
<p>那你会发现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>x</mi><mi>R</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">LxRx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">x</span></span></span></span>的形式都是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000000000</mn><mo>(</mo><mi>x</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1000000000(x个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9999999999</mn><mo>(</mo><mi>y</mi><mi mathvariant="normal">个</mi><mo>)</mo><mo>?</mo><mo>?</mo><mo>?</mo><mo>?</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">9999999999(y个)????...
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">个</span><span class="mclose">)</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mclose">?</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></span></p>
<p>所以仔细思考一下我们一定能倍增出第一个合法的了</p>
<p>然后做完了</p>
<p>code:</p>
<pre><code class="language-cpp">

#include &lt;bits/stdc++.h&gt;
#define ll long long
#define maxn 100005 /*rem*/
#define mod 998244353
#define db double
#define vi vector&lt;int&gt;
#define pb push_back
#define mp make_pair
#define pi pair&lt;int, int&gt;
#define fi first
#define se second
using namespace std;
ll ksm(ll a, ll b) {
   if (!b) return 1;
   ll ns = ksm(a, b &gt;&gt; 1);
   ns = ns * ns % mod;
   if (b &amp; 1) ns = ns * a % mod;
   return ns;
}
const int mxs = 230; /*reme*/
void upd(vi &amp;a) {
	for (int i = 0; i &lt; a.size(); i++)
		if (a[i] &gt;= 10) {
			if (i == a.size() - 1)
				a.pb(a[i] / 10);
			else a[i + 1] += a[i] / 10;
			a[i] %= 10;
		}	
	if (a.size() &gt; mxs) {
		for (int j = 0; j &lt; mxs; j++)
			a[j] = a[a.size() - mxs + j];
		a.resize(mxs);
	} 
}
void otp(vi a) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		cout &lt;&lt; a[i];
	cout &lt;&lt; endl;
}
vi operator * (vi &amp;a, vi &amp;b) {
	vi c(a.size() + b.size() - 1);
	for (int i = 0; i &lt; c.size(); i++) c[i] = 0;
	for (int i = 0; i &lt; a.size(); i++)
		for (int j = 0; j &lt; b.size(); j++)
			c[i + j] += a[i] * b[j];
	upd(c);
//	cout &lt;&lt;&quot;NUL&quot; &lt;&lt; endl;
//	otp(a), otp(b), otp(c);
	return c;
}
bool operator &lt; (vi &amp;a, vi &amp;b) {
	for (int i = a.size() - 1; i &gt;= 0; i--)
		if (a[i] != b[i]) return a[i] &lt; b[i];
	return 0;
} 
vi operator + (vi &amp;a, vi &amp;b) {
	vi c(max(a.size(), b.size()));
	for (int i = 0; i &lt; c.size(); i++) {
		c[i] = 0;
		if (i &lt; a.size())
			c[i] += a[i];
		if (i &lt; b.size())
			c[i] += b[i];
	}
	upd(c);
	return c;
}
struct pw {
	vi a;
	vi b; // ��
	pw(){a.clear(), b.clear();}
	pw(vi x, vi y) {
		a = x, b = y;
	} 
	pw operator * (pw c) {
		
		return pw(a * c.a, b + c.b);
	}
};
pw L, R, cur;
vi lb, mx;
char inp[mxs];
void otp(pw a) {
	otp(a.a), otp(a.b);
}
int main() {
//	freopen(&quot;power.in&quot;, &quot;r&quot;, stdin);
//	freopen(&quot;power.out&quot;, &quot;w&quot;, stdout);
	int l;
	cin &gt;&gt; l;
	for (int i = 0; i &lt; l; i++)
		inp[i] = '1';
	vi u, v;
	for (int i = 0; i &lt; mxs - 1; i++)
		u.pb(0);
	u.pb(2), v.pb(1);	
	for (int i = 0; i &lt; mxs - l; i++)
		lb.pb(0), mx.pb(9);
	for (int i = l - 1; i &gt;= 0; i--)
		lb.pb(inp[i] - '0'), mx.pb(inp[i] - '0'); 
	L = pw(u, v);
	R = pw(u, v);		
	v[0] = 0, u[mxs - 1] = 1;
	cur = pw(u, v);
	while (1) {
	//	otp(L), otp(R);
		while (1) {
			pw ed = cur * L;
		//	otp(ed);
			if (cur.a &lt; ed.a &amp;&amp; ed.a &lt; mx) {
				cur = ed;
				if (!(cur.a &lt; lb)) {
					for (int i = cur.b.size() - 1; i &gt;= 0; i--)
						cout &lt;&lt; cur.b[i];
					cout &lt;&lt; endl;
					return 0;
				}
			}
			else break;
		}
		while (1) {
			pw nr = L * R;
			if (nr.a[mxs - 1] == 1) {
				L = nr;
				break;
			}
			else R = nr;
		}
	}
	return 0;
}



不是自己写的
</code></pre>
<p>C</p>
<p>倒序染色</p>
<p>然后你会发现我们每次还没有染色的相邻的不能染同一种颜色</p>
<p>其他的随便染上当前颜色即可</p>
<p>这个k的构造方式就是每次<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">n-n/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">3</span></span></span></span>的迭代到0的次数....</p>
<p>可以证明最后这样染出颜色的方案一定不会存在一个区间的没有出现次数为1的</p>
<p>因为不管怎么样你都会被一个新颜色叉掉</p>
<p>倒序是因为前面的限制严,要用出现次数少的颜色</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 1e5 + 7;
int n, k, a[MAXN];
//考虑用一种颜色染大于sum/3的灯然后我们递归剩下的解决
//我们要小心任何时刻都不能有相临相同的?
int b[MAXN], vis[MAXN], c[MAXN];
vector&lt;int&gt;  near[MAXN];
set&lt;int&gt; st;
inline void init() {
	st.clear();
	st.insert(n + 1);
	st.insert(0);
	for(int i = 1; i &lt;= n; ++i) {
		near[i].clear();
	}
	for(int i = 1; i &lt;= n; ++i)
		if(!vis[i]) {
			auto qwq1 = st.lower_bound(i);
			auto qwq2 = st.upper_bound(i);
			// printf(&quot;%d?%d\n&quot;, qwq1, qwq2);
			// near[a[i]].push_back(*qwq2);
			// near[*qwq2].push_back(a[i]);
			qwq1--;
			near[i].push_back(*qwq1);
			near[i].push_back(*qwq2);
			near[*qwq1].push_back(i);
			near[*qwq2].push_back(i);
			st.insert(i);
		}
	for(int i = 1; i &lt;= n; ++i) {
		if(!vis[i]) {
			sort(near[i].begin(), near[i].end());
			near[i].erase(unique(near[i].begin(), near[i].end()), near[i].end());
			// printf(&quot;%d\n&quot;, i);
			// for(auto v : near[i]) {
			// 	printf(&quot;%d &quot;, v);
			// }
			// puts(&quot;??&quot;);
		}
	}
	return ;
}

inline void solve(int l, int r, int dep) {
	if(l &gt; r)return;
	// printf(&quot;%d %d %d\n&quot;, l, r, dep);
	init();
	int limit = ceil((double)(r - l + 1) / 3);
	// if(limit == 0)limit = 1;
	for(int i = r; i &gt;= l; --i) {
		int p = a[i];
		if(!vis[p]) {
			bool flg = 1;
			// printf(&quot;in- &gt; %d\n&quot;, p);
			for(auto v : near[p]) {
				if(b[v] == dep) {
					// printf(&quot;%d %d???\n&quot;, v, dep);
					flg = 0;
				}
			}
			if(flg) {
				vis[p] = 1;
				b[p] = dep;
				limit--;
				// printf(&quot;%d %d\n&quot;, p, dep);
			}
		}
		if(!limit)break;
	}
	int tot = 0;
	for(int i = l; i &lt;= r; ++i) {
		if(!vis[a[i]]) {
			// printf(&quot;%d?\n&quot;, i);
			c[++tot] = a[i];
		}
	}
	// printf(&quot;tot-&gt;%d\n&quot;, tot);
	for(int i = l; i &lt;= l + tot - 1; ++i) {
		// printf(&quot;%d\n&quot;, c[i - l + 1]);
		a[i] = c[i - l + 1];
	}
	// if(l = l + tot - 1)
	solve(l, l + tot - 1, dep + 1);
	return ;
}

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	for(int i = 1; i &lt;= n; ++i)scanf(&quot;%d&quot;, &amp;a[i]);
	init();
	solve(1, n, 1);
	for(int i = 1; i &lt;= n; ++i)printf(&quot;%d &quot;, b[i]);
	puts(&quot;&quot;);
	return 0;
}

/*

3 3
1  2  3

4 3
4 3 2 1

*/



</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ZR2020普转提七连测day3]]></title>
        <id>https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/</id>
        <link href="https://xiaxiaoguang.github.io/post/zr2020-pu-zhuan-ti-qi-lian-ce-day3/">
        </link>
        <updated>2020-09-21T14:56:57.000Z</updated>
        <content type="html"><![CDATA[<p>http://www.zhengruioi.com/contest/704</p>
<p>没有上场毒瘤啊</p>
<p>A</p>
<p>打眼一看好像直接模拟就好了</p>
<p>但是可能有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k&gt;n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>情况</p>
<p>这种情况下根据kmp的错位相同原理,我们可能有很多字符是要一样的</p>
<p>那么我们用一个并查集把这样的字符形成的连通块找出来然后暴力看看每一块改成什么就好了</p>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>a</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nalogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>属于不精细的实现QAQ</p>
<p>code:</p>
<pre><code class="language-cpp">
#include&lt;bits/stdc++.h&gt;
const int MAXN = 1e5 + 7;
int n, k, ans;
char a[MAXN];
int fa[MAXN], num[MAXN][26];
inline int getf(int x) {
	return fa[x] == x ? x : fa[x] = getf(fa[x]);
}

inline void merge(int x, int y) {
	for(int i = 0; i &lt; 26; ++i) {
		num[getf(x)][i] += num[getf(y)][i];
	}
	fa[getf(y)] = getf(x);

	return ;
}

inline void init() {
	for(int i = 1; i &lt;= n; ++i) {
		fa[i] = i;
		num[i][a[i] - 'a'] = 1;
	}
	return ;
}
int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
	scanf(&quot;%s&quot;, a + 1);
	init();
	int l = n - k + 1, r, tmp;
	//错位相同,显然我们错位不能多了
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] != i)continue;
		r = l + i - 1;
		merge(i, r);
		tmp = r - 1 + l;
		while(tmp &lt;= n) {
			merge(i, tmp);
			if(tmp &gt; k) {
				break;
			}
			tmp = tmp - 1 + l;
		}
	}
	for(int i = 1; i &lt;= k; ++i) {
		if(fa[i] == i) {
			int S = 0, Max = -1;
			for(int j = 0; j &lt; 26; ++j) {
				if(num[i][j] &gt; Max)Max = num[i][j];
				S += num[i][j];
			}
			ans += S - Max;
		}
	}
	printf(&quot;%d\n&quot;, ans);
	return 0;
}

/*

10 7
aabaabaabc
5 4
abcde
5 3
abcba
6 4
abbbaa

*/


</code></pre>
<p>B</p>
<p>每一位只要出现011三个字符就一定可以判断出三种运算了</p>
<p>因为&amp;和其他可以用01去试,然后xor和|可以用11去试</p>
<p>显然不存在其他的不包括这个011的方案能验证出来....</p>
<p>答案每一位取max即可</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN = 505;

int n, m, T;
char a[MAXN][MAXN];
int cnt[MAXN], flg[MAXN];

inline void init() {
	for(int i = 1; i &lt;= m; ++i) {
		cnt[i] = flg[i] = 0;
	}
}

int main() {
	scanf(&quot;%d&quot;, &amp;T);
	while(T-- &gt; 0) {
		scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
		init();
		for(int i = 1; i &lt;= n; ++i) {
			scanf(&quot;%s&quot;, a[i] + 1);
		}
		for(int i = 1; i &lt;= n; ++i) {
			for(int j = 1; j &lt;= m; ++j) {
				if(a[i][j] == '0') {
					flg[j] = 1;
				}
				if(a[i][j] == '1') {
					cnt[j]++;
				}
			}
		}
		int ans = 0;
		for(int i = 1; i &lt;= m; ++i) {
			if(flg[i] &amp;&amp; cnt[i] &gt;= 2) {//110
				continue;
			} else if(!flg[i] &amp;&amp; cnt[i] &gt;= 2) {//111
				ans = max(ans, 1);
			} else if(flg[i] &amp;&amp; cnt[i] &lt; 2) {//0??
				ans = max(ans, 2 - cnt[i]);
			} else if(!flg[i] &amp;&amp; cnt[i] &lt; 2) {//???
				ans = max(ans, 3 - cnt[i]);
			}
		}
		printf(&quot;%d\n&quot;, ans);
	}
	return 0;
}


</code></pre>
<p>C</p>
<p>md....好像做过啊!</p>
<p>结论:大于53的质数没有用处,大于60的数没有用处</p>
<p>因为我们改成1一定更优秀</p>
<p>所以你会发现我们最后序列每个质因数一定只用了一次....</p>
<p>所以状压一下这16个质因数</p>
<p>然后考虑dp,f_{i,S}表示考虑了前i个数已经用了的质因数集合为S的最小代价</p>
<p>转移枚举下个数填什么,然后一定要是某个补集的子集才行</p>
<p>有很多种优化的方法</p>
<ol>
<li>60个数不用全部枚举,可以剪掉一些显然sb的</li>
<li>只枚举当前有用集合中的,而有用集合可以预处理</li>
</ol>
<p>code就没有了</p>
<p>D</p>
<p>重题</p>
<p>跟沈睿哥哥吐糟还被骂了</p>
<figure data-type="image" tabindex="1"><img src="https://xiaxiaoguang.github.io/post-images/1600701080965.png" alt="" loading="lazy"></figure>
<p>参照某篇叫[国家集训队]等差子序列的题</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[P5384 [Cnoi2019]雪松果树]]></title>
        <id>https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/</id>
        <link href="https://xiaxiaoguang.github.io/post/p5384-cnoi2019xue-song-guo-shu/">
        </link>
        <updated>2020-09-19T14:51:07.000Z</updated>
        <content type="html"><![CDATA[<p>单独腾一篇博客吧!</p>
<p>关于树上k级祖先和树上k级儿子的绝对快做法</p>
<p>首先枚举下各种做法吧!</p>
<h1 id="树上k级祖先">树上k级祖先</h1>
<h2 id="onlogn预处理"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>预处理</h2>
<ol>
<li>倍增求k级祖先</li>
</ol>
<p>显然,回答一组询问也是严格log的</p>
<p>访问空间太慢而且会被卡空间所以很屑</p>
<ol start="2">
<li>树剖求k级祖先</li>
</ol>
<p>当重链长度大于k,我们k级祖先就在这条链上,对于一个链都记录了直接访问即可...</p>
<p>这个显然不如:</p>
<ol start="3">
<li>长链剖分求k级祖先</li>
</ol>
<p>预处理每个长链数组还是要的</p>
<p>预处理倍增数组还是要的QAQ否则你可以尝试OnO1rmq!</p>
<p>然后你会发现我们如果一步跳到k最高二进制位的祖先后</p>
<p>由于k级祖先的长链长度一定大于这个数的</p>
<p>所以我们可以再从那个点向上或者向下沿着长链跳一步即可</p>
<p>时间复杂度回答起来是O1的</p>
<h2 id="on离线">O(n)离线</h2>
<p>开一个栈记录从根到x dfs经过的所有点</p>
<p>然后我们考虑dfs到x回答x的所有询问即可</p>
<h1 id="k级儿子个数和">k级儿子个数和</h1>
<p>hh</p>
<ol>
<li>线段树合并</li>
</ol>
<p>按照深度为下标建树然后每个位置记录有多少数</p>
<p>线段树合并</p>
<ol start="2">
<li>dsu on tree</li>
</ol>
<p><code>树上启发式合并</code></p>
<p>线段树合并另一种实现形式....</p>
<ol start="3">
<li>离线树状数组</li>
</ol>
<p>相当于数一个区间的某一个深度的个数</p>
<ol start="4">
<li>二分+vector</li>
</ol>
<p>每个深度的点开一个vector全部记录下来,然后在哪个vector处二分即可</p>
<p>当然可以压成所有的一个数组来优化空间</p>
<ol start="5">
<li>长链剖分</li>
</ol>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>!</mo></mrow><annotation encoding="application/x-tex">O(n)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span></p>
<p>出现了线性做法!</p>
<p>其实是利用了长链性质优化了dsu on tree</p>
<h1 id="finally">Finally</h1>
<p>my choice : (你谷最快)</p>
<p>可以离线求k级祖先</p>
<p>然后第二个数点我们可以树上差分</p>
<p>因为只求等于某个数的个数啊...</p>
<p>附上你谷rank 1代码</p>
<p>code:</p>
<pre><code class="language-cpp">

#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e6+7;
const int MAXQ=3e6+7;
int n,m;
int ccnt,home[MAXN],id[MAXQ],nxt[MAXQ],to[MAXQ],fst[MAXN],sec[MAXN],dep[MAXN];
int ans[MAXN],st[MAXN];

namespace fastIO {
#define BUF_SIZE (1&lt;&lt;21)
	static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
	inline char nc() {
		if(p1==pend) {
			p1=buf;
			pend=buf+fread(buf,1,BUF_SIZE,stdin);
		}
		return *p1++;
	}

	inline int read() {
		int x=0;
		char s=nc();
		for(; !isdigit(s); s=nc());
		for(; isdigit(s); s=nc())x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0';
		return x;
	}
	int _C=-1,_Z;
	char _sr[1&lt;&lt;21],_z[20];
	inline void Ot() {
		fwrite(_sr,1,_C+1,stdout),_C=-1;
	}
	inline void print(int x) {
		if(_C&gt;1&lt;&lt;20)Ot();
		while(_z[++_Z]=x%10+48,x/=10);
		while(_sr[++_C]=_z[_Z],--_Z);
		_sr[++_C]=' ';
	}
}
using namespace fastIO;

inline void ct(const int &amp;u,const int &amp;v) {
	ccnt++;
	nxt[ccnt]=home[u];
	home[u]=ccnt;
	to[ccnt]=v;
}

inline void ct2(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=fst[u];
	fst[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

inline void ct3(const int &amp;u,const int &amp;v,const int &amp;z) {
	ccnt++;
	nxt[ccnt]=sec[u];
	sec[u]=ccnt;
	to[ccnt]=v;
	id[ccnt]=z;
}

int tp,cnt[MAXN];
inline void dfs(int u) {
	st[++tp]=u;
	int v;
	for(int i=fst[u]; i; i=nxt[i]) {
		v=to[i];
		if(v&lt;tp) {
			ct3(st[tp-v],v,id[i]);
		}
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dep[v]=dep[u]+1;
		dfs(v);
	}
	--tp;
}

inline void dfs2(int u) {
	int v;
	cnt[dep[u]]++;
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]-=cnt[dep[u]+v];
	}
	for(int i=home[u]; i; i=nxt[i]) {
		v=to[i];
		dfs2(v);
	}
	for(int i=sec[u]; i; i=nxt[i]) {
		v=to[i];
		ans[id[i]]+=cnt[dep[u]+v]-1;
	}
}

int main() {
//	freopen(&quot;test.in&quot;,&quot;r&quot;,stdin);
	n=read();
	m=read();
	for(int i=2,x; i&lt;=n; ++i) {
		x=read();
		ct(x,i);
	}
	for(int i=1,x,y; i&lt;=m; ++i) {
		x=read();
		y=read();
		ct2(x,y,i);
	}
	dep[1]=1;
	dfs(1);
	dfs2(1);
	for(int i=1; i&lt;=m; ++i)print(ans[i]);
	Ot();
	return 0;
}


</code></pre>
]]></content>
    </entry>
</feed>